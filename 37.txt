<!DOCTYPE html>

<html lang="ko">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" name="viewport"/>
<title>가죽바지 빌런 서바이벌</title>
<script src="https://cdn.tailwindcss.com"></script>
<style>
        @import url('https://fonts.googleapis.com/css2?family=Black+Han+Sans&display=swap')
        @import url('https://fonts.googleapis.com/css2?family=Gugi&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            background-color: #c0c0c0;
            font-family: 'Black Han Sans', sans-serif;
            touch-action: none; 
            user-select: none;
            -webkit-user-select: none;
        }

        #gameCanvas {
            display: block;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
            z-index: 20; 
        }

        /* 데미지 텍스트 애니메이션 */
        @keyframes float-up {
            0% { transform: translateY(0) scale(1); opacity: 1; }
            100% { transform: translateY(-30px) scale(1.2); opacity: 0; }
        }
        .damage-text {
            position: absolute;
            color: #ffcc00;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 2px 2px 0 #000;
            pointer-events: none;
            animation: float-up 0.8s ease-out forwards;
            z-index: 25;
            white-space: nowrap;
        }

        /* 크리티컬 데미지 말풍선 스타일 */
        .crit-damage-text {
            position: absolute;
            color: #FFFF00 !important; /* 노란색 글씨 */
            background: #FF0000; /* 빨간색 배경 */
            padding: 8px 12px;
            border-radius: 20px;
            font-weight: bold;
            font-size: 32px !important;
            text-shadow: 2px 2px 0 #000;
            z-index: 50;
            animation: float-up 0.8s ease-out forwards;
            border: 3px solid #8B0000;
            box-shadow: 0 0 10px rgba(255, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
        }
        /* 말풍선 꼬리 */
        .crit-damage-text::after {
            content: '';
            position: absolute;
            bottom: -8px;
            left: 50%;
            transform: translateX(-50%);
            border-width: 8px 8px 0;
            border-style: solid;
            border-color: #FF0000 transparent transparent transparent;
        }

        .crit-text {
            color: #ff3333 !important;
            font-size: 32px !important;
        }
        
        .weak-text {
            color: #cccccc !important;
            font-size: 18px !important;
            text-shadow: 1px 1px 0 #000;
            opacity: 0.8;
        }
        
        .heal-text {
            color: #7FFF00 !important;
            font-size: 24px !important;
            text-shadow: 1px 1px 2px #000;
        }
        
        .block-text {
            color: #FFFF00 !important;
            font-size: 26px !important;
            text-shadow: 2px 2px 0 #000;
            font-weight: bold;
            z-index: 30;
        }
        
        #poopOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, rgba(60, 40, 10, 0.4) 10%, rgba(30, 15, 0, 0.98) 100%);
            opacity: 0;
            pointer-events: none;
            z-index: 14; 
            transition: opacity 0.5s ease;
            mix-blend-mode: multiply; 
        }

        #mindOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, transparent 30%, rgba(75, 0, 130, 0.8) 100%);
            opacity: 0;
            pointer-events: none;
            z-index: 16;
            transition: opacity 0.3s ease;
        }
        
        #darknessOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: black;
            opacity: 0;
            pointer-events: none;
            z-index: 999; 
            transition: opacity 0.1s ease-in-out;
        }

        #sacredFaithOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, transparent 40%, rgba(255, 215, 0, 0.3) 100%);
            opacity: 0;
            pointer-events: none;
            z-index: 15;
            transition: opacity 0.5s ease;
        }
        
        /* [신규] 아서 등장용 블러드 오버레이 */
        #bloodOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, rgba(255, 0, 0, 0.1) 20%, rgba(139, 0, 0, 0.8) 100%);
            opacity: 0;
            pointer-events: none;
            z-index: 17; /* 장판보다 위, UI보다 아래 */
            transition: opacity 1.5s ease-in-out;
            mix-blend-mode: multiply;
        }
        
        /* 정신착란(Confusion) 노란 점멸 오버레이 */
        #confusionOverlay {
           position: absolute;
           top: 0;
           left: 0;
           width: 100%;
           height: 100%;
           pointer-events: none;

    /* 노란색이 화면 가장자리쪽에서 더 강하게 보이게 */
    background: radial-gradient(circle, rgba(255,200,0,0.0) 35%, rgba(255,200,0,0.90) 100%);

    opacity: 0;
    z-index: 18; /* bloodOverlay(17) 위, UI(20) 아래 정도로 */
}

/* active일 때만 깜빡이기 */
#confusionOverlay.active {
    animation: confusionBlink 0.45s infinite;
}

/* 0 -> (최대값) -> 0 */
@keyframes confusionBlink {
    0%, 100% { opacity: 0; }
    50%      { opacity: var(--confusionAlpha, 0.45); }
}

        #visionOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, transparent 150px, black 300px);
            opacity: 0;
            pointer-events: none;
            z-index: 998; /* UI 바로 아래 */
            transition: opacity 0.5s ease;
        }

        #skillSealOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.3);
            display: none;
            justify-content: center;
            align-items: center;
            pointer-events: none;
            z-index: 200;
        }
        
        #skillSealText {
            font-family: 'Gugi', cursive;
            font-size: 80px;
            color: #800080;
            text-shadow: 2px 2px 0 #000, 0 0 20px #FF00FF;
            animation: pulse-seal 1s infinite;
        }
        
        @keyframes pulse-seal {
            0% { transform: scale(1); opacity: 0.8; }
            50% { transform: scale(1.1); opacity: 1; }
            100% { transform: scale(1); opacity: 0.8; }
        }

        .hud-top {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            width: 100%;
        }

        .status-container-left {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .status-container-right {
            display: flex;
            flex-direction: column;
            gap: 10px;
            align-items: flex-end;
        }

       .score-box {
    position: absolute;
    left: 50%;
    transform: translateX(-50%);
    
    /* [수정] 하단으로 이동 */
    top: auto; 
    bottom: 20px; 
    
    color: white;
    font-size: 24px;
    text-shadow: 2px 2px 0 #000;
    white-space: nowrap;
    z-index: 50; /* 다른 요소 위에 보이도록 z-index 추가 권장 */
}

        /* HP바와 스킬 아이콘을 가로로 배치하기 위한 컨테이너 */
        .hp-skill-row {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 20px;
        }

        .health-container {
            width: 300px;
            height: 25px;
            background: #333;
            border: 2px solid #fff;
            border-radius: 12px;
            overflow: hidden;
            position: relative;
        }

        .health-bar {
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, #ff4d4d, #ff9900);
            transition: width 0.1s linear;
        }

        .health-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 14px;
            text-shadow: 1px 1px 1px #000;
        }

        /* 스킬 아이콘 스타일 */
        .skill-icon-box {
            position: relative;
            width: 40px;
            height: 40px;
            background: #222;
            border: 2px solid #FFD700;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 0 5px #FFD700;
        }
        .skill-img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        .cooldown-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 0%; /* 쿨타임 중일 때 높이 조절 */
            background: rgba(0, 0, 0, 0.75);
            transition: height 0.1s linear;
        }
        .seal-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(80, 0, 80, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            color: red;
            font-weight: bold;
            z-index: 10;
        }
        
        .key-hint {
            position: absolute;
            top: 0;
            left: 2px;
            font-size: 12px;
            color: #fff;
            font-weight: bold;
            text-shadow: 1px 1px 0 #000;
            pointer-events: none;
        }
        .cooldown-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #fff;
            font-size: 16px;
            font-weight: bold;
            text-shadow: 1px 1px 0 #000;
            pointer-events: none;
            display: none;
        }

        .status-icon-box {
            display: flex;
            align-items: center;
            background: rgba(0, 0, 0, 0.6);
            padding: 4px 9px;
            border-radius: 9px;
            width: fit-content;
            margin-bottom: 4px;
        }

        .status-container-right .status-icon-box {
            flex-direction: row-reverse; 
        }
        .status-container-right .status-img {
            margin-right: 0;
            margin-left: 10px;
        }

        .poison-border { border: 2px solid #00ff00; } 
        .poop-border { border: 2px solid #8B4513; }   
        .kiss-border { border: 2px solid #FF1493; }   
        .semen-border { border: 2px solid #FFFFFF; } 
        .oral-border { border: 2px solid #FFFDD0; }
        .byururut-border { border: 2px solid #FFFDD0; }
        .shield-border { border: 2px solid #00BFFF; }
        .evil-mind-border { border: 2px solid #800080; }
        .curse-border { border: 2px solid #4B0082; } 
        .justice-border { border: 2px solid #FFD700; }
        .blind-border { border: 2px solid #808080; }
        .geoptal-border { border: 2px solid #ff0055; box-shadow: 0 0 5px #ff0055; }
        .fishy-border { border: 2px solid #7FFFD4; box-shadow: 0 0 5px #7FFFD4; }
        .malice-border { border: 2px solid #4B0082; box-shadow: 0 0 5px #8A2BE2; }
        .hyper-border { border: 2px solid #FFFF00; box-shadow: 0 0 5px #FFD700; animation: blink-border 1s infinite; }
        .paralysis-border { border: 2px solid #9370DB; box-shadow: 0 0 5px #8A2BE2; }
        
        @keyframes blink-border { 50% { border-color: #FF0000; } }

        /* 신규 디버프 테두리 */
        .corrupted-oath-border { border: 2px solid #8B0000; box-shadow: 0 0 5px #ff0000; }
        .dangerous-judgment-border { border: 2px solid #FFA500; box-shadow: 0 0 5px #ffcc00; }
        .deep-darkness-border { border: 2px solid #000000; box-shadow: 0 0 5px #333333; }
        .corrupted-justice-border { border: 2px solid #555555; box-shadow: 0 0 5px #aaaaaa; }
        .serum-contamination-border { border: 2px solid #8B0000; box-shadow: 0 0 10px #FF4500; animation: blink-border 0.5s infinite; }
        .death-brand-border { border: 2px solid #2F4F4F; box-shadow: 0 0 15px #000000, inset 0 0 10px #8B0000; animation: blink-border 0.5s infinite; }
        .darkness-border { border: 2px solid #000000; box-shadow: 0 0 15px #000000; }
        .confusion-border { border: 2px solid #FF4500; box-shadow: 0 0 10px #FF8C00; animation: blink-border 0.5s infinite; }
        .fake-item-border { border: 2px solid #9370DB; box-shadow: 0 0 5px #BA55D3; }
        .bleeding-border { border: 2px solid #DC143C; box-shadow: 0 0 5px #FF0000; animation: blink-border 1s infinite; }
        .shading-border { border: 2px solid #000000; box-shadow: 0 0 10px #4B0082; }
        .true-ancestor-border { border: 2px solid #DC143C; box-shadow: 0 0 5px #FF0000; }
        .fatal-scar-border { border: 2px solid #000000; box-shadow: 0 0 5px #8B0000; }
        .corrupted-blood-border { border: 2px solid #8B0000; box-shadow: 0 0 5px #800000; }
        .majesty-border { border: 2px solid #DAA520; box-shadow: 0 0 5px #FFD700; }
        .pheromone-overload-border { border: 2px solid #FF0000; box-shadow: 0 0 15px #FF0000; animation: blink-border 0.5s infinite; }
        .darkness-overwhelm-border { border: 2px solid #483d8b; box-shadow: 0 0 10px #483d8b; }
        .fracture-border { border: 2px solid #555555; box-shadow: 0 0 10px #000000, inset 0 0 5px #ff0000; animation: blink-border 1s infinite; }
        .dark-scent-border { border: 2px solid #2F4F4F; }
        .dark-smell-border { border: 2px solid #3e2723; }
        .dark-seed-border { border: 2px solid #4a4a4a; }
        .dark-kiss-border { border: 2px solid #880e4f; }
        .dark-receiver-border { border: 2px solid #1a237e; }
        .evil-light-border { border: 2px solid #220022; box-shadow: 0 0 10px #800080; }
        .dark-ecstasy-border { border: 2px solid #9932CC; box-shadow: 0 0 10px #8A2BE2; }
        .gnawing-life-border { border: 2px solid #556B2F; box-shadow: 0 0 10px #6B8E23; }
        .berserk-border { border: 2px solid #FF0000; box-shadow: 0 0 10px #FF0000; }
        .despair-border { border: 2px solid #2F4F4F; box-shadow: 0 0 10px #000000; animation: blink-border 0.5s infinite; }
        .baptism-border { border: 2px solid #191970; box-shadow: 0 0 10px #4169E1; }

        .status-img {
            width: 35px;
            height: 35px;
            border-radius: 7px;
            margin-right: 9px;
            object-fit: cover;
            background: #fff;
        }
        
        .dark-icon {
            filter: none;
        }

        .status-text {
            font-size: 18px;
            text-shadow: 1px 1px 0 #000;
            font-weight: bold;
        }

        #screen-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            pointer-events: auto;
            z-index: 30; 
        }

        .title {
            font-size: 48px;
            color: #ffd700;
            text-align: center;
            margin-bottom: 20px;
            text-shadow: 3px 3px 0 #5a3e1b;
        }

        .subtitle {
            font-size: 18px;
            color: #ddd;
            text-align: center;
            margin-bottom: 40px;
            line-height: 1.5;
        }

        .btn {
            padding: 15px 40px;
            font-size: 24px;
            background: #5a3e1b;
            color: white;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            font-family: 'Black Han Sans', sans-serif;
            box-shadow: 0 4px 0 #3e2b12;
            transition: transform 0.1s;
        }

        .btn:active {
            transform: translateY(4px);
            box-shadow: none;
        }

        .damage-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, transparent 50%, rgba(101, 67, 33, 0.6) 100%);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s;
            z-index: 5;
        }

        .mobile-hint {
            display: none;
            position: absolute;
            bottom: 50px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.5);
            font-size: 14px;
            pointer-events: none;
        }
        
        @media (hover: none) and (pointer: coarse) {
            .mobile-hint {
                display: block;
            }
        }
        
        @keyframes item-pickup {
            0% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
            100% { transform: translate(-50%, -150%) scale(1.5); opacity: 0; }
        }
        .pickup-effect {
            position: absolute;
            font-size: 30px;
            color: #ff4d4d;
            animation: item-pickup 0.8s ease-out forwards;
            pointer-events: none;
            z-index: 25;
        }

        @keyframes speech-float {
            0% { transform: translate(-50%, 0) scale(1); opacity: 1; }
            50% { transform: translate(-50%, -15px) scale(1.1); opacity: 0.9; }
            100% { transform: translate(-50%, -30px) scale(1); opacity: 0; }
        }
        .villain-speech {
            position: absolute;
            color: #fffdd0; 
            font-family: 'Gugi', cursive; 
            font-size: 24px;
            font-weight: bold;
            white-space: nowrap;
            pointer-events: none;
            z-index: 26;
            animation: speech-float 1.5s ease-out forwards;
            text-shadow: 1px 1px 0px #ccc, 0 0 5px rgba(255, 255, 200, 0.8); 
        }
        
        .sticky-text {
            color: #fffdd0 !important; 
            font-family: 'Gugi', cursive;
            text-shadow: 1px 1px 2px #555, 0 0 5px rgba(255,255,255,0.8);
        }
        
        .sticky-large-text {
            color: #fffdd0 !important;
            font-family: 'Gugi', cursive;
            font-size: 50px !important;
            font-weight: bold;
            text-shadow: 2px 2px 5px rgba(0,0,0,0.5), 0 0 10px rgba(255,255,255,0.8);
            animation: float-up 2.0s ease-out forwards;
            z-index: 101 !important;
        }

        .unwashed-text {
            color: #F0F8FF !important; 
            font-family: 'Gugi', cursive;
            font-size: 45px !important;
            font-weight: bold;
            text-shadow: 2px 2px 2px #aaa, 0 0 10px rgba(255, 255, 240, 0.9);
            animation: float-up 2.5s ease-out forwards;
            z-index: 102 !important;
        }

        .condensed-milk-text {
            color: #FFFDD0 !important;
            font-family: 'Gugi', cursive;
            font-size: 30px !important;
            font-weight: bold;
            text-shadow: 1px 1px 2px #555, 0 0 8px rgba(255,255,220,0.9);
            animation: float-up 2.0s ease-out forwards;
            z-index: 100 !important;
        }

        .dirty-pink-text {
            color: #d45d7d !important;
            font-family: 'Gugi', cursive;
            font-size: 50px !important;
            font-weight: bold;
            text-shadow: 2px 2px 0px #330011, 0 0 10px #ff0066;
            animation: float-up 1.0s ease-out forwards;
            z-index: 102 !important;
        }
        
        .dirty-brown-text { 
            color: #8B4513 !important; 
            font-family: 'Gugi', cursive; 
            font-size: 26px !important; 
            font-weight: bold; 
            text-shadow: 1px 1px 2px #000; 
            animation: float-up 1.0s ease-out forwards; 
            z-index: 102 !important; 
        }

        .pink-text { 
            color: #FF69B4 !important; 
            font-family: 'Gugi', cursive; 
            font-size: 40px !important; 
            font-weight: bold; 
            text-shadow: 1px 1px 2px #000; 
            animation: float-up 1.5s ease-out forwards; 
            z-index: 102 !important; 
        }
        
        .deep-pink-text {
            color: #FF1493 !important;
            font-family: 'Gugi', cursive;
            font-size: 40px !important;
            font-weight: bold;
            text-shadow: 2px 2px 0px #8B008B, 0 0 15px #FF69B4;
            animation: float-up 1.5s ease-out forwards;
            z-index: 102 !important;
        }
        
        .evil-purple-text {
            color: #8A2BE2 !important;
            font-family: 'Gugi', cursive;
            font-size: 50px !important;
            font-weight: bold;
            text-shadow: 2px 2px 0px #2a0033, 0 0 15px #4B0082;
            animation: float-up 1.2s ease-out forwards;
            z-index: 102 !important;
        }

        .shadow-text {
            color: #2F4F4F !important;
            font-family: 'Gugi', cursive;
            font-size: 45px !important;
            font-weight: bold;
            text-shadow: 2px 2px 0 #000, 0 0 10px #708090;
            animation: float-up 1.0s ease-out forwards;
            z-index: 102 !important;
        }

        .poop-text {
            color: #5c4033 !important; 
            font-family: 'Gugi', cursive;
            font-size: 45px !important; 
            font-weight: bold;
            text-shadow: 3px 3px 0px #2a1a0a, 0 0 15px rgba(60, 40, 0, 0.9);
            animation: float-up 1.8s ease-out forwards;
            z-index: 100 !important;
        }

        .evil-summon-text {
            color: #9400D3 !important; 
            font-family: 'Gugi', cursive;
            font-size: 60px !important; 
            font-weight: bold;
            text-shadow: 5px 5px 0px #000000, 0 0 30px rgba(75, 0, 130, 1);
            animation: float-up 3s ease-out forwards; 
            z-index: 100 !important;
        }
        
        .wicked-large-text {
            color: #3d004d !important;
            font-family: 'Gugi', cursive;
            font-size: 90px !important;
            font-weight: bold;
            text-shadow: 4px 4px 0px #000000, 0 0 30px #800080;
            animation: float-up 3.5s ease-out forwards;
            z-index: 102 !important;
        }
        
        .boss-warning-text {
            color: #ff0000 !important;
            font-family: 'Gugi', cursive;
            font-size: 40px !important;
            text-shadow: 3px 3px 0px #000, 0 0 20px rgba(255, 0, 0, 0.8);
            animation: float-up 2s ease-out forwards;
        }
        
        .mind-break-text {
            color: #800080 !important;
            font-family: 'Gugi', cursive;
            font-size: 30px !important;
            text-shadow: 2px 2px 0px #000, 0 0 15px rgba(128, 0, 128, 0.8);
            animation: float-up 1.5s ease-out forwards;
        }

        .pregnancy-text, .evil-shout-text {
            color: #8A2BE2 !important; 
            font-family: 'Gugi', cursive;
            font-size: 70px !important; 
            font-weight: bold;
            text-shadow: 4px 4px 0px #000000, 0 0 20px rgba(75, 0, 130, 1);
            animation: float-up 2.5s ease-out forwards;
            z-index: 101 !important;
        }

        .choke-text {
            color: #2F4F4F !important; 
            font-family: 'Gugi', cursive;
            font-size: 40px !important;
            font-weight: bold;
            text-shadow: 2px 2px 0px #000, 0 0 10px rgba(50, 205, 50, 0.6);
            animation: float-up 2.0s ease-out forwards;
            z-index: 100 !important;
        }

        .fishy-text {
            color: #7FFFD4 !important;
            font-family: 'Gugi', cursive;
            font-size: 40px !important;
            font-weight: bold;
            text-shadow: 2px 2px 0px #008080, 0 0 15px rgba(127, 255, 212, 0.8);
            animation: float-up 2.0s ease-out forwards;
            z-index: 101 !important;
        }
        
        .hollow-night-text {
            color: #9370DB !important;
            font-family: 'Gugi', cursive;
            font-size: 60px !important;
            text-shadow: 0 0 10px #8A2BE2, 0 0 20px #4B0082;
            animation: float-up 2.5s ease-out forwards;
            z-index: 100 !important;
        }

        .malice-text {
            color: #8A2BE2 !important;
            font-family: 'Gugi', cursive;
            font-size: 35px !important;
            font-weight: bold;
            text-shadow: 2px 2px 0px #4B0082, 0 0 15px rgba(138, 43, 226, 0.8);
            animation: float-up 2.0s ease-out forwards;
            z-index: 101 !important;
        }

        .corrupted-text {
            color: #8B0000 !important;
            font-family: 'Gugi', cursive;
            font-size: 40px !important;
            font-weight: bold;
            text-shadow: 2px 2px 0px #000000, 0 0 15px #3f0000;
            animation: float-up 2.0s ease-out forwards;
            z-index: 102 !important;
        }
        
        .sniper-text {
            color: #FFFFFF !important;
            font-family: 'Gugi', cursive;
            font-size: 35px !important;
            font-weight: bold;
            text-shadow: 1px 1px 0px #000, 0 0 10px rgba(255, 255, 255, 0.8);
            animation: float-up 1.5s ease-out forwards;
            z-index: 102 !important;
        }
        
        .ozma-text {
            color: #FF00FF !important;
            font-family: 'Gugi', cursive;
            font-size: 40px !important;
            font-weight: bold;
            text-shadow: 2px 2px 0px #4B0082, 0 0 15px #FF1493;
            animation: float-up 1.5s ease-out forwards;
            z-index: 102 !important;
        }

        .gawain-text {
            color: #9370DB !important; /* MediumPurple */
            font-family: 'Gugi', cursive;
            font-size: 40px !important;
            font-weight: bold;
            text-shadow: 2px 2px 0 #4B0082, 0 0 15px #FFFFFF;
            animation: float-up 1.5s ease-out forwards;
            z-index: 102 !important;
        }
        
        .aki-text {
            color: #1a1a1a !important; /* Very Dark Gray */
            font-family: 'Gugi', cursive;
            font-size: 40px !important;
            font-weight: bold;
            text-shadow: 2px 2px 0 #4B0082, 0 0 15px #000000;
            animation: float-up 1.5s ease-out forwards;
            z-index: 102 !important;
        }

        .hiro-text {
            color: #9932CC !important; /* DarkOrchid */
            font-family: 'Gugi', cursive;
            font-size: 40px !important;
            font-weight: bold;
            text-shadow: 2px 2px 0 #000, 0 0 15px #8B008B;
            animation: float-up 1.5s ease-out forwards;
            z-index: 102 !important;
        }
        
        .arthur-text {
            color: #DC143C !important; /* Crimson */
            font-family: 'Gugi', cursive;
            font-size: 45px !important;
            font-weight: bold;
            text-shadow: 2px 2px 0 #000, 0 0 15px #8B0000;
            animation: float-up 1.5s ease-out forwards;
            z-index: 102 !important;
        }

        .goddess-text {
            color: #FFD700 !important;
            font-family: 'Gugi', cursive;
            font-size: 50px !important;
            font-weight: bold;
            text-shadow: 2px 2px 0 #000, 0 0 20px #FFA500;
            animation: float-up 2s ease-out forwards;
            z-index: 200 !important;
        }
         #xp-bar-container {
            position: absolute;
            top: 60px; /* HP바 아래 */
            left: 20px;
            width: 300px;
            height: 15px;
            background: #222;
            border: 2px solid #fff;
            border-radius: 8px;
            overflow: hidden;
            z-index: 20;
        }
        #xp-bar {
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #8BC34A);
            transition: width 0.2s;
        }
        #level-text {
            position: absolute;
            top: 58px;
            left: 330px;
            color: #fff;
            font-size: 20px;
            font-weight: bold;
            text-shadow: 1px 1px 0 #000;
            z-index: 20;
        }

        #levelUpModal {
            display: none;
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.85);
            z-index: 9999;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            pointer-events: auto;
        }
        #levelUpTitle {
            font-family: 'Gugi', cursive;
            font-size: 50px;
            color: #FFD700;
            margin-bottom: 30px;
            text-shadow: 0 0 10px #FFA500;
            animation: float-up 1s infinite alternate;
        }
        .card-container {
            display: flex;
            gap: 20px;
        }
        .upgrade-card {
            width: 220px;
            height: 300px;
            background: #333;
            border-radius: 15px;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: space-between;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            border: 3px solid #555;
            text-align: center;
            color: white;
            font-family: 'Black Han Sans', sans-serif;
        }
        .upgrade-card.selected {
            transform: translateY(-10px);
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
            border-color: #ffffff; /* 선택됨을 명확히 하기 위해 흰색 테두리 */
            background-color: #444; /* 배경도 살짝 밝게 */
        }
        .upgrade-card:hover {
            transform: translateY(-10px);
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.3);
        }
        .card-rarity { font-size: 18px; margin-bottom: 10px; }
        .card-name { font-size: 24px; color: #fff; margin-bottom: 10px; }
        .card-desc { font-size: 16px; color: #ccc; word-break: keep-all; }
        .card-stat { font-size: 30px; font-weight: bold; margin-top: 10px; }

        /* 등급별 스타일 */
        .rarity-common { border-color: #b0b0b0; box-shadow: 0 0 5px #b0b0b0; }
        .rarity-rare { border-color: #00BFFF; box-shadow: 0 0 10px #00BFFF; }
        .rarity-unique { border-color: #9370DB; box-shadow: 0 0 15px #9370DB; }
        .rarity-legendary { border-color: #FFD700; box-shadow: 0 0 20px #FFD700; animation: blink-border 1s infinite; }
        
        .rarity-text-common { color: #b0b0b0; }
        .rarity-text-rare { color: #00BFFF; }
        .rarity-text-unique { color: #9370DB; }
        .rarity-text-legendary { color: #FFD700; }
        
        /* [신규] 로열 빌런 텍스트 스타일 (검정/청록 테마) */
        .masakuni-text {
            color: #2F4F4F !important; /* DarkSlateGray */
            font-family: 'Gugi', cursive;
            font-size: 45px !important;
            font-weight: bold;
            text-shadow: 2px 2px 0px #000000, 0 0 15px #00CED1;
            animation: float-up 1.5s ease-out forwards;
            z-index: 105 !important;
        }

        /* [신규] 스탯 확인 버튼 스타일 */
        #showStatsBtn {
            margin-top: 20px;
            padding: 10px 20px;
            font-size: 20px;
            background: #444;
            color: #fff;
            border: 2px solid #fff;
            border-radius: 10px;
            cursor: pointer;
            font-family: 'Black Han Sans', sans-serif;
            transition: 0.2s;
        }
        #showStatsBtn:hover {
            background: #666;
        }

        /* [신규] 스탯 정보창 스타일 */
        #statsInfoBox {
            display: none; /* 기본적으로 숨김 */
            position: fixed;
            pointer-events: auto;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 350px;
            background: rgba(0, 0, 0, 0.95);
            border: 3px solid #FFD700;
            border-radius: 15px;
            padding: 20px;
            color: white;
            font-family: 'Black Han Sans', sans-serif;
            z-index: 10000;
            box-shadow: 0 0 20px rgba(0,0,0,0.8);
            text-align: left;
        }
        .stat-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 18px;
            border-bottom: 1px solid #444;
            padding-bottom: 4px;
        }
        .stat-label { color: #ccc; }
        .stat-value { color: #FFD700; font-weight: bold; }
        #closeStatsBtn {
            margin-top: 15px;
            width: 100%;
            padding: 10px;
            background: #8B0000;
            color: white;
            border: none;
            font-size: 18px;
            cursor: pointer;
            font-family: 'Black Han Sans', sans-serif;
        }
    </style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<div class="damage-overlay" id="damageOverlay"></div>
<div id="poopOverlay"></div>
<div id="mindOverlay"></div>
<div id="confusionOverlay"></div>
<div id="darknessOverlay"></div>
<div id="sacredFaithOverlay"></div>
<div id="bloodOverlay"></div> <!-- [신규] 블러드 오버레이 추가 -->
<div id="visionOverlay"></div>
<div id="skillSealOverlay">
<div id="skillSealText">스킬 봉인!</div>
</div>
<div id="ui-layer">
<div class="hud-top">
<div class="status-container-left">
<!-- HP 바와 스킬 아이콘을 가로로 배치 -->
<div class="hp-skill-row">
<div class="health-container">
<div class="health-bar" id="healthBar"></div>
<div class="health-text" id="healthText">HP</div>
</div>
<!-- 여신의 가호 스킬 아이콘 -->
<div class="skill-icon-box" id="goddessSkillIcon">
<img alt="여신의 가호" class="skill-img" id="goddessSkillImg" src=""/>
<div class="cooldown-overlay" id="goddessCooldownOverlay"></div>
<div class="seal-overlay" id="goddessSealOverlay">X</div>
<span class="key-hint">Q</span>
<span class="cooldown-text" id="goddessCooldownText">45</span>
</div>
<!-- 성스러운 믿음 스킬 아이콘 -->
<div class="skill-icon-box" id="sacredFaithSkillIcon" style="margin-left: 5px;">
<img alt="성스러운 믿음" class="skill-img" id="sacredFaithSkillImg" src=""/>
<div class="cooldown-overlay" id="sacredFaithCooldownOverlay"></div>
<div class="seal-overlay" id="sacredFaithSealOverlay">X</div>
<span class="key-hint">W</span>
<span class="cooldown-text" id="sacredFaithCooldownText">45</span>
</div>
<!-- 한계 집중 스킬 아이콘 -->
<div class="skill-icon-box" id="limitFocusIcon" style="margin-left: 5px;">
<img alt="한계 집중" class="skill-img" id="limitFocusImg" src=""/>
<div class="cooldown-overlay" id="limitFocusCooldownOverlay"></div>
<div class="seal-overlay" id="limitFocusSealOverlay">X</div>
<span class="key-hint">E</span> <span class="cooldown-text" id="limitFocusCooldownText">45</span>
</div>
<!-- 천상의 도약 스킬 아이콘 -->
<div class="skill-icon-box" id="divineDashSkillIcon" style="margin-left: 5px;">
<img alt="천상의 도약" class="skill-img" id="divineDashSkillImg" src=""/>
<div class="cooldown-overlay" id="divineDashCooldownOverlay"></div>
<div class="seal-overlay" id="divineDashSealOverlay">X</div>
<span class="key-hint">Space</span>
<span class="cooldown-text" id="divineDashCooldownText">7</span>
</div>
<!-- 회개의 외침 스킬 아이콘 -->
<div class="skill-icon-box" id="novaSkillIcon" style="margin-left: 5px;">
<img alt="회개의 외침" class="skill-img" id="novaSkillImg" src=""/>
<div class="cooldown-overlay" id="novaCooldownOverlay"></div>
<div class="seal-overlay" id="novaSealOverlay">X</div>
<span class="key-hint">A</span>
<span class="cooldown-text" id="novaCooldownText">15</span>
</div>
</div>
<div class="status-icon-box berserk-border" id="berserkStatus" style="display: none;">
<img alt="베르세르크" class="status-img" id="berserkIcon" src=""/>
<span class="status-text" style="color:#FF0000;"><span id="berserkName">베르세르크!</span></span>
</div>
<div class="status-icon-box shield-border" id="shieldStatus" style="display: none;">
<img alt="보호" class="status-img" id="shieldIcon" src=""/>
<span class="status-text" style="color:#00BFFF;"><span id="shieldName">보호막</span> x <span id="shieldStacks">0</span></span>
</div>
<div class="status-icon-box justice-border" id="justiceStatus" style="display: none;">
<img alt="정의" class="status-img" id="justiceIcon" src=""/>
<span class="status-text" style="color:#FFD700;"><span id="justiceName">정의의 가호</span> x <span id="justiceStacks">0</span></span>
</div>
<div class="status-icon-box blind-border" id="blindStatus" style="display: none;">
<img alt="실명" class="status-img" id="blindIcon" src=""/>
<span class="status-text" style="color:#808080;"><span id="blindName">실명(명중↓)</span> x <span id="blindStacks">0</span></span>
</div>
<div class="status-icon-box paralysis-border" id="paralysisStatus" style="display: none;">
<img alt="마비" class="status-img" id="paralysisIcon" src=""/>
<span class="status-text" style="color:#9370DB;"><span id="paralysisName">마비(이동↓)</span> x <span id="paralysisStacks">0</span></span>
</div>
<div class="status-icon-box poison-border" id="poisonStatus" style="display: none;">
<img alt="가스중독" class="status-img" id="poisonDebuffIcon" src=""/>
<span class="status-text" style="color:#00ff00;"><span id="poisonName">가스</span> x <span id="poisonStacks">0</span></span>
</div>

<div class="status-icon-box fishy-border" id="fishyStatus" style="display: none;">
<img alt="비린내" class="status-img" id="fishyIcon" src=""/>
<span class="status-text" style="color:#7FFFD4;"><span id="fishyName">비린내 붓카게</span> x <span id="fishyStacks">0</span></span>
</div>
<div class="status-icon-box poop-border" id="poopStatus" style="display: none;">
<img alt="똥독" class="status-img" id="poopDebuffIcon" src=""/>
<span class="status-text" style="color:#D2691E;"><span id="poopName">똥독</span> x <span id="poopStacks">0</span></span>
</div>
<div class="status-icon-box bleeding-border" id="bleedingStatus" style="display: none;">
<img alt="출혈" class="status-img" id="bleedingIcon" src=""/>
<span class="status-text" style="color:#DC143C;">출혈 <span id="bleedingVal"></span></span>
</div>
<div class="status-icon-box darkness-border" id="darknessStatus" style="display: none;">
<img alt="암흑" class="status-img dark-icon" id="darknessIcon" src=""/>
<span class="status-text" style="color:#555;">암흑</span>
</div>
<div class="status-icon-box malice-border" id="maliceStatus" style="display: none;">
<img alt="악의의 바이러스" class="status-img" id="maliceIcon" src=""/>
<span class="status-text" style="color:#8A2BE2;"><span id="maliceName">악의의 바이러스</span> x <span id="maliceStacks">0</span></span>
</div>
<!-- -------------------------------------------- -->
<div class="status-icon-box kiss-border" id="kissStatus" style="display: none;">
<img alt="속박키스" class="status-img" id="kissDebuffIcon" src=""/>
<span class="status-text" style="color:#FF1493;"><span id="kissName">키스</span> x <span id="kissStacks">0</span></span>
</div>
<div class="status-icon-box semen-border" id="semenStatus" style="display: none;">
<img alt="질내사정" class="status-img" id="semenDebuffIcon" src=""/>
<span class="status-text" style="color:#FFFFFF; text-shadow: 1px 1px 0 #888;"><span id="semenName">점액</span> x <span id="semenStacks">0</span></span>
</div>
<div class="status-icon-box oral-border" id="oralStatus" style="display: none;">
<img alt="구내사정" class="status-img" id="oralDebuffIcon" src=""/>
<span class="status-text" style="color:#FFFDD0; text-shadow: 1px 1px 0 #888;"><span id="oralName">구내사정</span> x <span id="oralStacks">0</span></span>
</div>
<div class="status-icon-box byururut-border" id="byururutStatus" style="display: none;">
<img alt="뷰루룻" class="status-img" id="byururutDebuffIcon" src=""/>
<span class="status-text" style="color:#FFFDD0; text-shadow: 1px 1px 0 #888;"><span id="byururutName">뷰루룻</span> x <span id="byururutStacks">0</span></span>
</div>
<div class="status-icon-box evil-mind-border" id="evilMindStatus" style="display: none;">
<img alt="사악한 마음" class="status-img" id="evilMindDebuffIcon" src=""/>
<span class="status-text" style="color:#800080;"><span id="evilMindName">사악한 마음</span> x <span id="evilMindStacks">0</span></span>
</div>
</div>
<div class="score-box">생존: <span id="scoreVal">0</span> | 킬: <span id="killVal">0</span></div>
<div class="status-container-right">
<div class="status-icon-box pheromone-overload-border" id="pheromoneOverloadStatus" style="display: none;">
<img alt="페로몬 오버로드" class="status-img" id="pheromoneOverloadIcon" src=""/>
<div class="flex flex-col" style="line-height: 1.1;">
<span class="status-text" style="color:#FF0000;">페로몬 오버로드</span>
<span id="pheromoneOverloadInfo" style="font-size: 14px; color: #FFB3B3; text-shadow: 1px 1px 0 #000; font-weight: bold;">남은 0.0s | 크리 0/3</span>
</div>
</div>
<div class="status-icon-box darkness-overwhelm-border" id="darknessOverwhelmStatus" style="display: none;">
<img alt="다크니스 오버휠름" class="status-img" id="darknessOverwhelmIcon" src=""/>
<span class="status-text" style="color:#483d8b;">다크니스 오버휠름 (속도)</span>
</div>
<div class="status-icon-box hyper-border" id="hypersensitivityStatus" style="display: none;">
<img alt="과민 반응" class="status-img" id="hyperIcon" src=""/>
<span class="status-text" style="color:#FFFF00;"><span id="hyperName">과민 반응 (기절주의!)</span></span>
</div>
<div class="status-icon-box corrupted-oath-border" id="corruptedOathStatus" style="display: none;">
<img alt="타락한 맹세" class="status-img" id="corruptedOathIcon" src=""/>
<span class="status-text" style="color:#8B0000;"><span id="corruptedOathName">타락한 맹세</span> x <span id="corruptedOathStacks">0</span></span>
</div>
<div class="status-icon-box dangerous-judgment-border" id="dangerousJudgmentStatus" style="display: none;">
<img alt="위험한 판단" class="status-img" id="dangerousJudgmentIcon" src=""/>
<span class="status-text" style="color:#FFA500;"><span id="dangerousJudgmentName">위험한 판단</span> x <span id="dangerousJudgmentStacks">0</span></span>
</div>
<div class="status-icon-box deep-darkness-border" id="deepDarknessStatus" style="display: none;">
<img alt="짙은 어둠" class="status-img" id="deepDarknessIcon" src=""/>
<span class="status-text" style="color:#222;"><span id="deepDarknessName">짙은 어둠</span> x <span id="deepDarknessStacks">0</span></span>
</div>
<div class="status-icon-box corrupted-justice-border" id="corruptedJusticeStatus" style="display: none;">
<img alt="타락한 정의" class="status-img" id="corruptedJusticeIcon" src=""/>
<span class="status-text" style="color:#555;"><span id="corruptedJusticeName">타락한 정의</span> x <span id="corruptedJusticeStacks">0</span></span>
</div>
<div class="status-icon-box serum-contamination-border" id="serumContaminationStatus" style="display: none;">
<img alt="혈청 오염" class="status-img" id="serumContaminationIcon" src=""/>
<span class="status-text" style="color:#FF6347;">혈청 오염 (회복 불가)</span>
</div>
<!-- 아서 신규 디버프 UI -->
<div class="status-icon-box majesty-border" id="majestyStatus" style="display: none;">
<img alt="군주의 위엄" class="status-img" id="majestyIcon" src=""/>
<span class="status-text" style="color:#DAA520;">군주의 위엄 (쿨감↓, 회복↓)</span>
</div>
<div class="status-icon-box true-ancestor-border" id="trueAncestorKissStatus" style="display: none;">
<img alt="진조의 키스" class="status-img" id="trueAncestorKissIcon" src=""/>
<span class="status-text" style="color:#DC143C;">진조의 키스 x <span id="trueAncestorKissStacks">0</span></span>
</div>
<div class="status-icon-box fatal-scar-border" id="fatalScarStatus" style="display: none;">
<img alt="페이탈 스칼" class="status-img" id="fatalScarIcon" src=""/>
<span class="status-text" style="color:#8B0000;">페이탈 스칼 x <span id="fatalScarStacks">0</span></span>
</div>
<div class="status-icon-box corrupted-blood-border" id="corruptedBloodStatus" style="display: none;">
<img alt="더럽혀진 피" class="status-img" id="corruptedBloodIcon" src=""/>
<span class="status-text" style="color:#800000;">더럽혀진 피 x <span id="corruptedBloodStacks">0</span></span>
</div>
<div class="status-icon-box geoptal-border" id="geoptalStatus" style="display: none;">
<img alt="겁탈" class="status-img" id="geoptalIcon" src=""/>
<span class="status-text" style="color:#ff0055;"><span id="geoptalName">겁탈(방어↓)</span> x <span id="geoptalStacks">0</span></span>
</div>
<div class="status-icon-box death-brand-border" id="deathBrandStatus" style="display: none;">
<img alt="죽음의 낙인" class="status-img" id="deathBrandIcon" src=""/>
<span class="status-text" style="color:#696969; text-shadow: 1px 1px 0 #000;">죽음의 낙인 (회피/치명타 저항 확률 50%↓)</span>
</div>
<div class="status-icon-box curse-border" id="curseStatus" style="display: none;">
<img alt="저주" class="status-img" id="curseIcon" src=""/>
<span class="status-text" style="color:#4B0082;"><span id="curseName">저주</span> x <span id="curseStacks">0</span></span>
</div>
<div class="status-icon-box fracture-border" id="fractureStatus" style="display: none;">
<img alt="골절" class="status-img" id="fractureIcon" src=""/>
<span class="status-text" style="color:#A9A9A9;">골절 (치명타 저항 확률 -5) x <span id="fractureStacks">0</span></span>
</div>
<div class="status-icon-box gnawing-life-border" id="gnawingLifeStatus" style="display: none;">
<img alt="좀먹는 생명" class="status-img" id="gnawingLifeIcon" src=""/>
<span class="status-text" style="color:#6B8E23;"><span id="gnawingLifeName">좀먹는 생명</span> x <span id="gnawingLifeStacks">0</span></span>
</div>
<div class="status-icon-box dark-scent-border" id="darkScentStatus" style="display: none;">
<img alt="카인의 향기" class="status-img dark-icon" id="darkScentIcon" src=""/>
<span class="status-text" style="color:#2F4F4F;"><span id="darkScentName">카인의 향기</span> x <span id="darkScentStacks">0</span></span>
</div>
<div class="status-icon-box dark-smell-border" id="darkSmellStatus" style="display: none;">
<img alt="카인의 똥내" class="status-img dark-icon" id="darkSmellIcon" src=""/>
<span class="status-text" style="color:#3e2723;"><span id="darkSmellName">카인의 똥내</span> x <span id="darkSmellStacks">0</span></span>
</div>
<div class="status-icon-box dark-seed-border" id="darkSeedStatus" style="display: none;">
<img alt="카인의 씨앗" class="status-img dark-icon" id="darkSeedIcon" src=""/>
<span class="status-text" style="color:#4a4a4a;"><span id="darkSeedName">카인의 씨앗</span> x <span id="darkSeedStacks">0</span></span>
</div>
<div class="status-icon-box dark-kiss-border" id="darkKissStatus" style="display: none;">
<img alt="카인의 키스" class="status-img dark-icon" id="darkKissIcon" src=""/>
<span class="status-text" style="color:#880e4f;"><span id="darkKissName">카인의 키스</span> x <span id="darkKissStacks">0</span></span>
</div>
<div class="status-icon-box dark-receiver-border" id="darkReceiverStatus" style="display: none;">
<img alt="카인의 좆집" class="status-img dark-icon" id="darkReceiverIcon" src=""/>
<span class="status-text" style="color:#1a237e;"><span id="darkReceiverName">카인의 좆집</span> x <span id="darkReceiverStacks">0</span></span>
</div>
<div class="status-icon-box evil-light-border" id="evilLightStatus" style="display: none;">
<img alt="사악한 빛" class="status-img dark-icon" id="evilLightIcon" src=""/>
<span class="status-text" style="color:#3d004d;"><span id="evilLightName">사악한 빛</span></span>
</div>
<div class="status-icon-box" id="blasphemyStatus" style="display: none; border: 2px solid #000000; box-shadow: 0 0 10px #FF0000;">
<img alt="신성 모독" class="status-img" id="blasphemyIcon" src=""/>
<span class="status-text" style="color:#FF0000;">신성 모독</span>
</div>
<div class="status-icon-box confusion-border" id="confusionStatus" style="display: none;">
<img alt="정신착란" class="status-img" id="confusionIcon" src=""/>
<span class="status-text" style="color:#FF4500;">정신착란</span>
</div>
<div class="status-icon-box shading-border" id="shadingStatus" style="display: none;">
<img alt="차광" class="status-img" id="shadingIcon" src=""/>
<span class="status-text" style="color:#4B0082;">차광 (치명타 저항 감소)</span>
</div>
<div class="status-icon-box dark-ecstasy-border" id="darkEcstasyStatus" style="display: none;">
<img alt="어둠의 환희" class="status-img" id="darkEcstasyIcon" src=""/>
<span class="status-text" style="color:#9932CC;"><span id="darkEcstasyName">어둠의 환희</span> x <span id="darkEcstasyStacks">0</span></span>
</div>
<div class="status-icon-box despair-border" id="despairStatus" style="display: none;">
<img alt="절망" class="status-img" id="despairIcon" src=""/>
<span class="status-text" style="color:#708090;">절망 (스킬 실패)</span>
</div>
<div class="status-icon-box baptism-border" id="baptismStatus" style="display: none;">
<img alt="세례" class="status-img" id="baptismIcon" src=""/>
<span class="status-text" style="color:#4169E1;">세례 (공격력↓) x <span id="baptismStacks">0</span></span>
</div>
<div id="xp-bar-container">
<div id="xp-bar"></div>
</div>
<div id="level-text">Lv.1</div>
</div>
<div class="mobile-hint">화면을 드래그하여 이동하세요</div>
<div id="levelUpModal">
<div id="levelUpTitle">LEVEL UP!</div>
<div class="card-container" id="cardContainer">
</div>
<button id="showStatsBtn">내 스탯 확인</button>
</div> <div id="statsInfoBox">
<h2 style="text-align:center; color:#fff; margin-top:0; margin-bottom:15px;">현재 스탯</h2>
<div id="statsContent">
</div>
<button id="closeStatsBtn">닫기</button>
</div>
</div>
<div id="screen-overlay">
<h1 class="title">가죽바지 빌런<br/>서바이벌</h1>
<p class="subtitle">
            캐릭터가 <span style="color:#ffcc00">자동으로 공격</span>합니다.<br/>
<span style="color:#00BFFF">보호의 하트</span>와 <span style="color:#FFD700">Q스킬(여신의 가호)</span>로 상태이상을 방어하세요!<br/>
<span style="color:#ffd700">W스킬(성스러운 믿음)</span>으로 치명타 확률을 줄이세요!<br/>
<span style="color:#00ffff">A스킬(회개의 외침)</span>으로 위기를 탈출하세요!<br/>
<span style="color:#FF0000; font-weight:bold;">어둠의 도래</span>
</p>
<button class="btn" id="startBtn">게임 시작</button>
<button class="btn" id="gameOverStatsBtn" style="display:none; margin-top:15px; background-color: #333; border: 2px solid #aaa; font-size: 20px;">사망 스탯 확인</button>
</div>
<script>
        // ==================================================================================
        // [이미지 커스터마이징 영역]
        // ==================================================================================
        const novaSkillIconSrc = "https://i.ifh.cc/8wVPWP.jpg"; 
        const sacredFaithSkillImgSrc = "https://i.ifh.cc/zcCSL8.jpg"; 
        const limitFocusIconSrc = "https://i.ifh.cc/dR0TkQ.jpg";
        const goddessSkillImgSrc = "https://i.ifh.cc/t1V1v5.jpg"; 
        const hiroImgSrc = "https://i.ifh.cc/3YwsSM.jpg"; 
        // [신규] 아키 '이블 애로우' 발사체 이미지 (첨부 PNG를 배경 제거 후 내장)
        const akiEvilArrowDevilImg = new Image();
        akiEvilArrowDevilImg.src = "./evil_arrow_devil_transparent.png";
        // base64가 보기 싫으면, 이미지를 파일로 분리해서 같은 폴더에 두는 방식이 가장 깔끔합니다.
        akiEvilArrowDevilImg.onerror = () => console.warn("evil_arrow_devil_transparent.png를 HTML과 같은 폴더에 넣어주세요.");

        // [신규] 아키 '포이즈너스 샷' 발사체 이미지 (투명 PNG 파일을 같은 폴더에 두세요)
        const akiPoisonousShotImg = new Image();
        akiPoisonousShotImg.src = "./aki_poisonous_shot.png";
        akiPoisonousShotImg.onerror = () => console.warn("aki_poisonous_shot.png를 HTML과 같은 폴더에 넣어주세요.");

        
        // [신규] 검은 민족 테토라 및 스킬 이미지
        const tetoraImgSrc = "https://i.ifh.cc/OoPjFM.jpg"; // ★ 테토라 이미지 (커스텀 필요)
        const tetoraImg = new Image(); 
        tetoraImg.src = tetoraImgSrc;

        // [신규] 퀘스타 이미지 및 아이콘
        const questaImgSrc = "https://i.ifh.cc/HfdXXh.jpg"; // ★ 퀘스타 이미지 주소 입력 (커스터마이즈)
        const fractureIconSrc = "https://i.ifh.cc/4Kcfo8.jpg"; // ★ 골절 아이콘 주소 입력 (커스터마이즈)
        
        const questaImg = new Image(); 
        questaImg.src = questaImgSrc;

        // [신규] 검은 민족 카이토 및 관련 이미지
        const kaitoImgSrc = "https://i.ifh.cc/MbWl3j.jpg"; //
        const kaitoImg = new Image(); kaitoImg.src = kaitoImgSrc;

        const despairIconSrc = "https://i.ifh.cc/8W1Qbf.jpg";
        const baptismIconSrc = "https://i.ifh.cc/kKnoKF.jpg";

        // [신규] 검은 민족 마사쿠니 이미지 (커스터마이즈 가능)
        const masakuniImgSrc = "https://i.ifh.cc/l7Knjn.jpg";
        const masakuniImg = new Image(); 
        masakuniImg.src = masakuniImgSrc;

        const kaiImgSrc = "https://i.ifh.cc/lDSMxF.jpg";
        const kaiImg = new Image(); kaiImg.src = kaiImgSrc;

        const jacquesImgSrc = "https://i.ifh.cc/caP80b.jpg";
        const jacquesImg = new Image(); jacquesImg.src = jacquesImgSrc;
        const blasphemyIconSrc = "https://i.ifh.cc/4j7Alv.jpg";
        const deathBrandIconSrc = "https://i.ifh.cc/OGcch6.jpg"; // 원하는 이미지 주소로 변경하세요 ★죽음의 낙인 아이콘 주소 입력★
        const bleedingIconSrc = "https://i.ifh.cc/faQZ8Z.jpg"; // 출혈 아이콘 주소
        const shadingIconSrc = "https://i.ifh.cc/16CqwH.jpg"; // 차광 아이콘 주소
        const darknessIconSrc = "https://i.ifh.cc/Z94Wa8.jpg"; // 암흑 아이콘
        const confusionIconSrc = "https://i.ifh.cc/5hbTZ0.jpg"; // 정신착란 아이콘

        // [신규] 보스 기믹 아이콘 이미지 (원하는 주소로 변경 가능)
        const pheromoneOverloadIconSrc = "https://i.ifh.cc/Rs2bWR.jpg"; 
        const darknessOverwhelmIconSrc = "https://i.ifh.cc/soyV4f.jpg"; 


        // ================================================================
        // [보조] 페로몬 오버로드: UI 갱신 / 해제 공통 처리
        //  - 해제 조건: (1) 10초 경과, (2) 크리티컬 3회 피격, (3) 카인 사망
        // ================================================================
        function updatePheromoneOverloadUI() {
            const infoEl = document.getElementById('pheromoneOverloadInfo');
            if (!infoEl) return;
            if (player.pheromoneOverloadTimer > 0) {
                const sec = (player.pheromoneOverloadTimer / 60).toFixed(1);
                const cnt = (player.pheromoneOverloadCritCount || 0);
                infoEl.textContent = `남은 ${sec}s | 크리 ${cnt}/3`;
            }
        }

        function endPheromoneOverload() {
            player.pheromoneOverloadTimer = 0;
            player.pheromoneOverloadCritCount = 0;

            // UI 즉시 반영
            const phStatus = document.getElementById('pheromoneOverloadStatus');
            if (phStatus) phStatus.style.display = 'none';

            // bloodOverlay는 다른 효과(군주의 위엄/더럽혀진 피)가 없을 때만 끄기
            const bloodOverlay = document.getElementById('bloodOverlay');
            if (bloodOverlay && !player.majestyActive && player.corruptedBloodTimers.length === 0) {
                bloodOverlay.style.opacity = 0;
            }
        }

        // [신규] 혈청 오염 아이콘 (커스터마이징 가능)
        const serumContaminationIconSrc = "https://i.ifh.cc/zGNVfg.jpg";

        const arthurImgSrc = "https://i.ifh.cc/lMCXBQ.jpg"; // 아서 이미지
        const majestyIconSrc = "https://i.ifh.cc/l8KVCB.jpg"; // 군주의 위엄 (아서 아이콘 재활용)
        const trueAncestorKissIconSrc = "https://i.ifh.cc/FZRpzQ.jpg"; // 진조의 키스 (키스 아이콘 재활용)
        const fatalScarIconSrc = "https://i.ifh.cc/zYKx2c.jpg"; // 페이탈 스칼
        const corruptedBloodIconSrc = "https://i.ifh.cc/T8FJOn.jpg"; // 더럽혀진 피

        // [신규] 천상의 도약 스킬 아이콘 (커스터마이징 가능)
        const divineDashIconSrc = "https://i.ifh.cc/nTqFDL.jpg"; // 원하는 이미지 주소로 변경하세요

        // [신규] 아서 등장 BGM
        const arthurSpawnBgmSrc = "https://adverse-chocolate-xu548n9xf6-uxib5ngrdl.edgeone.dev/KakaoTalk_20251228_162954993.mp4"; //
        // ==================================================================================

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // =========================
        // [최적화] 다크 똥(유도 포함) 스프라이트 캐시
        // - 기존: 매 프레임마다 createRadialGradient/ellipse/shadowBlur 등을 똥 개수만큼 수행 → 프레임 드랍
        // - 변경: radius별로 1회만 오프스크린 캔버스에 그려두고, 매 프레임엔 drawImage만 수행
        // =========================
        const _darkBigPoopSpriteCache = new Map();

        function _makeDarkBigPoopSprite(radius) {
            const r = Math.max(1, radius);
            const pad = Math.ceil(r * 1.6);  // 오라/그림자 여백
            const size = Math.ceil(r * 4.2) + pad * 2;
            const c = document.createElement('canvas');
            c.width = size; c.height = size;
            const g = c.getContext('2d');

            const cx = size / 2, cy = size / 2;

            // 색상 팔레트 (검정, 다크 그레이, 보라빛)
            const baseColor = '#1a1a1a';
            const midColor  = '#333333';
            const darkColor = '#000000';
            const glowColor = '#4B0082';

            g.save();
            g.translate(cx, cy);

            // 오라(스프라이트 내부에서만 1회 계산)
            g.shadowColor = glowColor;
            g.shadowBlur = Math.max(8, Math.floor(r * 0.35));

            const drawDarkLump = (yOffset, width, height) => {
                g.beginPath();
                const grad = g.createRadialGradient(-width*0.2, yOffset-height*0.2, width*0.1, 0, yOffset, width);
                grad.addColorStop(0, midColor);
                grad.addColorStop(0.3, baseColor);
                grad.addColorStop(0.8, darkColor);
                grad.addColorStop(1, '#100010');
                g.fillStyle = grad;
                g.ellipse(0, yOffset, width, height, 0, 0, Math.PI * 2);
                g.fill();

                // 균열(정적)
                g.shadowBlur = 0;
                g.strokeStyle = 'rgba(75, 0, 130, 0.45)';
                g.lineWidth = 1;
                g.beginPath();
                g.moveTo(-width*0.5, yOffset);
                g.quadraticCurveTo(0, yOffset - height*0.5, width*0.5, yOffset + height*0.3);
                g.stroke();

                // 오라 재적용(다음 덩어리용)
                g.shadowColor = glowColor;
                g.shadowBlur = Math.max(8, Math.floor(r * 0.35));
            };

            // 바닥, 중간, 끝 (기존과 동일한 비율)
            drawDarkLump(r * 0.4,  r,       r * 0.6);
            drawDarkLump(-r * 0.2, r * 0.8, r * 0.55);
            drawDarkLump(-r * 0.8, r * 0.5, r * 0.5);

            // 간단한 "냄새" 라인(정적) — 기존의 Date.now 기반 웨이브는 런타임 비용이 커서 정적으로 축소
            g.shadowBlur = Math.max(4, Math.floor(r * 0.12));
            g.shadowColor = '#8A2BE2';
            g.strokeStyle = 'rgba(50, 0, 50, 0.7)';
            g.lineWidth = Math.max(2, Math.floor(r * 0.06));
            g.beginPath();
            for (let k = 0; k < 3; k++) {
                const startX = (k - 1) * r * 0.35;
                g.moveTo(startX, -r * 0.9);
                g.lineTo(startX + (k === 1 ? 8 : -6), -r * 3.2);
            }
            g.stroke();

            g.restore();

            // 메타(그리기에서 편하게 쓰기)
            c.__half = size / 2;
            return c;
        }

        function getDarkBigPoopSprite(radius) {
            // radius가 부동소수로 바뀌어도 캐시가 과도하게 쌓이지 않도록 0.5단위로 스냅
            const key = Math.max(1, Math.round(radius * 2) / 2);
            let sprite = _darkBigPoopSpriteCache.get(key);
            if (!sprite) {
                sprite = _makeDarkBigPoopSprite(key);
                _darkBigPoopSpriteCache.set(key, sprite);
            }
            return sprite;
        }

// [Polyfill] ctx.roundRect for older browsers
if (ctx && !ctx.roundRect) {
  CanvasRenderingContext2D.prototype.roundRect = function(x, y, w, h, r) {
    const rr = Array.isArray(r) ? r[0] : r;
    const radius = Math.max(0, Math.min(rr || 0, Math.min(w, h) / 2));
    this.beginPath();
    this.moveTo(x + radius, y);
    this.lineTo(x + w - radius, y);
    this.quadraticCurveTo(x + w, y, x + w, y + radius);
    this.lineTo(x + w, y + h - radius);
    this.quadraticCurveTo(x + w, y + h, x + w - radius, y + h);
    this.lineTo(x + radius, y + h);
    this.quadraticCurveTo(x, y + h, x, y + h - radius);
    this.lineTo(x, y + radius);
    this.quadraticCurveTo(x, y, x + radius, y);
    this.closePath();
    return this;
  };
}

// === [Aki] Projectile Draw Cache (Evil Arrow / Drag Shot) ===
let _akiProjectileUid = 1;
const _akiDrawCache = {
  hookPath: null,
  devilBodyPath: null,
};

function _initAkiProjectilePaths() {
  if (_akiDrawCache.hookPath && _akiDrawCache.devilBodyPath) return;

  // Long hook (local space: forward = +x)
  const hook = new Path2D();
  // Shaft + hook curve
  hook.moveTo(-80, -10);
  hook.lineTo(20, -10);
  hook.quadraticCurveTo(45, -10, 45, -32);
  hook.quadraticCurveTo(45, -60, 10, -60);
  hook.lineTo(2, -46);
  hook.quadraticCurveTo(22, -46, 22, -32);
  hook.quadraticCurveTo(22, -22, 5, -22);
  hook.lineTo(-80, -22);
  hook.closePath();

  // Spikes / barbs (multiple) — cached Path2D (no per-frame random)
  // Main big barb (top)
  hook.moveTo(-10, -22);
  hook.lineTo(-28, -44);
  hook.lineTo(-6, -34);
  hook.closePath();

  // Additional barbs along the shaft (alternate top/bottom)
  // Barb 1 (top)
  hook.moveTo(-58, -10);
  hook.lineTo(-74, -26);
  hook.lineTo(-52, -18);
  hook.closePath();

  // Barb 2 (bottom)
  hook.moveTo(-48, -22);
  hook.lineTo(-66, -8);
  hook.lineTo(-44, -12);
  hook.closePath();

  // Barb 3 (top)
  hook.moveTo(-34, -10);
  hook.lineTo(-50, -28);
  hook.lineTo(-30, -18);
  hook.closePath();

  // Barb 4 (bottom)
  hook.moveTo(-24, -22);
  hook.lineTo(-42, -6);
  hook.lineTo(-20, -12);
  hook.closePath();

  // Barb 5 (top near curve)
  hook.moveTo(-8, -10);
  hook.lineTo(-24, -26);
  hook.lineTo(-4, -18);
  hook.closePath();

  _akiDrawCache.hookPath = hook;

  // Devil body silhouette (local space: forward = +x)
  // Rebuilt to be grotesque / unsettling (less round, more torn + asymmetrical)
  const devil = new Path2D();

  // Twisted torso
  devil.moveTo(-26, 0);
  devil.bezierCurveTo(-30, -22, -6, -32, 10, -24);
  devil.bezierCurveTo(30, -16, 44, -8, 46, 0);
  devil.bezierCurveTo(44, 16, 24, 30, 6, 26);
  devil.bezierCurveTo(-12, 22, -24, 12, -26, 0);
  devil.closePath();

  // Snout extension (longer, sharper)
  devil.moveTo(18, -4);
  devil.quadraticCurveTo(42, -16, 48, 0);
  devil.quadraticCurveTo(40, 16, 18, 5);
  devil.closePath();

  // Split jaw / fang
  devil.moveTo(12, 8);
  devil.lineTo(28, 22);
  devil.lineTo(8, 26);
  devil.closePath();

  // Torn back membrane (top)
  devil.moveTo(-10, -6);
  devil.lineTo(-46, -34);
  devil.lineTo(-30, -2);
  devil.closePath();

  // Torn back membrane (bottom)
  devil.moveTo(-12, 8);
  devil.lineTo(-42, 32);
  devil.lineTo(-24, 24);
  devil.closePath();

  // Ragged spine spikes
  devil.moveTo(-6, -14);
  devil.lineTo(-22, -30);
  devil.lineTo(-4, -24);
  devil.closePath();

  devil.moveTo(2, -16);
  devil.lineTo(-6, -38);
  devil.lineTo(12, -22);
  devil.closePath();

  devil.moveTo(10, -14);
  devil.lineTo(4, -36);
  devil.lineTo(22, -18);
  devil.closePath();

  // Asymmetric horns (one longer, one jagged)
  devil.moveTo(2, -18);
  devil.lineTo(-12, -48);
  devil.lineTo(16, -26);
  devil.closePath();

  devil.moveTo(18, -16);
  devil.lineTo(44, -44);
  devil.lineTo(24, -22);
  devil.closePath();

  // Forehead spike (adds "wrong" silhouette)
  devil.moveTo(8, -18);
  devil.lineTo(14, -36);
  devil.lineTo(20, -18);
  devil.closePath();

  _akiDrawCache.devilBodyPath = devil;
}

function _drawAkiPurpleElectric(ctx, frame, seed, backLen, spread, lineWidth = 2) {
  // Deterministic "sparks" (no Math.random in render loop)
  const phase = frame * 0.22 + seed * 0.001;

  ctx.save();
  ctx.globalCompositeOperation = 'lighter';
  ctx.lineWidth = lineWidth;
  ctx.lineCap = 'round';

  for (let s = 0; s < 2; s++) {
    const sign = s === 0 ? 1 : -1;

    ctx.beginPath();
    ctx.strokeStyle = 'rgba(75, 0, 130, 0.75)'; // Indigo
    ctx.moveTo(10, 0);
    for (let j = 1; j <= 3; j++) {
      const xx = -j * (backLen / 3);
      const yy = sign * (Math.sin(phase + j * 1.6 + s * 2.2) * spread) + (j === 3 ? 0 : sign * 4);
      ctx.lineTo(xx, yy);
    }
    ctx.stroke();

    ctx.beginPath();
    ctx.strokeStyle = 'rgba(138, 43, 226, 0.55)'; // BlueViolet glow
    ctx.moveTo(6, 0);
    for (let j = 1; j <= 3; j++) {
      const xx = -j * (backLen / 3);
      const yy = sign * (Math.sin(phase + j * 1.9 + 1.3 + s) * (spread * 0.8));
      ctx.lineTo(xx, yy);
    }
    ctx.stroke();
  }

  ctx.restore();
}

function drawAkiDragShot(ctx, shot, frame) {
    // 요청한 신규 드래그 샷 발사체 렌더링: 검정 전류 + 갈고리
    // (기존 Path2D 캐시/가스/보라 전류 연출은 사용하지 않음)
    // NOTE: Math.random()을 사용하므로 프레임마다 모양이 흔들리며 '찌릿' 느낌이 납니다.

    // [1] 검정색 전류 이펙트 (찌릿거리는 효과)
    ctx.save();
    ctx.strokeStyle = 'black';
    ctx.lineWidth = 2;
    ctx.beginPath();

    // 전류 줄기 3개를 랜덤하게 생성
    for (let k = 0; k < 3; k++) {
        let lx = shot.x;
        let ly = shot.y;
        ctx.moveTo(lx, ly);

        // 전류의 길이와 굴절
        for (let j = 0; j < 3; j++) {
            // 진행 방향 반대로 약간 퍼지며 찌릿거림
            lx += (Math.random() - 0.5) * 30 - (Math.cos(shot.angle) * 10);
            ly += (Math.random() - 0.5) * 30 - (Math.sin(shot.angle) * 10);
            ctx.lineTo(lx, ly);
        }
    }
    ctx.stroke();
    ctx.restore();

    // [2] 갈고리 모양 그리기
    ctx.save();
    ctx.translate(shot.x, shot.y);
    ctx.rotate(shot.angle); // 발사 각도에 맞춰 회전

    ctx.fillStyle = '#1a1a1a'; // 아주 진한 회색 (Aki 테마)
    ctx.strokeStyle = '#4B0082'; // 보라색 테두리
    ctx.lineWidth = 3;

    ctx.beginPath();
    // 갈고리 형상 그리기 (좌표는 크기에 맞춰 조절 가능)
    // 중심에서 시작하여 굽은 칼날 모양 형성
    ctx.moveTo(10, 0);
    ctx.bezierCurveTo(20, -15, 40, -30, 10, -40); // 윗 날 곡선
    ctx.lineTo(-10, -10);
    ctx.lineTo(-20, 0);
    ctx.lineTo(-10, 10);
    ctx.lineTo(10, 40); // 아랫 날 끝
    ctx.bezierCurveTo(40, 30, 20, 15, 10, 0); // 아랫 날 곡선

    ctx.fill();
    ctx.stroke();

    ctx.restore();
}

function drawAkiEvilArrow(ctx, arrow, frame) {
    // 첨부 이미지의 악마 발사체를 그대로 렌더링 (배경 제거된 PNG 내장)
    const r = (arrow.radius || 60);

    // 원본 이미지 비율(512x347)을 유지하면서, 날개가 잘 보이게 판정보다 조금 크게 표시
    const w = r * 3.0;
    const h = w * (347 / 512);

    ctx.save();
    ctx.translate(arrow.x, arrow.y);

    // 정면 실루엣이라 회전은 하지 않음 (원하면 아래 주석 해제)
    // ctx.rotate(arrow.angle);

    if (typeof akiEvilArrowDevilImg !== "undefined" &&
        akiEvilArrowDevilImg.complete &&
        akiEvilArrowDevilImg.naturalWidth > 0) {
        ctx.drawImage(akiEvilArrowDevilImg, -w / 2, -h / 2, w, h);
    } else {
        // 로딩 실패/지연 대비 임시 대체
        ctx.fillStyle = "rgba(180, 0, 0, 0.9)";
        ctx.beginPath();
        ctx.arc(0, 0, r, 0, Math.PI * 2);
        ctx.fill();
    }

    ctx.restore();
}


function drawAkiPoisonousShot(ctx, shot, frame) {
    // 첨부 이미지(빌런+가스+응가)를 그대로 렌더링 (투명 PNG)
    const r = (shot.radius || 60);

    // Evil Arrow와 같은 체급(크기 체감)을 맞추기 위해 동일 스케일 사용
    const w = r * 3.0;

    ctx.save();
    ctx.translate(shot.x, shot.y);

    // 이미지가 정면형이라 회전은 하지 않음 (원하면 아래 주석 해제)
    // ctx.rotate(shot.angle);

    if (typeof akiPoisonousShotImg !== "undefined" &&
        akiPoisonousShotImg.complete &&
        akiPoisonousShotImg.naturalWidth > 0) {

        const iw = akiPoisonousShotImg.naturalWidth || 1;
        const ih = akiPoisonousShotImg.naturalHeight || 1;
        const h = w * (ih / iw);

        ctx.drawImage(akiPoisonousShotImg, -w / 2, -h / 2, w, h);
    } else {
        // 로딩 실패/지연 대비 임시 대체
        ctx.fillStyle = "rgba(20, 120, 20, 0.85)";
        ctx.beginPath();
        ctx.arc(0, 0, r, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = "rgba(120, 80, 20, 0.9)";
        ctx.beginPath();
        ctx.arc(0, r * 0.45, r * 0.55, 0, Math.PI * 2);
        ctx.fill();
    }

    ctx.restore();
}

// === [/Aki] Projectile Draw Cache ===


        // === [Firm Darkness] Dome 캐시 ===
        const _firmDarknessCache = {
          dome: null, // { key: string, canvas: HTMLCanvasElement }
        };

        function getFirmDarknessDomeCanvas(radius) {
          // 캐시 키: 반지름이 조금만 달라도 새로 만들지 않게 반올림/정수화
          const r = Math.max(1, Math.round(radius));
          const key = `r:${r}`;

          if (_firmDarknessCache.dome && _firmDarknessCache.dome.key === key) {
            return _firmDarknessCache.dome.canvas;
          }

          // 오프스크린 캔버스(이미지) 생성
          const c = document.createElement("canvas");
          c.width = c.height = r * 2;

          const g = c.getContext("2d");
          const cx = r, cy = r;

          // 기존과 동일한 그라데이션 (원본 돔 효과와 동일)
          const domeGrad = g.createRadialGradient(cx, cy, r * 0.2, cx, cy, r);
          domeGrad.addColorStop(0, 'rgba(0, 0, 0, 0.2)');
          domeGrad.addColorStop(0.7, 'rgba(20, 0, 30, 0.5)');
          domeGrad.addColorStop(0.95,'rgba(0, 0, 0, 0.9)');
          domeGrad.addColorStop(1, 'rgba(75, 0, 130, 0.6)');

          g.fillStyle = domeGrad;
          g.beginPath();
          g.arc(cx, cy, r, 0, Math.PI * 2);
          g.fill();

          _firmDarknessCache.dome = { key, canvas: c };
          return c;
        }
        const startBtn = document.getElementById('startBtn');
        const overlay = document.getElementById('screen-overlay');
        const gameOverStatsBtn = document.getElementById('gameOverStatsBtn');
        const healthBar = document.getElementById('healthBar');
        const scoreVal = document.getElementById('scoreVal');
        const killVal = document.getElementById('killVal');
        const damageOverlay = document.getElementById('damageOverlay');
        const mindOverlay = document.getElementById('mindOverlay');
        const darknessOverlay = document.getElementById('darknessOverlay'); 
        const sacredFaithOverlay = document.getElementById('sacredFaithOverlay'); 
        const bloodOverlay = document.getElementById('bloodOverlay');
        const confusionOverlay = document.getElementById('confusionOverlay');
        const visionOverlay = document.getElementById('visionOverlay');
        const skillSealOverlay = document.getElementById('skillSealOverlay');
        // [최적화] 데미지 오버레이 플래시 상태 (히트마다 setTimeout을 쌓지 않고, 애니메이션 루프에서 감쇠)
        let damageFlashOpacity = 0;
        let damageFlashColor = '101, 67, 33';
        let damageFlashAlpha = 0.6; // rgba 알파
        let damageFlashDirty = false;
        const DAMAGE_FLASH_DECAY = 0.85; // 0.0~1.0 (낮을수록 더 빨리 사라짐)
        const GAWAIN_SANCTUARY_STRIDE = 6; // 성역 범위 체크 간격(프레임)

        const uiLayer = document.getElementById('ui-layer');
        const UI_LAYER_DEFAULT_Z = parseInt(getComputedStyle(uiLayer).zIndex, 10) || 20;
        const UI_LAYER_LEVELUP_Z = 20000;
        const poopOverlay = document.getElementById('poopOverlay');
        
        // UI Elements
        const poisonStatus = document.getElementById('poisonStatus');
        const poisonDebuffIcon = document.getElementById('poisonDebuffIcon');
        const poisonStacksText = document.getElementById('poisonStacks');
        const poopStatus = document.getElementById('poopStatus');
        const poopStacksText = document.getElementById('poopStacks');
        const poopDebuffIcon = document.getElementById('poopDebuffIcon');
        
        const maliceStatus = document.getElementById('maliceStatus');
        const maliceStacksText = document.getElementById('maliceStacks');
        const maliceIcon = document.getElementById('maliceIcon');

        const kissStatus = document.getElementById('kissStatus');
        const kissStacksText = document.getElementById('kissStacks');
        const kissDebuffIcon = document.getElementById('kissDebuffIcon');
        const semenStatus = document.getElementById('semenStatus');
        const semenStacksText = document.getElementById('semenStacks');
        const semenDebuffIcon = document.getElementById('semenDebuffIcon');
        const oralStatus = document.getElementById('oralStatus');
        const oralStacksText = document.getElementById('oralStacks');
        const oralDebuffIcon = document.getElementById('oralDebuffIcon');
        
        const byururutStatus = document.getElementById('byururutStatus');
        const byururutStacksText = document.getElementById('byururutStacks');
        const byururutDebuffIcon = document.getElementById('byururutDebuffIcon');

        const geoptalStatus = document.getElementById('geoptalStatus');
        const geoptalStacksText = document.getElementById('geoptalStacks');
        const geoptalIcon = document.getElementById('geoptalIcon');

        const fishyStatus = document.getElementById('fishyStatus');
        const fishyStacksText = document.getElementById('fishyStacks');
        const fishyIcon = document.getElementById('fishyIcon');

        const shieldStatus = document.getElementById('shieldStatus');
        const shieldStacksText = document.getElementById('shieldStacks');
        const shieldIcon = document.getElementById('shieldIcon');

        const justiceStatus = document.getElementById('justiceStatus');
        const justiceStacksText = document.getElementById('justiceStacks');
        const justiceIcon = document.getElementById('justiceIcon');
        
        const blindStatus = document.getElementById('blindStatus');
        const blindStacksText = document.getElementById('blindStacks');
        const blindIcon = document.getElementById('blindIcon');
        
        const paralysisStatus = document.getElementById('paralysisStatus');
        const paralysisStacksText = document.getElementById('paralysisStacks');
        const paralysisIcon = document.getElementById('paralysisIcon');

        const berserkStatus = document.getElementById('berserkStatus');
        const berserkIcon = document.getElementById('berserkIcon'); 
        
        const hypersensitivityStatus = document.getElementById('hypersensitivityStatus');
        const hyperIcon = document.getElementById('hyperIcon');

        const evilMindStatus = document.getElementById('evilMindStatus');
        const evilMindStacksText = document.getElementById('evilMindStacks');
        const evilMindDebuffIcon = document.getElementById('evilMindDebuffIcon');
        
        const curseStatus = document.getElementById('curseStatus');
        const curseStacksText = document.getElementById('curseStacks');
        const curseIcon = document.getElementById('curseIcon');

        const gnawingLifeStatus = document.getElementById('gnawingLifeStatus');
        const gnawingLifeStacksText = document.getElementById('gnawingLifeStacks');
        const gnawingLifeIcon = document.getElementById('gnawingLifeIcon');

        const darkScentStatus = document.getElementById('darkScentStatus');
        const darkScentStacksText = document.getElementById('darkScentStacks');
        const darkScentIcon = document.getElementById('darkScentIcon');
        
        const darkSmellStatus = document.getElementById('darkSmellStatus');
        const darkSmellStacksText = document.getElementById('darkSmellStacks');
        const darkSmellIcon = document.getElementById('darkSmellIcon');
        
        const darkSeedStatus = document.getElementById('darkSeedStatus');
        const darkSeedStacksText = document.getElementById('darkSeedStacks');
        const darkSeedIcon = document.getElementById('darkSeedIcon');

        const darkKissStatus = document.getElementById('darkKissStatus');
        const darkKissStacksText = document.getElementById('darkKissStacks');
        const darkKissIcon = document.getElementById('darkKissIcon');

        const darkReceiverStatus = document.getElementById('darkReceiverStatus');
        const darkReceiverStacksText = document.getElementById('darkReceiverStacks');
        const darkReceiverIcon = document.getElementById('darkReceiverIcon');

        const evilLightStatus = document.getElementById('evilLightStatus');
        const evilLightIcon = document.getElementById('evilLightIcon');

        const darkEcstasyStatus = document.getElementById('darkEcstasyStatus');
        const darkEcstasyStacksText = document.getElementById('darkEcstasyStacks');
        const darkEcstasyIcon = document.getElementById('darkEcstasyIcon');

        const corruptedOathStatus = document.getElementById('corruptedOathStatus');
        const corruptedOathStacksText = document.getElementById('corruptedOathStacks');
        const corruptedOathIcon = document.getElementById('corruptedOathIcon');

        const dangerousJudgmentStatus = document.getElementById('dangerousJudgmentStatus');
        const dangerousJudgmentStacksText = document.getElementById('dangerousJudgmentStacks');
        const dangerousJudgmentIcon = document.getElementById('dangerousJudgmentIcon');

        const deepDarknessStatus = document.getElementById('deepDarknessStatus');
        const deepDarknessStacksText = document.getElementById('deepDarknessStacks');
        const deepDarknessIcon = document.getElementById('deepDarknessIcon');

        const corruptedJusticeStatus = document.getElementById('corruptedJusticeStatus');
        const corruptedJusticeStacksText = document.getElementById('corruptedJusticeStacks');
        const corruptedJusticeIcon = document.getElementById('corruptedJusticeIcon');

        const darknessStatusEl = document.getElementById('darknessStatus'); 
        const darknessIcon = document.getElementById('darknessIcon');
        const confusionStatusEl = document.getElementById('confusionStatus');
        const confusionIcon = document.getElementById('confusionIcon');

        const serumContaminationStatus = document.getElementById('serumContaminationStatus');
        const serumContaminationIcon = document.getElementById('serumContaminationIcon');
        if(serumContaminationIcon) serumContaminationIcon.src = serumContaminationIconSrc;
        
        // [신규] 출혈/차광 UI 연결
        const bleedingStatus = document.getElementById('bleedingStatus');
        const bleedingIcon = document.getElementById('bleedingIcon');
        const shadingStatus = document.getElementById('shadingStatus');
        const shadingIcon = document.getElementById('shadingIcon');
        
        if(bleedingIcon) bleedingIcon.src = bleedingIconSrc;
        if(shadingIcon) shadingIcon.src = shadingIconSrc;

        // [신규] 죽음의 낙인 UI 연결
        const deathBrandStatus = document.getElementById('deathBrandStatus');
        const deathBrandIcon = document.getElementById('deathBrandIcon');
        if(deathBrandIcon) deathBrandIcon.src = deathBrandIconSrc;

        if(darknessIcon) darknessIcon.src = darknessIconSrc;
        if(confusionIcon) confusionIcon.src = confusionIconSrc;

        const blasphemyIconEl = document.getElementById('blasphemyIcon');
        if (blasphemyIconEl) {
        blasphemyIconEl.src = blasphemyIconSrc;
       }
        const majestyStatus = document.getElementById('majestyStatus');
        const majestyIcon = document.getElementById('majestyIcon');
        
        const trueAncestorKissStatus = document.getElementById('trueAncestorKissStatus');
        const trueAncestorKissStacksText = document.getElementById('trueAncestorKissStacks');
        const trueAncestorKissIcon = document.getElementById('trueAncestorKissIcon');

        const fatalScarStatus = document.getElementById('fatalScarStatus');
        const fatalScarStacksText = document.getElementById('fatalScarStacks');
        const fatalScarIcon = document.getElementById('fatalScarIcon');

        const corruptedBloodStatus = document.getElementById('corruptedBloodStatus');
        const corruptedBloodStacksText = document.getElementById('corruptedBloodStacks');
        const corruptedBloodIcon = document.getElementById('corruptedBloodIcon');
       
        // [신규] 카이토 상태이상 UI 연결
        const despairStatus = document.getElementById('despairStatus');
        const despairIcon = document.getElementById('despairIcon');
        if(despairIcon) despairIcon.src = despairIconSrc;

        const baptismStatus = document.getElementById('baptismStatus');
        const baptismStacksText = document.getElementById('baptismStacks');
        const baptismIcon = document.getElementById('baptismIcon');
        if(baptismIcon) baptismIcon.src = baptismIconSrc;

        // 여신의 가호 UI 요소
        const goddessSkillImg = document.getElementById('goddessSkillImg');
        const goddessCooldownOverlay = document.getElementById('goddessCooldownOverlay');
        const goddessCooldownText = document.getElementById('goddessCooldownText');
        const goddessSealOverlay = document.getElementById('goddessSealOverlay');

        // 성스러운 믿음 UI 요소
        const sacredFaithSkillImg = document.getElementById('sacredFaithSkillImg');
        const sacredFaithCooldownOverlay = document.getElementById('sacredFaithCooldownOverlay');
        const sacredFaithCooldownText = document.getElementById('sacredFaithCooldownText');
        const sacredFaithSealOverlay = document.getElementById('sacredFaithSealOverlay');

        // [신규] 한계 집중 UI 요소
        const limitFocusImg = document.getElementById('limitFocusImg');
        const limitFocusCooldownOverlay = document.getElementById('limitFocusCooldownOverlay');
        const limitFocusCooldownText = document.getElementById('limitFocusCooldownText');
        const limitFocusSealOverlay = document.getElementById('limitFocusSealOverlay');

        // 회개의 외침 UI 요소
        const novaSkillImg = document.getElementById('novaSkillImg');
        const novaCooldownOverlay = document.getElementById('novaCooldownOverlay');
        const novaCooldownText = document.getElementById('novaCooldownText');
        const novaSealOverlay = document.getElementById('novaSealOverlay');
        
        // [신규] 천상의 도약 UI 요소 연결
        const divineDashSkillImg = document.getElementById('divineDashSkillImg');
        const divineDashCooldownOverlay = document.getElementById('divineDashCooldownOverlay');
        const divineDashCooldownText = document.getElementById('divineDashCooldownText');
        const divineDashSealOverlay = document.getElementById('divineDashSealOverlay');

        // ==================================================================================
        // [텍스트 커스터마이징] 
        // ==================================================================================
        
        const berserkText = "베르세르크!";
        const shieldText = "보호막";
        const justiceText = "정의의 가호";
        const poisonText = "가스중독";
        const poopText = "똥독";
        const maliceText = "악의의 바이러스"; 
        const kissText = "속박키스(지속↑)";
        const semenText = "질내사정(회피)";
        const oralText = "구내사정(리치)";
        const byururutText = "뷰루룻♡";
        const evilMindText = "사악한 마음";
        const geoptalText = "겁탈"; 
        const fishyText = "비린내 붓카게"; 
        const hyperText = "과민 반응 (기절주의!)";
        const blindText = "실명 (명중↓)";
        const paralysisText = "마비 (이동↓)";

        const curseText = "저주(종료시 피해)"; 
        const gnawingLifeText = "좀먹는 생명(회복↓)";
        const darkScentText = "카인의 향기";
        const darkSmellText = "카인의 똥내";
        const darkSeedText = "카인의 씨앗(공격)";
        const darkKissText = "카인의 키스(공속)";
        const darkReceiverText = "카인의 좆집(방증 2%)";
        const evilLightText = "사악한 빛";
        const darkEcstasyText = "어둠의 환희(적 이속)";

        const corruptedOathText = "타락한 맹세(치명타 확률↑)";
        const dangerousJudgmentText = "위험한 판단(치명타 저항 확률↓)";
        const deepDarknessText = "짙은 어둠(명중↓)";
        const corruptedJusticeText = "타락한 정의(쿨타임)";

        document.getElementById('berserkName').innerText = berserkText;
        document.getElementById('shieldName').innerText = shieldText;
        document.getElementById('justiceName').innerText = justiceText;
        document.getElementById('poisonName').innerText = poisonText;
        document.getElementById('poopName').innerText = poopText;
        document.getElementById('maliceName').innerText = maliceText; 
        document.getElementById('kissName').innerText = kissText;
        document.getElementById('semenName').innerText = semenText;
        document.getElementById('oralName').innerText = oralText;
        document.getElementById('byururutName').innerText = byururutText;
        document.getElementById('evilMindName').innerText = evilMindText;
        document.getElementById('geoptalName').innerText = geoptalText;
        document.getElementById('fishyName').innerText = fishyText; 
        document.getElementById('hyperName').innerText = hyperText;
        document.getElementById('blindName').innerText = blindText;
        document.getElementById('paralysisName').innerText = paralysisText;

        document.getElementById('curseName').innerText = curseText;
        document.getElementById('gnawingLifeName').innerText = gnawingLifeText;
        document.getElementById('darkScentName').innerText = darkScentText;
        document.getElementById('darkSmellName').innerText = darkSmellText;
        document.getElementById('darkSeedName').innerText = darkSeedText;
        document.getElementById('darkKissName').innerText = darkKissText;
        document.getElementById('darkReceiverName').innerText = darkReceiverText;
        document.getElementById('evilLightName').innerText = evilLightText;
        document.getElementById('darkEcstasyName').innerText = darkEcstasyText;

        document.getElementById('corruptedOathName').innerText = corruptedOathText;
        document.getElementById('dangerousJudgmentName').innerText = dangerousJudgmentText;
        document.getElementById('deepDarknessName').innerText = deepDarknessText;
        document.getElementById('corruptedJusticeName').innerText = corruptedJusticeText;
        

        const cainSpawnBgmSrc = "https://steady-crimson-4nscd46j2b-jy3x40xm74.edgeone.dev/KakaoTalk_20251228_165908350.mp4"; 
        const touyaSpawnBgmSrc = "https://steady-crimson-4nscd46j2b-jy3x40xm74.edgeone.dev/KakaoTalk_20251228_182024105.mp4"; 
        const pandemoniumBgmSrc = "https://steady-crimson-4nscd46j2b-jy3x40xm74.edgeone.dev/KakaoTalk_20251228_182026246.mp4"; 
        
        const impregnateAudioSrc = "https://steady-crimson-4nscd46j2b-jy3x40xm74.edgeone.dev/KakaoTalk_20251228_182023409.mp4"; 
        const impregnateAudio = new Audio(impregnateAudioSrc);
        impregnateAudio.volume = 0.8;

        const rapistAttachAudioSrc = "https://scrawny-purple-jefbabss6q-qdbf8o789a.edgeone.dev/KakaoTalk_20251218_222054381.mp4"; 
        const rapistAttachAudio = new Audio(rapistAttachAudioSrc);
        rapistAttachAudio.volume = 1.0;

        const darkDenizenSummonAudioSrc = "https://unfortunate-tan-h3am4473op-es3zafqeoh.edgeone.dev/KakaoTalk_20251219_232117812.mp4"; 
        const darkDenizenSummonAudio = new Audio(darkDenizenSummonAudioSrc);
        darkDenizenSummonAudio.volume = 0.5;

        const raiAttachAudioSrc = "https://scrawny-purple-jefbabss6q-qdbf8o789a.edgeone.dev/KakaoTalk_20251218_222054381.mp4"; 
        const raiAttachAudio = new Audio(raiAttachAudioSrc);
        raiAttachAudio.volume = 1.0;

        const cainAudio = new Audio(cainSpawnBgmSrc);
        cainAudio.volume = 1.0; 
        
        // [신규] 아서 BGM
        const arthurAudio = new Audio(arthurSpawnBgmSrc);
        arthurAudio.volume = 1.0;

        const touyaAudio = new Audio(touyaSpawnBgmSrc);
        touyaAudio.volume = 1.0; 

        const pandemoniumAudio = new Audio(pandemoniumBgmSrc); 
        pandemoniumAudio.volume = 1.0; 

        // [커스터마이즈] 아키 '포이즈너스 샷' 사용 시 재생할 사운드 (mp3/ogg 등)
        // 같은 폴더에 mp3를 두면: "./aki_poisonous_shot.mp3"
        const akiPoisonousShotSfxSrc = "./aki_poisonous_shot.mp3";
        const AKI_POISONOUS_SHOT_SFX_VOLUME = 0.4;

        // 짧은 시간에 연속 발사해도 끊기지 않도록 오디오 풀(4개) 사용
        const akiPoisonousShotSfxPool = Array.from({ length: 4 }, () => {
            const a = new Audio(akiPoisonousShotSfxSrc);
            a.preload = "auto";
            a.volume = AKI_POISONOUS_SHOT_SFX_VOLUME;
            return a;
        });
        let _akiPoisonousShotSfxIdx = 0;
        function playAkiPoisonousShotSfx() {
            // src가 비어있거나, 브라우저 정책상 막힐 수 있으니 try/catch
            if (!akiPoisonousShotSfxSrc) return;
            const a = akiPoisonousShotSfxPool[_akiPoisonousShotSfxIdx++ % akiPoisonousShotSfxPool.length];
            try {
                a.currentTime = 0;
                a.play().catch(()=>{});
            } catch(e) {}
        }


        
        // [커스터마이즈] 아키 '이블 애로우' 사용 시 재생할 사운드 (mp3/ogg 등)
        // 같은 폴더에 mp3를 두면: "./aki_evil_arrow.mp3"
        const akiEvilArrowSfxSrc = "./aki_evil_arrow.mp3";
        const AKI_EVIL_ARROW_SFX_VOLUME = 1.0;

        // 짧은 시간에 연속 발사해도 끊기지 않도록 오디오 풀(4개) 사용
        const akiEvilArrowSfxPool = Array.from({ length: 4 }, () => {
            const a = new Audio(akiEvilArrowSfxSrc);
            a.preload = "auto";
            a.volume = AKI_EVIL_ARROW_SFX_VOLUME;
            return a;
        });
        let _akiEvilArrowSfxIdx = 0;
        function playAkiEvilArrowSfx() {
            if (!akiEvilArrowSfxSrc) return;
            const a = akiEvilArrowSfxPool[_akiEvilArrowSfxIdx++ % akiEvilArrowSfxPool.length];
            try {
                a.currentTime = 0;
                a.play().catch(()=>{});
            } catch(e) {}
        }

const berserkUiIconSrc = "https://i.ifh.cc/2zdKr7.jpg"; 
        const shieldUiIconSrc = "https://i.ifh.cc/y69OcC.jpg";  
        const justiceUiIconSrc = "https://i.ifh.cc/bP1nVV.jpg"; 
        const blindIconSrc = "https://i.ifh.cc/dqwQpz.jpg"; 
        const magnetItemSrc = "https://i.ifh.cc/LzpmBZ.jpg"; 
        const paralysisIconSrc = "https://i.ifh.cc/SfR4f5.jpg"; // 마비 아이콘 (임시)
        
        const berserkItemImg = new Image(); berserkItemImg.src = berserkUiIconSrc;
        const shieldItemImg = new Image(); shieldItemImg.src = shieldUiIconSrc;
        const justiceItemImg = new Image(); justiceItemImg.src = justiceUiIconSrc;
        const magnetItemImg = new Image(); magnetItemImg.src = magnetItemSrc;
        
        const evilLightIconSrc = "https://i.ifh.cc/YkQoPQ.jpg";
        
        const geoptalIconSrc = "https://i.ifh.cc/9Jp26f.jpg"; 
        geoptalIcon.src = geoptalIconSrc;

        const fishyIconSrc = "https://i.ifh.cc/V14G9O.jpg"; 
        fishyIcon.src = fishyIconSrc;

        const maliceIconSrc = "https://i.ifh.cc/acHt9B.jpg"; 
        maliceIcon.src = maliceIconSrc;
        
        const hyperIconSrc = "https://i.ifh.cc/TbX5ak.jpg"; 
        hyperIcon.src = hyperIconSrc;

        const corruptedOathIconSrc = "https://i.ifh.cc/3fpSq8.jpg"; 
        const dangerousJudgmentIconSrc = "https://i.ifh.cc/OYCwhZ.jpg";
        const deepDarknessIconSrc = "https://i.ifh.cc/vSjmlo.jpg";
        const corruptedJusticeIconSrc = "https://i.ifh.cc/1myqLR.jpg";

        corruptedOathIcon.src = corruptedOathIconSrc;
        dangerousJudgmentIcon.src = dangerousJudgmentIconSrc;
        deepDarknessIcon.src = deepDarknessIconSrc;
        corruptedJusticeIcon.src = corruptedJusticeIconSrc;
        
        // [신규] 기믹 UI 연결
        const pheromoneOverloadStatus = document.getElementById('pheromoneOverloadStatus');
        const pheromoneOverloadIcon = document.getElementById('pheromoneOverloadIcon');
        pheromoneOverloadIcon.src = pheromoneOverloadIconSrc;

        const darknessOverwhelmStatus = document.getElementById('darknessOverwhelmStatus');
        const darknessOverwhelmIcon = document.getElementById('darknessOverwhelmIcon');
        darknessOverwhelmIcon.src = darknessOverwhelmIconSrc;

        const fractureStatus = document.getElementById('fractureStatus');
        const fractureStacksText = document.getElementById('fractureStacks');
        const fractureIcon = document.getElementById('fractureIcon');
        if(fractureIcon) fractureIcon.src = fractureIconSrc;

        // [신규] 아서 디버프 아이콘 설정
        majestyIcon.src = majestyIconSrc;
        trueAncestorKissIcon.src = trueAncestorKissIconSrc;
        fatalScarIcon.src = fatalScarIconSrc;
        corruptedBloodIcon.src = corruptedBloodIconSrc;

        const projectileImg = new Image(); projectileImg.src = "https://i.ifh.cc/dgWMPY.jpg"; 
        poisonDebuffIcon.src = "https://i.ifh.cc/70Db1a.jpg"; 
        poopDebuffIcon.src = "https://i.ifh.cc/pA83O9.jpg";
        kissDebuffIcon.src = "https://i.ifh.cc/W7sZSA.jpg"; 
        blindIcon.src = blindIconSrc;
        paralysisIcon.src = paralysisIconSrc;
        
        const darkScentIconSrc = "https://i.ifh.cc/frk6ah.jpg"; 
        const darkSmellIconSrc = "https://i.ifh.cc/KWly6J.jpg";
        const darkSeedIconSrc = "https://i.ifh.cc/v16XGA.jpg";
        const darkKissIconSrc = "https://i.ifh.cc/BJxVzf.jpg";
        const darkReceiverIconSrc = "https://i.ifh.cc/zXk13D.jpg";

        const summonerVillainImgSrc = "https://i.ifh.cc/LlvP0q.jpg"; 
        const rapistVillainImgSrc = "https://i.ifh.cc/X6QpjD.jpg";   
        const zakoVillainImgSrc = "https://i.ifh.cc/FWJgpP.jpg";     
        
        const zakoTerroristImgSrc = "https://i.ifh.cc/jCmRky.jpg"; 
        const zakoTerroristImg = new Image();
        zakoTerroristImg.src = zakoTerroristImgSrc;

        const zakoPlagueImgSrc = "https://i.ifh.cc/mmZddv.jpg"; 
        const zakoPlagueImg = new Image();
        zakoPlagueImg.src = zakoPlagueImgSrc;

        const agentCurseImgSrc = "https://i.ifh.cc/YOtrJ1.jpg"; 
        const agentPainImgSrc = "https://i.ifh.cc/328BaC.jpg";
        const agentBlindImgSrc = "https://i.ifh.cc/zsh8Hz.jpg";

        const agentCurseImg = new Image(); agentCurseImg.src = agentCurseImgSrc;
        const agentPainImg = new Image(); agentPainImg.src = agentPainImgSrc;
        const agentBlindImg = new Image(); agentBlindImg.src = agentBlindImgSrc;
        
        const akiImgSrc = "https://i.ifh.cc/bH4RAo.jpg"; 
        const akiImg = new Image(); akiImg.src = akiImgSrc;

        const hiroImg = new Image();
        hiroImg.src = hiroImgSrc;
        
        // [신규] 아서 이미지
        const arthurImg = new Image();
        arthurImg.src = arthurImgSrc;

        goddessSkillImg.src = goddessSkillImgSrc;
        sacredFaithSkillImg.src = sacredFaithSkillImgSrc;
        limitFocusImg.src = limitFocusIconSrc;
        novaSkillImg.src = novaSkillIconSrc;
        divineDashSkillImg.src = divineDashIconSrc;

        const summonerVillainImg = new Image(); summonerVillainImg.src = summonerVillainImgSrc;
        const rapistVillainImg = new Image(); rapistVillainImg.src = rapistVillainImgSrc;
        const zakoVillainImg = new Image(); zakoVillainImg.src = zakoVillainImgSrc;

        const eliteVillainImg = new Image(); eliteVillainImg.src = "https://i.ifh.cc/MJcqhD.jpg";
        
        const corruptedHeroImgSrc = "https://i.ifh.cc/7Cy4KY.jpg"; 
        const corruptedHeroImg = new Image(); corruptedHeroImg.src = corruptedHeroImgSrc;

        const corruptedSniperImgSrc = "https://i.ifh.cc/vyGsG5.jpg";
        const corruptedSniperImg = new Image(); corruptedSniperImg.src = corruptedSniperImgSrc;

        const ozmaImgSrc = "https://i.ifh.cc/CfXbx2.jpg"; 
        const ozmaImg = new Image(); ozmaImg.src = ozmaImgSrc;
        
        const taroImgSrc = "https://i.ifh.cc/ZqPPQc.jpg"; 
        const taroImg = new Image(); taroImg.src = taroImgSrc;

        const gawainImgSrc = "https://i.ifh.cc/lKzqBQ.jpg"; 
        const gawainImg = new Image(); gawainImg.src = gawainImgSrc;

        const playerImgSrc = "https://i.ifh.cc/g6CNM9.jpg"; 
        const playerImg = new Image();
        playerImg.src = playerImgSrc;

        const bossVillainImg = new Image(); 
        bossVillainImg.src = "https://i.ifh.cc/kMhZx6.jpg";

        const akitoImg = new Image();
        akitoImg.src = "https://i.ifh.cc/PvD0DF.jpg"; 
        
        const touyaImg = new Image();
        touyaImg.src = "https://i.ifh.cc/hWy9sB.jpg"; 

        const louieImgSrc = "https://i.ifh.cc/H7CKDf.jpg"; 
        const louieImg = new Image(); louieImg.src = louieImgSrc;

        const raiImgSrc = "https://i.ifh.cc/2HKg2q.jpg"; 
        const raiImg = new Image(); raiImg.src = raiImgSrc;

        const kissEffectImgSrc = "https://i.ifh.cc/W7sZSA.jpg"; 
        semenDebuffIcon.src = "https://i.ifh.cc/yTks6A.jpg"; 
        oralDebuffIcon.src = "https://i.ifh.cc/oqTaNK.jpg";
        const byururutDebuffIconSrc = "https://i.ifh.cc/HB6Kqs.jpg"; 
        byururutDebuffIcon.src = byururutDebuffIconSrc;
        
        const gnawingLifeIconSrc = "https://i.ifh.cc/cfASLW.jpg"; 
        gnawingLifeIcon.src = gnawingLifeIconSrc;

        berserkIcon.src = berserkUiIconSrc;
        shieldIcon.src = shieldUiIconSrc; 
        justiceIcon.src = justiceUiIconSrc; 

        darkScentIcon.src = darkScentIconSrc;
        darkSmellIcon.src = darkSmellIconSrc;
        darkSeedIcon.src = darkSeedIconSrc;
        darkKissIcon.src = darkKissIconSrc;
        darkReceiverIcon.src = darkReceiverIconSrc;
        
        evilLightIcon.src = evilLightIconSrc;
        
        darkEcstasyIcon.src = "https://i.ifh.cc/5JWG2Z.jpg";

        const evilMindIconSrc = "https://i.ifh.cc/ZzxJms.jpg"; 
        evilMindDebuffIcon.src = evilMindIconSrc;
     
        curseIcon.src = "https://i.ifh.cc/cfASLW.jpg"; 

        const bgmSrc = "https://miserable-jade-dmyozf8ndo.edgeone.dev/0-ntr5.mp3";
        const bgmAudio = new Audio(bgmSrc);
        bgmAudio.loop = true;
        bgmAudio.volume = 0.3;

        let isGameRunning = false;
        let score = 0;
        let enemyTimer = 0;
        let lastTime = 0;
        let frameDt = 1000 / 60;
        let frameDtScale = 1;

        let lastScoreTime = 0;
        let killCount = 0;
        let startTime = 0;
        let animationId;
        let itemSpawnTimeout;
        let nextBossSpawnFrame = 0;
        let nextEliteSpawnFrame = 0;
        let xp = 0;
        let maxXp = 10;
        let level = 1;
        let isLevelUpPaused = false;
        let luck = 0;
        let rerollCount = 0;
        let frameCount = 0;
        let selectedCardIndex = 0;

        // =========================================================
        // [밸런스] 만렙 확장 + 레벨업 경험치 완화
        // =========================================================
        const MAX_LEVEL = 500;              // 만렙 (기존 200)

// [밸런스] 레벨업 필요 XP: 구간별 증가 배율(요청값)
//  Lv  1~ 50 : 1.09
//  Lv 51~150 : 1.08
//  Lv151~300 : 1.06
//  Lv301~500 : 1.04
const XP_GROWTH_SEG1_MULT   = 1.09;
const XP_GROWTH_SEG2_MULT   = 1.08;
const XP_GROWTH_SEG3_MULT   = 1.06;
const XP_GROWTH_SEG4_MULT   = 1.04;

const XP_GROWTH_SEG1_END_LV = 50;
const XP_GROWTH_SEG2_END_LV = 150;
const XP_GROWTH_SEG3_END_LV = 300;
const XP_GROWTH_SEG4_END_LV = 500;
        
        let shockwaves = []; 
        let groundCracks = [];
        let dragShots = []; 
        let evilArrows = []; 
        let poisonousShots = [];
        let jammingWaves = [];
        let neuroNeedles = [];
        let bloodBats = [];
        let bloodPuddles = [];
        let excaliburSlashes = [];
        let slashTrails = [];
        let chaosOrbs = [];
        let pinkGases = [];
        let sadismBrownGases = [];
        let darkNotes = [];
        let blinkMines = [];
        let blackHolyBloods = [];
        let antiPassingTentacles = [];
        let pianissimoSnipes = [];
        let soulHarvestSlashes = [];
        let cursedCatastrophes = [];
        let prismSweeps = [];
        let occlusionSpools = [];
        let darkMatters = [];
        let confessionalTotems = [];
        let shadowGrips = [];
        let maliceBallistics = [];
        let maliceGasParticles = [];
        let phantomGasParticles = [];
        let phantomSparkParticles = [];
        let cruelChargeAuras = [];
        let justiceChargeAuras = [];
        let floatingTexts = [];
        let activeAkiCount = 0;
        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resize);
        resize();

        // [Anti Passing] cached render assets for performance (telegraph silhouette + gas sprite)
        let _apTeleTex = null;
        let _apSmokeTex = null;
        function _ensureAntiPassingAssets() {
            if (_apTeleTex && _apSmokeTex) return;

            // Telegraph texture (tapered silhouette, drawn once then scaled/rotated)
            _apTeleTex = document.createElement('canvas');
            _apTeleTex.width = 256;
            _apTeleTex.height = 64;
            {
                const c = _apTeleTex.getContext('2d');
                c.clearRect(0, 0, _apTeleTex.width, _apTeleTex.height);
                const w = _apTeleTex.width, h = _apTeleTex.height;

                const grad = c.createLinearGradient(0, 0, w, 0);
                grad.addColorStop(0, 'rgba(0,0,0,1)');
                grad.addColorStop(0.55, 'rgba(0,0,0,0.85)');
                grad.addColorStop(1, 'rgba(0,0,0,0)');

                c.fillStyle = grad;
                c.beginPath();
                c.moveTo(0, h * 0.5);
                c.quadraticCurveTo(w * 0.35, h * 0.08, w * 0.82, h * 0.34);
                c.quadraticCurveTo(w, h * 0.5, w * 0.82, h * 0.66);
                c.quadraticCurveTo(w * 0.35, h * 0.92, 0, h * 0.5);
                c.closePath();
                c.fill();

                // Outline hint (visibility)
                c.strokeStyle = 'rgba(0,0,0,0.95)';
                c.lineWidth = 3;
                c.stroke();
            }

            // Gas/smoke texture (radial blob)
            _apSmokeTex = document.createElement('canvas');
            _apSmokeTex.width = 64;
            _apSmokeTex.height = 64;
            {
                const g = _apSmokeTex.getContext('2d');
                g.clearRect(0, 0, _apSmokeTex.width, _apSmokeTex.height);
                const cx = 32, cy = 32, r = 28;
                const rg = g.createRadialGradient(cx, cy, 0, cx, cy, r);
                rg.addColorStop(0, 'rgba(151, 171, 86, 0.85)');
                rg.addColorStop(0.55, 'rgba(98, 86, 43, 0.55)');
                rg.addColorStop(1, 'rgba(53, 45, 22, 0)');
                g.fillStyle = rg;
                g.beginPath();
                g.arc(cx, cy, r, 0, Math.PI * 2);
                g.fill();
            }
        }

        const player = {
            x: canvas.width / 2,
            y: canvas.height / 2,
            radius: 30,
            baseSpeed: 4.625, 
            speed: 4.625,
            vx: 0, 
            vy: 1,
            baseMaxHealth: 300, 
            maxHealth: 300,
            health: 300,
            
            baseCritChance: 25, 
            critChance: 25,
            baseCritResist: 15,   
            critResist: 15,
            baseCritDamageMultiplier: 1.5,
            critDamageMultiplier: 1.5,
            baseRegen: 1,
            regen: 1,
            
            corruptedOathStacks: 0, 
            dangerousJudgmentStacks: 0,
            deepDarknessStacks: 0,
            corruptedJusticeStacks: 0,

            poisonTimers: [],
            poopPoisonTimers: [],
            maliceTimers: [], 
            kissTimers: [],
            semenTimers: [],
            oralTimers: [],
            byururutTimers: [],
            evilMindTimers: [],
            curseTimers: [],
            gnawingLifeTimers: [], 
            fishyTimers: [], 
            darkScentTimers: [],
            darkSmellTimers: [],
            darkSeedTimers: [],
            darkKissTimers: [],
            darkReceiverTimers: [],
            blindTimers: [], 
            paralysisTimers: [],
            deathBrandTimers: [],
            evilLightTimers: [],
            bleedingTimers: [], // 출혈 타이머
            shadingTimers: [],  // 차광 타이머
            darkEcstasyTimers: [], 
            serumContaminationTimers: [],
            fractureTimers: [],

            // [신규] 아서 디버프 관련
            majestyActive: false, // 군주의 위엄 활성 여부
            trueAncestorKissTimers: [], // 진조의 키스 (스택형, 타이머)
            fatalScarTimers: [], // 페이탈 스칼
            corruptedBloodTimers: [], // 더럽혀진 피
            
            geoptalCount: 0, 
            hasHypersensitivity: false,

            // paralysisStacks: 0, // [삭제] 기존 단순 스택 변수 삭제 (Timers로 대체)
            rootTimer: 0,
            skillSealTimer: 0,
            pheromoneOverloadTimer: 0, // 카인 기믹 타이머
            darknessOverwhelmActive: false, // 아키토 기믹 활성화 여부
            stunTimer: 0,
            evilMindGasTimer: 0,
            despairTimer: 0,
            baptismStacks: 0,
            netherGrabbedBy: null, // 네더 그랩에 잡혔는지 확인 (카이토 객체 참조)
            netherGrabTimer: 0, // 네더 그랩 데미지 틱
            semenCooldown: 0,
            oralCooldown: 0,
            darkReceiverCooldown: 0,

            byururutCooldown: 0,
            bodyHitCooldown: 0,
            shieldStacks: 0, 
            justiceShield: 0, 
            slowedByCloud: false,
            slowedByStickyCream: false,
            invincibleTimer: 0, 
            berserkTimer: 0, 
            
            defense: 0, 
            defenseBroken: false,

            goddessSkill: {
                cooldown: 0, 
                maxCooldown: 2700
            },
            
            sacredFaithSkill: {
                cooldown: 0,
                maxCooldown: 2700, 
                duration: 900, 
                activeTimer: 0
            },
            
            novaSkill: {
                cooldown: 0,
                maxCooldown: 3600, 
                range: 250,       
                pushPower: 300    
            },

            limitFocusSkill: {
                cooldown: 0,
                maxCooldown: 3600,
                duration: 900,
                activeTimer: 0
            },

            divineDashSkill: {
                cooldown: 0,
                maxCooldown: 900, // 쿨타임 15초
                duration: 15,     // 돌진 지속 시간 (0.25초)
                speed: 25         // 돌진 속도
            },
            dashTimer: 0,         // 현재 돌진 중인지 체크하는 타이머
            dashVx: 0,            // 돌진 X 벡터
            dashVy: 0,            // 돌진 Y 벡터

            weapon: {
                length: 280, 
                baseLength: 280, 
                width: 10,  
                color: 'black', 
                angle: 0, 
                baseAngle: 0, 
                isAttacking: false,
                attackTimer: 0,
                cooldown: 0,
                baseDamage: 22, 
                damage: 22, 
                autoAttackInterval: 27.5, 
                baseAutoAttackInterval: 27.5,
                originalAutoAttackInterval: 28,
                autoTimer: 0,
                buffTimer: 0 
            },
                bonusAttackSpeed: 0
         };
        const keys = { ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false, Space: false, KeyQ: false, KeyW: false, KeyE: false, KeyA: false };
        let touchStart = { x: 0, y: 0 };
        let touchCurrent = { x: 0, y: 0 };
        let isTouching = false;

        let enemies = [];
        let gases = []; 
        let darkGases = []; 
        let poops = []; 
        let bigPoops = []; 
        let darkBigPoops = []; 
        let darkSemens = []; 
        let homingSemens = []; 
        let poopStains = []; 
        let whiteshots = []; 
        let ghosts = []; 
        let deathClouds = []; 
        let items = [];
        let mindSkulls = [];
        let stickyCreamPuddles = []; 
        let pandemoniums = []; 
        let hollowNight = [];
        let darkHearts = []; 
        let darkWaves = []; 
        let pheromoneMarkers = []; 
        let pleasureZones = [];
        let movingGases = [];
        let explosions = [];
        let phantomSwords = [];
        let blackMoons = [];
        let deathMetalNotes = [];      // 데스메탈 크레센도 투사체 배열
        let darknessSpotlights = [];   // 다크니스 스포트라이트 장판 배열
        let tetoraRequiemActive = false; // 진혼곡 활성화 상태 (전역)
        let tetoraRhapsodyActive = false; // 광시곡 활성화 상태 (전역)
        let royalSpawnTimer = 0;
        let performanceState = {
            mode: 'normal',
            enemySpawnMultiplier: 1,
            enemyHardCap: 180,
            projectileStride: 1,
            effectsStride: 1,
            particleStride: 1,
            maxFloatingTexts: 40,
            allowDomEffects: true
        };

        function updatePerformanceState() {
            const loadScore =
                (enemies.length * 2) +
                floatingTexts.length +
                gases.length +
                darkGases.length +
                poops.length +
                bigPoops.length +
                darkBigPoops.length +
                darkSemens.length +
                homingSemens.length +
                whiteshots.length +
                ghosts.length +
                deathClouds.length +
                items.length +
                mindSkulls.length +
                pandemoniums.length +
                hollowNight.length +
                darkHearts.length +
                darkWaves.length +
                pheromoneMarkers.length +
                pleasureZones.length +
                movingGases.length +
                explosions.length +
                phantomSwords.length +
                blackMoons.length +
                deathMetalNotes.length +
                darknessSpotlights.length;

            if (loadScore > 1400) {
                performanceState.mode = 'high';
                performanceState.enemySpawnMultiplier = 2.2;
                performanceState.enemyHardCap = 140;
                performanceState.projectileStride = 2;
                performanceState.effectsStride = 2;
                performanceState.particleStride = 3;
                performanceState.maxFloatingTexts = 25;
                performanceState.allowDomEffects = false;
            } else if (loadScore > 900) {
                performanceState.mode = 'medium';
                performanceState.enemySpawnMultiplier = 1.5;
                performanceState.enemyHardCap = 170;
                performanceState.projectileStride = 1;
                performanceState.effectsStride = 2;
                performanceState.particleStride = 2;
                performanceState.maxFloatingTexts = 35;
                performanceState.allowDomEffects = true;
            } else {
                performanceState.mode = 'normal';
                performanceState.enemySpawnMultiplier = 1;
                performanceState.enemyHardCap = 180;
                performanceState.projectileStride = 1;
                performanceState.effectsStride = 1;
                performanceState.particleStride = 1;
                performanceState.maxFloatingTexts = 40;
                performanceState.allowDomEffects = true;
            }
        }

        startBtn.addEventListener('click', () => {
            startGame();
        });
        gameOverStatsBtn.addEventListener('click', () => {
            updateStatsContent(); // 현재(사망 시점) 스탯 정보 갱신
            document.getElementById('statsInfoBox').style.display = 'block'; // 스탯창 열기
        });
        function startGame() {
            isGameRunning = true;
            score = 0;
            gameOverStatsBtn.style.display = 'none';
            killCount = 0;
            frameCount = 0;
            activeAkiCount = 0; 
            killVal.innerText = 0;
            
            player.baseMaxHealth = 330; 
            player.maxHealth = 330; 
            player.health = player.maxHealth;
            player.x = canvas.width / 2;
            player.y = canvas.height / 2;
            
            // [수정 위치 1] 플레이어 기본 방어력 설정
            player.defense = 2; // 이 숫자를 올리면 시작 방어력이 높아집니다.
            player.baseRegen = 2;
            player.regen = 2;
            
            player.critChance = player.baseCritChance;
            player.critResist = player.baseCritResist;
            
            player.critDamageMultiplier = player.baseCritDamageMultiplier;
            player.corruptedOathStacks = 0;
            player.dangerousJudgmentStacks = 0;
            player.deepDarknessStacks = 0;
            player.corruptedJusticeStacks = 0;
            player.deathBrandTimers = [];
            player.poisonTimers = [];
            player.poopPoisonTimers = [];
            player.maliceTimers = []; 
            player.kissTimers = [];
            player.semenTimers = [];
            player.oralTimers = [];
            player.byururutTimers = [];
            player.evilMindTimers = [];
            player.curseTimers = [];
            player.gnawingLifeTimers = [];
            player.fishyTimers = []; 
            player.darkScentTimers = [];
            player.darkSmellTimers = [];
            player.darkSeedTimers = [];
            player.darkKissTimers = [];
            player.darkReceiverTimers = [];
            player.evilLightTimers = []; 
            player.darkEcstasyTimers = [];
            player.bleedingTimers = [];
            player.shadingTimers = [];
            player.blasphemyTimers = []; // 신성 모독 타이머
            player.inPinkGas = false; // 최음 가스 안에 있는지 여부
            player.blindTimers = [];
            player.paralysisTimers = [];
            player.geoptalCount = 0;
            player.hasHypersensitivity = false;
            player.bonusAccuracy = 0;
            player.bonusEvasion = 0;
            player.bonusXpGain = 0;

            player.bonusStunChance = 0;

            player.majestyActive = false;
            player.trueAncestorKissTimers = [];
            player.fatalScarTimers = [];
            player.corruptedBloodTimers = [];
            player.darknessTimers = [];
            player.confusionTimers = [];
            player.pheromoneOverloadTimer = 0;
            player.pheromoneOverloadCritCount = 0;
            player.darknessOverwhelmActive = false;
            pheromoneOverloadStatus.style.display = 'none';
            darknessOverwhelmStatus.style.display = 'none';
            player.fractureTimers = [];
            fractureStatus.style.display = 'none';
            shadowGrips = [];
            // player.paralysisStacks = 0; // [삭제]
            player.rootTimer = 0;
            player.skillSealTimer = 0;
            
            player.stunTimer = 0;
            player.evilMindGasTimer = 0;
            player.semenCooldown = 0;
            player.oralCooldown = 0;
            player.darkReceiverCooldown = 0;
            player.byururutCooldown = 0;
            player.deathCloudTimer = 0;
            player.bodyHitCooldown = 0; 
            player.shieldStacks = 0; 
            player.justiceShield = 0;
            player.slowedByCloud = false;
            player.invincibleTimer = 0;
            player.berserkTimer = 0;
            player.defenseBroken = false;
            
            player.goddessSkill.cooldown = 0; 
            updateGoddessSkillUI();

            player.sacredFaithSkill.cooldown = 0;
            player.sacredFaithSkill.activeTimer = 0;
            updateSacredFaithUI();
          
            player.limitFocusSkill.cooldown = 0;
            player.limitFocusSkill.activeTimer = 0;
            updateLimitFocusUI();

            player.novaSkill.cooldown = 0;
            updateNovaUI();

            player.divineDashSkill.cooldown = 0;
            player.dashTimer = 0;
            updateDivineDashUI();

            xp = 0;
            maxXp = 10;
            level = 1;
            luck = 0;
            rerollCount = 0;
            isLevelUpPaused = false;
            document.getElementById('level-text').innerText = 'Lv.1';
            document.getElementById('xp-bar').style.width = '0%';
            document.getElementById('levelUpModal').style.display = 'none';

            player.speed = 5.125; 
            player.weapon.isAttacking = false;
            player.weapon.cooldown = 0;
            player.weapon.autoTimer = 0;
            player.weapon.buffTimer = 0;
            player.weapon.baseDamage = 24;
            player.weapon.damage = 24;
            player.weapon.baseLength = 280; 
            player.weapon.length = 280;
            player.weapon.color = 'black';
            player.weapon.originalAutoAttackInterval = 29; // 원본값 복구
            player.weapon.baseAutoAttackInterval = 29;     // 베이스 복구
            player.weapon.autoAttackInterval = 29;         // 현재값 복구
            player.bonusAttackSpeed = 0;                   // 보너스 수치 초기화
            
            poopOverlay.style.opacity = 0;
            mindOverlay.style.opacity = 0;
            darknessOverlay.style.opacity = 0; 
            sacredFaithOverlay.style.opacity = 0;
            bloodOverlay.style.opacity = 0;
            visionOverlay.style.opacity = 0;
            skillSealOverlay.style.display = 'none';
            goddessSealOverlay.style.display = 'none';
            sacredFaithSealOverlay.style.display = 'none';
            novaSealOverlay.style.display = 'none';
            divineDashSealOverlay.style.display = 'none';

            enemies = [];
            gases = [];
            darkGases = [];
            poops = []; 
            bigPoops = [];
            darkBigPoops = [];
            darkSemens = [];
            homingSemens = [];
            poopStains = []; 
            whiteshots = [];
            ghosts = [];
            deathClouds = []; 
            items = [];
            mindSkulls = [];
            stickyCreamPuddles = [];
            pandemoniums = []; 
            hollowNight = [];
            darkHearts = [];
            darkWaves = [];
            pheromoneMarkers = [];
            pleasureZones = []; 
            shockwaves = [];
            groundCracks = [];
            dragShots = [];
            evilArrows = [];
            poisonousShots = [];
            jammingWaves = [];
            neuroNeedles = [];
            bloodBats = [];
            bloodPuddles = [];
            excaliburSlashes = [];
            slashTrails = [];
            blinkMines = [];
            chaosOrbs = [];
            pinkGases = [];
            darkNotes = [];
            pianissimoSnipes = [];
            cursedCatastrophes = [];
            soulHarvestSlashes = [];
            prismSweeps = [];
            occlusionSpools = [];
            movingGases = [];
            explosions = [];
            blackMoons = [];
            maliceBallistics = [];
            antiPassingTentacles = [];

            document.getElementById('blasphemyStatus').style.display = 'none';
            document.getElementById('blasphemyIcon').src = blasphemyIconSrc;

            player.despairTimer = 0;
            player.baptismStacks = 0;
            player.netherGrabbedBy = null;
            darkMatters = [];
            confessionalTotems = [];
            despairStatus.style.display = 'none';
            baptismStatus.style.display = 'none';

            startTime = Date.now();
            lastScoreTime = Date.now();
            overlay.style.display = 'none';
            updateHealthUI();
            updateStatusUI();
            
            bgmAudio.currentTime = 0;
            bgmAudio.play().catch(e => console.log("Audio play failed:", e));
            
            clearTimeout(itemSpawnTimeout);
            score = 0;
            enemyTimer = 0;
            royalSpawnTimer = 0;
            lastScoreTime = Date.now();
            for (let i = 0; i < 2; i++) { spawnEnemy(true); }
            animate();
            spawnItemLoop(); 
        }
        
        function addStatus(name, duration, maxStacks) {
            let finalDuration = duration;
            if (['poison', 'poopPoison', 'malice', 'kiss', 'semen', 'oral', 'byururut', 'fishy'].includes(name)) finalDuration += 600;
            if (['darkScent', 'darkSmell', 'darkSeed', 'darkKiss', 'darkReceiver'].includes(name)) finalDuration += 600;
            if (['evilMind', 'curse'].includes(name)) finalDuration += 900; 
            if (name === 'gnawingLife') finalDuration = 1800; 
            if (name === 'blind') finalDuration = 900; // 실명 15초
            if (name === 'paralysis') finalDuration = 900; // [수정] 마비 15초 (900프레임) 설정
            if (name === 'malice') finalDuration = 1800;
            if (name === 'deathBrand') finalDuration = 600;
            if (name === 'bleeding') finalDuration = 600; // 기본 지속시간
            if (name === 'shading') finalDuration = 600;   // 10초
            // [신규] 아서 디버프 지속시간
            if (['trueAncestorKiss', 'fatalScar', 'corruptedBlood'].includes(name)) finalDuration = 1800; // 30초

            if (name !== 'kiss' && player.kissTimers.length > 0) {
                finalDuration += (player.kissTimers.length * 30);
            }

            const timers = player[name + 'Timers'];
            if (name === 'darkEcstasy' || name === 'gnawingLife') {
                if (timers.length < 5) timers.push(finalDuration); 
                else timers[0] = finalDuration; 
            } else if (name === 'fishy' || name === 'evilLight' || name === 'byururut') {
                timers.push(finalDuration);
            } else {
                timers.push(finalDuration);
                if (timers.length > maxStacks) {
                    timers.shift(); 
                }
            }
            
            if (name === 'evilMind' || name === 'evilLight') updateMaxHealth();
            updateStatusUI();
        }
        
        function checkShieldBlockStatus(type = 'normal') {
            if (type === 'normal') {
                if (player.shieldStacks > 0) {
                    player.shieldStacks--;
                    updateStatusUI();
                    showPickupEffect(player.x, player.y - 30, "상태이상 방어!", false);
                    return true;
                }
            } else if (type === 'evil') {
                if (player.justiceShield > 0) {
                    player.justiceShield--;
                    updateStatusUI();
                    showPickupEffect(player.x, player.y - 30, "정의의 방어!", false);
                    return true;
                }
            }
            return false;
        }

        function gameOver() {
            isGameRunning = false;
            cancelAnimationFrame(animationId);
            clearTimeout(itemSpawnTimeout);
            
            bgmAudio.pause();
            cainAudio.pause();
            touyaAudio.pause();
            pandemoniumAudio.pause();
            arthurAudio.pause();
            
            document.querySelector('.title').innerHTML = "어둠에 먹혔다..♡";
            document.querySelector('.subtitle').innerHTML = `버틴 시간: ${score}초 | 처치: ${killCount}명`;
            startBtn.innerText = "다시 도전";
            gameOverStatsBtn.style.display = 'inline-block';
            overlay.style.display = 'flex';
        }
        
     function getColorFromClass(className, defaultColor) {
    const colorMap = {
        'crit-text': '#ff3333',
        'weak-text': '#cccccc',
        'gnawing-life-text': '#6B8E23',
        'heal-text': '#7FFF00',
        'block-text': '#FFFF00',
        'sticky-text': '#fffdd0',
        'sticky-large-text': '#fffdd0',
        'unwashed-text': '#F0F8FF',
        'condensed-milk-text': '#FFFDD0',
        'dirty-pink-text': '#d45d7d',
        'dirty-brown-text': '#8B4513',
        'pink-text': '#FF69B4',
        'deep-pink-text': '#FF1493',
        'evil-purple-text': '#8A2BE2',
        'shadow-text': '#2F4F4F',
        'poop-text': '#5c4033',
        'evil-summon-text': '#9400D3',
        'wicked-large-text': '#3d004d',
        'boss-warning-text': '#ff0000',
        'mind-break-text': '#800080',
        'pregnancy-text': '#8A2BE2',
        'evil-shout-text': '#8A2BE2',
        'choke-text': '#2F4F4F',
        'fishy-text': '#7FFFD4',
        'hollow-night-text': '#9370DB',
        'malice-text': '#8A2BE2',
        'corrupted-text': '#8B0000',
        'sniper-text': '#FFFFFF',
        'ozma-text': '#FF00FF',
        'gawain-text': '#9370DB',
        'aki-text': '#1a1a1a',
        'hiro-text': '#9932CC',
        'arthur-text': '#DC143C',
        'goddess-text': '#FFD700',
        'crit-damage-text': '#FFFF00',
        'player-crit-text': '#FF0000'
    };

    if (colorMap[className]) return colorMap[className];
    
    // 포함된 단어로 대략적인 색상 유추
    if (className.includes('pink')) return '#FF69B4';
    if (className.includes('poop')) return '#8B4513';
    
    return defaultColor;
} 

       function showDamageText(x, y, text, isCrit, isRear, customClass) {
    if (floatingTexts.length >= performanceState.maxFloatingTexts) return;
    let color = '#ffcc00'; // 기본 노랑
    let size = 24;
    let borderColor = '#000000'; // 기본 테두리 검정
    
    if (isCrit) {
        color = '#FFFF00'; // 크리티컬 노랑
        size = 32;
        text += "!";
        borderColor = '#8B0000'; // 크리티컬은 붉은 테두리 느낌
    } else if (isRear) {
        color = '#cccccc'; // 후방 회색
        size = 18;
    }
    
    // 커스텀 클래스가 있으면 색상 덮어쓰기
    if (customClass) {
        color = getColorFromClass(customClass, color);

        // 플레이어가 '피격 크리티컬'을 맞았을 때만 크게/더 눈에 띄게
        if (customClass === 'player-crit-text') {
            size = Math.max(size, 48);
            borderColor = '#FFFF00';
        }
    }

    floatingTexts.push({
        x: x,
        y: y,
        text: text,
        life: 100,       
        maxLife: 100,
        vy: -1.5,       
        color: color,
        size: size,
        borderColor: borderColor,
        isCrit: isCrit
    });
}
        function showPickupEffect(x, y, text, isGood, isBig = false, customClass = '') {
    if (floatingTexts.length >= performanceState.maxFloatingTexts) return;
    let color = isGood ? '#00ff00' : '#ff4d4d';
    let size = isBig ? 40 : 30;
    
    // 커스텀 클래스가 있으면 색상 덮어쓰기
    if (customClass) {
        color = getColorFromClass(customClass, color);
    }
    
    floatingTexts.push({
        x: x,
        y: y,
        text: text,
        life: 100,
        maxLife: 100,
        vy: -1.0,
        color: color,
        size: size,
        borderColor: '#000000'
    });
}
        
        function showVillainSpeech(x, y, text) {
            if (!performanceState.allowDomEffects) return;
            const el = document.createElement('div');
            el.className = 'villain-speech';
            el.style.left = x + 'px';
            el.style.top = y + 'px';
            el.innerText = text;
            document.body.appendChild(el);
            setTimeout(() => el.remove(), 1500);
        }

        function spawnGhost(x, y, radius, rotation, img, isElite) {
            ghosts.push({ x: x, y: y, radius: radius, rotation: rotation, img: img, life: 15, maxLife: 15, isElite: isElite });
        }
        function updateGhosts() {
            for (let i = ghosts.length - 1; i >= 0; i--) {
                const g = ghosts[i]; g.life--; if (g.life <= 0) ghosts.splice(i, 1);
            }
        }

       function spawnBoss() {
            let x, y;
            if (Math.random() < 0.5) {
                x = Math.random() < 0.5 ? -100 : canvas.width + 100;
                y = Math.random() * canvas.height;
            } else {
                x = Math.random() * canvas.width;
                y = Math.random() < 0.5 ? -100 : canvas.height + 100;
            }

            if (Math.random() < 0.5) {
                spawnArthur(x, y);
                return;
            }

            let bossType = Math.floor(Math.random() * 5);
            let hp = 360;
            let defense = Math.floor(score * 0.07); 

            const hpMultiplier = 1 + (score / 100 * 1.6);
            hp = Math.floor(hp * hpMultiplier);
if (bossType === 4) {
                 for (let k = 0; k < 3; k++) addStatus('darkReceiver', 900, 20);
                 showPickupEffect(player.x, player.y, "넌 내 좆집이다!", false, false, "evil-shout-text");
            }

            cainAudio.currentTime = 0;
            cainAudio.play().catch(()=>{});

            const initialSummonTimer = 2340; 
            const bossRadius = 100;
            const boss = {
                x: x, y: y, radius: bossRadius, baseRadius: bossRadius, 
                baseSpeed: 1.3, 
                speed: 0, vx: 0, vy: 0,
                
                // [수정] 카인: 명중 10%, 회피 10%
                accuracy: 0.10, evasion: 0.10,

                critChance: 25, critResist: 15,
                
                darkGasTimer: 0, darkBigPoopTimer: 0, darkSemenScatterTimer: 0, darkTargetSemenTimer: 0, darkNormalSemenTimer: 0,
                summonTimer: 0, consumeTimer: 0, regenTimer: 0, mindBreakTimer: Math.random() * 480, tanetsukeTimer: 0, tanetsukeTeleportTimer: 0, darkGasExtraTimer: 0,
                demonSummonTimer: initialSummonTimer, hollowNightTimer: 0, 
                angle: 0, isElite: true, isBoss: true, isZako: false, maxHp: hp, hp: hp, defense: defense,
                hitFlash: 0, erectionStacks: 0, erectionTimer: 0, passiveErectionTimer: 0, contactStackTimer: 0, 
                bossType: bossType, buffType: -1, alpha: 1.0, dashTimer: 0, dashVx: 0, dashVy: 0,
                stunTimer: 0, gasExplosionTimer: 900, devilsProtectionTimer: 840, protectionTarget: null, evilDigestTimer: 960, isEvilDigestActive: false, evilDigestDuration: 0, devilsProtectionDuration: 0
            };
            enemies.push(boss);
            
            let bossName = "";
            if (bossType === 0) bossName = "방구킹 카인 (블랙 미스트)";
            else if (bossType === 1) bossName = "방구킹 카인 (다크 테러리스트)";
            else if (bossType === 2) bossName = "방구킹 카인 (테러블 자멘)";
            else if (bossType === 3) bossName = "방구킹 카인 (호러블 네크로맨서)";
            else if (bossType === 4) bossName = "방구킹 카인 (타네츠케 데빌)";

            showPickupEffect(player.x, player.y - 100, `WARNING: ${bossName}!!`, false, false, "boss-warning-text");
        }
        
        function spawnArthur(x, y) {
            let hp = 330;
            let defense = Math.floor(score * 0.07);
            const hpMultiplier = 1 + (score / 100 * 1.6);
            hp = Math.floor(hp * hpMultiplier);
arthurAudio.currentTime = 0;
            arthurAudio.play().catch(()=>{});
            const boss = {
                x: x, y: y, radius: 100, baseRadius: 100,
                baseSpeed: 1.0, speed: 0, vx: 0, vy: 0,
                
                // [수정] 아서: 명중 5%, 회피 5% (유지)
                accuracy: 0.05, evasion: 0.05,

                critChance: 25, critResist: 15,
                
                isElite: true, isBoss: true, isArthur: true,
                maxHp: hp, hp: hp, defense: defense,
                hitFlash: 0, erectionStacks: 0, alpha: 1.0,
                
                bloodDrainTimer: 0,
                excaliburTimer: 0,
                bloodSwarmTimer: 0,
                arthurSummonTimer: 0, 
                initialSummonTimer: 420,
                stunTimer: 0
            };
            enemies.push(boss);
            
            player.majestyActive = true;
            updateStatusUI();
            bloodOverlay.style.opacity = 1;
            setTimeout(() => { 
                if(isGameRunning) bloodOverlay.style.opacity = 0; 
            }, 4000);

            showPickupEffect(player.x, player.y - 100, "WARNING: 타락한 킹 아서!!", false, false, "arthur-text");
            showPickupEffect(player.x, player.y - 50, "군주의 위엄 (쿨감 감소)", false, true, "majesty-border");
        }
        
      

        // [신규] 박쥐 투사체 생성
       function spawnBloodBat(x, y, owner, accuracy = 0) {
    bloodBats.push({
        x: x, y: y,
        owner: owner,
        speed: 3,
        radius: 60,
        life: 300,
        angle: Math.atan2(player.y - y, player.x - x),
        accuracy: accuracy // [추가]
    });
}
        
      function spawnBloodPuddle(x, y, owner, accuracy = 0) {
    bloodPuddles.push({
        x: x, y: y,
        radius: 290,
        owner: owner,
        life: 480,
        tickTimer: 0,
        accuracy: accuracy // [추가]
    });
}

        // ... (이하 기존 함수들 그대로 유지) ...

        function spawnArchdemons(x, y) {
            spawnArchdemonUnit(0, canvas.height / 2, 0, '대악마 아키토');
            spawnArchdemonUnit(canvas.width, canvas.height / 2, 2, '대악마 토우야');
        }

       function spawnArchdemonUnit(x, y, bossType, name) {
            const radius = 85;
            let baseHp = 170; 
            let baseDefense = 3;

            const hpMultiplier = 1 + (score / 100 * 1.6);
            const currentHp = Math.floor(baseHp * hpMultiplier);
            const currentDefense = Math.floor(score * 0.07);
// [수정] 대악마 스탯 설정
            let accuracy = 0;
            let evasion = 0;
            if (name.includes('아키토')) {
                accuracy = 0.10; evasion = 0.05; // 아키토: 명중 10%, 회피 5%
            } else if (name.includes('토우야')) {
                accuracy = 0.05; evasion = 0.10; // 토우야: 명중 5%, 회피 10%
            }

            const unit = {
                x: x, y: y, radius: radius, baseRadius: radius,
                baseSpeed: 1.04, speed: 0, vx: 0, vy: 0,
                
                // [추가]
                accuracy: accuracy,
                evasion: evasion,
                // [신규] 상태이상 저항(기절 확률과 상쇄)
                baseStatusResist: 0,
                statusResist: 0,

                critChance: 25, critResist: 15,
                
                darkGasTimer: 0, darkBigPoopTimer: 0, darkSemenScatterTimer: 0, darkTargetSemenTimer: 0, darkNormalSemenTimer: 0,
                mindBreakTimer: 0, tanetsukeTimer: 0, tanetsukeTeleportTimer: 0, darkGasExtraTimer: 0,
                pandemoniumTimer: 0, evilLightTimer: 0, appliedEvilLightCount: 0,
                angle: 0, isElite: true, isBoss: true, isArchdemon: true, archdemonName: name, bossType: bossType, 
                isZako: false, maxHp: currentHp, hp: currentHp, defense: currentDefense,
                hitFlash: 0, erectionStacks: 0, erectionTimer: 0, passiveErectionTimer: 0, contactStackTimer: 0,
                buffType: -1, eliteType: -1, alpha: 1.0, dashTimer: 0, dashVx: 0, dashVy: 0,
                stunTimer: 0
            };
            enemies.push(unit);
            
            if (name.includes('토우야')) {
                setTimeout(() => triggerEvilLight(unit), 500);
                touyaAudio.currentTime = 0;
                touyaAudio.play().catch(()=>{});
            } else if (name.includes('아키토')) {
                setTimeout(() => {
                    pandemoniumAudio.currentTime = 0;
                    pandemoniumAudio.play().catch(()=>{});
                }, 3000);
            }
        }
        
        function spawnMinionRapist(x, y) {
             if (enemies.length >= performanceState.enemyHardCap) return;
             const traitRoll = Math.random();
             let isStealth = false;
             let isAmbush = false;
             if (traitRoll < 0.33) isStealth = true;
             else if (traitRoll < 0.66) isAmbush = true;
             
             let hp = 65; 
             let defense = Math.floor(score * 0.07);
             
             if (isAmbush) { hp = 65; defense = 1; }
             else if (isStealth) { hp = 55; defense = 1; }
             
             const hpMultiplier = 1 + (score / 100 * 1.6);
             hp = Math.floor(hp * hpMultiplier);
let baseSpeed = 1.3;
             
             const enemy = {
                x: x, y: y, radius: 45, baseRadius: 45, 
                baseSpeed: baseSpeed, speed: 0, vx: 0, vy: 0,
                accuracy: 0, evasion: 0.05,
                critChance: 25, critResist: 15,
                
                gasTimer: 0, gasInterval: 9999,
                bigPoopTimer: 0, scatterTimer: 0, whiteShotTimer: 0, summonTimer: 0, 
                regenTimer: 0, homingPoopTimer: 0, angle: 0, isElite: false, isZako: false, 
                maxHp: hp, hp: hp, defense: defense,
                hitFlash: 0, erectionStacks: 0, erectionTimer: 0, passiveErectionTimer: 0, contactStackTimer: 0, 
                buffType: -1, eliteType: -1, stealthTimer: 0, alpha: 1.0, dashTimer: 0, dashVx: 0, dashVy: 0,
                normalType: 'rapist', isAttached: false, attachTimer: 0, isStealth: isStealth, isAmbush: isAmbush,
                ambushState: 'approach', ambushTimer: 0,
                stunTimer: 0
            };
            enemy.speed = enemy.baseSpeed;
            enemies.push(enemy);
        }

        function spawnEnemy(isElite, forcedEliteName = null, fixedX = null, fixedY = null) {
            if (!isElite && enemies.length >= performanceState.enemyHardCap) return;
            let x, y;
            let normalType = 'summoner';
            let isStealth = false;
            let isAmbush = false;
            let isAgent = false;
            let agentType = "";
            
            // ... (기존 타입 결정 로직 유지) ...
            if (!isElite) {
                if (Math.random() < 0.2) {
                    isAgent = true;
                    const rand = Math.random();
                    if (rand < 0.33) agentType = 'curse';
                    else if (rand < 0.66) agentType = 'pain';
                    else agentType = 'blind';
                } else {
                    if (Math.random() < 0.5) {
                        normalType = 'rapist';
                        const traitRoll = Math.random();
                        if (traitRoll < 0.33) isStealth = true;
                        else if (traitRoll < 0.66) isAmbush = true;
                    }
                }
            }
            
            let eliteType = -1;
            let buffType = -1;
            let hp = 65; 
            let defense = Math.floor(score * 0.07); 
            let radius; 
            let isRyuon = false;
            let isLuca = false; 
            let isOzma = false; 
            let isTaro = false;
            let isGawain = false; 
            let isAki = false;
            let isHiro = false;
            let isKai = false;
            let isJacques = false;
            let isCassias = false;

            // [수정] 명중률, 회피율 변수 초기화
            let accuracy = 0;
            let evasion = 0;

                        if (isElite) {
                // [추가] 강제 엘리트 소환 지원 (아서 소환 등)
                if (forcedEliteName) {
                    const n = forcedEliteName;

                    // ※ 이름은 기존 아서 소환에서 쓰던 'Ryuon', 'Gawain' 등을 그대로 사용
                    if (n === 'Aki') {
                        isAki = true; hp = 130; defense = 2; radius = 70;
                        accuracy = 0.05; evasion = 0.08;
                    } else if (n === 'Gawain') {
                        isGawain = true; hp = 160; defense = 2; radius = 70;
                        accuracy = 0.01; evasion = 0.04;
                    } else if (n === 'Taro') {
                        isTaro = true; hp = 140; defense = 2; radius = 70;
                        accuracy = 0.05; evasion = 0.10;
                    } else if (n === 'Ozma') {
                        isOzma = true; hp = 120; defense = 1; radius = 70;
                        accuracy = 0.03; evasion = 0.02;
                    } else if (n === 'Luca') {
                        isLuca = true; hp = 130; defense = 2; radius = 70;
                        accuracy = 0.05; evasion = 0.08;
                    } else if (n === 'Ryuon') {
                        isRyuon = true; hp = 170; defense = 3; radius = 70;
                        accuracy = 0.01; evasion = 0.04;
                    } else if (n === 'Hiro') {
                        isHiro = true; hp = 140; defense = 2; radius = 70;
                        accuracy = 0.05; evasion = 0.05;
                    } else if (n === 'Kai') {
                        isKai = true; hp = 100; defense = 1; radius = 70;
                        accuracy = 0.03; evasion = 0.02;
                    } else if (n === 'Jacques') {
                        isJacques = true; hp = 120; defense = 1; radius = 70;
                        accuracy = 0.03; evasion = 0.02;
                    } else {
                        // 카시아스 (통합)
                        isCassias = true;
                        hp = 150; defense = 2; radius = 70;
                        accuracy = 0.03; evasion = 0.03;
                    }
                } else {
                    const rand = Math.random();
                    // 확률 분포에 따라 엘리트 결정
                    if (rand < 0.10) {
                        isAki = true; hp = 130; defense = 2; radius = 70;
                        accuracy = 0.05; evasion = 0.08; // 아키: 명중 5%, 회피 8% (상향)
                    } else if (rand < 0.20) {
                        isGawain = true; hp = 160; defense = 2; radius = 70;
                        accuracy = 0.01; evasion = 0.04; // 가웨인: 명중 1%, 회피 4% (하향)
                    } else if (rand < 0.30) {
                        isTaro = true; hp = 140; defense = 2; radius = 70;
                        accuracy = 0.05; evasion = 0.10; // 타로: 명중 5%, 회피 10%
                    } else if (rand < 0.40) {
                        isOzma = true; hp = 120; defense = 1; radius = 70;
                        accuracy = 0.03; evasion = 0.02; // 오즈마: 명중 3%, 회피 2%
                    } else if (rand < 0.50) {
                        isLuca = true; hp = 130; defense = 2; radius = 70;
                        accuracy = 0.05; evasion = 0.08; // 루카: 명중 5%, 회피 8%
                    } else if (rand < 0.60) {
                        isRyuon = true; hp = 170; defense = 3; radius = 70;
                        accuracy = 0.01; evasion = 0.04; // 류온: 명중 1%, 회피 4%
                    } else if (rand < 0.70) {
                        isHiro = true; hp = 140; defense = 2; radius = 70;
                        accuracy = 0.05; evasion = 0.05; // 히로: 명중 5%, 회피 5%
                    } else if (rand < 0.80) {
                        isKai = true; hp = 100; defense = 1; radius = 70;
                        accuracy = 0.03; evasion = 0.02; // 카이: 명중 3%, 회피 2%
                    } else if (rand < 0.90) { 
                        isJacques = true; hp = 120; defense = 1; radius = 70;
                        accuracy = 0.03; evasion = 0.02; // 자크: 명중 3%, 회피 2%
                    } else {
                        // 카시아스 (통합)
                        isCassias = true;
                        hp = 150; defense = 2; radius = 70;
                        accuracy = 0.03; evasion = 0.03; // 카시아스: 명중 3%, 회피 3%
                    }
                }
            } else {
                // 자코들은 기본 0
                if (isAgent) { hp = 45; defense = 1; radius = 35; accuracy = 0; evasion = 0.05;}
                else if (normalType === 'rapist') {
                     accuracy = 0;
                     evasion = 0.05;
                     if (isAmbush) { hp = 65; defense = 1; } 
                     else if (isStealth) { hp = 55; defense = 1; } 
                     else { hp = 65; defense = 1; } 
                     radius = 45;
                } else if (normalType === 'summoner') {
                     accuracy = 0.05;
                     evasion = 0;
                     eliteType = Math.floor(Math.random() * 3);
                     hp = 60; defense = 0; radius = 45; 
                }
            }

            // ... (위치 결정 및 HP 계산 로직 유지) ...
            if (fixedX !== null && fixedX !== undefined && fixedY !== null && fixedY !== undefined) {
                x = fixedX;
                y = fixedY;
            } else if (Math.random() < 0.5) {
                x = Math.random() < 0.5 ? 0 - radius : canvas.width + radius;
                y = Math.random() * canvas.height;
            } else {
                x = Math.random() * canvas.width;
                y = Math.random() < 0.5 ? 0 - radius : canvas.height + radius;
            }

            const hpMultiplier = 1 + (score / 100 * 1.6);
            hp = Math.floor(hp * hpMultiplier);
let baseSpeed = 0.6 + (Math.random() * 0.6);
            
            // ... (속도 보정 로직 유지) ...
            if (!isElite && normalType === 'rapist') baseSpeed *= 1.3;
            if (isRyuon) { baseSpeed *= 1.0; }
            if (isLuca) { baseSpeed = 1.5; } 
            if (isOzma) { baseSpeed = 1.5; } 
            if (isTaro) { baseSpeed = 1.0; } 
            if (isGawain) { baseSpeed = 1.0; } 
            if (isAgent) { baseSpeed *= 1.0; } 
            if (isAki) { baseSpeed *= 1.5; } 
            if (isHiro) { baseSpeed *= 1.5; }
            if (isKai) { baseSpeed = 1.5; }
            if (isJacques) { baseSpeed = 1.5; }

            const enemy = {
                x: x, y: y, radius: radius, baseRadius: radius, 
                baseSpeed: baseSpeed, speed: 0, vx: 0, vy: 0,
                
                // [추가] 명중, 회피 속성 적용
                accuracy: accuracy,
                evasion: evasion,

                critChance: 25, critResist: 15,
                gasTimer: 0, gasInterval: 120,
                bigPoopTimer: isElite ? Math.random() * 300 : 0, 
                scatterTimer: 0, whiteShotTimer: 0, summonTimer: 0, 
                regenTimer: 0, homingPoopTimer: 0, 
                angle: 0, isElite: isElite, isZako: false, maxHp: hp, hp: hp, defense: defense,
                hitFlash: 0, erectionStacks: 0, erectionTimer: 0, passiveErectionTimer: 0,
                contactStackTimer: 0, 
                buffType: buffType, eliteType: eliteType, stealthTimer: 0, alpha: 1.0, dashTimer: 0, dashVx: 0, dashVy: 0,
                darkDenizenSummonTimer: 0, hasSummonedDenizen: false, darkHeartTimer: 0, homingSemenTimer: 0,
                normalType: normalType, isAttached: false, attachTimer: 0,
                isStealth: isStealth, isAmbush: isAmbush, ambushState: 'approach', ambushTimer: 0,
                darkWaveTimer: 0, chargeState: 'idle', chargeTimer: 0, chargeCount: 0, 
                isRyuon: isRyuon, isLuca: isLuca, isOzma: isOzma, isTaro: isTaro, isGawain: isGawain, 
                isAki: isAki, isHiro: isHiro, isKai: isKai, isJacques: isJacques,
                isCassias: isCassias,
                dragShotTimer: 0, evilArrowTimer: 0, poisonousShotTimer: 0, akiSummonTimer: 0, evilKagerouTimer: 0,
                gawainSanctuaryTimer: 300, gawainSanctuaryActive: 0, gawainSwordTimer: 0, gawainJumpState: 'idle', gawainJumpTimer: 0,
                cruelChargeTimer: 120, isCruelChargeCharging: false, cruelChargeWindup: 0, isCruelCharging: false, cruelChargeDuration: 0, cruelChargeAngle: 0, cruelChargeVictim: false,
                aimTimer: 0, pheromoneTimer: 0, healPulseTimer: 0, pleasureZoneTimer: 0, darkBlessingTimer: 0, hasShield: false, 
                poopShotTimer: 0, backstabTimer: 0, sonicBoomTimer: 0, deathGripTimer: 0, deathGripActive: false, deathGripDuration: 0,
                isTransparent: false, transparentTimer: 0, speedBoostTimer: 0, sonicState: 'idle', sonicHitCooldown: 0,
                isAgent: isAgent, agentType: agentType, agentDeathTimer: 900,
                stunTimer: 0, abyssalResonanceTimer: 0, jacquesAdrenalineTimer: 0, pianissimoTimer: 240,
                jacquesGasTimer: 0, jacquesHymnTimer: 0, shadowSwapTimer: 0,
                shadowSwapCharging: false, shadowSwapChargeTimer: 0, shadowSwapChargeMax: 240,
                shadowSwapShield: 0, shadowSwapShieldMax: 0,
                chaosOrbTimer: 0, shadowCloakTimer: 0, isInvisible: false, invisibleDuration: 0, soulLinkCooldown: 540, soulLinkTarget: null, soulLinkHealTimer: 0,
                jammingTimer: 0, needleTimer: 0, hiroSummonTimer: 0, blackHolyBloodTimer: 720,
                antiPassingTimer: 0, antiPassingCharging: false, antiPassingChargeTimer: 0, antiPassingChargeMax: 360,
                antiPassingShield: 0, antiPassingShieldMax: 0, antiPassingTentacleSpawnTimer: 0,
            };
            enemy.speed = enemy.baseSpeed;
            enemies.push(enemy);

            // ... (등장 이펙트 로직 유지) ...
            if (isRyuon) { player.corruptedOathStacks++; showPickupEffect(player.x, player.y - 40, "맹세가 타락했다..", false, true); updateStatusUI(); }
            if (isLuca) { player.dangerousJudgmentStacks++; showPickupEffect(player.x, player.y - 40, "판단력이 흐려진다..", false, true); updateStatusUI(); }
            if (isOzma) { player.deepDarknessStacks++; showPickupEffect(player.x, player.y - 40, "어둠이 짙어진다..", false, true); updateStatusUI(); }
            if (isGawain) { player.corruptedJusticeStacks++; showPickupEffect(player.x, player.y - 40, "정의가 왜곡된다..", false, true); updateStatusUI(); }
            if (isAki) { activeAkiCount++; showPickupEffect(player.x, player.y - 40, "기세 등등한 어둠..", false, true); }
            if (isKai) { showPickupEffect(player.x, player.y - 40, "욕심쟁이♥", false, true, "evil-purple-text"); spawnFakeItem(enemy.accuracy); spawnFakeItem(enemy.accuracy, enemy); }
            if (isJacques) { showPickupEffect(enemy.x, enemy.y - 40, "타락한 선율..", false, true, "evil-purple-text"); }
            if (isHiro) { 
                const hiroCount = enemies.filter(e => e.isHiro).length;
                let sealDuration = 600; if (hiroCount >= 2) sealDuration = 1200;
                player.skillSealTimer = sealDuration;
                showPickupEffect(player.x, player.y - 40, "당황스럽지♥?", false, true, "hiro-text");
                skillSealOverlay.style.display = 'flex'; updateStatusUI();
            }

            if (!isElite && !isAgent && !isGawain && !isAki && !isHiro) {
                const zakoTypes = [null, 'terrorist', 'plague'];
                const randomZako = zakoTypes[Math.floor(Math.random() * 3)];
                const offsetX = (Math.random() - 0.5) * 100;
                const offsetY = (Math.random() - 0.5) * 100;
                spawnZako(x + offsetX, y + offsetY, randomZako);
            }
        }

        function spawnDragShot(x, y, angle, accuracy = 0, owner = null) {
    dragShots.push({
        x: x, y: y,
        vx: Math.cos(angle) * 5,
        vy: Math.sin(angle) * 5,
        radius: 60,
        angle: angle,
        startX: x, startY: y,
        life: 240,
        accuracy: accuracy, // [신규]
        owner: owner,
        seed: (_akiProjectileUid++ * 10007),
    });
}

function spawnEvilArrow(x, y, angle, accuracy = 0, owner = null) {
    // [SFX] Evil Arrow
    if (typeof playAkiEvilArrowSfx === 'function') playAkiEvilArrowSfx();

    evilArrows.push({
        x: x, y: y,
        vx: Math.cos(angle) * 7,
        vy: Math.sin(angle) * 7,
        radius: 45,
        angle: angle,
        life: 300,
        accuracy: accuracy, // [신규]
        owner: owner,
        seed: (_akiProjectileUid++ * 10007),
    });
}


function spawnPoisonousShot(x, y, angle, accuracy = 0, owner = null) {
    // [SFX] Poisonous Shot
    if (typeof playAkiPoisonousShotSfx === 'function') playAkiPoisonousShotSfx();

    // [Aki] Poisonous Shot: villain + gas + poop projectile (same size level as Evil Arrow)
    poisonousShots.push({
        x: x, y: y,
        vx: Math.cos(angle) * 7,
        vy: Math.sin(angle) * 7,
        radius: 45,
        angle: angle,
        life: 300, // 5초(60fps 기준)
        accuracy: accuracy,
        owner: owner,
        seed: (_akiProjectileUid++ * 10007),
    });
}


function spawnShadowGrip(x, y, owner) {
            const angle = Math.atan2(player.y - y, player.x - x);
            shadowGrips.push({
                x: x, y: y,
                vx: Math.cos(angle) * 8, // 빠른 속도
                vy: Math.sin(angle) * 8,
                radius: 48,
                angle: angle,
                owner: owner,
                life: 300, // 5초 후 소멸
                accuracy: owner.accuracy
            });
            showPickupEffect(x, y - 50, "그림자 품으로♥", false, true, "evil-purple-text");
        }

       function spawnBlackMoon(x, y, accuracy = 0, owner = null) {
    // [신규] 크레이터(달 무늬) 데이터 생성
    const craters = [];
    for (let i = 0; i < 7; i++) {
        // 달 내부 랜덤 위치
        const angle = Math.random() * Math.PI * 2;
        const dist = Math.random() * 45; // 반지름 60 안쪽
        craters.push({
            dx: Math.cos(angle) * dist,
            dy: Math.sin(angle) * dist,
            r: 4 + Math.random() * 8 // 크기 랜덤
        });
    }

    blackMoons.push({
        x: x,
        y: y,
        radius: 60,          // 흑월의 피격 범위
        pullRange: 430,      // 흡인(끌어당김) 범위
        life: 480,           // 지속시간 8초
        maxLife: 480,
        accuracy: accuracy,// 명중률 전달
        owner: owner,
        angle: 0,            // 회전 애니메이션용
        craters: craters     // [추가] 크레이터 정보 저장
    });

    // 등장 이펙트
    showPickupEffect(x, y - 80, "흑월(Black Moon)", false, true, "masakuni-text");
    shockwaves.push({ x: x, y: y, radius: 10, speed: 5, alpha: 1.0, fade: 0.02 });
}

function updateBlackMoons() {
    for (let i = blackMoons.length - 1; i >= 0; i--) {
        const moon = blackMoons[i];
        moon.life--;
        moon.angle += 0.02; 

        if (moon.life <= 0) {
            blackMoons.splice(i, 1);
            continue;
        }

        const dx = player.x - moon.x;
        const dy = player.y - moon.y;
        const distSq = dx * dx + dy * dy; // 거리 제곱

        // 2. 플레이어 흡인 로직 (끌어당김)
        // 거리제곱 < 당기기범위제곱
        if (distSq < moon.pullRange * moon.pullRange) {
            // 거리가 가까울수록 더 강하게 끌어당김 (정확한 거리 계산이 필요하므로 여기서만 sqrt 사용하거나, 근사치 사용)
            // 최적화를 위해 distSq를 이용하되, 물리적으로 정확할 필요는 없으므로 sqrt는 최소화
            const dist = Math.sqrt(distSq); 
            if (dist > 0) {
                const pullPower = (1 - (dist / moon.pullRange)) * 1.9;
                player.x -= (dx / dist) * pullPower * 3.0; 
                player.y -= (dy / dist) * pullPower * 3.0;
            }
        }

        // 3. 충돌 처리 (플레이어 타격)
        // 거리제곱 < (반지름합)^2
        const hitRadius = moon.radius + player.radius;
        if (distSq < hitRadius * hitRadius) {
            if (player.invincibleTimer <= 0) {
                let dmg = 30 + Math.floor(score * 0.25);
                // [마사쿠니 패시브: 심안] 흑월도 다음 공격 치명타(1.5배) 적용
                if (moon.owner && moon.owner.nextAttackCrit) {
                    dmg *= 1.5;
                    moon.owner.nextAttackCrit = false;
                    showPickupEffect(player.x, player.y, "심안 치명타!!", false, true, "masakuni-text");
                }
                takeDamage(dmg, 'direct', moon.accuracy, moon);
                for(let k=0; k<5; k++) {
                   addStatus('bleeding', 600, 20);
                }
                
                showPickupEffect(player.x, player.y, "어둠의 달..", false, true, "bleeding-border");
                blackMoons.splice(i, 1);
                
                explosions.push({ 
                    x: moon.x, y: moon.y, 
                    radius: 80, life: 30, 
                    accuracy: moon.accuracy,
                    owner: moon.owner,
                    damage: 0, hasHit: true 
               });
            }
        }
    }
}
     function spawnJammingWave(x, y, angle, accuracy = 0, owner = null) {
    jammingWaves.push({
        x: x, y: y,
        vx: Math.cos(angle) * 8, 
        vy: Math.sin(angle) * 8,
        radius: 40,
        life: 300,
        angle: angle,
        accuracy: accuracy, // [추가]
        owner: owner,
    });
}

       function spawnNeuroNeedle(x, y, angle, accuracy = 0, owner = null) {
    neuroNeedles.push({
        x: x, y: y,
        vx: Math.cos(angle) * 9, 
        vy: Math.sin(angle) * 9,
        radius: 8,
        life: 300,
        angle: angle,
        accuracy: accuracy, // [추가]
        owner: owner,
    });
}
        function spawnBlackHolyBlood(x, y, accuracy, owner = null) {
        blackHolyBloods.push({
            x: x, y: y,
            radius: 55, // 투사체 크기
            speed: 3.3, // 투사체 속도
            angle: Math.atan2(player.y - y, player.x - x), // 초기 각도
            life: 300, // 지속 시간 6초
            homingPower: 0.07, // 유도 성능
            accuracy: accuracy,// 명중률
            owner: owner,
            wobbleOffset: Math.random() * 100 // 시각적 이펙트용 랜덤값
        });
        showPickupEffect(x, y - 40, "감염 시켜주마♥", false, true, "corrupted-text");
    }

        function spawnAntiPassingTentacle(owner) {
            if (!owner) return;

            const nearR = 90 + Math.random() * 160;
            const ang = Math.random() * Math.PI * 2;
            const tx = player.x + Math.cos(ang) * nearR;
            const ty = player.y + Math.sin(ang) * nearR;

            antiPassingTentacles.push({
                x: tx,
                y: ty,
                radius: 65,
                life: 210,
                maxLife: 210,
                hitDelay: 75,
                riseDuration: 15,
                hitApplied: false,
                gasSpawned: false,
                frame: 0,
                riseProgress: 0,
                baseAngle: Math.random() * Math.PI * 2,
                segCount: 7,
                owner: owner,
                accuracy: owner.accuracy || 0,
                gasBursts: Array.from({ length: 8 }, () => ({
                    angle: Math.random() * Math.PI * 2,
                    dist: 8 + Math.random() * 36,
                    size: 8 + Math.random() * 20,
                    drift: 0.3 + Math.random() * 1.0,
                }))
            });
        }

        function spawnDarkDenizen(x, y, denizenType) {
            const radius = 55; 
            let hp = 90;
            let defense = Math.floor(score * 0.07);
            let accuracy = 0;
            let evasion = 0;
            if (denizenType === 'louie') {
        // 루이: 명중 5%, 회피 0%
        accuracy = 0.05;
        evasion = 0;
    } else if (denizenType === 'rai') {
        // 라이: 명중 0%, 회피 5%
        accuracy = 0;
        evasion = 0.05;
    }
            const hpMultiplier = 1 + (score / 100 * 1.6);
            hp = Math.floor(hp * hpMultiplier);
const enemy = {
                x: x, y: y, radius: radius, baseRadius: radius,
                baseSpeed: 1.5, speed: 0, vx: 0, vy: 0,
                accuracy: accuracy,
                evasion: evasion,
                critChance: 25, critResist: 15,
                
                gasTimer: 0, gasInterval: 120, 
                bigPoopTimer: 0, scatterTimer: 0, whiteShotTimer: 0,
                angle: 0, isElite: false, isZako: false, isSummoned: true, isDarkDenizen: true, 
                denizenType: denizenType, 
                maxHp: hp, hp: hp, defense: defense,
                hitFlash: 0, erectionStacks: 0, erectionTimer: 0, passiveErectionTimer: 0, contactStackTimer: 0,
                eliteType: -1, buffType: -1, alpha: 1.0, dashTimer: 0, dashVx: 0, dashVy: 0,
                darkHeartTimer: 0, attachTimer: 0, isAttached: false, readyStacks: 0, readyTimer: 0,
                stunTimer: 0
            };
            enemies.push(enemy);
        }
        
        function spawnMonolith(x, y, accuracy = 0, owner = null) {
    let hp = 75;
    const hpMultiplier = 1 + (score / 100 * 1.6);
    hp = Math.floor(hp * hpMultiplier);
    const monolith = {
        x: x, y: y,
        radius: 35,       // 비석 크기
        baseRadius: 35,
        baseSpeed: 0,     // 움직이지 않음
        speed: 0, vx: 0, vy: 0,
        
        hp: hp, maxHp: hp,
        defense: 3,  
        
        isZako: false, isElite: false, isBoss: false,
        isMonolith: true,
        accuracy: accuracy,
        
        gasTimer: 0,      // 가스 패턴용 타이머
        
        // 필수 초기화 변수들 (에러 방지)
        critChance: 0, critResist: 100,
        isSuperArmor: true,
        hitFlash: 0, alpha: 1.0, 
        erectionStacks: 0, buffType: -1, eliteType: -1,
        stunTimer: 0, collisionTimer: 0
    };
    
    enemies.push(monolith);
    
    // 등장 이펙트
    showPickupEffect(x, y - 50, "혼돈의 비석!", false, true, "wicked-large-text");
    // 주변을 밀어내기 위한 충격파
    shockwaves.push({ x: x, y: y, radius: 10, speed: 8, alpha: 0.8, fade: 0.05 });
}
        
        function spawnAkiClone(x, y, maxHp, accuracy, owner = null) {
            const hp = Math.floor(maxHp * 0.6); // 본체 체력의 60%
            const clone = {
                x: x, y: y, radius: 70, baseRadius: 70,
                baseSpeed: 1.5 * 1.5, // 아키와 동일한 기본 속도 (기본 1.5배)
                speed: 0, vx: 0, vy: 0,
                accuracy: accuracy, evasion: 0.1, // 분신도 회피율 가짐
                critChance: 25, critResist: 15,
                
                angle: 0, isElite: false, isZako: false, isBoss: false,
                isAkiClone: true, // 분신 식별 플래그
                
                maxHp: hp, hp: hp, defense: 2,
                hitFlash: 0, erectionStacks: 0, alpha: 1.0,
                
                erectionBuffTimer: 0, // 주변 아군 발기 버프 타이머
                passiveErectionTimer: 0,

                // 필수 초기화 변수들
                gasTimer: 0, gasInterval: 180, buffType: -1, eliteType: -1,
                dashTimer: 0, dashVx: 0, dashVy: 0, stunTimer: 0
            };
            enemies.push(clone);
            showPickupEffect(x, y - 60, "카게로우♥", false, true, "pink-text");
        }
        function spawnMasakuni() {
            // 위치: 화면 밖 랜덤
            let x, y;
            if (Math.random() < 0.5) {
                x = Math.random() < 0.5 ? -100 : canvas.width + 100;
                y = Math.random() * canvas.height;
            } else {
                x = Math.random() * canvas.width;
                y = Math.random() < 0.5 ? -100 : canvas.height + 100;
            }

            let hp = 280;
            let defense = Math.floor(score * 0.07);
            const hpMultiplier = 1 + (score / 100 * 1.6);
            hp = Math.floor(hp * hpMultiplier);
const enemy = {
                x: x, y: y, radius: 90, baseRadius: 90,
                baseSpeed: 0, // 기본 이동 속도는 0 (대쉬로만 이동)
                speed: 0, vx: 0, vy: 0,
                
                // 마사쿠니 스탯
                accuracy: 0.08, 
                evasion: 0.15,  
                critChance: 25, 
                critResist: 15,

                isElite: false, isBoss: false, isZako: false, isRoyal: true,
                isMasakuni: true,
                
                maxHp: hp, hp: hp, defense: defense,
                hitFlash: 0, alpha: 1.0,
                erectionStacks: 0, passiveErectionTimer: 0,
                
                // [패시브] 심안
                nextAttackCrit: false,

                // [이동 패턴] 가스 추진 대쉬 (평상시 이동)
                moveDashTimer: 0,       // 대쉬 쿨타임 체크용
                moveDashDuration: 0,    // 대쉬 지속 시간
                moveDashCooldown: 90,  // 대쉬 간격

                // [스킬 1] 일섬 (가웨인 돌진 기반)
                flashState: 'idle', 
                flashTimer: 0, 
                flashCooldown: 660,
                flashAngle: 0,
                hasHitFlash: false, // 돌진 중 플레이어 타격 여부 (다단히트 방지)

                // [스킬 2] 흑월
                blackMoonState: 'idle', blackMoonTimer: 0, blackMoonCooldown: 600, 

                // [스킬 3] 환영검
                phantomSwordCooldown: 900, 
                phantomSwordsActive: false,

                // 필수 초기화 변수
                gasTimer: 0, gasInterval: 9999, buffType: -1, eliteType: -1, 
                dashTimer: 0, dashVx: 0, dashVy: 0, stunTimer: 0
            };
            
            enemies.push(enemy);
            showPickupEffect(player.x, player.y - 100, "WARNING: 검은 민족 마사쿠니!", false, true, "masakuni-text");
        }

        function spawnKaito() {
            // 위치: 화면 밖 랜덤
            let x, y;
            if (Math.random() < 0.5) {
                x = Math.random() < 0.5 ? -100 : canvas.width + 100;
                y = Math.random() * canvas.height;
            } else {
                x = Math.random() * canvas.width;
                y = Math.random() < 0.5 ? -100 : canvas.height + 100;
            }

            let hp = 260;
            let defense = Math.floor(score * 0.07);
            const hpMultiplier = 1 + (score / 100 * 1.6);
            hp = Math.floor(hp * hpMultiplier);
const enemy = {
                x: x, y: y, radius: 80, baseRadius: 80,
                baseSpeed: 2.5,
                speed: 2.5, vx: 0, vy: 0,
                
                // 카이토 스탯
                accuracy: 0.10, 
                evasion: 0.15,  
                critChance: 25, 
                critResist: 15,

                isElite: false, isBoss: false, isZako: false, isRoyal: true,
                isKaito: true,
                
                maxHp: hp, hp: hp, defense: defense,
                hitFlash: 0, alpha: 1.0,
                erectionStacks: 0, passiveErectionTimer: 0,
                
                // 스킬 쿨타임 및 타이머
                voidWarpTimer: 0, voidWarpCooldown: 180, // 3초
                darkMatterTimer: 0, darkMatterCooldown: 720, // 12초
                confessionalTimer: 0, confessionalCooldown: 960, // 16초
                netherGrabTimer: 0, netherGrabCooldown: 960, // 16초
                
                netherGrabActive: false,
                netherGrabDuration: 0,

                kaitoStealthTimer: 0,
                isKaitoStealth: false,

                // 필수 초기화 변수
                gasTimer: 0, gasInterval: 9999, buffType: -1, eliteType: -1, 
                dashTimer: 0, dashVx: 0, dashVy: 0, stunTimer: 0
            };
            enemies.push(enemy);
            showPickupEffect(player.x, player.y - 100, "WARNING: 검은 민족 카이토!", false, true, "masakuni-text"); // 텍스트 스타일 재활용
        }

        function spawnQuesta() {
    // 위치: 화면 밖 랜덤
    let x, y;
    if (Math.random() < 0.5) {
        x = Math.random() < 0.5 ? -100 : canvas.width + 100;
        y = Math.random() * canvas.height;
    } else {
        x = Math.random() * canvas.width;
        y = Math.random() < 0.5 ? -100 : canvas.height + 100;
    }

    let hp = 290;
    let defense = Math.floor(score * 0.07);
    const hpMultiplier = 1 + (score / 100 * 1.6);
    hp = Math.floor(hp * hpMultiplier);
const enemy = {
        x: x, y: y, radius: 80, baseRadius: 80,
        baseSpeed: 0, // 기본 이동은 0, 로직으로 제어
        speed: 0, vx: 0, vy: 0,

        // --- [추가됨: 덮치기 패턴용 상태 변수] ---
        state: 'idle',         // idle(접근), warmup(준비), dashing(돌진), cooldown(휴식)
        actionTimer: 0,        // 각 상태별 지속 시간 체크용
        dashDir: {x: 0, y: 0}, // 돌진 시 방향 고정용 벡터
        // ------------------------------------
        
        // 퀘스타 스탯
        accuracy: 0.05, 
        evasion: 0.20,
        baseEvasion: 0.20, // 기본 회피율 저장
        critChance: 25, 
        critResist: 15,

        isElite: false, isBoss: false, isZako: false, isRoyal: true,
        isQuesta: true,
        
        maxHp: hp, hp: hp, defense: defense,
        hitFlash: 0, alpha: 1.0,
        erectionStacks: 0, passiveErectionTimer: 0,

        // [스킬 1] 그림자 손아귀 (10초)
        shadowGripTimer: 0, shadowGripCooldown: 600,

        // [스킬 2] 다크 플리커 (6초)
        flickerTimer: 0, flickerCooldown: 360,
        isFlickering: false, flickerCount: 0, flickerStepTimer: 0, flickerHitCooldown: 0,

        // [스킬 3] 칠흑의 장막 (10초)
        veilTimer: 600, veilCooldown: 600,
        isVeiled: false, veilDuration: 0,

        // [스킬 4] 본 크러셔 (17초)
        boneCrusherTimer: 0, boneCrusherCooldown: 1020,
        boneCrusherState: 'idle', // idle, charging, rushing
        boneCrusherChargeTimer: 0,
        
        // 이동 패턴용 (기존 변수 유지 혹은 state 로직이 대체하지만 호환성을 위해 남김)
        moveDelay: 0,

        // 필수 초기화
        gasTimer: 0, gasInterval: 9999, buffType: -1, eliteType: -1, 
        dashTimer: 0, dashVx: 0, dashVy: 0, stunTimer: 0
    };
    enemies.push(enemy);
    showPickupEffect(player.x, player.y - 100, "WARNING: 검은 민족 퀘스타!", false, true, "masakuni-text");
}

        function spawnTetora() {
            // 위치: 화면 밖 랜덤
            let x, y;
            if (Math.random() < 0.5) {
                x = Math.random() < 0.5 ? -100 : canvas.width + 100;
                y = Math.random() * canvas.height;
            } else {
                x = Math.random() * canvas.width;
                y = Math.random() < 0.5 ? -100 : canvas.height + 100;
            }

            let hp = 230;
            let defense = Math.floor(score * 0.07);
            // 스코어 비례 강화
            const hpMultiplier = 1 + (score / 100 * 1.6);
            hp = Math.floor(hp * hpMultiplier);
// 등장 시 진혼곡/광시곡 중 하나 랜덤 즉시 발동
            const startWithRequiem = Math.random() < 0.5;

            const enemy = {
                x: x, y: y, radius: 80, baseRadius: 80,
                baseSpeed: 1.5,
                speed: 1.5, vx: 0, vy: 0,

                // 테토라 스탯
                accuracy: 0.15,
                evasion: 0.15,
                critChance: 25,
                critResist: 15,

                isElite: false, isBoss: false, isZako: false, isRoyal: true,
                isTetora: true, // 식별 플래그

                maxHp: hp, hp: hp, defense: defense,
                hitFlash: 0, alpha: 1.0,
                erectionStacks: 0, passiveErectionTimer: 0,

                // [패시브] 불협화음 계산용
                allyCount: 0, 

                // [스킬] 노래 (진혼곡/광시곡)
                // 16초 지속(960프레임), 16초 쿨타임
                currentSong: startWithRequiem ? 'requiem' : 'rhapsody',
                songTimer: 960,       // 지속 시간 타이머
                songCooldown: 960,    // 쿨타임 (지속시간 끝나면 쿨타임 시작 or 지속시간 포함 쿨타임인지에 따라 로직 조정. 여기선 지속 끝난 후 쿨타임으로 구현하거나 스위칭 형태로 구현)
                // 요구사항: 쿨타임 16초, 지속 16초. 즉 무한 유지 가능한지 여부가 중요하나, "쿨타임 16초"가 사용 후 16초라면 텀이 빔.
                // 여기서는 "지속시간 동안 사용 불가"이므로, 효과 종료 후 쿨타임이 도는 방식으로 구현하거나, 
                // 등장 시 바로 사용하고 쿨타임이 같이 돈다면 무한 유지가 됨. 로직 상 '지속 시간'을 우선시합니다.
                
                // [스킬] 데스메탈 크레센도 (10초 쿨타임)
                crescendoTimer: 0, 
                crescendoCooldown: 600,

                // [스킬] 다크니스 스포트라이트 (14초 쿨타임)
                spotlightTimer: 0,
                spotlightCooldown: 840,

                // 필수 초기화 변수
                gasTimer: 0, gasInterval: 9999, buffType: -1, eliteType: -1, 
                dashTimer: 0, dashVx: 0, dashVy: 0, stunTimer: 0
            };
            enemies.push(enemy);
            showPickupEffect(player.x, player.y - 100, "WARNING: 검은 민족 테토라!", false, true, "masakuni-text");
        }

        function spawnZako(x, y, type = null) {
            const zakoCount = enemies.filter(e => e.isZako).length;
            if (zakoCount >= 30) return;
            const radius = 30; 
            let hp = 18; 
            const hpMultiplier = 1 + (score / 100 * 1.6);
            hp = Math.floor(hp * hpMultiplier);
            let defense = Math.floor(score * 0.07);

            let state = 'idle';
            let isAmbush = false;
            
            if (type === 'terrorist') {
                state = 'wandering';
            } else if (type === 'plague') {
                state = 'wandering';
                isAmbush = false;
            }

            const enemy = {
                x: x, y: y, radius: radius, baseRadius: radius,
                baseSpeed: (0.6 + (Math.random() * 0.6)) * 0.5, speed: 0, vx: 0, vy: 0,
                accuracy: 0.01, evasion: 0.01,
                critChance: 25, critResist: 15,
                
                gasTimer: Math.random() * 300, gasInterval: 300, whiteShotTimer: 0, angle: 0,
                isElite: false, isZako: true, maxHp: hp, hp: hp, defense: defense, 
                hitFlash: 0, erectionStacks: 0, erectionTimer: 0, passiveErectionTimer: 0,
                contactStackTimer: 0, 
                buffType: -1, eliteType: -1, alpha: 1.0, 
                state: state, 
                pounceTimer: 0, cooldownTimer: 0,
                zakoType: type, 
                isAmbush: isAmbush,
                ambushState: null,
                wanderTimer: 0,
                wanderAngle: Math.random() * Math.PI * 2,
                ambushTimer: 0,
                readyStacks: 0,
                readyTimer: 0,
                enraged: false, 
                enrageTimer: 0,
                hasShield: false,
                stunTimer: 0
            };
            enemy.speed = 0; 
            enemies.push(enemy);
        }

       function spawnDarkBigPoop(x, y, isScatter = false, angle = 0, isHoming = false, accuracy = 0, owner = null) {
            let vx = 0, vy = 0;
            if (isHoming) {
                const targetAngle = Math.atan2(player.y - y, player.x - x);
                const speed = 3.0; 
                vx = Math.cos(targetAngle) * speed;
                vy = Math.sin(targetAngle) * speed;
            } else if (isScatter) {
                const speed = 4;
                vx = Math.cos(angle) * speed;
                vy = Math.sin(angle) * speed;
            } else {
                const targetAngle = Math.atan2(player.y - y, player.x - x);
                const speed = 3;
                vx = Math.cos(targetAngle) * speed;
                vy = Math.sin(targetAngle) * speed;
            }

            darkBigPoops.push({
                x: x, y: y, vx: vx, vy: vy,
                radius: 45, life: isHoming ? 600 : 600, isScatter: isScatter, isHoming: isHoming,
                accuracy: accuracy, // [신규]
                owner: owner,
            });
        }

       function spawnDarkSemen(x, y, isHoming = false, angle = 0, sizeMult = 1.0, accuracy = 0, owner = null) {
            let vx = 0, vy = 0;
            const speed = 3.5;
            
            if (isHoming) {
                 const targetAngle = Math.atan2(player.y - y, player.x - x);
                 vx = Math.cos(targetAngle) * speed;
                 vy = Math.sin(targetAngle) * speed;
            } else {
                 vx = Math.cos(angle) * speed;
                 vy = Math.sin(angle) * speed;
            }

            darkSemens.push({
                x: x, y: y, vx: vx, vy: vy,
                radius: 15 * sizeMult, life: isHoming ? 360 : 400, isHoming: isHoming,
                accuracy: accuracy, // [신규]
                owner: owner,
                stickyTrailTimer: 0,
            });
        }

        function spawnPandemonium(x, y, accuracy = 0, owner = null) {
    const angle = Math.atan2(player.y - y, player.x - x);
    const speed = 2.1;
    pandemoniums.push({
        x: x, y: y, 
        vx: Math.cos(angle) * speed, 
        vy: Math.sin(angle) * speed,
        radius: 52.5, 
        life: 300,
        speed: speed,
        accuracy: accuracy, // [추가]
        owner: owner,
    });
}

        function spawnDarkHeart(x, y, accuracy = 0, owner = null) {
    const angle = Math.atan2(player.y - y, player.x - x);
    const speed = 2.78;
    darkHearts.push({
        x: x, y: y, 
        vx: Math.cos(angle) * speed, 
        vy: Math.sin(angle) * speed,
        radius: 52.5, 
        life: 345,
        speed: speed,
        isHoming: true,
        accuracy: accuracy, // [추가]
        owner: owner,
    });
}
        
        function spawnChaosOrb(x, y, accuracy = 0, owner = null) {
    const angle = Math.atan2(player.y - y, player.x - x);
    const speed = 2.5;
    chaosOrbs.push({
        x: x, y: y,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        radius: 52.5,
        life: 300,
        speed: speed,
        accuracy: accuracy, // [추가]
        owner: owner,
    });
}

        function spawnFakeItem(accuracy = 0, owner = null) {
            const margin = 50;
            const x = margin + Math.random() * (canvas.width - margin * 2);
            const y = margin + Math.random() * (canvas.height - margin * 2);
            // type을 'fakeHealth'로 지정하여 구분
           items.push({ x: x, y: y, radius: 15, type: 'fakeHealth', life: 2100, accuracy: accuracy , owner: owner});
}

       function spawnDarkWave(x, y, angle, accuracy = 0, owner = null) {
            const speed = 5.5;
            const newRadius = 45 * 1.25;
            const newLength = 120 * 1.25;
            darkWaves.push({
                x: x, y: y, 
                vx: Math.cos(angle) * speed, 
                vy: Math.sin(angle) * speed,
                rotation: angle,
                radius: newRadius, 
                length: newLength, 
                life: 300,
                bounceCount: 0,
                maxBounces: 3,
                accuracy: accuracy, // [신규]
                owner: owner,
            });
        }
        
        // [신규] 소울 하비스트 시각 효과 생성
    function spawnSoulHarvestSlash(targetX, targetY) {
        soulHarvestSlashes.push({
            x: targetX,
            y: targetY,
            life: 45,
            scale: 1.0,
            angle: Math.random() * Math.PI * 2
        });
    }
        // [신규] 가이코츠 카타스트로피(커스드 카타스트로피) 생성
   function spawnCursedCatastrophe(x, y, accuracy, owner = null) {
    const angle = Math.atan2(player.y - y, player.x - x); // 각도 미리 계산
    const speed = 3.5; // 초기 속도

    cursedCatastrophes.push({
        x: x, y: y,
        // [수정] vx, vy에 초기 속도 적용
        vx: Math.cos(angle) * speed, 
        vy: Math.sin(angle) * speed,
        
        speed: speed, // (참고: 업데이트 로직에서 p.speed를 직접 쓰지 않고 vx, vy에서 역산한다면 이 값은 참조용이 됩니다)
        maxSpeed: 4.3,
        angle: angle,
        radius: 160,
        life: 480,
        accuracy: accuracy,
        owner: owner,
    });
    showPickupEffect(x, y - 50, "불알의 낙인♥", false, true, "wicked-large-text");
}

        // [신규] 아키토의 소울 하비스트 로직 (이름 변경: aki -> akito)
    function castSoulHarvest(akito) {
        // 1. 플레이어의 디버프 목록 확인
        const debuffKeys = [
            'poisonTimers', 'poopPoisonTimers', 'maliceTimers', 'kissTimers',
            'semenTimers', 'oralTimers', 'byururutTimers'
        ];
        
        let removedCount = 0;
        let stacksToRemove = 10; // 최대 10중첩 제거

        // 제거 가능한 디버프 수집 및 제거
        for (let key of debuffKeys) {
            if (stacksToRemove <= 0) break;
            if (player[key] && player[key].length > 0) {
                while (player[key].length > 0 && stacksToRemove > 0) {
                    player[key].shift(); // 스택 하나 제거
                    removedCount++;
                    stacksToRemove--;
                }
            }
        }
        
        updateStatusUI(); // UI 갱신

        // 2. 효과 적용
        if (removedCount > 0) {
            let damage = removedCount * 2.5;
            damage += Math.floor(score * 0.12); 
            
            // 데미지 입히기 (명중률 적용 - akito 변수 사용)
            takeDamage(damage, 'direct', akito.accuracy, akito);
            showPickupEffect(player.x, player.y, `영혼 수확 -${damage}`, false, true, "evil-purple-text");

            // 아키토 회복: 치료한 중첩 수 * 3% (akito 변수 사용)
            let healAmount = akito.maxHp * (removedCount * 0.03);
            akito.hp = Math.min(akito.maxHp, akito.hp + healAmount);
            showDamageText(akito.x, akito.y, `+${Math.floor(healAmount)}`, false, false, "heal-text");
        } else {
            // 치료할 디버프가 없다면 '좀먹는 생명' 3중첩 부여
            for(let i=0; i<3; i++) addStatus('gnawingLife', 1800, 10);
            showPickupEffect(player.x, player.y, "먹을게 없군..", false, true, "gnawing-life-border");
        }

        // 3. 시각 효과 (은색 낫)
        spawnSoulHarvestSlash(player.x, player.y);
    }

        function spawnPheromoneMarker(x, y, angle, accuracy = 0, owner = null) {
    const speed = 3.2;
    pheromoneMarkers.push({
        x: x, y: y,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        radius: 15 * 1.25, 
        life: 360,
        accuracy: accuracy, // [추가]
        owner: owner,
    });
}
        
       function spawnPleasureZone(x, y, accuracy = 0, owner = null) {
    pleasureZones.push({
        x: x, y: y,
        radius: 240,
        life: 300,
        stackTimer: 0,
        accuracy: accuracy, // [추가]
        owner: owner,
    });
}

       function updatePleasureZones() {
    let inZone = false;
    for (let i = pleasureZones.length - 1; i >= 0; i--) {
        const zone = pleasureZones[i];
        zone.life--;
        
        if (zone.life <= 0) {
            pleasureZones.splice(i, 1);
            continue;
        }
        
        // [최적화] 플레이어 충돌 판정 (제곱 거리 사용)
        const dx = player.x - zone.x;
        const dy = player.y - zone.y;
        const distSq = dx * dx + dy * dy;
        const zoneRadiusSq = zone.radius * zone.radius;

        if (distSq < zoneRadiusSq) {
            player.slowedByCloud = true;
            player.defenseBroken = true; 
            inZone = true;

            let dmgPerFrame = (3 + Math.floor(score * 0.04)) / 60;
            takeDamage(dmgPerFrame, 'direct', zone.accuracy, zone);
            zone.stackTimer = (zone.stackTimer || 0) + 1;
            if (zone.stackTimer >= 30) {
                 if (!checkShieldBlockStatus()) {
                     addStatus('kiss', 900, 30);
                 }
                 zone.stackTimer = 0;
            }
        } else {
            zone.stackTimer = 0;
        }
        
        // 적들이 쾌락의 장판 위에 있을 때 발기 수치 증가
        for (let e of enemies) {
            // [최적화] 적 충돌 판정 (제곱 거리 사용)
            const edx = e.x - zone.x;
            const edy = e.y - zone.y;
            const eDistSq = edx * edx + edy * edy;
            const hitRadius = zone.radius + e.radius;

            if (eDistSq < hitRadius * hitRadius) {
                 e.passiveErectionTimer += 1.5;
                 // 자코(쫄병)가 장판 위에 있으면 분노 상태가 됨
                 if (e.isZako && !e.enraged) {
                    e.enraged = true;
                    e.enrageTimer = 60; 
                }
            }
        }
    }
    
    if (!inZone) player.defenseBroken = false;
}

        function spawnPinkGas(x, y) {
            const puffs = [];
            const puffCount = 100; // 구름 조각 개수
            for (let i = 0; i < puffCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                const dist = Math.random() * 450; // 중심에서 퍼지는 거리
                puffs.push({
                    dx: Math.cos(angle) * dist,
                    dy: Math.sin(angle) * dist,
                    r: 60 + Math.random() * 50, // 조각의 크기 (40~80)
                    scale: 0.1 // 등장 애니메이션용 스케일
            });
        }

           pinkGases.push({
                x: x, y: y,
                radius: 450, 
                life: 480,   
                alpha: 0, // 서서히 나타나도록 0부터 시작
                maxAlpha: 0.4,
                puffs: puffs 
            });
        }
        
   
        function updatePinkGases() {
    player.inPinkGas = false; // 매 프레임 초기화
    
    for (let i = pinkGases.length - 1; i >= 0; i--) {
        const g = pinkGases[i];
        g.life--;
        if (g.life <= 0) { pinkGases.splice(i, 1); continue; }

        // [최적화] 플레이어 체크 (제곱 거리)
        const dx = player.x - g.x;
        const dy = player.y - g.y;
        const distSq = dx * dx + dy * dy;
        const radiusSq = g.radius * g.radius;

        if (distSq < radiusSq) {
            player.inPinkGas = true; // 가스 안에 있음
        }

        // 적 버프 체크 (영구 적용이므로 한 번만 적용하도록 플래그 사용)
        enemies.forEach(e => {
            // [최적화] 적 거리 체크 (제곱 거리)
            const edx = e.x - g.x;
            const edy = e.y - g.y;
            const eDistSq = edx * edx + edy * edy;
            const hitRadius = g.radius + e.radius;

            if (eDistSq < hitRadius * hitRadius) {
                if (!e.hasPinkGasBuff) {
                    e.hasPinkGasBuff = true;
                    e.hpRecoveryRate = (e.hpRecoveryRate || 1) * 1.5; // 회복량 1.5배 플래그
                    e.baseSpeed *= 1.2;
                    e.speed *= 1.2;
                    showDamageText(e.x, e.y, "UP!", false, false, "heal-text");
                }
            }
        });
    }
}
      


        // ==========================================================
        // [신규] 퀘스타 '새디즘' 활성화 연출: 갈색 방구 가스 (핑크가스 스타일)
        // - 게임플레이 효과 없음(시각 연출만)
        // - sadismGasTimer가 켜져 있는 동안 10프레임마다 계속 뿜어져나옴
        // - sadismGasTimer가 꺼지거나(해제), 퀘스타가 사망하면 즉시 소멸
        // ==========================================================
        const SADISM_BROWN_GAS_RADIUS = 340; // 새디즘 방구 가스 퍼짐 반경(요청: 더 넓게)

        function spawnSadismBrownGas(x, y, owner) {
            if (!owner) return;

            // 과도한 누적 방지(성능)
            const hardCap = Math.max(18, Math.floor(((performanceState && performanceState.maxParticles) ? performanceState.maxParticles : 6000) / 350));
            if (sadismBrownGases.length >= hardCap) return;

            const puffs = [];
            const stride = (performanceState && performanceState.particleStride) ? performanceState.particleStride : 1;
            const puffCount = Math.max(40, Math.floor(80 / stride)); // 성능 상태에 따라 가볍게 조절
            for (let i = 0; i < puffCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                const dist = Math.random() * SADISM_BROWN_GAS_RADIUS; // 중심에서 퍼지는 거리(확장)
                puffs.push({
                    dx: Math.cos(angle) * dist,
                    dy: Math.sin(angle) * dist,
                    r: 55 + Math.random() * 45,
                    scale: 0.1
                });
            }

            sadismBrownGases.push({
                x: x, y: y,
                owner: owner,
                radius: SADISM_BROWN_GAS_RADIUS,
                life: 240,
                maxLife: 240,
                alpha: 0,
                maxAlpha: 0.35,
                puffs: puffs
            });
        }

        function clearSadismBrownGasesFor(owner) {
            if (!owner || sadismBrownGases.length === 0) return;
            for (let i = sadismBrownGases.length - 1; i >= 0; i--) {
                if (sadismBrownGases[i].owner === owner) {
                    sadismBrownGases.splice(i, 1);
                }
            }
        }

        function updateSadismBrownGases() {
            let inSadismGas = false;

            for (let i = sadismBrownGases.length - 1; i >= 0; i--) {
                const g = sadismBrownGases[i];

                // [요청] 퀘스타 사망/새디즘 해제 시에도, 이미 생성된 가스는 자연 소멸
                if (!g.owner) {
                    sadismBrownGases.splice(i, 1);
                    continue;
                }

                // [신규] 새디즘 가스 접촉 판정(제곱 거리)
                const dx = player.x - g.x;
                const dy = player.y - g.y;
                const distSq = dx * dx + dy * dy;
                const hitR = player.radius + g.radius;
                if (distSq < hitR * hitR) {
                    inSadismGas = true;
                }

                // 시각적인 자연 소멸
                g.life--;
                if (g.life <= 0) {
                    sadismBrownGases.splice(i, 1);
                }
            }

            // [신규] 새디즘 가스에 닿으면 30프레임마다 '가스 중독' 1중첩
            if (inSadismGas && (frameCount % 30 === 0) && player.invincibleTimer <= 0) {
                if (!checkShieldBlockStatus()) {
                    addStatus('poison', 900, 30);
                }
                // 텍스트는 과도한 출력 방지(1.5초에 1번)
                player._sadismGasMsgCD = player._sadismGasMsgCD || 0;
                if (player._sadismGasMsgCD <= 0) {
                    showPickupEffect(player.x, player.y, "가스중독!", false, true);
                    player._sadismGasMsgCD = 90;
                }
            }
            if (player._sadismGasMsgCD > 0) player._sadismGasMsgCD--;
        }

        function updateSadismGasEmitters() {
            const stride = (performanceState && performanceState.particleStride) ? performanceState.particleStride : 1;
            const interval = 60 * stride; // 요청: 60프레임마다 (렉 완화)

            for (let i = 0; i < enemies.length; i++) {
                const e = enemies[i];
                if (!e || !e.isQuesta) continue;

                // 사망 시: 즉시 "분사 중단"만 하고, 남아있던 가스는 자연 소멸
                if (e.hp <= 0) {
                    e.sadismGasTimer = 0;
                    e.sadismGasActive = false;
                    e.sadismGasSpawnTick = 0;
                    continue;
                }

                // 새디즘 연출 활성 상태
                if ((e.sadismGasTimer || 0) > 0) {
                    e.sadismGasTimer--;
                    e.sadismGasActive = true;

                    e.sadismGasSpawnTick = (e.sadismGasSpawnTick || 0) + 1;
                    if (e.sadismGasSpawnTick >= interval) {
                        e.sadismGasSpawnTick = 0;

                        // 퀘스타 주변에서 "뿜어져나오는" 느낌으로 약간 랜덤 오프셋
                        const ox = (Math.random() - 0.5) * 40;
                        const oy = (Math.random() - 0.5) * 40;
                        spawnSadismBrownGas(e.x + ox, e.y + oy, e);
                    }

                    // 타이머가 끝나면: 즉시 분사 중단(이미 뿜은 가스는 자연 소멸)
                    if ((e.sadismGasTimer || 0) <= 0) {
                        e.sadismGasActive = false;
                        e.sadismGasSpawnTick = 0;
                    }
                } else {
                    // 비활성화로 전환되면: 분사만 중단(남아있던 가스는 자연 소멸)
                    if (e.sadismGasActive) {
                        e.sadismGasActive = false;
                    }
                    e.sadismGasSpawnTick = 0;
                }
            }
        }

// ==========================================================
// [OPT] Occlusion Spool / Questa Veil / Cursed Catastrophe 캐시
// - 색감은 기존 유지, 연산만 줄임
// ==========================================================
const __optCaches = {
    occlusionDisc: new Map(),
    questaVeil: new Map(),
    cursedCat: new Map(),
    tadHead: null
};

function __hash01(n) {
    const x = Math.sin(n) * 10000;
    return x - Math.floor(x);
}

// ---- Occlusion Spool: 바닥 그라데이션 디스크 텍스처 캐시 ----
function getOcclusionSpoolDiscTex(radius) {
    const r = Math.max(10, Math.floor(radius));
    const key = r;
    const cached = __optCaches.occlusionDisc.get(key);
    if (cached) return cached;

    const c = document.createElement('canvas');
    c.width = c.height = r * 2;
    const cctx = c.getContext('2d');
    cctx.translate(r, r);

    const grad = cctx.createRadialGradient(0, 0, r * 0.2, 0, 0, r);
    // [조정] 더 진한 보라색(오클루전 스풀) - 색감 강화
    grad.addColorStop(0.0, "rgba(45, 0, 90, 0.90)");   // 중심(딥 퍼플)
    grad.addColorStop(0.55, "rgba(110, 0, 200, 0.40)"); // 중간(보라빛)
    grad.addColorStop(1.0, "rgba(0, 0, 0, 0)");         // 외곽(투명)

    cctx.fillStyle = grad;
    cctx.beginPath();
    cctx.arc(0, 0, r, 0, Math.PI * 2);
    cctx.fill();

    __optCaches.occlusionDisc.set(key, c);
    // 간단한 메모리 제한
    if (__optCaches.occlusionDisc.size > 40) __optCaches.occlusionDisc.clear();
    return c;
}

// ---- Questa Veil: 칠흑의 장막 스프라이트 캐시(12fps) ----
function getQuestaVeilSprite(size, timeKey) {
    const sizeKey = Math.max(32, Math.round(size / 4) * 4);
    const key = sizeKey + ":" + timeKey;

    const cached = __optCaches.questaVeil.get(key);
    if (cached) return cached;

    // 기존 로직 기준 최대 반경 추정: ((size/2)+35)*1.5
    const maxR = ((sizeKey / 2) + 35) * 1.5 + 12;
    const csz = Math.max(96, Math.ceil(maxR * 2));
    const c = document.createElement('canvas');
    c.width = c.height = csz;
    const cctx = c.getContext('2d');
    cctx.translate(csz / 2, csz / 2);

    // 기존 색감 유지
    cctx.shadowColor = "#4B0082";
    cctx.shadowBlur = 25;
    cctx.lineJoin = "round";

    const nowApprox = timeKey * 83; // 12fps 버킷
    const time = nowApprox / 30;

    for (let layer = 0; layer < 3; layer++) {
        cctx.strokeStyle = "black";
        // lineWidth 랜덤은 해시로 결정(색감/느낌 유지 + Math.random 제거)
        const lw = 8 + __hash01(timeKey * 13.7 + layer * 7.3) * 4;
        cctx.lineWidth = lw;

        cctx.beginPath();
        const segments = 16;
        for (let k = 0; k <= segments; k++) {
            const angle = (k / segments) * Math.PI * 2 + time + (layer * Math.PI / 3);

            const h = __hash01(timeKey * 0.91 + layer * 11.1 + k * 17.3);
            const noise = 10 + h * 25;
            const r = ((sizeKey / 2) + noise) * 1.5;

            const lx = Math.cos(angle) * r;
            const ly = Math.sin(angle) * r;
            if (k === 0) cctx.moveTo(lx, ly);
            else cctx.lineTo(lx, ly);
        }
        cctx.closePath();
        cctx.stroke();
    }

    cctx.shadowBlur = 0;

    const out = { canvas: c, size: csz };
    __optCaches.questaVeil.set(key, out);
    if (__optCaches.questaVeil.size > 60) __optCaches.questaVeil.clear();
    return out;
}

function drawQuestaVeilCached(ctx, size) {
    const stride = (performanceState && performanceState.particleStride) ? performanceState.particleStride : 1;
    const timeKey = Math.floor(Date.now() / (83 * stride));
    const spr = getQuestaVeilSprite(size, timeKey);
    ctx.drawImage(spr.canvas, -spr.size / 2, -spr.size / 2);
}

// ---- Cursed Catastrophe: 전체 스프라이트 캐시(12fps) ----
function getTadpoleHeadTex() {
    if (__optCaches.tadHead) return __optCaches.tadHead;

    const c = document.createElement('canvas');
    c.width = c.height = 64;
    const cctx = c.getContext('2d');
    cctx.translate(32, 32);

    // [수정] 검정색 정자 머리(타원형) 텍스처
    // - 기본 형태는 +X 방향을 "앞"으로 둠(그릴 때 rotate로 방향 맞춤)
    const g = cctx.createRadialGradient(12, -10, 2, 0, 0, 34);
    g.addColorStop(0, '#222');
    g.addColorStop(0.35, '#080808');
    g.addColorStop(1, '#000');

    // 메인 헤드(앞쪽이 더 넓은 타원)
    cctx.fillStyle = g;
    cctx.beginPath();
    cctx.ellipse(6, 0, 22, 16, 0, 0, Math.PI * 2);
    cctx.fill();

    // 뒤쪽(꼬리 연결부) 조금 더 좁게
    cctx.fillStyle = '#000';
    cctx.beginPath();
    cctx.ellipse(-12, 0, 14, 12, 0, 0, Math.PI * 2);
    cctx.fill();

    // 아주 얇은 외곽선(검정)
    cctx.strokeStyle = 'rgba(0, 0, 0, 0.95)';
    cctx.lineWidth = 2;
    cctx.beginPath();
    cctx.ellipse(6, 0, 22, 16, 0, 0, Math.PI * 2);
    cctx.stroke();

    __optCaches.tadHead = c;
    return c;
}

function getCursedCatastropheSprite(outerR, timeKey, stride) {
    const rKey = Math.max(15, Math.round(outerR));
    const key = rKey + ":" + timeKey + ":" + stride;
    const cached = __optCaches.cursedCat.get(key);
    if (cached) return cached;

    const coreR = rKey * 0.5;

    // 원본 기준 바깥 반경 ~ 1.2 * outerR, 여유 추가
    const sprR = Math.ceil(rKey * 1.35 + 20);
    const csz = sprR * 2;

    const c = document.createElement('canvas');
    c.width = c.height = csz;
    const cctx = c.getContext('2d');
    cctx.translate(sprR, sprR);

    // 시간 버킷(원본 Date.now 기반)
    const nowApprox = timeKey * 83 * stride;
    const time = nowApprox / 150;
    const timeTad = nowApprox / 500;

    // (1) 코어
    cctx.beginPath();
    cctx.arc(0, 0, coreR, 0, Math.PI * 2);
    cctx.fillStyle = "#1a0505";
    cctx.fill();

    // (1-1) 올챙이(헤드 스프라이트 + 꼬리)
    const headTex = getTadpoleHeadTex();

    // 원본의 개수/비용을 stride로 조절
    const baseCount = Math.max(8, Math.min(22, Math.floor(coreR * 1.2)));
    const tadpoleCount = Math.max(6, Math.floor(baseCount / stride));

    // 코어 클립
    cctx.save();
    cctx.beginPath();
    cctx.arc(0, 0, coreR, 0, Math.PI * 2);
    cctx.clip();

    for (let j = 0; j < tadpoleCount; j++) {
        const t = timeTad * 2 + j * 113.7;
        const rMax = coreR * 0.75;
        const dist = (Math.sin(t * 0.3) * 0.5 + 0.5) * rMax;
        const angle = t * 0.5 + (j * (Math.PI * 2 / 13));

        const tx = Math.cos(angle) * dist;
        const ty = Math.sin(angle) * dist;

        // 머리(텍스처) - [수정] 크기 소폭 감소 + 검정색 정자 형태
        const headBase = Math.max(2, coreR * 0.15);
        let headSize = headBase + Math.sin(t * 3) * Math.max(0.3, coreR * 0.02);
        headSize *= 0.85;

        // 정자 "앞" 방향 (머리가 바라보는 방향)
        const moveDir = angle + Math.PI / 2;

        cctx.save();
        cctx.translate(tx, ty);
        cctx.rotate(moveDir);
        const scale = headSize / 30; // 텍스처 기준(30)
        cctx.scale(scale, scale);
        cctx.drawImage(headTex, -32, -32);
        cctx.restore();

        // 꼬리 - [수정] 머리 뒤쪽에서 시작해 정자 느낌 강화
        const backOff = headSize * 0.45;
        const startX = tx - Math.cos(moveDir) * backOff;
        const startY = ty - Math.sin(moveDir) * backOff;

        const wiggle = Math.sin(t * 15) * (coreR * 0.35);
        const tailLen = Math.max(10, coreR * 1.10);
        const tailBaseAngle = moveDir + Math.PI;

        const tailEndX = startX + Math.cos(tailBaseAngle) * tailLen + Math.cos(tailBaseAngle + Math.PI / 2) * wiggle;
        const tailEndY = startY + Math.sin(tailBaseAngle) * tailLen + Math.sin(tailBaseAngle + Math.PI / 2) * wiggle;
        const cpX = (startX + tailEndX) / 2 + Math.cos(tailBaseAngle + Math.PI / 2) * (wiggle * 0.5);
        const cpY = (startY + tailEndY) / 2 + Math.sin(tailBaseAngle + Math.PI / 2) * (wiggle * 0.5);

        cctx.beginPath();
        cctx.moveTo(startX, startY);
        cctx.strokeStyle = "#000";
        cctx.lineWidth = Math.max(1.2, coreR * 0.085);
        cctx.lineCap = "round";
        cctx.quadraticCurveTo(cpX, cpY, tailEndX, tailEndY);
        cctx.stroke();
    }

    cctx.restore(); // clip 해제

    // (2) 잔털(비용 큰 부분: stride로 개수 줄임)
    const hairBaseCount = Math.min(28, Math.max(16, Math.floor(coreR / 6)));
    const hairCount = Math.max(10, Math.floor(hairBaseCount / stride));
    const baseRadius = coreR;

    cctx.strokeStyle = "#2b2b2b";
    cctx.lineWidth = Math.max(1.5, coreR * 0.02);

    for (let j = 0; j < hairCount; j++) {
        const angle = (j / hairCount) * Math.PI * 2;
        const wiggle = Math.sin(time * 2 + j * 132) * 0.5;

        const sx = Math.cos(angle) * baseRadius;
        const sy = Math.sin(angle) * baseRadius;

        const hairLen = baseRadius + Math.sin(j * 55) * (baseRadius * 0.35);
        const ex = Math.cos(angle + wiggle * 0.2) * (baseRadius + hairLen);
        const ey = Math.sin(angle + wiggle * 0.2) * (baseRadius + hairLen);

        const cp1Mod = (j % 2 === 0) ? 1 : -1;
        const cp1x = Math.cos(angle + 0.5 * cp1Mod + wiggle) * (baseRadius + hairLen * 0.4);
        const cp1y = Math.sin(angle + 0.5 * cp1Mod + wiggle) * (baseRadius + hairLen * 0.4);

        const cp2Mod = (j % 3 === 0) ? -1 : 1;
        const cp2x = Math.cos(angle - 0.5 * cp2Mod - wiggle) * (baseRadius + hairLen * 0.8);
        const cp2y = Math.sin(angle - 0.5 * cp2Mod - wiggle) * (baseRadius + hairLen * 0.8);

        cctx.beginPath();
        cctx.moveTo(sx, sy);
        cctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, ex, ey);
        cctx.stroke();
    }

    // (3) 오라(기존 유지)
    cctx.shadowBlur = Math.min(40, Math.max(10, coreR * 0.25));
    cctx.shadowColor = "#8b0000";
    cctx.strokeStyle = "rgba(139, 0, 0, 0.3)";
    cctx.lineWidth = Math.max(2, coreR * 0.03);
    cctx.beginPath();
    cctx.arc(0, 0, coreR * 1.05, 0, Math.PI * 2);
    cctx.stroke();
    cctx.shadowBlur = 0;

    const out = { canvas: c, w: csz, h: csz };
    __optCaches.cursedCat.set(key, out);
    if (__optCaches.cursedCat.size > 90) __optCaches.cursedCat.clear();
    return out;
}



        // [신규] 어둠의 음표 생성
        function spawnDarkNote(x, y, owner) {
            darkNotes.push({
                x: x, y: y,
                owner: owner, // 발사한 주체
                speed: 4,
                life: 300,
                target: null // 유도 대상
            });
        }

       function updateDarkNotes() {
    for (let i = darkNotes.length - 1; i >= 0; i--) {
        const note = darkNotes[i];
        note.life--;
        if (note.life <= 0) { darkNotes.splice(i, 1); continue; }

        // 타겟 찾기 (가장 가까운 아군) - 여기서는 거리 비교만 하므로 sqrt 생략 가능
        if (!note.target || note.target.hp <= 0) {
            let minDistSq = 9999 * 9999; // 제곱 거리로 초기화
            let newTarget = null;
            enemies.forEach(e => {
                if (e !== note.owner && e.hp > 0) {
                    const dx = e.x - note.x;
                    const dy = e.y - note.y;
                    const dSq = dx * dx + dy * dy;
                    if (dSq < minDistSq) { 
                        minDistSq = dSq; 
                        newTarget = e; 
                    }
                }
            });
            note.target = newTarget;
        }

        // 이동
        if (note.target) {
            const angle = Math.atan2(note.target.y - note.y, note.target.x - note.x);
            note.x += Math.cos(angle) * note.speed;
            note.y += Math.sin(angle) * note.speed;

            // [최적화] 충돌 (아군 힐) - 제곱 거리 사용
            const dx = note.target.x - note.x;
            const dy = note.target.y - note.y;
            const distSq = dx * dx + dy * dy;
            const hitRadiusSq = note.target.radius * note.target.radius;

            if (distSq < hitRadiusSq) {
                note.target.erectionStacks = Math.min((note.target.erectionStacks || 0) + 2, 20);
                let heal = Math.floor(note.target.maxHp * 0.15);
                heal = Math.floor(heal * (note.target.hpRecoveryRate || 1));
                note.target.hp = Math.min(note.target.maxHp, note.target.hp + heal);
                
                showDamageText(note.target.x, note.target.y, "+" + heal, false, false, "heal-text");
                showPickupEffect(note.target.x, note.target.y, "UP!!", false, false, "pink-text");
                
                darkNotes.splice(i, 1);
                continue;
            }
        } else {
            // 타겟 없으면 직진하거나 사라짐
            note.y += note.speed;
        }
    }
}

       function spawnDarkMatter(x, y, owner) {
            const angle = Math.atan2(player.y - y, player.x - x);
            darkMatters.push({
                x: x, y: y,
                vx: Math.cos(angle) * 2.9, // 느린 속도
                vy: Math.sin(angle) * 2.9,
                angle: angle,
                radius: 100,
                owner: owner,
                life: 900, // 15초
                gasTrailTimer: 0,
                accuracy: owner.accuracy
            });
            showPickupEffect(x, y - 60, "다크 매터!", false, true, "evil-purple-text");
        }

        function spawnConfessionalTotem(x, y, accuracy, owner = null) {
            confessionalTotems.push({
                x: x, y: y,
                radius: 40, // 토템 자체 크기
                range: 300, // 효과 범위
                life: 720, // 12초
                damageTimer: 0,
                accuracy: accuracy,
                owner: owner,
            });
            showPickupEffect(x, y - 60, "컨페셔너..", false, true, "corrupted-text");
        }

  function updatePheromoneMarkers() {
    for (let i = pheromoneMarkers.length - 1; i >= 0; i--) {
        const marker = pheromoneMarkers[i];
        
        // [유도 로직 최적화]
        const dx = player.x - marker.x;
        const dy = player.y - marker.y;
        
        // 유도 계산을 위해 거리가 필요하지만, 매 프레임 정확할 필요가 없다면
        // 일정 거리 이내일 때만 정밀 유도하거나 할 수 있습니다. 
        // 여기서는 기존 로직 유지하되 안전장치 추가
        const distSq = dx * dx + dy * dy;
        
        if (distSq > 0) {
            const dist = Math.sqrt(distSq); // 유도 벡터 정규화를 위해 필요
            const homingStrength = 0.06;
            const currentSpeed = Math.sqrt(marker.vx * marker.vx + marker.vy * marker.vy);
            
            marker.vx += (dx / dist) * homingStrength * currentSpeed;
            marker.vy += (dy / dist) * homingStrength * currentSpeed;
            
            // 속도 재정규화
            const newSpeedSq = marker.vx * marker.vx + marker.vy * marker.vy;
            const newSpeed = Math.sqrt(newSpeedSq);
            marker.vx = (marker.vx / newSpeed) * currentSpeed;
            marker.vy = (marker.vy / newSpeed) * currentSpeed;
        }

        marker.x += marker.vx;
        marker.y += marker.vy;
        marker.life--;

        if (marker.life <= 0 || marker.x < -100 || marker.x > canvas.width + 100 || marker.y < -100 || marker.y > canvas.height + 100) {
            pheromoneMarkers.splice(i, 1);
            continue;
        }

        // ★ [최적화] 충돌 체크 (제곱 거리 사용)
        const hitRadius = player.radius + marker.radius;
        if (distSq < hitRadius * hitRadius) {
            if (player.invincibleTimer <= 0) {
                let dmg = 18 + Math.floor(score * 0.19);
                takeDamage(dmg, 'direct', marker.accuracy, marker);
                showPickupEffect(player.x, player.y, "수컷의 냄새♥", false, true, "pink-text");
                
                enemies.forEach(e => {
                    if (e.isZako) {
                        e.enraged = true;
                        e.enrageTimer = 600; 
                    }
                });
                pheromoneMarkers.splice(i, 1);
            }
        }
    }
}
        
        function updateExcaliburSlashes() {
    for (let i = excaliburSlashes.length - 1; i >= 0; i--) {
        const s = excaliburSlashes[i];
        s.x += s.vx;
        s.y += s.vy;
        s.life--;

        if (s.life <= 0 || s.x < -200 || s.x > canvas.width + 200 || s.y < -200 || s.y > canvas.height + 200) {
            excaliburSlashes.splice(i, 1);
            continue;
        }

        if (frameCount % 2 === 0) {
            slashTrails.push({
                x: s.x + (Math.random()-0.5)*40,
                y: s.y + (Math.random()-0.5)*40,
                radius: 20 + Math.random() * 10,
                life: 40,
                maxLife: 40,
                dx: (Math.random() - 0.5) * 2,
                dy: (Math.random() - 0.5) * 2
            });
        }

        // ★ [최적화] 제곱 거리 비교
        const dx = player.x - s.x;
        const dy = player.y - s.y;
        const distSq = dx * dx + dy * dy;
        const hitRadius = player.radius + s.radius;

        if (!s.hasHit && distSq < hitRadius * hitRadius) {
            if (player.invincibleTimer <= 0) {
                let dmg = 28 + Math.floor(score * 0.24);
                takeDamage(dmg, 'direct', s.accuracy, s);
                for(let k=0; k<2; k++) addStatus('fatalScar', 1800, 10);
                showPickupEffect(player.x, player.y, "페이탈 스칼!", false, true, "fatal-scar-border");
                
                s.hasHit = true;
            }
        }
    }
}
        // [신규] 연기 궤적 업데이트
function updateSlashTrails() {
    for (let i = slashTrails.length - 1; i >= 0; i--) {
        const t = slashTrails[i];
        t.x += t.dx;
        t.y += t.dy;
        t.radius *= 0.95; // 점점 작아짐
        t.life--;
        if (t.life <= 0) slashTrails.splice(i, 1);
    }
}

function updateFloatingTexts() {
    const MAX_FLOATING_TEXTS = performanceState.maxFloatingTexts; // 최대 개수 (성능에 따라 조절)

    // [최적화] 제한 개수를 넘으면 한 번에 여러 개 정리 (여유분 5개까지 포함해서 삭제)
    // 매 프레임 splice를 호출하는 것을 방지합니다.
    if (floatingTexts.length > MAX_FLOATING_TEXTS) {
        const removeCount = (floatingTexts.length - MAX_FLOATING_TEXTS) + 5;
        floatingTexts.splice(0, removeCount);
    }

    // 텍스트가 너무 많으면 수명 감소 속도를 가속 (렉 방지)
    const decayRate = (floatingTexts.length > 30) ? 2 : 1;

    for (let i = floatingTexts.length - 1; i >= 0; i--) {
        let ft = floatingTexts[i];
        
        ft.y += ft.vy; 
        ft.vy *= 0.95;

        ft.life -= decayRate;
        
        // 수명이 다하면 제거
        if (ft.life <= 0) {
            floatingTexts.splice(i, 1);
        }
    }
}

    function drawFloatingTexts() {
    ctx.save();
    
    // 공통 스타일 미리 설정 (루프 밖)
    ctx.shadowBlur = 0;
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.lineWidth = 3;

    let lastFont = ""; // [최적화] 마지막으로 설정한 폰트 기억

    for (let i = 0; i < floatingTexts.length; i++) {
        const ft = floatingTexts[i];
        
        // 투명도 계산
        const alpha = Math.max(0, ft.life / ft.maxLife);
        
        // [최적화] 거의 보이지 않는 텍스트는 그리기 연산 스킵
        if (alpha < 0.05) continue; 

        ctx.globalAlpha = alpha;
        
        // [최적화] 폰트 문자열 생성 비용은 어쩔 수 없지만, 
        // ctx.font 대입(무거운 연산)은 값이 다를 때만 수행
        const currentFont = `bold ${ft.size}px 'Black Han Sans', sans-serif`;
        
        if (lastFont !== currentFont) {
            ctx.font = currentFont;
            lastFont = currentFont;
        }
        
        // 좌표 소수점 제거 (렌더링 선명도 향상 및 미세한 성능 이득)
        const drawX = Math.floor(ft.x);
        const drawY = Math.floor(ft.y);

        // 테두리
        ctx.strokeStyle = ft.borderColor;
        ctx.strokeText(ft.text, drawX, drawY);
        
        // 글자
        ctx.fillStyle = ft.color;
        ctx.fillText(ft.text, drawX, drawY);
    }

    ctx.restore();
}

        function spawnHollowNight(x, y, accuracy = 0, owner = null) {
    // [최적화] 중첩 하드캡 (오라가 여러 개 겹치면 급격히 무거워짐)
    if (hollowNight.length >= 2) hollowNight.shift();
    hollowNight.push({
        x: x, y: y,
        radius: 144, 
        life: 1200, 
        angle: 0,
        cooldown: 0,
        accuracy: accuracy, // [추가]
        owner: owner,
    });
    showPickupEffect(x, y - 80, "할로우 나이트!", false, false, "hollow-night-text");
}
        
        function triggerEvilLight(sourceEnemy) {
            darknessOverlay.style.opacity = 1;
            setTimeout(() => { darknessOverlay.style.opacity = 0; }, 500);

            updateMaxHealth();
            showPickupEffect(player.x, player.y - 40, "사악한 빛..", false);
            
            showPickupEffect(player.x, player.y, "이 세상에 어둠을..", false, true, "wicked-large-text");
            
            addStatus('evilLight', 999999, 9999);
            
            if (sourceEnemy) {
                sourceEnemy.appliedEvilLightCount = (sourceEnemy.appliedEvilLightCount || 0) + 1;
            }

            if (player.shieldStacks > 0) {
                player.shieldStacks = Math.floor(player.shieldStacks / 2);
            }
            if (player.justiceShield > 0) {
                player.justiceShield = Math.floor(player.justiceShield / 2);
            }
            updateStatusUI();
        }

        function spawnWhiteShot(x, y, isElite, isZako, extraStacks = 0, isLucaShot = false, accuracy = 0, owner = null) {
            const angle = Math.atan2(player.y - y, player.x - x);
            const speed = 1.5; 
            let radius = 30;
            if (isElite) radius = 45; if (isZako) radius = 16;
            whiteshots.push({ 
                x: x, y: y, 
                vx: Math.cos(angle) * speed, 
                vy: Math.sin(angle) * speed, 
                radius: radius, 
                life: 400, 
                isZako: isZako, 
                isElite: isElite, 
                extraStacks: extraStacks,
                isLucaShot: isLucaShot,
                accuracy: accuracy, // [신규]
                owner: owner,
            });
        }
       function spawnPoop(startX, startY, isEliteOrOptions, isZako = false, isGreen = false, accuracy = 0, owner = null) {
            const options = (typeof isEliteOrOptions === 'object' && isEliteOrOptions !== null)
                ? isEliteOrOptions
                : { isElite: !!isEliteOrOptions, isZako, isGreen, accuracy, owner, sizeMult: 1 };

            const angle = Math.atan2(player.y - startY, player.x - startX);

            // ------------------------------------------------------------
            // [PATCH] Poop 개체별 이동속도 랜덤/가변 지원
            //  - 기본: baseSpeed(=2) * speedMult(기본 1)
            //  - speedMin/speedMax가 있으면 개체마다 랜덤 배율 적용 (권장)
            //  - speedJitter(예: 0.25)만 있으면 ±jitter 범위로 흔들림
            // ------------------------------------------------------------
            const baseSpeed = 2;
            const speedMult = (options.speedMult != null) ? options.speedMult : 1;

            let randMult = 1;
            if (options.speedMin != null && options.speedMax != null) {
                randMult = options.speedMin + Math.random() * (options.speedMax - options.speedMin);
            } else if (options.speedJitter != null) {
                const j = options.speedJitter;
                randMult = 1 + ((Math.random() * 2 - 1) * j);
            } else if (options.speedRand != null) {
                randMult = options.speedRand;
            }

            const speed = baseSpeed * speedMult * randMult;

            let radius = 18;
            if (options.isElite) radius = 36;
            if (options.isZako) radius = 9;
            if (options.isGreen) radius = 10;
            radius *= (options.sizeMult || 1);

            poops.push({
                x: startX, y: startY,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed,
                radius: radius,
                rotation: Math.random() * Math.PI * 2,
                isElite: !!options.isElite,
                isZako: !!options.isZako,
                isGreen: !!options.isGreen,
                life: 600,
                accuracy: options.accuracy || 0,
                owner: options.owner || null,
            });
        }function spawnHomingBigPoop(x, y, accuracy = 0, owner = null) {
    bigPoops.push({ x: x, y: y, radius: 52.5, life: 360, isHoming: true, vx: 0, vy: 0, accuracy: accuracy, owner: owner });
}
       function spawnHomingSemen(x, y, accuracy = 0, owner = null) {
    homingSemens.push({ x: x, y: y, radius: 52.5, life: 360, isHoming: true, vx: 0, vy: 0, accuracy: accuracy, owner: owner });
}
        function spawnGas(x, y, isElite, isZako, extraStacks = 0, sizeMult = 1, accuracy = 0, owner = null) {
            let radius = 50;
            let maxRadius = 150; 
            if (isElite) { radius = 70; maxRadius = 210; } 
            if (isZako) { radius = 35; maxRadius = 120; } 
            radius *= sizeMult;
            maxRadius *= sizeMult;
            gases.push({ 
                x: x, y: y, radius: radius, maxRadius: maxRadius, 
                alpha: 0.8, growth: 0.5 * sizeMult, life: 300, 
                isElite: isElite, isZako: isZako, extraStacks: extraStacks,
                accuracy: accuracy, // [신규]
                owner: owner,
            });
        }
       function spawnDarkGas(x, y, sizeMult = 1.0, damageMult = 1.0, accuracy = 0, explosionDamage = 0, owner = null) {
    let radius = 20 * sizeMult;
    let maxRadius = 140 * sizeMult;
    
    darkGases.push({ 
        x: x, 
        y: y, 
        radius: radius, 
        maxRadius: maxRadius, 
        alpha: 0.8, 
        growth: 0.5 * sizeMult, 
        life: 300,
        damageMult: damageMult,
        accuracy: accuracy,// [신규]
        owner: owner,
        
        // [추가] 가스가 다 커졌을 때 터질 데미지와 폭발 여부 저장
        pendingDamage: explosionDamage,
        hasExploded: false
    });
}

// [NEW] DarkGas trail variant (purely visual, lightweight)
function spawnDarkGasTrail(x, y, sizeMult = 0.6, owner = null, damageMult = 0.85, accuracy = 0) {
    // Mini real DarkGas for Evil Arrow trail: deals damage + applies darkScent, but kept short/small for performance.
    // Soft cap to prevent runaway perf drops when many effects exist.
    if (darkGases.length > 240) return;

    const radius = 11 * sizeMult;
    const maxRadius = 78 * sizeMult;

    darkGases.push({
        x: x,
        y: y,
        radius: radius,
        maxRadius: maxRadius,
        alpha: 0.72,
        growth: 0.75 * sizeMult,
        life: 150,
        lifeMax: 150,

        // Gameplay effects (real darkgas)
        damageMult: damageMult,
        accuracy: accuracy,
        owner: owner,

        pendingDamage: 0,
        hasExploded: true,

        // Draw optimizations
        simpleDraw: true,
        isEvilTrail: true
    });
}

      function spawnExcaliburSlash(x, y, angle, accuracy = 0, owner = null) {
    excaliburSlashes.push({
        x: x, y: y,
        vx: Math.cos(angle) * 8, 
        vy: Math.sin(angle) * 8,
        angle: angle,
        radius: 90,
        life: 180,
        hasHit: false,
        accuracy: accuracy, // [추가]
        owner: owner,
    });
}
       function spawnBigPoop(x, y, accuracy = 0, owner = null) {
    bigPoops.push({ x: x, y: y, radius: 60, life: 480, accuracy: accuracy, owner: owner });
}
        function spawnPoopStain(x, y) {
            let puffs = [];
            for(let i=0; i<8; i++) { 
                puffs.push({
                    dx: (Math.random() - 0.5) * 60,
                    dy: (Math.random() - 0.5) * 60,
                    r: 20 + Math.random() * 20
                });
            }
            poopStains.push({ x: x, y: y, radius: 45, life: 420, puffs: puffs }); 
        }

       function spawnDeathCloud(x, y, isElite, isBoss, accuracy = 0, owner = null) {
            let r = 125;
            if (isElite) r = 175; if (isBoss) r = 275; 
            deathClouds.push({ x: x, y: y, radius: r, life: 240, accuracy: accuracy , owner: owner});
        }

       function spawnPianissimoSnipe(x, y, angle, accuracy = 0, owner = null) {
        pianissimoSnipes.push({
        x: x,
        y: y,
        state: 'charging', // charging(생성중) -> firing(발사)
        chargeTimer: 0,
        chargeMax: 360,    // 6초 동안 서서히 진해짐
        alpha: 0,          // 투명도 0에서 시작
        vx: 0,
        vy: 0,
        radius: 30,        // 크기
        accuracy: accuracy,
        owner: owner,
        life: 300          // 발사 후 수명 5초
    });
}
       // [신규] 프리즘 스윕 생성
        function spawnPrismSweep(x, y, accuracy, owner = null) {
            // 하늘에서 생성되므로 y는 화면 위쪽이나 타겟 근처 위
            prismSweeps.push({
                x: x, y: y - 300, // 위에서 시작
                targetY: y,       // 목표 고도
                life: 1080,       // 18초
                laserTimer: 0,
                colors: ['black', 'purple', 'red'], // 3색
                accuracy: accuracy,
                owner: owner,
            });
            showPickupEffect(player.x, player.y - 100, "프리즘♥", false, true, "wicked-large-text");
        }

        // [신규] 프리즘 스윕 업데이트
        function updatePrismSweeps() {
            for (let i = prismSweeps.length - 1; i >= 0; i--) {
                const p = prismSweeps[i];
                p.life--;
                
                // 등장 애니메이션 (부드럽게 내려옴)
                if (p.y < p.targetY) p.y += 2;
                else if (p.y > p.targetY) p.y -= 2;
                // 레이저 발사 로직 (매 프레임 레이저 유도 및 판정)
                // 레이저는 플레이어 위치로 천천히 유도됨
                const dx = player.x - p.x;
                const dy = player.y - p.y;
                const dist = Math.hypot(dx, dy);
                
                // 프리즘 자체의 이동
                p.x += (dx / dist) * 4.3; 
                p.targetY += (dy / dist) * 4.3;

                // 레이저 발사 (60프레임마다 피격 판정)
                p.laserTimer++;
                if (p.laserTimer >= 60) {
                    p.laserTimer = 0;
                    // 플레이어가 프리즘 아래(레이저 범위)에 있는지 확인 (수직 박스 판정)
                    if (Math.abs(player.x - p.x) < 40) { // 레이저 폭
                        if (player.invincibleTimer <= 0) {
                            let dmg = 18 + Math.floor(score * 0.12);
                            takeDamage(dmg, 'direct', p.accuracy, p);
                            
                            const color = p.colors[Math.floor(Date.now() / 6000) % 3];
                            if (color === 'black') {
                                addStatus('blind', 900, 10);
                                showPickupEffect(player.x, player.y, "실명..", false, true, "darkness-border");
                            } else if (color === 'purple') {
                                addStatus('curse', 900, 10);
                                showPickupEffect(player.x, player.y, "저주..", false, true, "curse-border");
                            } else if (color === 'red') {
                                addStatus('bleeding', 1800, 20);
                                showPickupEffect(player.x, player.y, "출혈..", false, true, "bleeding-border");
                            }
                        }
                    }
                }           
                if (p.life <= 0) prismSweeps.splice(i, 1);
            }
        }

function spawnGasExplosionPattern(accuracy = 0, owner = null) {
    const corners = [
        {x: 50, y: 50}, 
        {x: canvas.width - 50, y: 50},
        {x: canvas.width - 50, y: canvas.height - 50},
        {x: 50, y: canvas.height - 50} 
    ];
    
    const centerX = canvas.width / 2;
    const centerY = canvas.height / 2;
    const speed = 4.0; 

    corners.forEach(pos => {
        const angle = Math.atan2(centerY - pos.y, centerX - pos.x);
        
        movingGases.push({
            x: pos.x,
            y: pos.y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            radius: 180, // 이동 중 크기
            life: 300,
            centerX: centerX,
            centerY: centerY,
            accuracy: accuracy,
            owner: owner,
        });
    });

    showPickupEffect(player.x, player.y - 100, "똥방구 모이는 중...♥", false, true, "wicked-large-text");
}

        // [신규] 오클루전 스풀 생성
        function spawnOcclusionSpool(accuracy, owner = null) {
            const margin = 100;
            const x = margin + Math.random() * (canvas.width - margin * 2);
            const y = margin + Math.random() * (canvas.height - margin * 2);
            
            occlusionSpools.push({
                x: x, y: y,
                radius: SADISM_BROWN_GAS_RADIUS, // 볼륨감 있는 번개 필드 크기
                life: 600,   // 10초
                tickTimer: 0,
                accuracy: accuracy,
                owner: owner,
            });
            showPickupEffect(x, y, "찌릿찌릿..", false, true, "evil-purple-text");
        }
       // [신규] 오클루전 스풀 업데이트
        function updateOcclusionSpools() {
            for (let i = occlusionSpools.length - 1; i >= 0; i--) {
                const s = occlusionSpools[i];
                s.life--;
                
                const dx = player.x - s.x;
                const dy = player.y - s.y;
                const distSq = dx * dx + dy * dy;
                const rSq = s.radius * s.radius;
                if (distSq < rSq) {
                    // 번개 접촉 시 효과
                    s.tickTimer++;
                    if (s.tickTimer >= 120) { // 120프레임(2초)마다
                        s.tickTimer = 0;
                        if (player.invincibleTimer <= 0) {
                            // 1. 기절 0.5초 (18프레임)
                            player.stunTimer = 30;
                            // 2. 데미지
                            let dmg = 9 + Math.floor(score * 0.17);
                            takeDamage(dmg, 'direct', s.accuracy, s);
                            // 3. 차광 디버프
                            addStatus('shading', 600, 1); 
                            showPickupEffect(player.x, player.y, "차광! (치명타 저항 감소)", false, true, "shading-border");
                        }
                    }
                } else {
                    s.tickTimer = 100; // 범위 밖이면 타이머 리셋하되, 재진입시 빨리 맞게 설정
                }

                if (s.life <= 0) occlusionSpools.splice(i, 1);
            }
        }
        
        // [신규] 플레이어 출혈 도트 데미지 처리 (게임 루프에서 호출)
        function updatePlayerBleeding() {
            if (player.bleedingTimers.length > 0) {
                // 프레임당 데미지: 0.005 * 중첩 수
                let dotDmg = 0.005 * player.bleedingTimers.length;
                if (player.health > 0) {
                    player.health -= dotDmg;
                    if (player.health <= 0) gameOver();
                }
            }
            // 타이머 감소
            for (let i = player.bleedingTimers.length - 1; i >= 0; i--) {
                player.bleedingTimers[i]--;
                if (player.bleedingTimers[i] <= 0) player.bleedingTimers.splice(i, 1);
            }
            // 차광 타이머 감소
            for (let i = player.shadingTimers.length - 1; i >= 0; i--) {
                player.shadingTimers[i]--;
                if (player.shadingTimers[i] <= 0) player.shadingTimers.splice(i, 1);
            }
            
            // 차광 효과: 공격자 기준 크리로 전환됨 (피격 취약은 takeDamage에서 defenderCritResist 감소로 처리)
            // ※ 여기서 player.critChance를 덮어쓰지 않음
}
       // [신규] 데스메탈 크레센도 투사체 생성
        function spawnDeathMetalNote(x, y, angle, owner) {
            deathMetalNotes.push({
                x: x, y: y,
                vx: Math.cos(angle) * 7.5,
                vy: Math.sin(angle) * 7.5,
                radius: 200,
                owner: owner,
                life: 420, // 7초 (벽에 닿을 때까지라 충분히 김)
                draggingPlayer: false // 플레이어 납치 여부
            });
            showPickupEffect(x, y - 40, "크레센도!", false, true, "evil-purple-text");
        }

        // [신규] 데스메탈 크레센도 업데이트
        function updateDeathMetalNotes() {
            for (let i = deathMetalNotes.length - 1; i >= 0; i--) {
                const note = deathMetalNotes[i];
                note.x += note.vx;
                note.y += note.vy;
                note.life--;

                // 벽 충돌 체크
                const hitWall = note.x < 0 || note.x > canvas.width || note.y < 0 || note.y > canvas.height;
                
                if (hitWall || note.life <= 0) {
                    if (note.draggingPlayer) {
                        // 벽 충돌 시 데미지 및 디버프
                        let dmg = 30 + Math.floor(score * 0.3);
                        takeDamage(dmg, 'direct', note.owner.accuracy, note.owner);
                        addStatus('confusion', 300, 1); // 정신착란 5초
                        showPickupEffect(player.x, player.y, "정신착란!", false, true, "confusion-border");
                    }
                    deathMetalNotes.splice(i, 1);
                    continue;
                }

                // 플레이어 충돌 체크 (납치)
                if (!note.draggingPlayer) {
                    const dx = player.x - note.x;
                    const dy = player.y - note.y;
                    const distSq = dx*dx + dy*dy;
                    if (distSq < (player.radius + note.radius)**2) {
                        if (player.invincibleTimer <= 0) {
                            note.draggingPlayer = true;
                            showPickupEffect(player.x, player.y, "잡힘!", false, true, "weak-text");
                        }
                    }
                }

                // 플레이어 드래그 처리
                if (note.draggingPlayer) {
                    player.x = note.x;
                    player.y = note.y;
                    player.stunTimer = 2; // 이동 불가하게 기절 유지
                }
            }
        }

        function spawnDarknessSpotlight(x, y, owner) {
    // owner가 있으면 owner.radius를 사용하고, 없으면 기본값 80 사용
    const baseRadius = owner ? owner.radius : 80;
    
    darknessSpotlights.push({
        x: x,
        y: y,
        radius: baseRadius * 2.5, // [수정] 테토라 크기의 2.5배로 설정
        life: 720, 
        owner: owner,
        tickTimer: 0,
        angle: 0 
    });
}

        // [신규] 다크니스 스포트라이트 업데이트
        function updateDarknessSpotlights() {
            for (let i = darknessSpotlights.length - 1; i >= 0; i--) {
                const spot = darknessSpotlights[i];
                
                // [수정] 테토라(owner)에게 부착되어 함께 움직이도록 좌표 동기화
        if (spot.owner && spot.owner.hp > 0) {
            spot.x = spot.owner.x;
            spot.y = spot.owner.y;
            
            // [추가] 테토라가 커지면(발기 스택 등) 장판 크기도 같이 커지도록 동기화
            if (spot.owner.radius) {
                spot.radius = spot.owner.radius * 2.5;
            }
        } else {
                    // 주인이 죽으면 스포트라이트도 소멸
                    spot.life = 0;
                }

                spot.life--;
                spot.angle += 0.02; // 마법진 회전
                spot.tickTimer++;
                
                if (spot.life <= 0) {
                    darknessSpotlights.splice(i, 1);
                    continue;
                }

                // 180프레임마다 효과 발동
                if (spot.tickTimer >= 180) {
                    spot.tickTimer = 0;
                    // 아군(적)에게 발기 스택 부여
                    enemies.forEach(e => {
                        if (e === spot.owner) return;
                        const dx = e.x - spot.x;
                        const dy = e.y - spot.y;
                        if (dx*dx + dy*dy < spot.radius**2) {
                            e.erectionStacks = Math.min((e.erectionStacks || 0) + 1, 20);
                            showDamageText(e.x, e.y, "UP", false, false, "pink-text");
                        }
                    });
                }

                // 플레이어가 안에 있으면 치명타 저항 감소 (매 프레임 체크하면 너무 빠르니 60프레임마다)
                if (frameCount % 60 === 0) {
                    const dx = player.x - spot.x;
                    const dy = player.y - spot.y;
                    if (dx*dx + dy*dy < spot.radius**2) {
                        const hadShading = player.shadingTimers.length > 0;
                        addStatus('shading', 600, 1);
                        if (!hadShading) {
                            showPickupEffect(player.x, player.y, "차광! (치명타 저항 감소)", false, true, "shading-border");
                        }
                    }
                }
            }
        }

       function spawnMindSkull(x, y, accuracy = 0, owner = null) {
    const angle = Math.atan2(player.y - y, player.x - x);
    let speed = 2.5; 
    if (owner && owner.isBoss && owner.bossType === 3) {
        const randomSpeeds = [1.2, 1.8, 2.5, 3.5, 4.5];
        speed = randomSpeeds[Math.floor(Math.random() * randomSpeeds.length)];
    }
    mindSkulls.push({
        x: x, y: y,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        radius: 20,
        angle: angle,
        speed: speed,
        life: 400,
        isScatter: false,
        accuracy: accuracy, // [추가]
        owner: owner,
    });
}
       function spawnMindSkullScatter(x, y, accuracy = 0, owner = null) {
    const count = 8;
    const speed = 2.0;
    for (let i = 0; i < count; i++) {
        const angle = (Math.PI * 2 * i) / count;
        mindSkulls.push({
            x: x,
            y: y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            radius: 20,
            angle: angle,
            speed: speed,
            life: 400,
            isScatter: true,
            accuracy: accuracy, // [추가]
            owner: owner,
        });
    }
}
        function spawnItemLoop() { 
              if (!isGameRunning) return;
              if (isLevelUpPaused) {
                itemSpawnTimeout = setTimeout(spawnItemLoop, 100);
                return;
            }
              const nextSpawnTime = 3000 + Math.random() * 3000; itemSpawnTimeout = setTimeout(() => { spawnItem(); spawnItemLoop(); }, nextSpawnTime); }
        function spawnItem() {
            const margin = 50; const rand = Math.random(); let type = 'health';
            if (rand < 0.04) type = 'magnet';
            else if (rand < 0.23) type = 'health'; 
            else if (rand < 0.42) type = 'berserk';
            else if (rand < 0.61) type = 'white';
            else if (rand < 0.80) type = 'shield';
            else type = 'justice';

            const item = { x: margin + Math.random() * (canvas.width - margin * 2), y: margin + Math.random() * (canvas.height - margin * 2), radius: 15, type: type, life: 2100 };
            items.push(item);
        }
        function spawnDroppedItem(x, y, type) { 
            const item = { x: x, y: y, radius: 15, type: type, life: 2100 }; 
            items.push(item); 
        }
       function updateCardSelection() {
            const cards = document.querySelectorAll('.upgrade-card');
            cards.forEach((card, index) => {
                if (index === selectedCardIndex) {
                    card.classList.add('selected');
                } else {
                    card.classList.remove('selected');
                }
            });
        }
        const cardContainerEl = document.getElementById('cardContainer');
        if (cardContainerEl) {
            const observer = new MutationObserver((mutations) => {
                mutations.forEach((mutation) => {
                    if (mutation.addedNodes.length > 0) {
                        // 카드가 추가되면 0번 인덱스 선택 및 하이라이트
                        selectedCardIndex = 0;
                        setTimeout(updateCardSelection, 10);
                    }
                });
            });
            observer.observe(cardContainerEl, { childList: true });
        }
       window.addEventListener('keydown', (e) => { 
            // 1. 레벨업 모달이 떠있을 때 (일시정지 상태) -> 카드 선택 모드
            if (isLevelUpPaused) {
                const cards = document.querySelectorAll('.upgrade-card');
                if (cards.length === 0) return;

                if (e.code === 'ArrowLeft') {
                    // 왼쪽 이동 (0번보다 작아지면 마지막 카드로)
                    selectedCardIndex = (selectedCardIndex - 1 + cards.length) % cards.length;
                    updateCardSelection();
                } else if (e.code === 'ArrowRight') {
                    // 오른쪽 이동
                    selectedCardIndex = (selectedCardIndex + 1) % cards.length;
                    updateCardSelection();
                } else if (e.code === 'Space' || e.code === 'Enter') {
                    // 스페이스바 또는 엔터로 선택
                    if (cards[selectedCardIndex]) {
                        cards[selectedCardIndex].click(); // 클릭 이벤트 트리거
                    }
                }
                return; // 게임 조작 키 입력 방지
            }

            // 2. 평상시 게임 플레이 조작
            if (keys.hasOwnProperty(e.code)) keys[e.code] = true;
            if (e.code === 'KeyQ') activateGoddessProtection(); 
            if (e.code === 'KeyW') activateSacredFaith();
            if (e.code === 'KeyE') activateLimitFocus();
            if (e.code === 'KeyA') activateNova();
            if (e.code === 'Space') activateDivineDash();
        });

        window.addEventListener('keyup', (e) => { if (keys.hasOwnProperty(e.code)) keys[e.code] = false; });
        window.addEventListener('touchstart', (e) => { isTouching = true; touchStart.x = e.touches[0].clientX; touchStart.y = e.touches[0].clientY; touchCurrent.x = touchStart.x; touchCurrent.y = touchStart.y; }, {passive: false});
        window.addEventListener('touchmove', (e) => { e.preventDefault(); if (isTouching) { touchCurrent.x = e.touches[0].clientX; touchCurrent.y = e.touches[0].clientY; } }, {passive: false});
        window.addEventListener('touchend', () => { isTouching = false; });

        function activateGoddessProtection() {
            if (player.goddessSkill.cooldown > 0 || player.skillSealTimer > 0) return;
            if (player.despairTimer > 0) {
                if (Math.random() < 0.5) {
                    player.goddessSkill.cooldown = player.goddessSkill.maxCooldown; // 쿨타임 적용
                    updateGoddessSkillUI();
                    showPickupEffect(player.x, player.y - 60, "절망..", false, true, "weak-text");
                    return; // 스킬 발동 중단
                }
            }

            player.poisonTimers = [];
            player.poopPoisonTimers = [];
            player.maliceTimers = [];
            player.kissTimers = [];
            player.semenTimers = [];
            player.oralTimers = [];
            player.byururutTimers = [];
            player.blindTimers = []; 
            player.darknessTimers = [];

            player.fishyTimers = [];
            // [수정] 아서 전용 디버프 해제 불가
            // player.trueAncestorKissTimers = [];
            // player.fatalScarTimers = [];
            // player.corruptedBloodTimers = [];
            
            // const hadEvilMind = player.evilMindTimers.length > 0;
            // player.evilMindTimers = [];
            // if (hadEvilMind) updateMaxHealth();
            
            player.goddessSkill.cooldown = player.goddessSkill.maxCooldown;
            let healAmount = player.maxHealth * (0.0025 * level);
            player.health = Math.min(player.maxHealth, player.health + healAmount);
            showDamageText(player.x, player.y, "+" + Math.floor(healAmount), false, false, "heal-text");

            showPickupEffect(player.x, player.y - 60, "성스러운 힘이여!", false, true, "goddess-text");
            updateStatusUI();
            updatePoopVisual();
        }

        function activateSacredFaith() {
            if (player.sacredFaithSkill.cooldown > 0 || player.skillSealTimer > 0) return;
            if (player.despairTimer > 0) {
                if (Math.random() < 0.5) {
                    // 쿨타임만 적용되고 효과는 발동 안 함
                    player.sacredFaithSkill.cooldown = player.sacredFaithSkill.maxCooldown;
                    updateSacredFaithUI();
                    showPickupEffect(player.x, player.y - 60, "절망..", false, true, "weak-text");
                    return;
                }
            }
            player.sacredFaithSkill.cooldown = player.sacredFaithSkill.maxCooldown;
            player.sacredFaithSkill.activeTimer = player.sacredFaithSkill.duration;

            showPickupEffect(player.x, player.y - 60, "믿음이 충만해진다!", false, true, "goddess-text");
            
            sacredFaithOverlay.style.opacity = 0.5;
            setTimeout(() => { sacredFaithOverlay.style.opacity = 0; }, 500);

            updateSacredFaithUI();
        }

        function activateLimitFocus() {
            if (player.limitFocusSkill.cooldown > 0 || player.skillSealTimer > 0) return;
            if (player.despairTimer > 0) {
                if (Math.random() < 0.5) {
                    player.limitFocusSkill.cooldown = player.limitFocusSkill.maxCooldown;
                    updateLimitFocusUI();
                    showPickupEffect(player.x, player.y - 60, "절망..", false, true, "weak-text");
                    return;
                }
            }
            player.limitFocusSkill.cooldown = player.limitFocusSkill.maxCooldown;
            player.limitFocusSkill.activeTimer = player.limitFocusSkill.duration;

            showPickupEffect(player.x, player.y - 60, "한계 집중!", false, true, "hyper-border"); // 이펙트
            
            // UI 즉시 갱신
            updateLimitFocusUI();
        }

        function activateNova() {
            if (player.novaSkill.cooldown > 0 || player.skillSealTimer > 0) return;
            if (player.despairTimer > 0) {
                if (Math.random() < 0.5) {
                    player.novaSkill.cooldown = player.novaSkill.maxCooldown;
                    updateNovaUI();
                    showPickupEffect(player.x, player.y - 60, "절망..", false, true, "weak-text");
                    return;
                }
            }
            player.novaSkill.cooldown = player.novaSkill.maxCooldown;
            
            shockwaves.push({
                x: player.x,
                y: player.y,
                radius: 10,
                speed: 15,
                alpha: 1.0,
                fade: 0.05
            });
            showPickupEffect(player.x, player.y - 60, "꺼져라!!", false, true, "block-text");

            enemies.forEach(e => {
                const dist = Math.hypot(e.x - player.x, e.y - player.y);
                
                if (dist < player.novaSkill.range || e.isAttached) {
                    
                    if (e.isAttached) {
                        e.isAttached = false;
                        e.attachTimer = 0; // 즉시 재부착 방지를 위한 쿨타임 (필요 시 값을 늘리세요)
                    }

                    // 밀어낼 방향 계산
                    // 적이 플레이어와 완전히 겹쳐있을 경우(붙잡힌 상태 등)를 대비해 각도 계산
                    let angle = Math.atan2(e.y - player.y, e.x - player.x);
                    
                    e.x += Math.cos(angle) * player.novaSkill.pushPower;
                    e.y += Math.sin(angle) * player.novaSkill.pushPower;
                    
                    // [요청 사항] 기절 2초 적용
                    let stunDuration = 120;
                    
                    // 보스나 엘리트는 기절 시간을 절반(0.5초)으로 줄이는 기존 로직 유지 (원치 않으면 제거 가능)
                    if (e.isBoss || e.isElite) {
                        stunDuration = 60;
                        showDamageText(e.x, e.y, "소용없다..", false, false, "weak-text"); 
                    }
                    let finalStunDuration = stunDuration + (level * 6);
                    let finalDamage = 30 + (level * 3);
                    // 기절 타이머 적용
                    if (e.stunTimer < finalStunDuration) e.stunTimer = finalStunDuration;
                    
                    e.hp -= finalDamage;
                    e.hitFlash = 5;
                    showDamageText(e.x, e.y, "PUSH!", true);
                }
            });
            updateNovaUI();
        }

        function updateGoddessSkillUI() {
            if (player.goddessSkill.cooldown > 0) {
                const percent = (player.goddessSkill.cooldown / player.goddessSkill.maxCooldown) * 100;
                goddessCooldownOverlay.style.height = percent + '%';
                goddessCooldownText.style.display = 'block';
                goddessCooldownText.innerText = Math.ceil(player.goddessSkill.cooldown / 60);
            } else {
                goddessCooldownOverlay.style.height = '0%';
                goddessCooldownText.style.display = 'none';
            }
            
            // 봉인 오버레이
            if (player.skillSealTimer > 0) {
                goddessSealOverlay.style.display = 'flex';
            } else {
                goddessSealOverlay.style.display = 'none';
            }
        }

        function updateSacredFaithUI() {
            if (player.sacredFaithSkill.cooldown > 0) {
                const percent = (player.sacredFaithSkill.cooldown / player.sacredFaithSkill.maxCooldown) * 100;
                sacredFaithCooldownOverlay.style.height = percent + '%';
                sacredFaithCooldownText.style.display = 'block';
                sacredFaithCooldownText.innerText = Math.ceil(player.sacredFaithSkill.cooldown / 60);
            } else {
                sacredFaithCooldownOverlay.style.height = '0%';
                sacredFaithCooldownText.style.display = 'none';
            }
            
             // 봉인 오버레이
            if (player.skillSealTimer > 0) {
                sacredFaithSealOverlay.style.display = 'flex';
            } else {
                sacredFaithSealOverlay.style.display = 'none';
            }
        }
        
        function updateNovaUI() {
            if (player.novaSkill.cooldown > 0) {
                const percent = (player.novaSkill.cooldown / player.novaSkill.maxCooldown) * 100;
                novaCooldownOverlay.style.height = percent + '%';
                novaCooldownText.style.display = 'block';
                novaCooldownText.innerText = Math.ceil(player.novaSkill.cooldown / 60);
            } else {
                novaCooldownOverlay.style.height = '0%';
                novaCooldownText.style.display = 'none';
            }
            
             // 봉인 오버레이
            if (player.skillSealTimer > 0) {
                novaSealOverlay.style.display = 'flex';
            } else {
                novaSealOverlay.style.display = 'none';
            }
        }

            function updateLimitFocusUI() {
            // 쿨타임 오버레이 처리
            if (player.limitFocusSkill.cooldown > 0) {
                const percent = (player.limitFocusSkill.cooldown / player.limitFocusSkill.maxCooldown) * 100;
                limitFocusCooldownOverlay.style.height = percent + '%';
                limitFocusCooldownText.style.display = 'block';
                limitFocusCooldownText.innerText = Math.ceil(player.limitFocusSkill.cooldown / 60);
            } else {
                limitFocusCooldownOverlay.style.height = '0%';
                limitFocusCooldownText.style.display = 'none';
            }
            
            // 지속시간 표시 (아이콘 테두리가 반짝이거나 활성 상태 표시)
            if (player.limitFocusSkill.activeTimer > 0) {
                 limitFocusImg.style.border = "3px solid #00FFFF"; // 활성화 시 청록색 테두리
            } else {
                 limitFocusImg.style.border = "none";
            }

            // 봉인 오버레이
            if (player.skillSealTimer > 0) {
                limitFocusSealOverlay.style.display = 'flex';
            } else {
                limitFocusSealOverlay.style.display = 'none';
            }
        }

       function activateDivineDash() {
    if (player.divineDashSkill.cooldown > 0 || player.skillSealTimer > 0 || player.dashTimer > 0 || player.stunTimer > 0 || player.rootTimer > 0) return;

    let reducedCooldown = 900 - (level * 18);
    if (reducedCooldown < 420) reducedCooldown = 420;

    if (player.despairTimer > 0) {
        if (Math.random() < 0.5) {
            player.divineDashSkill.cooldown = reducedCooldown; // 계산된 쿨타임 적용
            updateDivineDashUI();
            showPickupEffect(player.x, player.y - 60, "절망..", false, true, "weak-text");
            return;
        }
    }

    let dx = 0, dy = 0;
    if (keys.ArrowUp) dy = -1;
    if (keys.ArrowDown) dy = 1;
    if (keys.ArrowLeft) dx = -1;
    if (keys.ArrowRight) dx = 1;

    // 모바일 터치 대응
    if (isTouching) {
        const touchDx = touchCurrent.x - touchStart.x;
        const touchDy = touchCurrent.y - touchStart.y;
        const distance = Math.hypot(touchDx, touchDy);
        if (distance > 10) {
            dx = touchDx / distance;
            dy = touchDy / distance;
        }
    }

    // 이동 입력이 없으면 현재 캐릭터(무기)가 바라보는 방향으로 돌진
    if (dx === 0 && dy === 0) {
        dx = Math.cos(player.weapon.angle);
        dy = Math.sin(player.weapon.angle);
    } else {
        // 벡터 정규화 (대각선 속도 일정하게)
        const len = Math.hypot(dx, dy);
        if (len > 0) {
            dx /= len;
            dy /= len;
        }
    }

    // 돌진 상태 설정
    player.dashTimer = player.divineDashSkill.duration;
    player.dashVx = dx * player.divineDashSkill.speed;
    player.dashVy = dy * player.divineDashSkill.speed;

    player.divineDashSkill.cooldown = reducedCooldown; 
    
    player.invincibleTimer = player.divineDashSkill.duration; // 돌진 시간 동안 무적
    showPickupEffect(player.x, player.y - 60, "천상의 도약!", false, true, "block-text");
    updateDivineDashUI();
}

        // [신규] 천상의 도약 UI 업데이트 함수
        function updateDivineDashUI() {
            if (player.divineDashSkill.cooldown > 0) {
                const percent = (player.divineDashSkill.cooldown / player.divineDashSkill.maxCooldown) * 100;
                divineDashCooldownOverlay.style.height = percent + '%';
                divineDashCooldownText.style.display = 'block';
                divineDashCooldownText.innerText = Math.ceil(player.divineDashSkill.cooldown / 60);
            } else {
                divineDashCooldownOverlay.style.height = '0%';
                divineDashCooldownText.style.display = 'none';
            }
            
            if (player.skillSealTimer > 0) {
                divineDashSealOverlay.style.display = 'flex';
            } else {
                divineDashSealOverlay.style.display = 'none';
            }
        }

        function performAttack() {
            if (player.weapon.isAttacking) return;
            player.weapon.isAttacking = true; player.weapon.attackTimer = 15;
            let angle = player.weapon.angle; if (player.vx !== 0 || player.vy !== 0) { angle = Math.atan2(player.vy, player.vx); }
            player.weapon.baseAngle = angle; 
            checkWeaponCollision(angle, false);
            checkWeaponCollision(angle + Math.PI, true);
        }

        function checkWeaponCollision(faceAngle, isRear = false) {
    const range = player.weapon.length + 30;
    let baseDamage = player.weapon.damage;
    if (isRear) {
        baseDamage = baseDamage * 0.75;
    }

    let finalDamage = baseDamage;
    if (player.baptismStacks > 0) {
        finalDamage *= (1 - (player.baptismStacks * 0.15));
    }
    if (player.darkSeedTimers.length > 0) {
        finalDamage *= (1 - (player.darkSeedTimers.length * 0.02));
    }
    
    const darkReceiverMultiplier = 1 + (player.darkReceiverTimers.length * 0.02);
    const attackArc = (Math.PI / 2) * 0.9375;

    let missChance = (player.blindTimers.length * 0.05) + (player.evilLightTimers.length > 0 ? 0.05 : 0) + (player.deepDarknessStacks * 0.1) - player.bonusAccuracy;
    if (player.limitFocusSkill.activeTimer > 0) {
        missChance -= (0.05 + (level * 0.0015));
    }

    for (const enemy of enemies) {
        if (enemy.isAttached) continue;
        const dx = enemy.x - player.x; const dy = enemy.y - player.y; const dist = Math.hypot(dx, dy);
        const angleToEnemy = Math.atan2(dy, dx);
        let angleDiff = angleToEnemy - faceAngle; while (angleDiff <= -Math.PI) angleDiff += Math.PI*2;
        while (angleDiff > Math.PI) angleDiff -= Math.PI*2;
        
        const hitByWeapon = dist < range + enemy.radius && Math.abs(angleDiff) < attackArc;
        let hitByBody = false;
        if (!isRear) {
            hitByBody = dist < player.radius + enemy.radius + 15;
        }

        if (hitByWeapon || hitByBody) {
            // 기존 카이 은신 판정
            if (enemy.isKai && enemy.isInvisible) {
                showDamageText(enemy.x, enemy.y, "MISS (은신)", false, false, "weak-text");
                continue; 
            }

            // [추가됨] 검은 민족 카이토 은신 판정
            if (enemy.isKaito && enemy.isKaitoStealth) {
                showDamageText(enemy.x, enemy.y, "MISS (은신)", false, false, "weak-text");
                continue;
            }

            if (enemy.isQuesta && enemy.isFlickering) {
                finalDamage *= 0.75; // 받는 데미지 25% 감소 (즉, 75% 받음)
            }
            if (enemy.isMasakuni && enemy.moveDashDuration > 0) {
                 finalDamage *= 0.5; // 데미지 50% 감소
            }

            // [수정] 적 고유 회피율 적용
            let enemyEvasion = enemy.evasion || 0;

            // [신규] 생존 시간(초) 기반 적 회피 증가
            enemyEvasion += (score / 10) * 0.007;

                    if (enemy.erectionStacks > 0) {
                        let evaPerStack = 0.005 + (score / 15000);
                        let stackBonus = enemy.erectionStacks * evaPerStack;
                        let timeBonus = (score / 10) * 0.005;
                        enemyEvasion += (stackBonus + timeBonus);
                    }

                    if (player.semenTimers.length > 0) {
                        enemyEvasion += (player.semenTimers.length * 0.005);
                    }
                    
                    if (enemy.gawainSanctuaryCount > 0) {
                        enemyEvasion += (0.05 * enemy.gawainSanctuaryCount);
                    }
                    
                    if (activeAkiCount > 0) {
                         enemyEvasion += (0.02 * activeAkiCount);
                    }

                    // [신규] 기절 중인 적은 회피가 50% 감소
                    if (enemy.stunTimer > 0) enemyEvasion *= 0.5;
                    
                   if (hitByWeapon && (Math.random() < (missChance + enemyEvasion))) {
                           showDamageText(enemy.x, enemy.y, "MISS!", false, false, "crit-text");
                        if (enemy.isMasakuni) {
                            enemy.nextAttackCrit = true;
                            showDamageText(enemy.x, enemy.y - 40, "심안 발동!", false, false, "masakuni-text");
                        }

                    if (enemy.isQuesta) {
                            // 쉐도우 위빙: 회피 시 3.5배 다크가스
                            spawnDarkGas(enemy.x, enemy.y, 4, 1.0, enemy.accuracy, 0, enemy);
                            showPickupEffect(enemy.x, enemy.y - 40, "곁에서 뿌우욱♥", false, true, "shadow-text");
                        }

                        continue; 
                    }

                    if (enemy.hasShield) {
                        enemy.hasShield = false;
                        showDamageText(enemy.x, enemy.y, "BLOCKED!", false);
                        showPickupEffect(enemy.x, enemy.y - 40, "쉴드 방어!", false, false, "block-text");
                        continue;
                    }

                    // [신규] 악마의 보호: 데미지 분산 로직
                    if (enemy.isBoss && enemy.protectionTarget && enemy.protectionTarget.hp > 0) {
                        finalDamage *= 0.5;
                        let redirectDmg = (player.weapon.damage * 0.25);
                        enemy.protectionTarget.hp -= redirectDmg;
                        showDamageText(enemy.protectionTarget.x, enemy.protectionTarget.y, "대신 맞음! -" + Math.floor(redirectDmg), false, false, "weak-text");
                    }

                    if (enemy.isKai && enemy.soulLinkTarget && enemy.soulLinkTarget.hp > 0 && !enemy.shadowSwapCharging) {
                        showDamageText(enemy.x, enemy.y, "IMMUNE", false, false, "block-text");
                        continue; 
                    }

                    let totalDefense = (enemy.defense || 0);
                    
                    if (enemy.isTetora) {
                         const reduction = Math.min(0.25, enemy.allyCount * 0.025);
                         finalDamage *= (1 - reduction);
                    }

                    // [수정] 발기 상태일 때만
                    if (enemy.erectionStacks > 0) {
                        let defensePerStack = 0.3 + (score / 200);
                        let stackBonus = enemy.erectionStacks * defensePerStack;
                        let timeBonus = (score / 25);
                        totalDefense += (stackBonus + timeBonus);
                    }
                    
                    totalDefense *= darkReceiverMultiplier;

                    // [신규] 기절 중인 적은 방어가 50% 감소
                    if (enemy.stunTimer > 0) totalDefense *= 0.5;

                    let actualDamage = finalDamage - totalDefense;
                    actualDamage = Math.floor(actualDamage);
                    if (actualDamage < 1) actualDamage = 1;

                    if (enemy.isTaro && enemy.isTransparent) {
                        actualDamage *= 0.5;
                        showDamageText(enemy.x, enemy.y, "뎀감..", false); 
                    } else if (enemy.isStealth && enemy.alpha < 0.9) {
                        actualDamage *= 0.75;
                    }
                    
                    if (enemy.isAmbush && enemy.ambushState === 'ambush' && enemy.normalType === 'rapist') {
                         actualDamage *= 0.75;
                    }

                    if (enemy.isZako && enemy.state === 'pouncing') {
                        actualDamage *= 0.5;
                    }

                    let enemyCritResist = (enemy.critResist || 0);
                    const tetora = enemies.find(e => e.isTetora && e.hp > 0);
                    if (tetora && tetora.currentSong === 'requiem' && tetora.songTimer > 0 && enemy !== tetora) {
                       totalDefense *= 1.2; 
                       enemyCritResist *= 1.2; 
                    }
                    // [수정] 발기 상태일 때만
                    if (enemy.erectionStacks > 0) {
                        let resistPerStack = 0.5 + (score / 150);
                        let stackBonus = enemy.erectionStacks * resistPerStack;
                        let timeBonus = (score / 10); // 10점당 치명타 저항 확률 1
                        enemyCritResist += (stackBonus + timeBonus);
                    }
                    
                    let attackerCritChance = (player.critChance || 0);
                    if (player.limitFocusSkill.activeTimer > 0) {
                      enemyCritResist = (enemyCritResist * 0.7) - (level * 0.25);
                      attackerCritChance = attackerCritChance * 1.3;
                    }

                    if (activeAkiCount > 0) {
                        enemyCritResist += (activeAkiCount * 5);
                    }

                    const critChance = Math.max(0, Math.min(100, attackerCritChance - enemyCritResist));
                    let isCrit = false;
                    
                    if (Math.random() * 100 < critChance) {
                        actualDamage *= (player.critDamageMultiplier || 1.5);
                        isCrit = true;
                    }

                    actualDamage = Math.floor(actualDamage);
                    if (actualDamage < 1) actualDamage = 1;

                    // [신규] 카이 그림자 스왑 차지 보호막: HP보다 먼저 깎임
                    if ((enemy.shadowSwapShield || 0) > 0) {
                        const blocked = Math.min(enemy.shadowSwapShield, actualDamage);
                        enemy.shadowSwapShield -= blocked;
                        actualDamage -= blocked;

                        showDamageText(enemy.x, enemy.y, "BLOCK " + blocked, false, false, "block-text");

                        // 보호막 파괴로 차지 취소(즉시)
                        if (enemy.shadowSwapShield <= 0 && enemy.shadowSwapCharging) {
                            enemy.shadowSwapCharging = false;
                            enemy.shadowSwapChargeTimer = 0;
                            enemy.shadowSwapShield = 0;
                            enemy.shadowSwapShieldMax = 0;
                            enemy.shadowSwapTimer = 0; // 쿨타임 재시작
                            showPickupEffect(enemy.x, enemy.y - 60, "보호막 파괴! 스왑 취소", false, true, "dirty-pink-text");
                        }
                    }

                    if ((enemy.antiPassingShield || 0) > 0) {
                        const blocked = Math.min(enemy.antiPassingShield, actualDamage);
                        enemy.antiPassingShield -= blocked;
                        actualDamage -= blocked;

                        showDamageText(enemy.x, enemy.y, "BLOCK " + blocked, false, false, "block-text");

                        if (enemy.antiPassingShield <= 0 && enemy.antiPassingCharging) {
                            enemy.antiPassingCharging = false;
                            enemy.antiPassingChargeTimer = 0;
                            enemy.antiPassingShield = 0;
                            enemy.antiPassingShieldMax = 0;
                            enemy.antiPassingTentacleSpawnTimer = 0;
                            enemy.antiPassingTimer = 0;
                            showPickupEffect(enemy.x, enemy.y - 60, "보호막 파괴! 안티 패싱 취소", false, true, "poop-text");
                        }
                    }

                    if (actualDamage > 0) {
                        enemy.hp -= actualDamage; 
                        enemy.hitFlash = 5; 
                        showDamageText(enemy.x, enemy.y, actualDamage, isCrit, isRear);
                    }


                    // [신규] 기절 확률: 적 상태이상 저항과 상쇄
                    const baseStunChance = player.bonusStunChance || 0;
                    const resist = enemy.statusResist || 0;
                    let effectiveStunChance = baseStunChance - resist;
                    if (effectiveStunChance > 0) {
                        effectiveStunChance = Math.max(0, Math.min(1, effectiveStunChance));
                        if (Math.random() < effectiveStunChance) {
                            // 무기 타격 기절: 발동 시 0.75초 고정
                            const stunFrames = Math.max(1, Math.floor(0.75 * 60)); // 45프레임
                            enemy.stunTimer = Math.max(enemy.stunTimer || 0, stunFrames);
                        }
                    }

                    let knockbackPower = 10;
                    if (enemy.isBoss) knockbackPower *= 0.1; 
                    else if (enemy.isElite) knockbackPower *= 0.3;

                    if (!enemy.isSuperArmor) { 
                        const pushAngle = Math.atan2(enemy.y - player.y, enemy.x - player.x);
                        enemy.x += Math.cos(pushAngle) * knockbackPower;
                        enemy.y += Math.sin(pushAngle) * knockbackPower;
                    } else {
                        showDamageText(enemy.x, enemy.y, "SUPER ARMOR", false, false, "block-text");
                    }
                } 
            }
        }

     function updateGeoptalHeal() {
    if (player.geoptalCount > 0 && frameCount % 120 === 0) {
        let baseHeal = 2 + Math.floor(score * 0.04);
        for (let e of enemies) {
            if (e.hp > 0) {
                let healAmount = (baseHeal * player.geoptalCount) * (e.hpRecoveryRate || 1);
                healAmount = Math.floor(healAmount);
                
                // [수정] 최대 체력을 넘지 않도록 제한
                e.hp = Math.min(e.maxHp, e.hp + healAmount); 
                
                showDamageText(e.x, e.y, "+" + healAmount, false, false, 'heal-text');
            }
        }
    }
}

        // [신규] 새디즘 판정에 사용: 상태이상까지 반영한 '최종 치명타 저항'
        const SADISM_CRITRESIST_THRESHOLD = 0;
        const SADISM_LIFESTEAL_RATIO = 0.3;  


        // [신규] 새디즘 활성화 연출(시각효과): 갈색 방구 가스 지속 타이머
        // - 새디즘 회복이 한 번이라도 발동하면 시작
        // - 새디즘이 다시 발동하면 타이머가 갱신됨
        // - 타이머가 끝나거나(해제), 퀘스타가 사망하면 분사만 중단(이미 나온 가스는 자연 소멸)
        const SADISM_GAS_DURATION_FRAMES = 360; // 60fps 기준 6초

        function activateSadismGas(owner) {
            if (!owner) return;
            owner.sadismGasTimer = SADISM_GAS_DURATION_FRAMES; // 발동 시 항상 갱신
            owner.sadismGasSpawnTick = owner.sadismGasSpawnTick || 0;
            owner.sadismGasActive = true;
        }

        function getEffectiveDefenderCritResist() {
            let defenderCritResist = player.critResist;

            // takeDamage()의 크리 판정과 동일한 '피격 취약' / 가스 / 낙인 / 버프 반영
            defenderCritResist -= (player.dangerousJudgmentStacks * 10);
            defenderCritResist -= (player.corruptedOathStacks * 10);

            if (player.fractureTimers.length > 0) {
                defenderCritResist -= (player.fractureTimers.length * 5);
            }
            if (player.inPinkGas) {
                defenderCritResist *= 0.5;
            }
            if (player.deathBrandTimers.length > 0) {
                defenderCritResist *= 0.5;
            }
            if (player.shadingTimers.length > 0) {
                defenderCritResist -= 15;
            }
            if (player.trueAncestorKissTimers.length > 0) {
                defenderCritResist -= (player.trueAncestorKissTimers.length * 3);
            }
            if (player.fatalScarTimers.length > 0) {
                defenderCritResist -= (player.fatalScarTimers.length * 3);
            }
            if (player.sacredFaithSkill && player.sacredFaithSkill.activeTimer > 0) {
                let sfBonus = 5 + (level * 0.25);
                defenderCritResist += (sfBonus * 2);
            }
            return defenderCritResist;
        }


        
       function takeDamage(amount, type = 'direct', accuracy = 0, attacker = null) {
            if (player.invincibleTimer > 0) return;
            
            if (type === 'direct') {
                let effectiveAccuracy = accuracy;

                 let totalEvasion = 0.02 + (player.bonusEvasion || 0);
                // [수정] 플레이어 기절 중: **총 회피(기본 2% 포함) 50% 감소**
                if (player.stunTimer > 0) totalEvasion *= 0.5;

                let dodgeChance = totalEvasion - effectiveAccuracy;
             if (player.deathBrandTimers.length > 0) {
                 dodgeChance *= 0.5;
            }
                if (Math.random() < dodgeChance) {
                    showDamageText(player.x, player.y, "DODGE", false, false, "weak-text");
                    return;
                }
            }

            // [신규] 더럽혀진 피: 받는 데미지 증가 (도트딜 제외)
            let damageMultiplier = 1;
            if (type === 'direct' && player.corruptedBloodTimers.length > 0) {
                damageMultiplier += (player.corruptedBloodTimers.length * 0.025);
            }

            const curseMultiplier = 1;
            let currentDefense = player.defenseBroken ? 0 : player.defense;
            // [신규] 플레이어 기절 중: 방어 50% 감소
            if (player.stunTimer > 0) currentDefense *= 0.5;
            let finalAmount = amount * curseMultiplier * damageMultiplier;
            
            let attackerCritChance = 0;
            if (attacker) {
                // attacker가 투사체/장판 등이고 critChance가 없으면 owner의 critChance를 사용
                let src = attacker;
                if (src.critChance == null && src.owner) src = src.owner;
                if (src && src.critChance == null && src.owner) src = src.owner;
                attackerCritChance = (src && src.critChance != null) ? src.critChance : 0;
            }
            let defenderCritResist = player.critResist;
            // 공격자 기준 크리: attackerCritChance - defenderCritResist
            // (타락한 맹세/차광/진조의 키스 등은 '피격 취약'이므로 defenderCritResist를 깎는다)
            defenderCritResist -= (player.dangerousJudgmentStacks * 10);
            defenderCritResist -= (player.corruptedOathStacks * 10);
            if (player.fractureTimers.length > 0) {
                defenderCritResist -= (player.fractureTimers.length * 5);
            }
            if (player.inPinkGas) {
                defenderCritResist *= 0.5;
            }
            // [신규] 죽음의 낙인: 치명타 저항 확률 50% 감소
            if (player.deathBrandTimers.length > 0) {
                defenderCritResist *= 0.5;
            }
            // [신규] 차광: (피격) 치명타 저항 확률 감소
            if (player.shadingTimers.length > 0) {
                defenderCritResist -= 15;
            }
            // [신규] 진조의 키스: (피격) 치명타 저항 확률 감소
            if (player.trueAncestorKissTimers.length > 0) {
                defenderCritResist -= (player.trueAncestorKissTimers.length * 3);
            }
             // [신규] 페이탈 스칼: 치명타 저항 확률 감소
            if (player.fatalScarTimers.length > 0) {
                defenderCritResist -= (player.fatalScarTimers.length * 3);
            }

            if (player.sacredFaithSkill.activeTimer > 0) {
                let sfBonus = 5 + (level * 0.25);
                // 기존 효과(치확 -sfBonus, 저항 +sfBonus) = net을 2*sfBonus만큼 낮춤
                defenderCritResist += (sfBonus * 2);
            }
            let isCriticalHit = false;
if (type === 'direct') {
                const critChance = Math.max(0, Math.min(100, attackerCritChance - defenderCritResist));
        if (player.pheromoneOverloadTimer > 0 || Math.random() * 100 < critChance) {
            finalAmount *= 1.5;
            isCriticalHit = true;
        }

        // [신규] 페로몬 오버로드 해제 로직 (크리티컬 3회 피격 시)
        if (player.pheromoneOverloadTimer > 0 && isCriticalHit) {
            player.pheromoneOverloadCritCount = (player.pheromoneOverloadCritCount || 0) + 1;

            // UI 갱신(즉시)
            updatePheromoneOverloadUI();

            // 3회 이상 크리티컬을 받으면 즉시 해제
            if (player.pheromoneOverloadCritCount >= 3) {
                endPheromoneOverload();
                showPickupEffect(player.x, player.y - 80, "오버로드 해제!", false, true, "heal-text");
            }
        }

finalAmount -= currentDefense;
    }
            
            if (finalAmount < 0) finalAmount = 0;
            player.health -= finalAmount; if (player.health < 0) player.health = 0; updateHealthUI();

            // [신규] 적이 플레이어에게 '크리티컬'을 준 경우에만 (숫자) 데미지 텍스트 표시
            if (isCriticalHit) {
                const dmgText = Math.floor(finalAmount);
                if (dmgText > 0) {
                    showDamageText(player.x, player.y - (player.radius || 0) - 40, dmgText, true, false, "player-crit-text");
                }
            }

            
            let color = '101, 67, 33';
            if (player.poisonTimers.length > 0 || player.darkScentTimers.length > 0) color = '0, 100, 0';
            if (player.poopPoisonTimers.length > 0 || player.darkSmellTimers.length > 0) color = '139, 69, 19';
            if (player.kissTimers.length > 0 || player.darkKissTimers.length > 0) color = '255, 20, 147';
            if (player.curseTimers.length > 0) color = '75, 0, 130'; 
            if (player.evilLightTimers.length > 0) color = '50, 0, 50';
            if (player.maliceTimers.length > 0) color = '128, 0, 128'; 
            if (player.corruptedBloodTimers.length > 0) color = '139, 0, 0';

            // [최적화] 데미지 오버레이는 히트마다 setTimeout을 쌓지 않고,
            //           애니메이션 루프에서 1프레임 1회만 감쇠 처리
            const strongHit = finalAmount > 0.1;
            damageFlashColor = color;
            damageFlashAlpha = strongHit ? 0.6 : 0.3;
            const targetOpacity = strongHit ? (0.5 + (Math.random() * 0.3)) : 0.1;
            if (targetOpacity > damageFlashOpacity) damageFlashOpacity = targetOpacity;
            damageFlashDirty = true;
if (player.health <= 0) gameOver();
        }

        function processStatusTimers(timers) {
             // [최적화] filter로 새 배열을 매번 만들지 않고, 제자리(in-place)로 만료 타이머 제거
             let expiredCount = 0;
             const prevLen = timers.length;
             let write = 0;

             for (let i = 0; i < prevLen; i++) {
                 const t = timers[i] - 1;
                 if (t > 0) {
                     timers[write++] = t;
                 } else {
                     expiredCount++;
                 }
             }

             if (write !== prevLen) timers.length = write;

             return {
                 active: timers,
                 changed: expiredCount > 0,
                 expired: expiredCount
             };
        }

        function updatePlayer() {
            player.slowedByCloud = false; 

            // 데스 클라우드 감속은 이동 계산 전에 즉시 판정해야 확실히 반영됨
            for (let i = deathClouds.length - 1; i >= 0; i--) {
                const cloud = deathClouds[i];
                const dxCloud = player.x - cloud.x;
                const dyCloud = player.y - cloud.y;
                const hitRadius = player.radius + cloud.radius;
                if ((dxCloud * dxCloud + dyCloud * dyCloud) < hitRadius * hitRadius) {
                    player.slowedByCloud = true;
                    break;
                }
            }

            if (player.stunTimer > 0) {
                player.stunTimer--;
            }
            // =================================================================
        // [신규] 카인: 페로몬 오버로드 로직
        // =================================================================
        // 카인이 살아있는지 확인
        const cainExists = enemies.some(e => e.isBoss && !e.isArthur && !e.isArchdemon && e.hp > 0);
        
        if (cainExists) {
            // 디버프 스택 총합 계산 (향기, 똥내, 씨앗, 키스, 좆집)
            const overloadStacks = player.darkScentTimers.length + 
                                   player.darkSmellTimers.length + 
                                   player.darkSeedTimers.length + 
                                   player.darkKissTimers.length + 
                                   player.darkReceiverTimers.length;

            // 발동 조건: 30스택 이상이고 아직 발동 안 했을 때
            if (overloadStacks >= 30 && player.pheromoneOverloadTimer <= 0) {
                player.pheromoneOverloadTimer = 600; // 10초 (60fps 기준)
                player.pheromoneOverloadCritCount = 0;
                updatePheromoneOverloadUI();
                pheromoneOverloadStatus.style.display = 'flex';

                // 1. 모든 액티브 스킬 쿨타임 10초 증가
                player.goddessSkill.cooldown += 600;
                player.sacredFaithSkill.cooldown += 600;
                player.limitFocusSkill.cooldown += 600;
                player.novaSkill.cooldown += 600;
                player.divineDashSkill.cooldown += 600;
                
                // UI 갱신
                updateGoddessSkillUI();
                updateSacredFaithUI();
                updateLimitFocusUI();
                updateNovaUI();
                updateDivineDashUI();

                showPickupEffect(player.x, player.y - 80, "페로몬 오버로드!!!", false, true, "boss-warning-text");
            }
        } else {
            // 카인 사망 시 즉시 해제
            if (player.pheromoneOverloadTimer > 0) {
                endPheromoneOverload();
                showPickupEffect(player.x, player.y - 80, "오버로드 해제!(카인 사망)", false, true, "heal-text");
            }
        }

        // 페로몬 오버로드 상태 관리
        if (player.pheromoneOverloadTimer > 0) {
            player.pheromoneOverloadTimer--;

            // 10초 경과로 타이머가 끝났으면 즉시 해제
            if (player.pheromoneOverloadTimer <= 0) {
                endPheromoneOverload();
                showPickupEffect(player.x, player.y - 80, "오버로드 해제!(시간)", false, true, "heal-text");
            } else {
                // 2. 화면에 bloodOverlay 강제 적용
                bloodOverlay.style.opacity = 0.8;

                pheromoneOverloadStatus.style.display = 'flex';
                updatePheromoneOverloadUI();
            }
        } else {
            // 타이머 종료 시 오버레이 복구 (다른 효과와 겹치지 않게 0으로)
            if (bloodOverlay.style.opacity > 0 && !player.majestyActive && player.corruptedBloodTimers.length === 0) {
                 // 서서히 사라지게 하거나 즉시 0 (여기선 자연스럽게 두기 위해 놔둠, 필요시 0 대입)
                 // bloodOverlay.style.opacity = 0; 
            }
            pheromoneOverloadStatus.style.display = 'none';
        }

        // =================================================================
        // [신규] 아키토: 다크니스 오버휠름 로직
        // =================================================================
        // 아키토가 살아있는지 확인 (archdemonName에 '아키토' 포함)
        const akitoExists = enemies.some(e => e.isArchdemon && e.archdemonName.includes('아키토') && e.hp > 0);
        
        if (akitoExists) {
            player.darknessOverwhelmActive = true;
            darknessOverwhelmStatus.style.display = 'flex';
        } else {
            player.darknessOverwhelmActive = false;
            darknessOverwhelmStatus.style.display = 'none';
        }

            // [신규] 스킬 봉인 타이머
            if (player.skillSealTimer > 0) {
                player.skillSealTimer--;
                if (player.skillSealTimer <= 0) {
                    skillSealOverlay.style.display = 'none';
                    showPickupEffect(player.x, player.y - 60, "스킬 봉인 해제!", false, true, "heal-text");
                }
                updateGoddessSkillUI();
                updateSacredFaithUI();
                updateNovaUI();
                updateLimitFocusUI();
                updateDivineDashUI();
            }

            // [신규] 속박(마비 10중첩) 처리
            if (player.rootTimer > 0) {
                player.rootTimer--;
                if (player.rootTimer <= 0) {
                    showPickupEffect(player.x, player.y - 40, "속박 해제", false, false, "heal-text");
                }
            }
            
            // [신규] 군주의 위엄 효과: 쿨타임 회복 속도 25% 감소
            let cooldownRecovery = 1.0;
            if (player.majestyActive) {
                cooldownRecovery *= 0.75;
            }
            // 타락한 정의 효과
            if (player.corruptedJusticeStacks > 0) {
                cooldownRecovery -= (player.corruptedJusticeStacks * 0.25);
            }
            if (cooldownRecovery < 0.1) cooldownRecovery = 0.1;

            if (player.goddessSkill.cooldown > 0) {
                player.goddessSkill.cooldown -= cooldownRecovery; 
                updateGoddessSkillUI();
            }

            if (player.sacredFaithSkill.activeTimer > 0) {
                player.sacredFaithSkill.activeTimer--;
                if (player.sacredFaithSkill.activeTimer <= 0) {
                }
            }
            if (player.sacredFaithSkill.cooldown > 0) {
                player.sacredFaithSkill.cooldown -= cooldownRecovery;
                updateSacredFaithUI();
            }
            
            if (player.novaSkill.cooldown > 0) {
                player.novaSkill.cooldown -= cooldownRecovery;
                updateNovaUI();
            }

            if (player.divineDashSkill.cooldown > 0) {
                player.divineDashSkill.cooldown -= cooldownRecovery;
                updateDivineDashUI();
            }

            if (player.limitFocusSkill.activeTimer > 0) {
                player.limitFocusSkill.activeTimer--;
                if(player.limitFocusSkill.activeTimer <= 0) {
                    showPickupEffect(player.x, player.y - 60, "집중 종료", false);
                }
            }

            if (player.limitFocusSkill.cooldown > 0) {
                player.limitFocusSkill.cooldown -= cooldownRecovery;
                updateLimitFocusUI();
            } else if (player.limitFocusSkill.activeTimer > 0) {
                 updateLimitFocusUI();
            }

            if (frameCount % 120 === 0 && player.regen > 0 && player.health > 0) {
    let regenAmount = player.regen;
            if (player.serumContaminationTimers && player.serumContaminationTimers.length > 0) {
                    regenAmount = 0;
                }

    // (선택 사항) 각종 회복 감소 디버프 적용
    if (player.gnawingLifeTimers.length > 0) {
        regenAmount *= (1 - player.gnawingLifeTimers.length * 0.03);
    }
    if (player.majestyActive) {
        regenAmount *= 0.9;
    }

    if (regenAmount > 0) {
        player.health = Math.min(player.maxHealth, player.health + regenAmount);
        updateHealthUI();
      }
  }

            if (frameCount % 1200 === 0 && frameCount > 0) {
                player.weapon.baseDamage += 0.7;
                player.baseMaxHealth += 3;
                player.baseCritChance += 0.5;
                if(player.critChance < player.baseCritChance) player.critChance = player.baseCritChance;
                updateMaxHealth();

                player.weapon.damage = player.weapon.baseDamage; 
            }

            // [수정 위치 3] 시간이 지남에 따라 증가하는 방어력
            if (frameCount % 1200 === 0 && frameCount > 0) {
                player.defense += 0.7; // 이 숫자를 수정하여 증가량을 조절하세요.
                showPickupEffect(player.x, player.y - 50, "방어력 +0.7", true); // 텍스트도 같이 수정해주세요.
            }

            if (player.invincibleTimer > 0) {
                player.invincibleTimer--;
            }
            if (player.berserkTimer > 0) {
                player.berserkTimer--;
                if (player.berserkTimer <= 0) {
                    player.weapon.damage = player.weapon.baseDamage;
                    player.weapon.autoAttackInterval = player.weapon.baseAutoAttackInterval;
                    berserkStatus.style.display = 'none';
                    showPickupEffect(player.x, player.y - 50, "베르세르크 종료", false);
                }
            }
            
            if (player.weapon.damage < 0.1) player.weapon.damage = 0.1;

            let uiUpdateNeeded = false;
            let dotTimeMult = 1 + (score * 0.003);
            
            const curseRes = processStatusTimers(player.curseTimers);
            player.curseTimers = curseRes.active;
            
            if (curseRes.expired > 0) {
                for(let k=0; k<curseRes.expired; k++) {
                    let dmg = player.health * 0.05;
                    if (dmg < 1) dmg = 1; 
                    takeDamage(dmg, 'curse');
                    showPickupEffect(player.x, player.y - 40, "아파..", false, true, "evil-purple-text");
                }
            }
            if (curseRes.changed) uiUpdateNeeded = true;
            
            const gnawingLifeRes = processStatusTimers(player.gnawingLifeTimers);
            player.gnawingLifeTimers = gnawingLifeRes.active;
            if (gnawingLifeRes.changed) uiUpdateNeeded = true;

            const darkSeedRes = processStatusTimers(player.darkSeedTimers);
            player.darkSeedTimers = darkSeedRes.active;
            if (darkSeedRes.changed) uiUpdateNeeded = true;

            const darkKissRes = processStatusTimers(player.darkKissTimers);
            player.darkKissTimers = darkKissRes.active;
            if (darkKissRes.changed) uiUpdateNeeded = true;

            const darkReceiverRes = processStatusTimers(player.darkReceiverTimers);
            player.darkReceiverTimers = darkReceiverRes.active;
            if (darkReceiverRes.changed) uiUpdateNeeded = true;
            
            const maliceRes = processStatusTimers(player.maliceTimers);
            player.maliceTimers = maliceRes.active;
            if (maliceRes.changed) uiUpdateNeeded = true;
            const maliceStacks = player.maliceTimers.length;
            
            const serumRes = processStatusTimers(player.serumContaminationTimers);
            player.serumContaminationTimers = serumRes.active;
            if (serumRes.changed) uiUpdateNeeded = true;

            const poisonRes = processStatusTimers(player.poisonTimers);
            player.poisonTimers = poisonRes.active;
            if (player.poisonTimers.length > 0) {
                let dmg = player.poisonTimers.length * 0.005 * dotTimeMult;
                if (maliceStacks > 0) {
                    dmg *= (1 + maliceStacks * 0.1);
                }
                takeDamage(dmg, 'dot');
            }
            if (poisonRes.changed) uiUpdateNeeded = true;
            
            const poopRes = processStatusTimers(player.poopPoisonTimers);
            player.poopPoisonTimers = poopRes.active;
            if (player.poopPoisonTimers.length > 0) {
                let dmg = player.poopPoisonTimers.length * 0.006 * dotTimeMult;
                if (maliceStacks > 0) {
                    dmg *= (1 + maliceStacks * 0.1);
                }
                takeDamage(dmg, 'dot');
            }
            if (poopRes.changed) uiUpdateNeeded = true;
            
            const fishyRes = processStatusTimers(player.fishyTimers);
            player.fishyTimers = fishyRes.active;
            if (player.fishyTimers.length > 0) {
                let dmg = player.fishyTimers.length * 0.004 * dotTimeMult;
                if (maliceStacks > 0) {
                    dmg *= (1 + maliceStacks * 0.1);
                }
                takeDamage(dmg, 'dot');
            }
            if (fishyRes.changed) uiUpdateNeeded = true;

            const kissRes = processStatusTimers(player.kissTimers);
            player.kissTimers = kissRes.active;
            if (kissRes.changed) uiUpdateNeeded = true;
            
            const semenRes = processStatusTimers(player.semenTimers);
            player.semenTimers = semenRes.active;
            if (semenRes.changed) uiUpdateNeeded = true;
            
            const oralRes = processStatusTimers(player.oralTimers);
            player.oralTimers = oralRes.active;
            if (oralRes.changed) uiUpdateNeeded = true;
            
            const evilMindRes = processStatusTimers(player.evilMindTimers);
            const prevEvilLen = player.evilMindTimers.length;
            player.evilMindTimers = evilMindRes.active;
            if (prevEvilLen !== player.evilMindTimers.length) { updateMaxHealth(); uiUpdateNeeded = true; }
            
            const darkScentRes = processStatusTimers(player.darkScentTimers);
            player.darkScentTimers = darkScentRes.active;
            if (player.darkScentTimers.length > 0) {
                let dmg = player.darkScentTimers.length * 0.0065 * dotTimeMult;
                if (maliceStacks > 0) {
                    dmg *= (1 + maliceStacks * 0.1);
                }
                takeDamage(dmg, 'dot');
            }
            if (darkScentRes.changed) uiUpdateNeeded = true;
            
            const darkSmellRes = processStatusTimers(player.darkSmellTimers);
            player.darkSmellTimers = darkSmellRes.active;
            if (player.darkSmellTimers.length > 0) {
                let dmg = player.darkSmellTimers.length * 0.007 * dotTimeMult;
                if (maliceStacks > 0) {
                    dmg *= (1 + maliceStacks * 0.1);
                }
                takeDamage(dmg, 'dot');
            }
            if (darkSmellRes.changed) uiUpdateNeeded = true;
            
            const evilLightRes = processStatusTimers(player.evilLightTimers);
            const prevEvilLightLen = player.evilLightTimers.length;
            player.evilLightTimers = evilLightRes.active;
            if (prevEvilLightLen !== player.evilLightTimers.length) { updateMaxHealth(); uiUpdateNeeded = true; }
            if (evilLightRes.changed) uiUpdateNeeded = true;

            const darkEcstasyRes = processStatusTimers(player.darkEcstasyTimers);
            player.darkEcstasyTimers = darkEcstasyRes.active;
            if (darkEcstasyRes.changed) uiUpdateNeeded = true;

            const blindRes = processStatusTimers(player.blindTimers);
            player.blindTimers = blindRes.active;
            if (blindRes.changed) uiUpdateNeeded = true;
            
            // [수정] 마비 타이머 처리 추가
            const paralysisRes = processStatusTimers(player.paralysisTimers);
            player.paralysisTimers = paralysisRes.active;
            if (paralysisRes.changed) uiUpdateNeeded = true;
            
            // [신규] 아서 디버프 타이머 처리
            const trueAncestorKissRes = processStatusTimers(player.trueAncestorKissTimers);
            player.trueAncestorKissTimers = trueAncestorKissRes.active;
            if (trueAncestorKissRes.changed) uiUpdateNeeded = true;
         
            const fatalScarRes = processStatusTimers(player.fatalScarTimers);
            player.fatalScarTimers = fatalScarRes.active;
            if (fatalScarRes.changed) uiUpdateNeeded = true;

            const corruptedBloodRes = processStatusTimers(player.corruptedBloodTimers);
            player.corruptedBloodTimers = corruptedBloodRes.active;
            if (corruptedBloodRes.changed) uiUpdateNeeded = true;
            
            // [신규] 죽음의 낙인 처리
            const deathBrandRes = processStatusTimers(player.deathBrandTimers);
            player.deathBrandTimers = deathBrandRes.active;
            if (player.deathBrandTimers.length > 0) {
                deathBrandStatus.style.display = 'flex';
            } else {
                deathBrandStatus.style.display = 'none';
            }
            if (deathBrandRes.changed) uiUpdateNeeded = true;

            // [신규] 암흑 디버프 처리
            const darknessRes = processStatusTimers(player.darknessTimers);
            player.darknessTimers = darknessRes.active;
            if (player.darknessTimers.length > 0) {
                visionOverlay.style.opacity = 1;
                // 플레이어 주변만 보이도록 그라디언트 중심 이동
                visionOverlay.style.background = `radial-gradient(circle at ${player.x}px ${player.y}px, transparent 100px, black 300px)`;
            } else {
                visionOverlay.style.opacity = 0;
            }
            if (darknessRes.changed) uiUpdateNeeded = true;

            // [신규] 정신착란 디버프 처리
            const confusionRes = processStatusTimers(player.confusionTimers);
            player.confusionTimers = confusionRes.active;
            if (player.confusionTimers.length > 0) {
    // 스택이 많을수록 더 눈에 띄게 (원하면 계수 조절)
    const alpha = Math.min(0.90, 0.25 + player.confusionTimers.length * 0.10);
    confusionOverlay.style.setProperty('--confusionAlpha', alpha.toFixed(2));
    confusionOverlay.classList.add('active');
} else {
    confusionOverlay.classList.remove('active');
    confusionOverlay.style.opacity = 0; // 애니메이션 끄고 즉시 숨김
}
            if (confusionRes.changed) uiUpdateNeeded = true;

            const blasphemyRes = processStatusTimers(player.blasphemyTimers);
            player.blasphemyTimers = blasphemyRes.active;
            if (player.blasphemyTimers.length > 0) {
                document.getElementById('blasphemyStatus').style.display = 'flex';
            } else {
                document.getElementById('blasphemyStatus').style.display = 'none';
            }

            // [신규] 절망 타이머 감소
            if (player.despairTimer > 0) player.despairTimer--;

            let stunTriggered = false;
            // [뷰루룻 개편] 스택이 여러 개여도 1개 스택만 타이머(쿨)가 흐르도록: 맨 앞 1개만 감소
            if (player.byururutTimers.length > 0) {
                player.byururutTimers[0]--;
                if (player.byururutTimers[0] <= 0) {
                    stunTriggered = true;
                    player.byururutTimers.shift(); // 1스택만 제거
                    uiUpdateNeeded = true;
                }
            }
            if (stunTriggered) {
                // 0.5초 기절 (60fps 기준 30프레임)
                player.stunTimer = Math.max(player.stunTimer, 30);
                showPickupEffect(player.x, player.y, "뷰릇♥", false, true, "condensed-milk-text");
                uiUpdateNeeded = true;
            }
            if (player.byururutTimers.length === 0 && stunTriggered) uiUpdateNeeded = true;
            
            // 마비 상태 UI 업데이트 체크
            if (player.paralysisTimers.length > 0) {
                paralysisStatus.style.display = 'flex';
                paralysisStacksText.innerText = player.paralysisTimers.length;
            } else {
                paralysisStatus.style.display = 'none';
            }
            
            // [신규] 골절 타이머 처리
            const fractureRes = processStatusTimers(player.fractureTimers);
            player.fractureTimers = fractureRes.active;
            if (fractureRes.changed) uiUpdateNeeded = true;

            if (uiUpdateNeeded) updateStatusUI();

            if (player.semenCooldown > 0) player.semenCooldown--;
            if (player.oralCooldown > 0) player.oralCooldown--;
            if (player.darkReceiverCooldown > 0) player.darkReceiverCooldown--;

            
            if (player.byururutCooldown > 0) player.byururutCooldown--;
           // [신규] 천상의 도약 이동 처리 (최우선)
            if (player.dashTimer > 0) {
                player.dashTimer--;
                player.x += player.dashVx;
                player.y += player.dashVy;
                // 무적 유지
                player.invincibleTimer = Math.max(player.invincibleTimer, 2);
            } else {
                // 돌진 중이 아닐 때만 일반 이동 로직 수행
                let totalSlowFactor = 0;
                if (player.slowedByCloud) totalSlowFactor += 0.25;
                if (player.slowedByStickyCream) totalSlowFactor += 0.25;

                // [신규] 다크니스 오버휠름: 이동 속도 5% 감소
                if (player.darknessOverwhelmActive) {
                    totalSlowFactor += 0.05;
                }
                
                // [신규] 마비 슬로우 효과 (스택당 2.5%)
                if (player.paralysisTimers.length > 0) {
                    totalSlowFactor += (player.paralysisTimers.length * 0.025);
                }

                if (player.stunTimer > 0 || player.rootTimer > 0) {
                    // 기절 또는 속박(마비 10중첩) 상태
                    player.speed = 0;
                    if (player.rootTimer > 0 && frameCount % 30 === 0) {
                        showDamageText(player.x, player.y, "속박됨!", false, false, "weak-text");
                    }
                } else {
                    totalSlowFactor = Math.min(0.9, totalSlowFactor);
                    player.speed = player.baseSpeed * (1 - totalSlowFactor);
                    
                    let moveMult = 1;
                    if (player.confusionTimers.length > 0) {
                        moveMult = -1;
                        // 방향 반전
                        if (frameCount % 60 === 0) showPickupEffect(player.x, player.y, "혼란하다..", false, false, "confusion-border");
                    }

                    let dx = 0, dy = 0;
                    if (keys.ArrowUp) dy = -1 * moveMult;
                    if (keys.ArrowDown) dy = 1 * moveMult;
                    if (keys.ArrowLeft) dx = -1 * moveMult;
                    if (keys.ArrowRight) dx = 1 * moveMult;
                    if (isTouching) {
                        const touchDx = touchCurrent.x - touchStart.x;
                        const touchDy = touchCurrent.y - touchStart.y; const distance = Math.hypot(touchDx, touchDy);
                        if (distance > 10) { dx = touchDx / distance; dy = touchDy / distance;
                        }
                    }
                    
                    if ((dx !== 0 || dy !== 0) && player.hasHypersensitivity) {
                        if (Math.random() < 0.003) {
                            player.stunTimer = 30; 
                            showPickupEffect(player.x, player.y, "과민반응!", false, true, "block-text");
                        }
                    }

                    if (dx !== 0 || dy !== 0) {
                        if (!isTouching) { const length = Math.hypot(dx, dy);
                        dx /= length; dy /= length; }
                        player.vx = dx;
                        player.vy = dy; player.x += dx * player.speed; player.y += dy * player.speed;
                    }
                }
            }
            
            if (player.bodyHitCooldown > 0) player.bodyHitCooldown--;
            player.x = Math.max(player.radius, Math.min(canvas.width - player.radius, player.x)); player.y = Math.max(player.radius, Math.min(canvas.height - player.radius, player.y));

            let attackInterval = player.weapon.autoAttackInterval;
            let atkSpeedReduction = 0;

            if (player.darkKissTimers.length > 0) {
                atkSpeedReduction += (player.darkKissTimers.length * 0.011);
            }

            if (player.darknessOverwhelmActive) {
                atkSpeedReduction += 0.05;
            }
            const speedFactor = 1 - atkSpeedReduction;
            if (speedFactor > 0.1) {
                attackInterval = attackInterval / speedFactor;
            } else {
                attackInterval = attackInterval / 0.1;
            }

            if (!player.weapon.isAttacking) {
                player.weapon.autoTimer++;
                if (player.weapon.autoTimer >= attackInterval) { performAttack(); player.weapon.autoTimer = 0; }
            }
            
            let reachReduction = 0;
            if (player.oralTimers.length > 0) reachReduction += (player.oralTimers.length * 0.008);
            if (player.evilLightTimers.length > 0) reachReduction += 0.05;

            player.weapon.length = player.weapon.baseLength * (1 - reachReduction);
            
            if (player.weapon.isAttacking) {
                player.weapon.attackTimer--;
                if (player.weapon.attackTimer <= 0) { player.weapon.isAttacking = false; }
                const progress = 1 - (player.weapon.attackTimer / 15); player.weapon.angle = player.weapon.baseAngle - Math.PI/2 + (Math.PI * progress);
            } else {
                let currentDir = player.weapon.baseAngle; if (player.vx !== 0 || player.vy !== 0) { currentDir = Math.atan2(player.vy, player.vx); } player.weapon.angle = currentDir - 0.4;
            }
        }
        
        function updateGases() {
    for (let i = gases.length - 1; i >= 0; i--) {
        const g = gases[i];
        if (g.radius < g.maxRadius) g.radius += g.growth;
        g.life--;
        
        if (g.life <= 0) {
            gases.splice(i, 1);
            continue;
        }

        // ★ [최적화] 제곱 거리 비교
        const dx = player.x - g.x;
        const dy = player.y - g.y;
        const distSq = dx * dx + dy * dy;
        const hitRadius = player.radius + g.radius;

        if (distSq < hitRadius * hitRadius) {
            player.slowedByCloud = true;
            takeDamage(0.000125, 'dot', g.accuracy);
            
            if (frameCount % 30 === 0) {
                if(player.invincibleTimer <= 0) {
                    const stacks = 1 + (g.extraStacks || 0);
                    for(let k=0; k<stacks; k++) {
                        if (!checkShieldBlockStatus()) {
                            addStatus('poison', 900, 30);
                        }
                    }
                    showPickupEffect(player.x, player.y, "콜록!", false, true);
                }
            }
        }
    }
}

        // [신규] 박쥐 투사체 업데이트
       function updateBloodBats() {
    for (let i = bloodBats.length - 1; i >= 0; i--) {
        const bat = bloodBats[i];
        const angle = Math.atan2(player.y - bat.y, player.x - bat.x);
        bat.x += Math.cos(angle) * bat.speed;
        bat.y += Math.sin(angle) * bat.speed;
        bat.life--;

        if (bat.life <= 0) {
            bloodBats.splice(i, 1);
            continue;
        }

        // ★ [최적화] 제곱 거리 계산
        const dx = player.x - bat.x;
        const dy = player.y - bat.y;
        const distSq = dx * dx + dy * dy;
        const radii = player.radius + bat.radius;

        if (distSq < radii * radii) {
            if (player.invincibleTimer > 0) {
                bloodBats.splice(i, 1);
                continue;
            }
            const dmg = 34 + Math.floor(score * 0.25);
            takeDamage(dmg, 'direct', bat.accuracy, bat);

            // 아서 체력 회복
            if (bat.owner && bat.owner.hp > 0) {
                let healAmt = dmg * 1.0;
                healAmt = Math.floor(healAmt * (bat.owner.hpRecoveryRate || 1));
                bat.owner.hp = Math.min(bat.owner.hp + healAmt, bat.owner.maxHp);
                showDamageText(bat.owner.x, bat.owner.y, "+" + healAmt, false, false, "heal-text");
            }

            // 진조의 키스 2중첩
            for (let k = 0; k < 2; k++) {
                addStatus('trueAncestorKiss', 1800, 10);
            }
            showPickupEffect(player.x, player.y, "진조의 키스!", false, true, "arthur-text");
            bloodBats.splice(i, 1);
        }
    }
}
        
      function updateBloodPuddles() {
    for (let i = bloodPuddles.length - 1; i >= 0; i--) {
        const p = bloodPuddles[i];
        p.life--;
        if (p.life <= 0) {
            bloodPuddles.splice(i, 1);
            continue;
        }
        
        p.tickTimer++;
        if (p.tickTimer >= 30) { 
            // 1. 플레이어 피격 체크 (최적화)
            const dx = player.x - p.x;
            const dy = player.y - p.y;
            const distSq = dx * dx + dy * dy;
            
            if (distSq < p.radius * p.radius) {
                if (player.invincibleTimer <= 0) {
                    let dmg = 5 + Math.floor(score * 0.1);
                    takeDamage(dmg, 'direct', p.accuracy, p);
                    for(let k = 0; k < 2; k++) {
                        addStatus('corruptedBlood', 1800, 10);
                    }
                    showPickupEffect(player.x, player.y, "더럽혀진 피!", false, false, "corrupted-blood-border");
                }
            }

            // 2. 아서 회복 체크 (최적화)
            if (p.owner && p.owner.hp > 0) {
                const odx = p.owner.x - p.x;
                const ody = p.owner.y - p.y;
                const ownerDistSq = odx * odx + ody * ody;

                if (ownerDistSq < p.radius * p.radius) {
                    let puddleHeal = 5 + Math.floor(score * 0.2);
                    puddleHeal = Math.floor(puddleHeal * (p.owner.hpRecoveryRate || 1));
                    p.owner.hp = Math.min(p.owner.hp + puddleHeal, p.owner.maxHp);
                    showDamageText(p.owner.x, p.owner.y, "+" + puddleHeal, false, false, "heal-text");
                }
            }
            p.tickTimer = 0;
        }
    }
}

     function updatePianissimoSnipes() {
    for (let i = pianissimoSnipes.length - 1; i >= 0; i--) {
        const p = pianissimoSnipes[i];
        
        // 1. 충전 상태
        if (p.state === 'charging') {
            p.chargeTimer++;
            p.alpha = p.chargeTimer / p.chargeMax;
            
            // 완충 시 발사
            if (p.chargeTimer >= p.chargeMax) {
                p.state = 'firing';
                p.alpha = 1.0;
                const angle = Math.atan2(player.y - p.y, player.x - p.x);
                const speed = 10; 
                p.vx = Math.cos(angle) * speed;
                p.vy = Math.sin(angle) * speed;
            }
        } 
        // 2. 발사 상태
        else if (p.state === 'firing') {
            p.x += p.vx;
            p.y += p.vy;
            p.life--;

            // 화면 밖 제거
            if (p.life <= 0 || p.x < -100 || p.x > canvas.width + 100 || p.y < -100 || p.y > canvas.height + 100) {
                pianissimoSnipes.splice(i, 1);
                continue;
            }

            // ★ [최적화] 제곱 거리 계산
            const dx = player.x - p.x;
            const dy = player.y - p.y;
            const distSq = dx * dx + dy * dy;
            const radii = player.radius + p.radius;

            if (distSq < radii * radii) {
                if (player.invincibleTimer <= 0) {
                    let dmg = 10 + Math.floor(score * 0.18);
                    takeDamage(dmg, 'direct', p.accuracy, p);
                    
                    player.stunTimer = Math.max(player.stunTimer || 0, 45);
                    showPickupEffect(player.x, player.y, "포르테..", false, true, "block-text");
                    pianissimoSnipes.splice(i, 1);
                }
            }
        }
    }
}

     function updateDarkGases() {
    for (let i = darkGases.length - 1; i >= 0; i--) {
        const g = darkGases[i];

        // 1. 가스 크기 성장 로직
        if (g.radius < g.maxRadius) {
            g.radius += g.growth;
            if (g.radius >= g.maxRadius) {
                g.radius = g.maxRadius;
                // 폭발 데미지 처리
                if (g.pendingDamage && g.pendingDamage > 0 && !g.hasExploded) {
                    explosions.push({
                        x: g.x,
                        y: g.y,
                        radius: g.maxRadius,
                        life: 20,
                        damage: g.pendingDamage,
                        accuracy: g.accuracy,
                        owner: g.owner,
                        hasHit: false
                    });
                    g.hasExploded = true;
                }
            }
        }

        // 2. 수명 감소 및 제거
        g.life--;
        if (g.life <= 0) {
            darkGases.splice(i, 1);
            continue;
        }

        // [Trail darkgas] purely visual: skip collision/damage for performance
        if (g.isTrail) {
            g.alpha *= 0.985;
            continue;
        }

        // [Mini darkgas] gentle fade but still deals damage/status
        if (g.simpleDraw) {
            g.alpha *= 0.994;
        }

        // ★ [최적화] 제곱 거리 계산
        const dx = player.x - g.x;
        const dy = player.y - g.y;
        const distSq = dx * dx + dy * dy;
        const radii = player.radius + g.radius;

        if (distSq < radii * radii) {
            let baseGasDmg = 0.0004;
            let finalGasDmg = baseGasDmg * (g.damageMult || 1.0);

            takeDamage(finalGasDmg, 'dot', g.accuracy);

            if (frameCount % 60 === 0 && player.invincibleTimer <= 0) {
                addStatus('darkScent', 900, 30);
            }
        }
    }
}
        

        function updateHollowNight() {
    for (let i = hollowNight.length - 1; i >= 0; i--) {
        const hk = hollowNight[i];
        hk.life--;
        if (hk.life <= 0) {
            hollowNight.splice(i, 1);
            continue;
        }
        if (hk.cooldown > 0) hk.cooldown--;

        // ★ [최적화] 제곱 거리 계산
        // (원본 로직: dist < hk.radius 였으므로 동일하게 적용)
        const dx = player.x - hk.x;
        const dy = player.y - hk.y;
        const distSq = dx * dx + dy * dy;

        if (distSq < hk.radius * hk.radius) {
            if (hk.cooldown <= 0 && player.invincibleTimer <= 0) {
                let dmg = 34 + Math.floor(score * 0.25);
                takeDamage(dmg, 'direct', hk.accuracy, hk);
                addStatus('darkEcstasy', 900, 5);
                showPickupEffect(player.x, player.y, "허무 속으로..", false);

                if (player.shieldStacks > 0) {
                    player.shieldStacks = Math.max(0, player.shieldStacks - 2);
                    updateStatusUI();
                }
                hk.cooldown = 60;
            }
        }
    }
}


        // [최적화] HollowNight(카인) 렌더 캐시 (프레임 드랍 완화)
        function renderHollowNightEffect(ctx, hk) {
            // Lazy init cache
            if (!hk._cache) {
                const canvas = document.createElement('canvas');
                // 작게 렌더한 뒤 업스케일 (GPU/CPU 부담 ↓)
                const size = 280;
                canvas.width = size;
                canvas.height = size;
                hk._cache = {
                    canvas,
                    ctx: canvas.getContext('2d'),
                    size,
                    lastFrame: -9999,
                    lastActive: null,
                    lastPhase: -9999
                };
            }

            const cache = hk._cache;
            const isActive = hk.cooldown <= 0;

            // 캐시 갱신 주기: effectsStride가 커질수록 더 드물게 갱신
            const refreshEvery = Math.max(4, ((performanceState && performanceState.effectsStride) ? performanceState.effectsStride : 1) * 6); // frames (추가 최적화)
            const phaseNow = (Date.now() / 1000);
            const phaseQ = Math.floor(phaseNow * 12); // [추가 최적화] 12fps로 양자화(캐시 갱신 시에만 사용)
            const needRedraw = (cache.lastActive !== isActive) || (frameCount - cache.lastFrame >= refreshEvery) || (cache.lastPhase !== phaseQ);

            if (needRedraw) {
                cache.lastActive = isActive;
                cache.lastFrame = frameCount;
                cache.lastPhase = phaseQ;

                const cctx = cache.ctx;
                const S = cache.size;
                cctx.clearRect(0, 0, S, S);

                // offscreen에서 그릴 때는 기본 반지름(=hk.radius)을 기준으로 그린 뒤,
                // 본 화면에서 pulse 스케일만 적용해서 drawImage로 출력.
                const t = phaseQ / 12;
                const baseR = hk.radius;
                const drawExtent = baseR * 2.35; // 바깥 오라까지 포함한 반경(대략)
                const scale = (S * 0.5) / drawExtent;

                cctx.save();
                cctx.translate(S * 0.5, S * 0.5);
                cctx.scale(scale, scale);

                const R = baseR;

                // 팔레트
                const colOuter  = isActive ? '120, 0, 235' : '95, 95, 95';
                const colMid    = isActive ? '70, 0, 150'  : '70, 70, 70';
                const colBright = isActive ? '235, 205, 255' : '170, 170, 170';
                const coreHex   = isActive ? '#000000' : '#111111';

                // 1) 바깥 오라
                const aura = cctx.createRadialGradient(0, 0, R * 0.15, 0, 0, R * 2.15);
                aura.addColorStop(0.0, 'rgba(0,0,0,0)');
                aura.addColorStop(0.25, `rgba(${colMid}, 0.16)`);
                aura.addColorStop(0.55, `rgba(${colOuter}, 0.20)`);
                aura.addColorStop(1.0, 'rgba(0,0,0,0)');
                cctx.fillStyle = aura;
                cctx.beginPath();
                cctx.arc(0, 0, R * 2.2, 0, Math.PI * 2);
                cctx.fill();

                // 2) 스파이크/코로나 (카운트 축소 + shadowBlur 축소)
                cctx.save();
                cctx.globalCompositeOperation = 'lighter';
                cctx.shadowBlur = isActive ? 14 : 6;
                cctx.shadowColor = `rgba(${colOuter}, ${isActive ? 0.85 : 0.55})`;

                const spikeCount = isActive ? 18 : 12;
                for (let i = 0; i < spikeCount; i++) {
                    const aBase = (i / spikeCount) * Math.PI * 2;
                    const a = aBase + Math.sin(t * 0.65 + i * 1.7) * 0.16;
                    const inner = R * (0.86 + Math.sin(t * 2.2 + i) * 0.03);
                    const len = R * (0.50 + 0.45 * Math.abs(Math.sin(t * 2.8 + i * 1.35)));
                    const mx = Math.cos(a + 0.25 * Math.sin(t * 3.2 + i)) * (inner + len * 0.45);
                    const my = Math.sin(a + 0.25 * Math.sin(t * 3.2 + i)) * (inner + len * 0.45);
                    const ex = Math.cos(a) * (inner + len);
                    const ey = Math.sin(a) * (inner + len);

                    cctx.lineWidth = Math.max(1.4, R * 0.018);
                    cctx.strokeStyle = `rgba(${colOuter}, ${isActive ? 0.20 : 0.10})`;
                    cctx.beginPath();
                    cctx.moveTo(Math.cos(a) * inner, Math.sin(a) * inner);
                    cctx.quadraticCurveTo(mx, my, ex, ey);
                    cctx.stroke();
                }
                cctx.restore();

                // 3) 코어
                const coreGrad = cctx.createRadialGradient(0, 0, 0, 0, 0, R * 1.05);
                coreGrad.addColorStop(0.0, coreHex);
                coreGrad.addColorStop(0.55, coreHex);
                coreGrad.addColorStop(0.78, isActive ? '#120018' : '#222222');
                coreGrad.addColorStop(0.92, isActive ? 'rgba(70, 0, 110, 0.90)' : 'rgba(100,100,100,0.50)');
                coreGrad.addColorStop(1.0, 'rgba(0,0,0,0)');
                cctx.fillStyle = coreGrad;
                cctx.beginPath();
                cctx.arc(0, 0, R * 1.05, 0, Math.PI * 2);
                cctx.fill();

                // 4) 테두리 링
                cctx.save();
                cctx.globalCompositeOperation = isActive ? 'lighter' : 'source-over';
                cctx.shadowBlur = isActive ? 16 : 0;
                cctx.shadowColor = `rgba(${colOuter}, 0.85)`;
                const ringGrad = cctx.createRadialGradient(0, 0, R * 0.55, 0, 0, R * 1.15);
                ringGrad.addColorStop(0.0, `rgba(${colOuter}, 0)`);
                ringGrad.addColorStop(0.55, `rgba(${colOuter}, ${isActive ? 0.18 : 0.08})`);
                ringGrad.addColorStop(1.0, `rgba(${colBright}, ${isActive ? 0.26 : 0.10})`);
                cctx.strokeStyle = ringGrad;
                cctx.lineWidth = Math.max(3, R * 0.14);
                cctx.beginPath();
                cctx.arc(0, 0, R * 0.84, 0, Math.PI * 2);
                cctx.stroke();
                cctx.restore();

                // 5) 내부 소용돌이 (포인트 수 축소)
                cctx.save();
                cctx.globalCompositeOperation = isActive ? 'lighter' : 'source-over';
                cctx.rotate(t * 0.55);
                cctx.lineWidth = Math.max(2, R * 0.028);
                cctx.strokeStyle = isActive ? `rgba(${colOuter}, 0.20)` : `rgba(130,130,130,0.16)`;
                cctx.shadowBlur = isActive ? 6 : 0;
                cctx.shadowColor = `rgba(${colOuter}, 0.75)`;
                const swirlSteps = 22;
                for (let s = 0; s < 2; s++) {
                    cctx.beginPath();
                    for (let k = 0; k <= swirlSteps; k++) {
                        const p = k / swirlSteps;
                        const ang = p * Math.PI * 2 * 1.25 + s * Math.PI;
                        const rr = R * (0.12 + p * 0.66);
                        const x = Math.cos(ang) * rr;
                        const y = Math.sin(ang) * rr;
                        if (k === 0) cctx.moveTo(x, y);
                        else cctx.lineTo(x, y);
                    }
                    cctx.stroke();
                }
                cctx.restore();

                // 6) 내부 번개(활성일 때만, 간소화)
                if (isActive) {
                    cctx.save();
                    cctx.globalCompositeOperation = 'lighter';
                    const boltCount = 2;
                    const steps = 5;

                    for (let b = 0; b < boltCount; b++) {
                        const a0 = t * 1.25 + b * (Math.PI * 2 / boltCount);
                        const r0 = R * 0.15;
                        const r1 = R * 0.78;

                        cctx.beginPath();
                        cctx.lineWidth = Math.max(2, R * 0.030);
                        cctx.strokeStyle = `rgba(${colBright}, 0.58)`;
                        cctx.shadowBlur = 16;
                        cctx.shadowColor = `rgba(${colBright}, 1)`;

                        for (let i = 0; i <= steps; i++) {
                            const p = i / steps;
                            const bend = Math.sin(t * 3.0 + b * 10 + p * 5) * 0.50 * (1 - p);
                            const ang = a0 + bend;
                            const rr = r0 + (r1 - r0) * p;
                            const jit = Math.sin(t * 8.0 + p * 22 + b * 30) * R * 0.035 * (1 - p);
                            const x = Math.cos(ang) * rr + Math.cos(ang + 1.4) * jit;
                            const y = Math.sin(ang) * rr + Math.sin(ang + 1.4) * jit;
                            if (i === 0) cctx.moveTo(x, y);
                            else cctx.lineTo(x, y);
                        }
                        cctx.stroke();
                    }

                    // 중심 스파크
                    cctx.beginPath();
                    cctx.arc(0, 0, R * 0.12, 0, Math.PI * 2);
                    cctx.fillStyle = `rgba(${colBright}, 0.30)`;
                    cctx.shadowBlur = 20;
                    cctx.shadowColor = `rgba(${colBright}, 1)`;
                    cctx.fill();

                    cctx.restore();
                }

                cctx.restore(); // scale/translate
            }

            // 본화면 출력 (가벼움)
            const tNow = Date.now() / 1000;
            const pulse = 1 + Math.sin(tNow * 3.6) * 0.06 + Math.cos(tNow * 9.0 + hk.x * 0.01) * 0.02;
            const drawR = hk.radius * pulse;
            const drawSize = drawR * 2 * 2.35;

            ctx.save();
            ctx.translate(hk.x, hk.y);
            ctx.globalCompositeOperation = (isActive ? 'lighter' : 'source-over');
            ctx.imageSmoothingEnabled = true;
            ctx.globalAlpha = 1.0;
            ctx.drawImage(cache.canvas, -drawSize / 2, -drawSize / 2, drawSize, drawSize);
            ctx.restore();
        }


        function updatePoops() {
    for (let i = poops.length - 1; i >= 0; i--) {
        const p = poops[i];
        p.x += p.vx;
        p.y += p.vy;
        p.life--;

        if (p.life <= 0) {
            poops.splice(i, 1);
            continue;
        }

        // ★ [최적화] Math.hypot 대체
        const dx = player.x - p.x;
        const dy = player.y - p.y;
        const distSq = dx * dx + dy * dy; 
        const radii = player.radius + p.radius;

        if (distSq < radii * radii) {
            if (player.invincibleTimer > 0) continue;

            let damage = p.isGreen ? 1 : 5;
            damage += Math.floor(score * 0.075);
            const maliceStacks = player.maliceTimers.length;
            if (maliceStacks > 0) {
                damage *= (1 + maliceStacks * 0.1);
            }
            takeDamage(damage, 'direct', p.accuracy, p);

            if (!checkShieldBlockStatus()) {
                addStatus('poopPoison', 900, 30);
                updatePoopVisual();
                showPickupEffect(player.x, player.y, "똥내..", false, true, "poop-text");
            }
            poops.splice(i, 1);
        }
    }
}

       function updateBigPoops() {
    for (let i = bigPoops.length - 1; i >= 0; i--) {
        const p = bigPoops[i];
        if (p.isHoming) {
            const angle = Math.atan2(player.y - p.y, player.x - p.x);
            p.x += Math.cos(angle) * 2.3;
            p.y += Math.sin(angle) * 2.3;
        }
        p.life--;

        if (p.life <= 0) {
            spawnPoopStain(p.x, p.y);
            bigPoops.splice(i, 1);
            continue;
        }

        // ★ [최적화] 제곱 거리 계산
        const dx = player.x - p.x;
        const dy = player.y - p.y;
        const distSq = dx * dx + dy * dy;
        const radii = player.radius + p.radius;

        if (distSq < radii * radii) {
            if (player.invincibleTimer > 0) continue;

            let dmg = 26;
            if (p.isHoming) dmg = 19;
            else dmg = 13;
            
            dmg += Math.floor(score * 0.15);
            const maliceStacks = player.maliceTimers.length;
            if (maliceStacks > 0) {
                dmg *= (1 + maliceStacks * 0.1);
            }
            takeDamage(dmg, 'direct', p.accuracy, p);

            const stacksToApply = p.isHoming ? 2 : 1;
            let applied = 0;
            const loopCount = p.isHoming ? 2 : 3;

            for (let k = 0; k < loopCount; k++) {
                if (!checkShieldBlockStatus()) {
                    addStatus('poopPoison', 900, 30);
                    applied++;
                }
            }
            if (applied > 0) {
                updatePoopVisual();
                showPickupEffect(player.x, player.y, "똥범벅이야..", false, true, "poop-text");
            }
            bigPoops.splice(i, 1);
        }
    }
}

        function updateDarkBigPoops() {
    for (let i = darkBigPoops.length - 1; i >= 0; i--) {
        const p = darkBigPoops[i];
        if (p.isHoming) {
            const angle = Math.atan2(player.y - p.y, player.x - p.x);
            p.x += Math.cos(angle) * 2.3;
            p.y += Math.sin(angle) * 2.3;
        } else {
            p.x += p.vx;
            p.y += p.vy;
        }
        p.life--;

        if (p.life <= 0) {
            spawnPoopStain(p.x, p.y);
            darkBigPoops.splice(i, 1);
            continue;
        }

        // ★ [최적화] 제곱 거리 계산
        const dx = player.x - p.x;
        const dy = player.y - p.y;
        const distSq = dx * dx + dy * dy;
        const radii = player.radius + p.radius;

        if (distSq < radii * radii) {
            if (player.invincibleTimer > 0) continue;

            let dmg = p.isHoming ? 26 : 19;
            dmg += Math.floor(score * 0.15);
            const maliceStacks = player.maliceTimers.length;
            if (maliceStacks > 0) {
                dmg *= (1 + maliceStacks * 0.1);
            }
            takeDamage(dmg, 'direct', p.accuracy, p);

            for (let k = 0; k < 2; k++) addStatus('darkSmell', 900, 30);
            showPickupEffect(player.x, player.y, "악마의 똥내♥", false, true, "poop-text");
            darkBigPoops.splice(i, 1);
        }
    }
}

       function updateDarkWaves() {
    for (let i = darkWaves.length - 1; i >= 0; i--) {
        const w = darkWaves[i];
        w.x += w.vx;
        w.y += w.vy;
        w.life--;
        
        // 벽 튕기기 로직
        let bounced = false;
        if (w.x < w.radius) { w.x = w.radius; w.vx *= -1; bounced = true; }
        else if (w.x > canvas.width - w.radius) { w.x = canvas.width - w.radius; w.vx *= -1; bounced = true; }
        
        if (w.y < w.radius) { w.y = w.radius; w.vy *= -1; bounced = true; }
        else if (w.y > canvas.height - w.radius) { w.y = canvas.height - w.radius; w.vy *= -1; bounced = true; }

        if (bounced) {
            w.bounceCount++;
            w.rotation = Math.atan2(w.vy, w.vx);
            if (w.bounceCount > w.maxBounces) { darkWaves.splice(i, 1); continue; }
        }

        if (w.life <= 0) { darkWaves.splice(i, 1); continue; }

        // [최적화] 충돌 체크 (제곱 거리)
        const dx = player.x - w.x;
        const dy = player.y - w.y;
        const distSq = dx * dx + dy * dy;
        const hitRadius = player.radius + w.radius;

        if (distSq < hitRadius * hitRadius) { 
            if (player.invincibleTimer > 0) continue;

            let dmg = 22 + Math.floor(score * 0.22);
            takeDamage(dmg, 'direct', w.accuracy, w);

            addStatus('darkSmell', 900, 10);
            addStatus('darkScent', 900, 10);
            showPickupEffect(player.x, player.y, "타락해라♥ ", false, true, "corrupted-text");
            darkWaves.splice(i, 1);
        }
    }
}
        
        function updateDragShots() {
    for (let i = dragShots.length - 1; i >= 0; i--) {
        const shot = dragShots[i];
        shot.x += shot.vx;
        shot.y += shot.vy;
        shot.life--;

        if (shot.life <= 0 || shot.x < -100 || shot.x > canvas.width + 100 || shot.y < -100 || shot.y > canvas.height + 100) {
            dragShots.splice(i, 1);
            continue;
        }

        // [최적화] 충돌 체크 (제곱 거리)
        const dx = player.x - shot.x;
        const dy = player.y - shot.y;
        const distSq = dx * dx + dy * dy;
        const hitRadius = player.radius + shot.radius;

        if (distSq < hitRadius * hitRadius) {
            if (player.invincibleTimer > 0) {
                 dragShots.splice(i, 1);
                 continue;
            }
            
            let dmg = 16 + Math.floor(score * 0.15);
            takeDamage(dmg, 'direct', shot.accuracy, shot);
            
            // 끌어당기기 효과
            const pullX = shot.startX;
            const pullY = shot.startY;
            player.x = player.x + (pullX - player.x) * 0.8;
            player.y = player.y + (pullY - player.y) * 0.8;
            
            showPickupEffect(player.x, player.y, "끌려간다!", false, true, "choke-text");
            dragShots.splice(i, 1);
        }
    }
}

        function updateEvilArrows() {
    for (let i = evilArrows.length - 1; i >= 0; i--) {
        const shot = evilArrows[i];
        shot.x += shot.vx;
        shot.y += shot.vy;
        shot.life--;

        // [Evil Arrow] Trail: spawn normal DarkGas (2x size) with real damage + darkScent
        shot.trailT = (shot.trailT || 0) + 1;
        if ((shot.trailT % 30) === 0) {
            const sp = Math.hypot(shot.vx, shot.vy) || 1;
            const nx = -shot.vy / sp;
            const ny = shot.vx / sp;

            // deterministic wobble (no Math.random)
            const off = Math.sin((shot.seed + shot.trailT) * 0.12) * 12;
            spawnDarkGas(
                shot.x - shot.vx * 1.8 + nx * off,
                shot.y - shot.vy * 1.8 + ny * off,
                2.0,                 // size multiplier (2x normal)
                1.0,                 // damage multiplier (normal)
                shot.accuracy || 0,  // accuracy
                0,                   // no explosion damage
                shot.owner || shot
            );
        }

        if (shot.life <= 0 || shot.x < -100 || shot.x > canvas.width + 100 || shot.y < -100 || shot.y > canvas.height + 100) {
            evilArrows.splice(i, 1);
            continue;
        }

        // [최적화] 충돌 체크 (제곱 거리)
        const dx = player.x - shot.x;
        const dy = player.y - shot.y;
        const distSq = dx * dx + dy * dy;
        const hitRadius = player.radius + shot.radius;

        if (distSq < hitRadius * hitRadius) {
            if (player.invincibleTimer > 0) {
                 evilArrows.splice(i, 1);
                 continue;
            }
            let dmg = 18 + Math.floor(score * 0.15);
            takeDamage(dmg, 'direct', shot.accuracy, shot);
            darknessOverlay.style.opacity = 1;
            setTimeout(() => { darknessOverlay.style.opacity = 0; }, 750);

            for (let k = 0; k < 5; k++) {
                const ang = Math.random() * Math.PI * 2;
                const dist = 35 + Math.random() * 70;
                const sx = player.x + Math.cos(ang) * dist;
                const sy = player.y + Math.sin(ang) * dist;
                spawnDarkGas(sx, sy, 1.0, 1.0, shot.accuracy || 0, 0, shot.owner || shot);
            }
            showPickupEffect(player.x, player.y, "눈가리기♥", false, true, "evil-purple-text");
            evilArrows.splice(i, 1);
        }
    }
}

function updatePoisonousShots() {
    for (let i = poisonousShots.length - 1; i >= 0; i--) {
        const shot = poisonousShots[i];
        shot.x += shot.vx;
        shot.y += shot.vy;
        shot.life--;

        // [Aki] Poisonous Shot trail: leave 2x Gases that apply '가스 중독'(poison) on contact
        shot.trailTimer = (shot.trailTimer || 0) + 1;
        if (shot.trailTimer % 30 === 0) {
            // Soft cap to avoid excessive perf spikes when many effects exist
            if (gases.length < 450) {
                spawnGas(
                    shot.x - shot.vx * 1.2,
                    shot.y - shot.vy * 1.2,
                    false, // isElite
                    false, // isZako
                    0,     // extraStacks (base 1 stack per tick)
                    2.0,   // sizeMult (2.0x)
                    shot.accuracy || 0,
                    shot.owner || shot
                );
            }
        }

        if (shot.life <= 0 || shot.x < -120 || shot.x > canvas.width + 120 || shot.y < -120 || shot.y > canvas.height + 120) {
            poisonousShots.splice(i, 1);
            continue;
        }

        // 충돌 체크 (제곱 거리)
        const dx = player.x - shot.x;
        const dy = player.y - shot.y;
        const distSq = dx * dx + dy * dy;
        const hitRadius = player.radius + shot.radius;

        if (distSq < hitRadius * hitRadius) {
            if (player.invincibleTimer > 0) {
                poisonousShots.splice(i, 1);
                continue;
            }

            let dmg = 14 + Math.floor(score * 0.15);
            takeDamage(dmg, 'direct', shot.accuracy, shot);

            // 피격 시: '가스 중독' 5중첩 + '똥독' 5중첩 (기존 유지)
            if (!checkShieldBlockStatus()) {
                for (let k = 0; k < 5; k++) addStatus('poison', 900, 30);
                for (let k = 0; k < 5; k++) addStatus('poopPoison', 900, 30);
                updatePoopVisual();
            }
            // [추가] 피격 지점 주변에 가스 5개 생성 (연출 + 후속 접촉 중독)
            for (let k = 0; k < 5; k++) {
                const ang = Math.random() * Math.PI * 2;
                const dist = 25 + Math.random() * 70;
                const gx = player.x + Math.cos(ang) * dist;
                const gy = player.y + Math.sin(ang) * dist;
                // Soft cap to avoid excessive perf spikes when many effects exist
                if (gases.length >= 450) break;
                spawnGas(gx, gy, false, false, 0, 1.0, shot.accuracy || 0, shot.owner || shot);
            }
            showPickupEffect(player.x, player.y, "중독!", false, true, "poop-text");

            poisonousShots.splice(i, 1);
        }
    }
}

function updateAntiPassingTentacles() {
    for (let i = antiPassingTentacles.length - 1; i >= 0; i--) {
        const t = antiPassingTentacles[i];
        t.life--;
        t.frame++;

        // [변경] hitDelay(=그림자 경고 시간) 이후에만 실제로 '솟아오름' 진행
        //  - riseProgress: 0(완전 지면 아래) ~ 1(완전 출현)
        const warn = (t.hitDelay || 0);
        const riseDur = (t.riseDuration || 16);
        const riseFrame = (t.frame - warn);
        t.riseProgress = Math.min(1, Math.max(0, riseFrame / riseDur));

        if (t.life <= 0) {
            antiPassingTentacles.splice(i, 1);
            continue;
        }

        if (t.hitApplied) continue;

        // [요청 반영] 촉수가 '완전히' 땅에서 나와야 데미지/디버프 판정
        if (t.riseProgress < 1) continue;

        // [신규] 촉수 완전 출현 시 '가스 중독' 가스 생성 (일반 빌런 gas 크기)
        if (!t.gasSpawned) {
            t.gasSpawned = true;
            // Soft cap to avoid excessive perf spikes when many effects exist
            if (gases.length < 450) {
                spawnGas(
                    t.x,
                    t.y - 20,
                    false, // isElite
                    false,  // isZako (일반 빌런 gas 크기)
                    0,     // extraStacks
                    1.0,   // sizeMult
                    t.accuracy || 0,
                    t.owner || t
                );
            }
        }

        // [히트박스 변경] '보이는 촉수(세그먼트)' 범위대로 판정 (멀티 서클)
        //  - 렌더의 세그먼트 배치(각도/거리/반경)와 동일한 방식으로 중심점을 만들고,
        //    플레이어 원과 각 세그먼트 원의 교차를 검사한다.
        if (!t._hitSegments) {
            const _apBaseR = 42;
            const _apScale = Math.max(0.2, (t.radius || _apBaseR) / _apBaseR);
            const _apDir = (typeof t.baseAngle === 'number') ? t.baseAngle : (-Math.PI / 2);
            const segsFull = Math.max(3, (t.segCount || 7));
            const arr = [];
            for (let sIdx = 0; sIdx < segsFull; sIdx++) {
                const k = (segsFull <= 1) ? 1 : (sIdx / (segsFull - 1));
                const segAngle = _apDir + k * 1.35;
                const dist = k * 132 * _apScale; // rise=1 기준(완전 출현 시)
                const dxs = Math.cos(segAngle) * dist;
                const dys = Math.sin(segAngle) * dist;
                const segR = (22 - k * 8) * _apScale;
                const tip = (7 - k * 2) * _apScale; // 가시 길이(렌더와 동일 계열)
                arr.push({ dx: dxs, dy: dys, r: segR * 1.05 + tip }); // 본체+가시까지 포함
            }
            t._hitSegments = arr;
        }

        let _apHit = false;
        {
            const segs = t._hitSegments;
            for (let s = 0; s < segs.length; s++) {
                const sg = segs[s];
                const hx = t.x + sg.dx;
                const hy = t.y + sg.dy;
                const ddx = player.x - hx;
                const ddy = player.y - hy;
                const rr = player.radius + sg.r;
                if (ddx * ddx + ddy * ddy < rr * rr) { _apHit = true; break; }
            }
        }

        if (_apHit) {
            if (player.invincibleTimer > 0) {
                // 무적이면 이번 촉수는 소비(기존 동작 유지)
                t.hitApplied = true;
                continue;
            }

            let dmg = 14 + Math.floor(score * 0.15);
            takeDamage(dmg, 'direct', t.accuracy, t);

            let applied = 0;
            for (let k = 0; k < 3; k++) {
                if (!checkShieldBlockStatus()) { addStatus('poison', 900, 30); applied++; }
            }
            for (let k = 0; k < 3; k++) {
                if (!checkShieldBlockStatus()) { addStatus('poopPoison', 900, 30); applied++; }
            }
            for (let k = 0; k < 3; k++) {
                if (!checkShieldBlockStatus()) { addStatus('fishy', 900, 9999); applied++; }
            }
            if (applied > 0) {
                updateStatusUI();
                updatePoopVisual();
                showPickupEffect(player.x, player.y, "가스 중독!!", false, true, "poop-text");
            }

            t.hitApplied = true;
        }
    }
}

function updateJammingWaves() {
    for (let i = jammingWaves.length - 1; i >= 0; i--) {
        const wave = jammingWaves[i];
        wave.x += wave.vx;
        wave.y += wave.vy;
        wave.life--;
        
        if (wave.life <= 0 || wave.x < -100 || wave.x > canvas.width + 100 || wave.y < -100 || wave.y > canvas.height + 100) {
            jammingWaves.splice(i, 1);
            continue;
        }

        // [최적화] 충돌 체크 (제곱 거리)
        const dx = player.x - wave.x;
        const dy = player.y - wave.y;
        const distSq = dx * dx + dy * dy;
        const hitRadius = player.radius + wave.radius;

        if (distSq < hitRadius * hitRadius) {
            if (player.invincibleTimer > 0) {
                jammingWaves.splice(i, 1);
                continue;
            }
            
            let dmg = 19 + Math.floor(score * 0.17);
            takeDamage(dmg, 'direct', wave.accuracy, wave);
            // 쿨타임 증가
            player.goddessSkill.cooldown += 600;
            player.sacredFaithSkill.cooldown += 600;
            player.novaSkill.cooldown += 600;
            player.limitFocusSkill.cooldown += 600;

            showPickupEffect(player.x, player.y, "재밍!!", false, true, "evil-purple-text");
            
            // 노이즈 이펙트
            const noiseDiv = document.createElement('div');
            noiseDiv.style.position = 'absolute';
            noiseDiv.style.top = 0; noiseDiv.style.left = 0;
            noiseDiv.style.width = '100%'; noiseDiv.style.height = '100%';
            noiseDiv.style.backgroundImage = 'url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHdpZHRoPScxMDAlJyBoZWlnaHQ9JzEwMCUnPjxmaWx0ZXIgaWQ9J25vaXNlJz48ZmVUdXJidWxlbmNlIHR5cGU9J2ZyYWN0YWxOb2lzZScgYmFzZUZyZXF1ZW5jeT0nMC41JyBudW1PY3RhdmVzPScxJyBzdGl0Y2hUaWxlcz0nc3RpdGNoJy8+PC9maWx0ZXI+PHJlY3Qgd2lkdGg9JzEwMCUnIGhlaWdodD0nMTAwJScgZmlsdGVyPSd1cmwoI25vaXNlKScgb3BhY2l0eT0nMC41Jy8+PC9zdmc+")';
            noiseDiv.style.opacity = 0.5;
            noiseDiv.style.pointerEvents = 'none';
            noiseDiv.style.zIndex = 9999;
            document.body.appendChild(noiseDiv);
            setTimeout(() => noiseDiv.remove(), 500);

            jammingWaves.splice(i, 1);
        }
    }
}

        function updateNeuroNeedles() {
    for (let i = neuroNeedles.length - 1; i >= 0; i--) {
        const n = neuroNeedles[i];
        n.x += n.vx;
        n.y += n.vy;
        n.life--;
        
        // 독바늘 꼬리(잔상)
        if (!n.trail) n.trail = [];
        n.trail.push({ x: n.x, y: n.y, size: Math.random() * 10 + 5, life: 20 });
        for (let t = n.trail.length - 1; t >= 0; t--) {
            n.trail[t].life--;
            if (n.trail[t].life <= 0) n.trail.splice(t, 1);
        }

        if (n.life <= 0 || n.x < -100 || n.x > canvas.width + 100 || n.y < -100 || n.y > canvas.height + 100) {
            neuroNeedles.splice(i, 1);
            continue;
        }

        // [최적화] 충돌 체크 (제곱 거리)
        const dx = player.x - n.x;
        const dy = player.y - n.y;
        const distSq = dx * dx + dy * dy;
        const hitRadius = player.radius + n.radius;

        if (distSq < hitRadius * hitRadius) {
            if (player.invincibleTimer > 0) {
                neuroNeedles.splice(i, 1);
                continue;
            }
            
            let dmg = 7 + Math.floor(score * 0.12);
            takeDamage(dmg, 'direct', n.accuracy, n);
            
            addStatus('paralysis', 900, 10);
            if (player.paralysisTimers.length >= 10) {
                player.paralysisTimers = [];
                player.rootTimer = 120;
                showPickupEffect(player.x, player.y, "몸이 굳었다!!", false, true, "evil-purple-text");
            } else {
                showPickupEffect(player.x, player.y, "마비..", false, false, "weak-text");
            }
            updateStatusUI();
            neuroNeedles.splice(i, 1);
        }
    }
}
        
        function updateChaosOrbs() {
    for (let i = chaosOrbs.length - 1; i >= 0; i--) {
        const orb = chaosOrbs[i];
        
        // 유도 움직임
        const angle = Math.atan2(player.y - orb.y, player.x - orb.x);
        orb.vx = Math.cos(angle) * orb.speed;
        orb.vy = Math.sin(angle) * orb.speed;
        
        orb.x += orb.vx;
        orb.y += orb.vy;
        orb.life--;

        if (orb.life <= 0) { chaosOrbs.splice(i, 1); continue; }

        // [최적화] 충돌 체크 (제곱 거리)
        const dx = player.x - orb.x;
        const dy = player.y - orb.y;
        const distSq = dx * dx + dy * dy;
        const hitRadius = player.radius + orb.radius;

        if (distSq < hitRadius * hitRadius) {
            if (player.invincibleTimer <= 0) {
                let dmg = 25 + Math.floor(score * 0.2);
                takeDamage(dmg, 'direct', orb.accuracy, orb);
                
                if (!checkShieldBlockStatus()) {
                    addStatus('darkness', 360, 1);
                    showPickupEffect(player.x, player.y, "암흑♥", false, true, "darkness-border");
                }
                chaosOrbs.splice(i, 1);
            }
        }
    }
}
        function updateShockwaves() {
        for (let i = shockwaves.length - 1; i >= 0; i--) {
        const sw = shockwaves[i];
        sw.radius += sw.speed; // 반경 확장
        sw.alpha -= sw.fade;   // 투명도 감소
        
        if (sw.alpha <= 0) {
            shockwaves.splice(i, 1); // 투명해지면 배열에서 제거
        }
    }
}

function updateItems() {
    for (let i = items.length - 1; i >= 0; i--) {
        const item = items[i];

        // 자석 효과 이동 로직
        if (item.isMagnetized) {
            const angle = Math.atan2(player.y - item.y, player.x - item.x);
            const speed = 15;
            item.x += Math.cos(angle) * speed;
            item.y += Math.sin(angle) * speed;
        }

        const dist = Math.hypot(player.x - item.x, player.y - item.y);
        
        // 플레이어와 아이템 충돌 시
        if (dist < player.radius + item.radius) {

            if (item.type === 'health') {
                // [수정 핵심] healAmount 변수 선언을 가장 먼저 수행합니다.
                let healAmount = player.maxHealth * 0.35;

                // 1. 출혈 체크 (이제 healAmount가 존재하므로 에러가 나지 않습니다)
                if (player.bleedingTimers.length > 0) {
                    let bleedReduction = player.bleedingTimers.length * 0.02;
                    healAmount *= (1 - bleedReduction);
                }

                // 2. 신성 모독 체크 (회복 불가)
                if (player.blasphemyTimers.length > 0) {
                    showPickupEffect(player.x, player.y, "신성 모독!! (회복 불가)", false, true, "corrupted-text");
                    player.stunTimer = 120; // 2초 기절
                    items.splice(i, 1);
                    return;
                }

                // 3. 혈청 오염 체크 (회복 불가)
                if (player.serumContaminationTimers && player.serumContaminationTimers.length > 0) {
                    showPickupEffect(player.x, player.y, "혈청 오염! (회복 불가)", false, true, "corrupted-text");
                    items.splice(i, 1);
                    return;
                }

                // 4. 시간 경과/점수 비례 감소 계산
                const reductionRate = 0.0075;
                let timeReduction = Math.floor(score / 10) * reductionRate;
                timeReduction = Math.min(0.9, timeReduction);
                healAmount *= (1 - timeReduction);

                // 5. 좀먹는 생명 (회복량 감소)
                if (player.gnawingLifeTimers.length > 0) {
                    const reduction = player.gnawingLifeTimers.length * 0.03;
                    healAmount *= (1 - reduction);
                }

                // 6. 군주의 위엄 (회복량 10% 감소)
                if (player.majestyActive) {
                    healAmount *= 0.9;
                }

                // 최소 회복량 보장 및 적용
                if (healAmount < 1) healAmount = 1;

                player.health = Math.min(player.maxHealth, player.health + healAmount);
                player.invincibleTimer = 60;
                showPickupEffect(item.x, item.y, `HP회복(+${Math.floor(healAmount)}) & 무적!`);
                updateHealthUI();

            } else if (item.type === 'berserk') {
                player.berserkTimer = 600;
                player.weapon.autoAttackInterval = player.weapon.baseAutoAttackInterval / 1.5;
                berserkStatus.style.display = 'flex';
                showPickupEffect(item.x, item.y, "베르세르크!", false);

            } else if (item.type === 'white') {
                // ... (기존 화이트 아이템 로직 그대로 유지)
                const debuffKeys = [
                    'poisonTimers', 'poopPoisonTimers', 'maliceTimers', 'kissTimers',
                    'semenTimers', 'oralTimers', 'byururutTimers', 'darknessTimers', 'fishyTimers'
                ];
                let healPower = 15;
                let totalHealed = 0;

                while (healPower > 0) {
                    const activeDebuffs = debuffKeys.filter(key => player[key] && player[key].length > 0);
                    if (activeDebuffs.length === 0) break;
                    const targetKey = activeDebuffs[Math.floor(Math.random() * activeDebuffs.length)];
                    const countToRemove = Math.min(healPower, player[targetKey].length);
                    
                    player[targetKey].sort((a, b) => a - b);
                    player[targetKey].splice(0, countToRemove);
                    
                    healPower -= countToRemove;
                    totalHealed += countToRemove;
                }

                if (totalHealed > 0) {
                    showPickupEffect(item.x, item.y, `연쇄 정화! (-${totalHealed})`, false);
                } else {
                    showPickupEffect(item.x, item.y, "정화 완료!", false);
                }
                updateStatusUI();
                updatePoopVisual();

            } else if (item.type === 'shield') {
                player.shieldStacks += 10;
                updateStatusUI();
                showPickupEffect(item.x, item.y, "보호막 +10", false);

            } else if (item.type === 'justice') {
                if (player.evilMindTimers.length > 0) {
                    player.evilMindTimers.sort((a, b) => a - b);
                    player.evilMindTimers.splice(0, 2);
                }
                player.justiceShield += 5;
                updateMaxHealth();
                updateStatusUI();
                showPickupEffect(item.x, item.y, "정의 구현!", false);

            } else if (item.type === 'ancientScroll') {
                // [신규] 고대의 두루마리: 레벨업 카드 리로드 기회 +1
                rerollCount++;
                showPickupEffect(item.x, item.y, "고대의 두루마리! (리로드 +1)", false, true, "justice-border");
            } else if (item.type === 'fakeHealth') {
                let fakeDamage = 12 + Math.floor(score * 0.17);
                takeDamage(fakeDamage, 'direct', item.accuracy, item);
                player.stunTimer = 60;
                showPickupEffect(player.x, player.y, "가짜였다!!", false, true, "weak-text");

            } else if (item.type === 'magnet') {
                items.forEach(otherItem => {
                    if (otherItem !== item && otherItem.type !== 'health' && otherItem.type !== 'magnet') {
                        otherItem.isMagnetized = true;
                    }
                });
                showPickupEffect(item.x, item.y, "자석 발동!", true);
            }

            // 타락한 정의(Corrupted Justice)에 의한 아이템 무효화 이펙트
            if (player.corruptedJusticeStacks > 0) {
                updateStatusUI();
                showPickupEffect(item.x, item.y, "정의에 의해 무효화!", false, true, "item-nullified-text");
            }

            // 아이템 제거
            items.splice(i, 1);
        }
    }
}
        
 function updateEnemies() {
    const ecstasyFlatBonus = player.darkEcstasyTimers.length * 0.8;
    const speedMultiplier = (1 + (player.kissTimers.length * 0.02));
    const activeTetora = enemies.find(e => e.isTetora && e.hp > 0);
    const isRhapsodyActive = activeTetora && activeTetora.currentSong === 'rhapsody' && activeTetora.songTimer > 0;

    // [최적화] 성역(가웨인) 범위 카운트는 매 프레임이 아니라 N프레임마다 갱신
    if (frameCount % GAWAIN_SANCTUARY_STRIDE === 0) {
        enemies.forEach(e => e.gawainSanctuaryCount = 0);
    }

    let attachedRapistCount = 0;
    let taroExists = false; 

    for (let i = enemies.length - 1; i >= 0; i--) {
        const enemy = enemies[i];
        const _preX = enemy.x;
        const _preY = enemy.y;
        // [신규] 적 상태이상 저항: 25초마다 +1%p
        enemy.statusResist = (enemy.baseStatusResist || 0) + Math.floor(score / 25) * 0.01;

    // =========================================================
        // [수정] 명중률 실시간 갱신 로직 (score 스케일 + 광시곡 버프)
        // =========================================================
        
        // 1. 기본 명중률 보존
        if (enemy.baseAccuracy === undefined) {
            enemy.baseAccuracy = enemy.accuracy || 0;
        }

        // =========================================================
        // [신규] 치명타 확률/치명타 저항 실시간 갱신 로직 (score 기반 스케일)
        //  - baseCritChance/baseCritResist를 보존하고 매 프레임 재계산
        // =========================================================
        if (enemy.baseCritChance === undefined) {
            enemy.baseCritChance = enemy.critChance || 0;
        }
        if (enemy.baseCritResist === undefined) {
            enemy.baseCritResist = enemy.critResist || 0;
        }
        const timeCritBonus = Math.floor(score / 10) * 0.7;
        enemy.critChance = enemy.baseCritChance + timeCritBonus;
        enemy.critResist = enemy.baseCritResist + timeCritBonus;

        let accuracyBonus = (score / 10) * 0.007;

        if (enemy.erectionStacks > 0) {
            let accPerStack = 0.005 + (score / 15000);
            let stackBonus = enemy.erectionStacks * accPerStack;
            let timeBonus = (score / 10) * 0.005;
            accuracyBonus += (stackBonus + timeBonus);
        }

        if (isRhapsodyActive && !enemy.isTetora) {
            accuracyBonus += 0.15;
        }

        enemy.accuracy = enemy.baseAccuracy + accuracyBonus;
        // 1. 심연의 공명 처리
        if (enemy.hasAbyssalResonance) {
            enemy.resonanceDuration--; 
            if (enemy.resonanceDuration <= 0) {
                enemy.hasAbyssalResonance = false;
            }
        }

        // 2. 타로(Taro) 관련 로직
        if (enemy.isTaro) taroExists = true;
        
        if (enemy.isTaro) {
            if (enemy.deathGripActive) {
                enemy.deathGripDuration--;
                player.skillSealTimer = 10; // 스킬 봉인 상태 유지

                // 사슬 연결 거리 제한 (650px)
                const dist = Math.hypot(player.x - enemy.x, player.y - enemy.y);
                const maxDist = 650;
                
                // 플레이어가 일정 거리 이상 멀어지면 타로 쪽으로 끌려감
                if (dist > maxDist) {
                    const angle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
                    player.x = enemy.x + Math.cos(angle) * maxDist;
                    player.y = enemy.y + Math.sin(angle) * maxDist;
                }

                const damagePerSec = 4 + (score * 0.04);
                const dmg = damagePerSec / 60;

                // 데스 그립 명중/회피 로직
                // 공식: 100% - (플레이어 회피율 - 적 명중률)
                let hitChance = 1.0 - (player.bonusEvasion - enemy.accuracy);
                
                if (Math.random() < hitChance) {
                    takeDamage(dmg, 'dot');
                } else {
                    // 회피 성공 시 (텍스트 도배 방지를 위해 1초에 한 번만 표시)
                    if (frameCount % 60 === 0) {
                        showDamageText(player.x, player.y, "DODGE", false, false, "weak-text");
                    }
                }

                // 지속시간 종료
                if (enemy.deathGripDuration <= 0) {
                    enemy.deathGripActive = false;
                    enemy.deathGripTimer = 0;
                }
            } else {
                // 쿨타임 진행
                enemy.deathGripTimer++;
                if (enemy.deathGripTimer >= 600) { // 10초
                    enemy.deathGripActive = true;
                    enemy.deathGripDuration = 480; // 8초
                    showPickupEffect(enemy.x, enemy.y - 60, "데스 그립!", false, false, "wicked-large-text");
                }
            }
        }
        
        // 3. [핵심 수정] 기절(Stun) 처리 로직
        if (enemy.stunTimer > 0) {
            enemy.stunTimer--;
            // 수정됨: 적이 살아있을 때만(HP > 0) 행동을 건너뜁니다.
            // HP가 0 이하라면 continue를 하지 않아, 아래쪽의 사망 처리 코드가 실행됩니다.
            if (enemy.hp > 0) {
                // [v13] 가웨인의 '잔혹한 돌진' 차지/돌진 중에는 기절로 패턴이 끊기지 않도록 예외 처리
                const ignoreStun = enemy.isGawain && (enemy.isCruelChargeCharging || enemy.isCruelCharging);
                if (!ignoreStun) {
                    continue;
                } else {
                    // 차지/돌진 중에는 스턴을 사실상 무시(이동/전환을 막지 않음)
                    enemy.stunTimer = 0;
                }
            }
        }

// 4. 모놀리스(Monolith) 가스 패턴
        if (enemy.isMonolith) {
            enemy.vx = 0; enemy.vy = 0; // 위치 절대 고정
            
            // 가스 타이머 증가 (초기화 안전장치 포함)
            enemy.gasTimer = (enemy.gasTimer || 0) + 1;
            
            // 가스 방출
            if (enemy.gasTimer >= 150) {
                // 1. 비석 주변 (크게)
                spawnDarkGas(enemy.x, enemy.y, 1.5, 1.0, enemy.accuracy, 0, enemy);
                // 2. 플레이어 위치 (중간)
                spawnDarkGas(player.x, player.y, 1.5, 1.0, enemy.accuracy, 0, enemy);
                
                enemy.gasTimer = 0;
            }
        }

                // [추가] 심연의 공명 효과 발동 로직
// 적이 '공명' 상태(hasAbyssalResonance)이고 플레이어와 접촉했을 때
if (enemy.hasAbyssalResonance) {
    // 플레이어와의 거리 계산
    const dist = Math.hypot(player.x - enemy.x, player.y - enemy.y);
    
    // 충돌 판정 (반지름 합 + 약간의 여유)
    if (dist < player.radius + enemy.radius) {
        // 1. 최대 체력의 15% 계산
        let healAmount = Math.floor(enemy.maxHp * 0.15);
        // (선택) 회복률 보정이 있다면 적용
        healAmount = Math.floor(healAmount * (enemy.hpRecoveryRate || 1));
        
        // 2. 체력 회복 적용
        enemy.hp = Math.min(enemy.maxHp, enemy.hp + healAmount);
        
        // 3. 시각 효과 (텍스트 및 이펙트)
        showDamageText(enemy.x, enemy.y, "+" + healAmount, false, false, "heal-text");
        showPickupEffect(enemy.x, enemy.y - 30, "공명 흡수!", false, true, "pink-text");
        
        // 4. 버프 소모 처리 (중복 발동 방지)
        enemy.hasAbyssalResonance = false; 
        enemy.usedAbyssalResonance = true; // 재부여 방지용 플래그
    }
}     
                
                // [신규] 카인 전용 스킬 로직 (아서/아키토/토우야가 아닌 순수 카인)
            if (enemy.isBoss && !enemy.isArthur && !enemy.isArchdemon) {
                // 1. 가스 익스플로젼
                enemy.gasExplosionTimer--;
                if (enemy.gasExplosionTimer <= 0) {
                    enemy.gasExplosionTimer = 900; // 쿨타임 리셋
                    spawnGasExplosionPattern(enemy.accuracy, enemy);    // 패턴 발동 함수 호출
                    showPickupEffect(enemy.x, enemy.y - 100, "냄새 폭발♥", false, true, "wicked-large-text");
                }

              // 2. 악마의 보호 (쿨타임 14초, 지속 10초)
                // 지속시간 체크 및 해제
                if (enemy.protectionTarget) {
                    enemy.devilsProtectionDuration--;
                    
                    // 지속시간 종료되거나 대상이 죽으면 해제
                    if (enemy.devilsProtectionDuration <= 0 || enemy.protectionTarget.hp <= 0) {
                        if (enemy.protectionTarget.hp > 0) {
                            enemy.protectionTarget.isProtectedByCain = false; // 대상의 플래그 해제
                            showPickupEffect(enemy.protectionTarget.x, enemy.protectionTarget.y - 60, "보호 해제", false, true, "weak-text");
                        }
                        enemy.protectionTarget = null; // 타겟 참조 제거
                    }
                }

                // 쿨타임 체크 및 발동
                enemy.devilsProtectionTimer--;
                if (enemy.devilsProtectionTimer <= 0) {
                    enemy.devilsProtectionTimer = 840; // 14초 쿨타임 리셋
                    
                    // 아키토나 토우야 찾기
                    let candidates = enemies.filter(e => e.isArchdemon && e.hp > 0);
                    if (candidates.length > 0) {
                        // 이미 보호중인 대상이 있다면 해제 후 재시전 (혹은 갱신)
                        if (enemy.protectionTarget) {
                            enemy.protectionTarget.isProtectedByCain = false;
                        }

                        // 랜덤 선택
                        let target = candidates[Math.floor(Math.random() * candidates.length)];
                        enemy.protectionTarget = target;
                        enemy.devilsProtectionDuration = 600; // [설정] 지속시간 10초 (60프레임 * 10)
                        
                        target.isProtectedByCain = true; // 타겟에게 보호 플래그 설정
                        target.protectionVisualTimer = 120; // 시각 효과용
                        showPickupEffect(target.x, target.y - 60, "악마의 보호!", false, true, "shield-border");
                    }
                }

                // 3. 이블 다이제스트 (20초 쿨타임, 16초 지속)
                if (enemy.isEvilDigestActive) {
                    enemy.evilDigestDuration--;
                    if (enemy.evilDigestDuration <= 0) {
                        enemy.isEvilDigestActive = false;
                        showPickupEffect(enemy.x, enemy.y - 60, "소화 끝..", false);
                    } else {
                        // 아이템 흡수 로직
                        for (let k = items.length - 1; k >= 0; k--) {
                            let it = items[k];
                            let d = Math.hypot(enemy.x - it.x, enemy.y - it.y);
                            if (d < (enemy.radius * 1.25) + it.radius + 100) {
                                items.splice(k, 1); // 아이템 삭제
                                // 효과: 유도 똥 발사 + 플레이어 발밑 다크가스
                                spawnDarkBigPoop(enemy.x, enemy.y, false, 0, true, enemy.accuracy, enemy);
                                spawnDarkGas(player.x, player.y, 3.0, 1.0, enemy.accuracy, 0, enemy);
                                showPickupEffect(enemy.x, enemy.y, "꺼억~♥", false, true, "poop-text");
                            }
                        }
                    }
                } else {
                    enemy.evilDigestTimer--;
                    if (enemy.evilDigestTimer <= 0) {
                        enemy.evilDigestTimer = 1200;
                        enemy.isEvilDigestActive = true;
                        enemy.evilDigestDuration = 960; 
                        showPickupEffect(enemy.x, enemy.y - 80, "먹고 껴주마..♥", false, true, "corrupted-text");
                    }
                }
            }

                // [신규] 아서 전용 패턴 로직
                if (enemy.isArthur) {
                    // 스킬 1: 블러드 드레인 (쿨타임 8초)
                    enemy.bloodDrainTimer = (enemy.bloodDrainTimer || 0) + 1;
                    if (enemy.bloodDrainTimer >= 480) {
        spawnBloodBat(enemy.x, enemy.y, enemy, enemy.accuracy); // [수정]
        showPickupEffect(enemy.x, enemy.y - 60, "피를 바쳐라!", false, false, "arthur-text");
        enemy.bloodDrainTimer = 0;
                    }
                    
                    // 스킬 2: 엑스칼리버 모르간 (쿨타임 9초)
                    enemy.excaliburTimer = (enemy.excaliburTimer || 0) + 1;
                    if (enemy.excaliburTimer >= 540) {
        const angle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
        spawnExcaliburSlash(enemy.x, enemy.y, angle, enemy.accuracy, enemy); // [수정]
        showPickupEffect(enemy.x, enemy.y - 60, "척살..", false, true, "arthur-text");
        enemy.excaliburTimer = 0;
                    }
                    
                    // 스킬 3: 블러드 스웜 (쿨타임 10초)
                    enemy.bloodSwarmTimer = (enemy.bloodSwarmTimer || 0) + 1;
                    if (enemy.bloodSwarmTimer >= 600) {
        spawnBloodPuddle(player.x, player.y, enemy, enemy.accuracy); // [수정]
        showPickupEffect(player.x, player.y - 40, "피바다♥", false, false, "arthur-text");
        enemy.bloodSwarmTimer = 0;
                    }
                    
                    // 소환 패턴
                    // 1. 등장 7초 후 (420프레임)
                    if (enemy.initialSummonTimer > 0) {
                        enemy.initialSummonTimer--;
                    if (enemy.initialSummonTimer <= 0) {
                        spawnEnemy(true, 'Ryuon', 0, canvas.height / 2);
                        spawnEnemy(true, 'Gawain', canvas.width, canvas.height / 2);
                           
                             showPickupEffect(enemy.x, enemy.y - 80, "나의 기사들이여!", false, true, "arthur-text");
                        }
                    }
                    
                    // 2. 50초마다 (3000프레임)
                    enemy.arthurSummonTimer = (enemy.arthurSummonTimer || 0) + 1;
                    if (enemy.arthurSummonTimer >= 3000) {
                        spawnEnemy(true, 'Ryuon', 0, canvas.height / 2);
                        spawnEnemy(true, 'Gawain', canvas.width, canvas.height / 2);
                        
                        showPickupEffect(enemy.x, enemy.y - 80, "일어나라!!", false, true, "arthur-text");
                        enemy.arthurSummonTimer = 0;
                    }
               }

                // [신규] 루카 패턴: 악의의 탄도
        if (enemy.isLuca) {
            enemy.maliceBallisticTimer = (enemy.maliceBallisticTimer || 0) + 1;
            if (enemy.maliceBallisticTimer >= 600) { // 쿨타임 10초 (600프레임)
                const baseAngle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
                // 3발 발사 (부채꼴 형태)
                for (let k = -1; k <= 1; k++) {
                    const angle = baseAngle + (k * 0.25); // 약간 퍼지게 발사
                    spawnMaliceBallistic(enemy.x, enemy.y, angle, enemy.accuracy, enemy);
                }
                showPickupEffect(enemy.x, enemy.y - 60, "헤헤헤♥", false, true, "malice-text");
                enemy.maliceBallisticTimer = 0;
            }
        }

                if (enemy.isRyuon) {
                 if (enemy.firmDarknessActive > 0) {
                    enemy.firmDarknessActive--;
                    const darknessRange = enemy.radius * 2.0; // 마법진 크기 (가웨인과 동일 비율)

                    // 범위 내 아군 버프 부여 (매 프레임 체크)
                    enemies.forEach(ally => {
                        // 살아있는 다른 아군 (자신 포함 or 제외 선택 가능, 여기선 자신도 포함됨)
                        if (ally.hp > 0) { 
                            const dist = Math.hypot(enemy.x - ally.x, enemy.y - ally.y);
                            
                            // 범위 안이고, 아직 버프가 없다면 부여
                            if (dist < darknessRange) {
                                // [Firm Darkness][수정] score(초) 기반 방어 버프 스케일: 50초에 약 +3.5 (기본 1.5 + 0.04/초)
                                const firmDarknessDefenseBonus = 1.5 + (score * 0.04);

                                if (!ally.firmDarknessBuffed) {
                                    ally.defense += firmDarknessDefenseBonus;
                                    ally.firmDarknessDefenseBonus = firmDarknessDefenseBonus;
                                    ally.critResist = (ally.critResist || 0) * 1.2; // 치명타 저항 확률 20% 증가 (곱연산)
                                    ally.firmDarknessBuffed = true;

                                    // (선택) 버프 받는 순간 이펙트
                                    // showDamageText(ally.x, ally.y, "▲", false, false, "heal-text"); 
                                } else {
                                    // 시간이 지나 보너스가 변하면 차이만큼만 보정 (다른 버프와 충돌 최소화)
                                    const prevBonus = ally.firmDarknessDefenseBonus || 0;
                                    const delta = firmDarknessDefenseBonus - prevBonus;
                                    if (Math.abs(delta) > 1e-6) {
                                        ally.defense += delta;
                                        ally.firmDarknessDefenseBonus = firmDarknessDefenseBonus;
                                    }
                                }
                            } 
                            // 범위 밖으로 나갔는데 버프가 있다면 즉시 해제
                            else {
                                if (ally.firmDarknessBuffed) {
                                    const prevBonus = ally.firmDarknessDefenseBonus || 0;
                                    ally.defense -= prevBonus;
                                    ally.firmDarknessDefenseBonus = 0;
                                    ally.critResist /= 1.2; // 치명타 저항 확률 원상복구
                                    ally.firmDarknessBuffed = false;
                                }
                            }
                        }
                    });
                } 
                // 2. 스킬 비활성 (쿨타임) 상태일 때
                else {
                    // 스킬이 막 끝난 직후라면, 남아있는 모든 아군의 버프 강제 해제 (안전장치)
                    if (enemy.firmDarknessBuffApplied) {
                        enemies.forEach(ally => {
                            if (ally.firmDarknessBuffed) {
                                const prevBonus = ally.firmDarknessDefenseBonus || 0;
                                ally.defense -= prevBonus;
                                ally.firmDarknessDefenseBonus = 0;
                                ally.critResist /= 1.2;
                                ally.firmDarknessBuffed = false;
                            }
                        });
                        enemy.firmDarknessBuffApplied = false; // 해제 완료 플래그
                    }

                    // 쿨타임 진행
                    enemy.firmDarknessTimer = (enemy.firmDarknessTimer || 0) + 1;
                    
                    if (enemy.firmDarknessTimer >= 840) { 
                        // 스킬 발동!
                        enemy.firmDarknessActive = 600; // 지속 10초 (600프레임)
                        enemy.firmDarknessTimer = 0;
                        enemy.firmDarknessBuffApplied = true; // 버프 관리 시작 플래그

                        showPickupEffect(enemy.x, enemy.y - 80, "굳건한 어둠!", false, true, "shadow-text");
                    }
                }

                // 쿨타임 15초 (900프레임)
                 enemy.abyssalResonanceTimer = (enemy.abyssalResonanceTimer || 0) + 1;
    
           if (enemy.abyssalResonanceTimer >= 900) {
        // 시전 텍스트
        showPickupEffect(enemy.x, enemy.y - 60, "공명하라!", false, true, "evil-purple-text");
        
        // 주변 아군(본인 제외)에게 버프 부여
        let buffCount = 0;
        enemies.forEach(ally => {
            if (ally !== enemy && ally.hp > 0 && !ally.isAttached) {
                const dist = Math.hypot(enemy.x - ally.x, enemy.y - ally.y);
                // 범위 350px 내의 아군
                if (dist < 350) {
                    // 이미 버프가 있거나 효과를 본 적이 없는 경우에만 부여 (개개인 1회 제한을 위해 flag 사용)
                    if (!ally.hasAbyssalResonance && !ally.usedAbyssalResonance) {
                        ally.hasAbyssalResonance = true; 
                        ally.resonanceDuration = 360;
                        buffCount++;
                        // 시각 효과 (간단한 이펙트 추가)
                        showDamageText(ally.x, ally.y, "공명", false, false, "evil-purple-text");
                    }
                }
            }
        });

        // 버프를 받은 아군이 1명이라도 있으면 효과음 등 추가 가능
        if (buffCount > 0) {
             // (선택) 효과음 재생 코드 추가
        }

        enemy.abyssalResonanceTimer = 0;
    }
}

                if (enemy.isAki) {
                    enemy.dragShotTimer++;
                   if (enemy.dragShotTimer >= 600) {
        spawnDragShot(enemy.x, enemy.y, enemy.angle, enemy.accuracy, enemy);
        showPickupEffect(enemy.x, enemy.y - 40, "이리와♥", false, false, "choke-text");
        enemy.dragShotTimer = 0;
                    }

                    enemy.evilArrowTimer++;
                    if (enemy.evilArrowTimer >= 480) {
        spawnEvilArrow(enemy.x, enemy.y, enemy.angle, enemy.accuracy, enemy);
        // 본체 회피 (옆으로 빠르게 대시) - 발사 직후
        const dashAngle = enemy.angle + (Math.random() < 0.5 ? Math.PI/2 : -Math.PI/2);
        enemy.dashTimer = 20; // 20프레임 동안 대시
        enemy.dashVx = Math.cos(dashAngle) * 15;
        enemy.dashVy = Math.sin(dashAngle) * 15;
        showPickupEffect(enemy.x, enemy.y - 40, "가려주마♥", false, false, "evil-purple-text");
        enemy.evilArrowTimer = 0;
                    }

                    enemy.poisonousShotTimer = (enemy.poisonousShotTimer || 0) + 1;
                    if (enemy.poisonousShotTimer >= 540) {
        spawnPoisonousShot(enemy.x, enemy.y, enemy.angle, enemy.accuracy, enemy);
        // 본체 회피 (옆으로 빠르게 대시) - 발사 직후
        const dashAngle = enemy.angle + (Math.random() < 0.5 ? Math.PI/2 : -Math.PI/2);
        enemy.dashTimer = 20; // 20프레임 동안 대시
        enemy.dashVx = Math.cos(dashAngle) * 15;
        enemy.dashVy = Math.sin(dashAngle) * 15;
        showPickupEffect(enemy.x, enemy.y - 40, "포이즈너스 샷♥", false, false, "poop-text");
        enemy.poisonousShotTimer = 0;
                    }

                    enemy.akiSummonTimer++;
                    if (enemy.akiSummonTimer >= 720) {
                        spawnMinionRapist(enemy.x + 30, enemy.y);
                        spawnMinionRapist(enemy.x - 30, enemy.y);
                        showPickupEffect(enemy.x, enemy.y - 60, "덮쳐라♥", false, false, "aki-text");
                        enemy.akiSummonTimer = 0;
                    }

                     enemy.evilKagerouTimer = (enemy.evilKagerouTimer || 0) + 1;
                    if (enemy.evilKagerouTimer >= 1080) {
                        // 1. 제자리에 분신 생성
                        spawnAkiClone(enemy.x, enemy.y, enemy.maxHp, enemy.accuracy, enemy);
                        spawnDarkGas(enemy.x, enemy.y, 3.5, 1.2, enemy.accuracy, 0, enemy);
                        
                        // 2. 본체 회피 (옆으로 빠르게 대시)
                        const dashAngle = enemy.angle + (Math.random() < 0.5 ? Math.PI/2 : -Math.PI/2);
                        enemy.dashTimer = 20; // 20프레임 동안 대시
                        enemy.dashVx = Math.cos(dashAngle) * 15;
                        enemy.dashVy = Math.sin(dashAngle) * 15;
                        
                        // 3. Ghost 이펙트 및 텍스트
                        spawnGhost(enemy.x, enemy.y, enemy.radius, enemy.angle, akiImg, true);
                        showPickupEffect(enemy.x, enemy.y - 80, "방구 분신♥", false, true, "aki-text");
                        
                        enemy.evilKagerouTimer = 0;
                    }
                }
                
                // [신규] 히로 패턴
                if (enemy.isHiro) {
                    if (enemy.antiPassingCharging) {
                        enemy.vx = 0;
                        enemy.vy = 0;
                        spawnJusticeChargeAura(enemy, 'hiroAntiPassing');

                        enemy.antiPassingChargeTimer++;
                        enemy.antiPassingTentacleSpawnTimer = (enemy.antiPassingTentacleSpawnTimer || 0) + 1;

                        if (enemy.antiPassingTentacleSpawnTimer >= 24) {
                            spawnAntiPassingTentacle(enemy);
                            enemy.antiPassingTentacleSpawnTimer = 0;
                        }

                        if ((enemy.antiPassingShield || 0) <= 0) {
                            enemy.antiPassingCharging = false;
                            enemy.antiPassingChargeTimer = 0;
                            enemy.antiPassingShield = 0;
                            enemy.antiPassingShieldMax = 0;
                            enemy.antiPassingTentacleSpawnTimer = 0;
                            enemy.antiPassingTimer = 0;
                            showPickupEffect(enemy.x, enemy.y - 60, "쳇..", false, true, "poop-text");
                        } else if (enemy.antiPassingChargeTimer >= (enemy.antiPassingChargeMax || 360)) {
                            enemy.antiPassingCharging = false;
                            enemy.antiPassingChargeTimer = 0;
                            enemy.antiPassingShield = 0;
                            enemy.antiPassingShieldMax = 0;
                            enemy.antiPassingTentacleSpawnTimer = 0;
                            enemy.antiPassingTimer = 0;
                            showPickupEffect(enemy.x, enemy.y - 60, "솟아라♥", false, true, "poop-text");
                        }
                    } else {
                        enemy.antiPassingTimer = (enemy.antiPassingTimer || 0) + 1;
                        if (enemy.antiPassingTimer >= 960) {
                            enemy.antiPassingCharging = true;
                            enemy.antiPassingChargeTimer = 0;
                            enemy.antiPassingTentacleSpawnTimer = 0;
                            enemy.antiPassingShieldMax = Math.max(1, Math.floor(enemy.maxHp * 0.50));
                            enemy.antiPassingShield = enemy.antiPassingShieldMax;
                            enemy.antiPassingTimer = 0;
                            showPickupEffect(enemy.x, enemy.y - 65, "솟아라♥♥", false, true, "poop-text");
                        }

                        // 재밍 신호
                        enemy.jammingTimer = (enemy.jammingTimer || 0) + 1;
                        if (enemy.jammingTimer >= 420) {
            const angle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
            spawnJammingWave(enemy.x, enemy.y, angle, enemy.accuracy, enemy); // [수정]
            showPickupEffect(enemy.x, enemy.y - 50, "치지직..", false, false, "evil-purple-text");
                            enemy.jammingTimer = 0;
                        }

                        // 신경 독바늘 (5갈래)
                        enemy.needleTimer = (enemy.needleTimer || 0) + 1;
                       if (enemy.needleTimer >= 240) {
            const baseAngle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
            for (let k = -2; k <= 2; k++) {
                const angle = baseAngle + (k * 0.08);
                spawnNeuroNeedle(enemy.x, enemy.y, angle, enemy.accuracy, enemy); // [수정]
            }
            showPickupEffect(enemy.x, enemy.y - 40, "마비돼라!", false, false, "paralysis-border");
            enemy.needleTimer = 0;
                        }

                        if (enemy.blackHolyBloodTimer > 0) {
                        enemy.blackHolyBloodTimer--;
                    } else {
                        // 스킬 발사!
                        spawnBlackHolyBlood(enemy.x, enemy.y, enemy.accuracy, enemy);
                        enemy.blackHolyBloodTimer = 720; // 쿨타임 12초 리셋
                    }

                        // 공작원 소환 (8초마다)
                        enemy.hiroSummonTimer = (enemy.hiroSummonTimer || 0) + 1;
                        if (enemy.hiroSummonTimer >= 480) {
                            for(let k=0; k<2; k++) {
                                const spawnX = enemy.x + (Math.random() - 0.5) * 100;
                                const spawnY = enemy.y + (Math.random() - 0.5) * 100;

                                // 랜덤 공작원 타입 결정
                                const rand = Math.random();
                                let aType = 'blind';
                                if (rand < 0.33) aType = 'curse';
                                else if (rand < 0.66) aType = 'pain';

                                // spawnEnemy 함수를 변형하여 공작원 직접 생성
                                // 여기서는 직접 객체를 만들어 푸시하는게 안전함
                                let hp = 45;
                                let defense = Math.floor(score * 0.07);
                                const hpMultiplier = 1 + (score / 100 * 1.6);
                                hp = Math.floor(hp * hpMultiplier);
const agent = {
                                    x: spawnX, y: spawnY, radius: 35, baseRadius: 35,
                                    baseSpeed: (0.6 + Math.random() * 0.6) * 1.5, speed: 0, vx: 0, vy: 0,
                                    critChance: 25, critResist: 15,
                                    gasTimer: Math.random() * 240, gasInterval: 240, bigPoopTimer: 0, scatterTimer: 0, whiteShotTimer: 0,
                                    angle: 0, isElite: false, isZako: false, isAgent: true, agentType: aType,
                                    maxHp: hp, hp: hp, defense: defense,
                                    hitFlash: 0, erectionStacks: 0, erectionTimer: 0, passiveErectionTimer: 0, contactStackTimer: 0,
                                    buffType: -1, eliteType: -1, alpha: 1.0, dashTimer: 0, dashVx: 0, dashVy: 0,
                                    agentDeathTimer: 900, stunTimer: 0
                                };
                                agent.speed = agent.baseSpeed;
                                enemies.push(agent);
                            }
                            showPickupEffect(enemy.x, enemy.y - 60, "처리해라.", false, false, "hiro-text");
                            enemy.hiroSummonTimer = 0;
                        }
                    }
                }
                
                if (enemy.isKai) {
                    // 1. 그림자 망토 (패시브): 6초마다 1초 투명
                    enemy.shadowCloakTimer++;
                    if (enemy.isInvisible) {
                        enemy.alpha = 0.2; // 투명화
                        enemy.invisibleDuration--;
                        if (enemy.invisibleDuration <= 0) {
                            enemy.isInvisible = false;
                            enemy.alpha = 1.0;
                            showPickupEffect(enemy.x, enemy.y - 40, "모습을 드러냈다", false);
                        }
                    } else {
                        if (enemy.shadowCloakTimer >= 360) { // 6초 (60fps 기준)
                            enemy.isInvisible = true;
                            enemy.invisibleDuration = 60; // 1초
                            enemy.shadowCloakTimer = 0;
                            showPickupEffect(enemy.x, enemy.y - 40, "그림자 망토", false, false, "shadow-text");
                        }
                    }

                    // [신규] 소울 링크 스킬 로직
            if (enemy.soulLinkTarget) {
                if (enemy.soulLinkDuration > 0) enemy.soulLinkDuration--;
                // 연결된 대상이 죽었거나 사라지면 링크 해제
                if (enemy.soulLinkTarget.hp <= 0 || !enemies.includes(enemy.soulLinkTarget) || enemy.soulLinkTarget.isAttached) {
                    enemy.soulLinkTarget = null;
                    enemy.soulLinkCooldown = 900;
                    showDamageText(enemy.x, enemy.y, "링크 파괴!", false, false, "weak-text");
                } else {
                    // 연결된 동안 지속 회복 (120프레임마다)
                    enemy.soulLinkHealTimer++;
                    if (enemy.soulLinkHealTimer >= 120) {
                        // 기본 10 + 점수(시간)에 따른 추가 회복
                        let heal = 5 + Math.floor(score * 0.05);
                        enemy.hp = Math.min(enemy.maxHp, enemy.hp + heal);
                        showDamageText(enemy.x, enemy.y, "+" + heal, false, false, "heal-text");
                        enemy.soulLinkHealTimer = 0;
                    }
                }
          } else {
                // 쿨타임 감소
                if (enemy.soulLinkCooldown > 0) {
                    enemy.soulLinkCooldown--;
                } else {
                    // 쿨타임 종료 시 타겟 탐색 (엘리트/보스 제외, 살아있는 아군, [추가] 부착되지 않은 적)
                    const candidates = enemies.filter(e => 
                        !e.isElite && 
                        !e.isBoss && 
                        e !== enemy && 
                        e.hp > 0 && 
                        !e.isAttached
                    );

                    if (candidates.length > 0) {
                        // 랜덤 타겟 선정
                        enemy.soulLinkTarget = candidates[Math.floor(Math.random() * candidates.length)];
                        enemy.soulLinkDuration = 540;
                        enemy.soulLinkHealTimer = 0;
                        showPickupEffect(enemy.x, enemy.y - 60, "소울 링크!", false, true, "evil-purple-text");
                    }
                }
            }

                    // 2. 카오스 오브 (10초 쿨타임)
                    enemy.chaosOrbTimer++;
                    if (enemy.chaosOrbTimer >= 600) {
        spawnChaosOrb(enemy.x, enemy.y, enemy.accuracy, enemy); // [수정]
        showPickupEffect(enemy.x, enemy.y - 50, "가려주마♥", false, false, "evil-purple-text");
        enemy.chaosOrbTimer = 0;
    }

                    // 3. 그림자 스왑 (15초 쿨타임) - 4초 차지 + 보호막(최대HP 30%), 보호막 파괴 시 취소
                    if (enemy.shadowSwapCharging) {
                        // 차지 중에는 이동 멈춤
                        enemy.vx = 0; enemy.vy = 0;

                        // 류온 정의의 돌진 차지 이펙트 재사용(핑크 테마)
                        spawnJusticeChargeAura(enemy, 'kaiSwap');

                        enemy.shadowSwapChargeTimer++;

                        // 보호막이 깨졌으면 즉시 취소
                        if ((enemy.shadowSwapShield || 0) <= 0) {
                            enemy.shadowSwapCharging = false;
                            enemy.shadowSwapChargeTimer = 0;
                            enemy.shadowSwapShield = 0;
                            enemy.shadowSwapShieldMax = 0;

                            // 쿨타임은 다시 시작
                            enemy.shadowSwapTimer = 0;

                            showPickupEffect(enemy.x, enemy.y - 60, "보호막 파괴! 스왑 취소", false, true, "dirty-pink-text");
                        }
                        // 차지 완료 -> 원래 그림자 스왑 발동
                        else if (enemy.shadowSwapChargeTimer >= (enemy.shadowSwapChargeMax || 240)) {
                            const oldPlayerX = player.x;
                            const oldPlayerY = player.y;

                            // 위치 교환
                            player.x = enemy.x;
                            player.y = enemy.y;
                            enemy.x = oldPlayerX;
                            enemy.y = oldPlayerY;

                            spawnDarkGas(player.x, player.y, 4, 1.0, enemy.accuracy, 0, enemy);

                            // 정신착란 디버프 부여 (5초)
                            addStatus('confusion', 300, 1);
                            showPickupEffect(player.x, player.y, "위치 교환! (정신착란)", false, true, "confusion-border");

                            // 정리
                            enemy.shadowSwapCharging = false;
                            enemy.shadowSwapChargeTimer = 0;
                            enemy.shadowSwapShield = 0;
                            enemy.shadowSwapShieldMax = 0;
                            enemy.shadowSwapTimer = 0;
                        }
                    } else {
                        enemy.shadowSwapTimer++;
                        if (enemy.shadowSwapTimer >= 900) {
                            // 차지 시작
                            enemy.shadowSwapCharging = true;
                            enemy.shadowSwapChargeTimer = 0;
                            enemy.shadowSwapChargeMax = 240; // 4초(60fps)
                            enemy.shadowSwapShieldMax = Math.max(1, Math.floor(enemy.maxHp * 0.40));
                            enemy.shadowSwapShield = enemy.shadowSwapShieldMax;

                            // 쿨타임은 차지 시작 시 리셋(취소/발동 후 다시 15초)
                            enemy.shadowSwapTimer = 0;

                            showPickupEffect(enemy.x, enemy.y - 60, "그림자 스왑 차지...", false, true, "dirty-pink-text");
                        }
                    }
                }
                
                if (enemy.isJacques) {
                // 1. 사악한 아드레날린
                enemy.jacquesAdrenalineTimer++;
                if (enemy.jacquesAdrenalineTimer >= 480) {
                    let target = null;
                    let minDist = 99999;
                    // 가장 가까운 강간범 or 소환사 찾기
                    enemies.forEach(ally => {
                        if (ally !== enemy && (ally.normalType === 'rapist' || ally.normalType === 'summoner')) {
                            const d = Math.hypot(enemy.x - ally.x, enemy.y - ally.y);
                            if (d < minDist) { minDist = d; target = ally; }
                        }
                    });

                    if (target) {
                        // 버프 부여: 크기 1.5배, 이속 1.5배, 슈퍼아머
                        target.radius *= 1.5;
                        target.baseSpeed *= 1.5;
                        target.speed *= 1.5;
                        target.isSuperArmor = true; // 넉백 면역 플래그 (넉백 로직 수정 필요)
                        enemy.jacquesAdrenalineTimer = 0;
                        showPickupEffect(target.x, target.y - 40, "아드레날린!!", false, true, "berserk-border");
                    }
                }

                // 2. 최음 가스
                enemy.jacquesGasTimer++;
                if (enemy.jacquesGasTimer >= 600) {
                    spawnPinkGas(enemy.x, enemy.y);
                    showPickupEffect(enemy.x, enemy.y - 40, "향긋하지?♥", false, false, "pink-text");
                    enemy.jacquesGasTimer = 0;
                }

                // 3. 어둠의 찬가
                enemy.jacquesHymnTimer++;
                if (enemy.jacquesHymnTimer >= 240) {
                    spawnDarkNote(enemy.x, enemy.y, enemy);
                    enemy.jacquesHymnTimer = 0;
                }
                    if (enemy.pianissimoTimer > 0) {
                       enemy.pianissimoTimer--;
        } else {
        // 12초 쿨타임 (60fps * 12 = 720)
        enemy.pianissimoTimer = 720; 
        
        // 랜덤 장소 3곳에 높은음자리표 소환
        for(let k=0; k<3; k++) {
            const rx = 50 + Math.random() * (canvas.width - 100);
            const ry = 50 + Math.random() * (canvas.height - 100);
            spawnPianissimoSnipe(rx, ry, 0, enemy.accuracy, enemy);
        }
        showPickupEffect(enemy.x, enemy.y - 60, "어둠의 선율..", false, true, "evil-purple-text");
    }
 }
               
               // [신규] 검은 민족 마사쿠니 패턴
                if (enemy.isMasakuni) {
                    // 스킬 사용 중이 아닐 때만 평타 이동 (가스 추진 대쉬) 실행
                    const isUsingSkill = (enemy.flashState !== 'idle') || (enemy.blackMoonState !== 'idle');

                    if (!isUsingSkill) {
                        // 가스 추진 이동 로직
                        if (enemy.moveDashDuration > 0) {
                            // 대쉬 중
                            enemy.x += enemy.dashVx;
                            enemy.y += enemy.dashVy;
                            enemy.moveDashDuration--;
                            
                            // 감속 (마찰력)
                            enemy.dashVx *= 0.95;
                            enemy.dashVy *= 0.95;

                            // 시각 효과: 이동 잔상
                            if (frameCount % 5 === 0) {
                                spawnGhost(enemy.x, enemy.y, enemy.radius, Math.atan2(enemy.dashVy, enemy.dashVx) + Math.PI/2, masakuniImg, true);
                            }
                        } else {
                            // 대쉬 대기 중
                            enemy.vx = 0; enemy.vy = 0;
                            enemy.moveDashTimer++;
                            
                            // 쿨타임이 차면 플레이어 방향으로 발사
                            if (enemy.moveDashTimer >= enemy.moveDashCooldown) {
                                const angle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
                                const thrustSpeed = 20; // 순간 속도
                                enemy.dashVx = Math.cos(angle) * thrustSpeed;
                                enemy.dashVy = Math.sin(angle) * thrustSpeed;
                                enemy.moveDashDuration = 38;
                                enemy.moveDashTimer = 0;
                                
                                // 추진 이펙트 (검은 연기)
                                spawnDarkGas(enemy.x, enemy.y, 3.5, 0.5, enemy.accuracy, 0, enemy);
                                showPickupEffect(enemy.x, enemy.y - 40, "스텝", false, false, "weak-text");
                            }
                        }
                    }

                    // 1. 일섬 (Flash): 가웨인 돌진 로직 (벽까지 돌진)
                    if (enemy.flashState === 'idle') {
                        enemy.flashTimer++;
                        if (enemy.flashTimer >= enemy.flashCooldown) {
                            enemy.flashState = 'warmup';
                            enemy.flashTimer = 0;
                            showPickupEffect(enemy.x, enemy.y - 60, "일섬 자세..", false, false, "masakuni-text");
                        }
                    } else if (enemy.flashState === 'warmup') {
                        enemy.vx = 0; enemy.vy = 0; // 정지
                        enemy.moveDashDuration = 0; // 이동 캔슬
                        enemy.flashTimer++;
                        
                        // 준비 동작 중 플레이어 조준
                        enemy.flashAngle = Math.atan2(player.y - enemy.y, player.x - enemy.x);

                        if (enemy.flashTimer > 90) {
                            enemy.flashState = 'dashing';
                            enemy.flashTimer = 0;
                            enemy.hasHitFlash = false; // 타격 플래그 초기화
                            showPickupEffect(enemy.x, enemy.y - 60, "일섬!!", false, true, "masakuni-text");
                        }
                    } else if (enemy.flashState === 'dashing') {
                        // 벽에 닿을 때까지 고속 이동
                        const speed = 20;
                        enemy.x += Math.cos(enemy.flashAngle) * speed;
                        enemy.y += Math.sin(enemy.flashAngle) * speed;

                        // 잔상 효과 (짙게)
                        if (frameCount % 2 === 0) {
                            spawnGhost(enemy.x, enemy.y, enemy.radius, enemy.flashAngle + Math.PI/2, masakuniImg, true);
                        }

                        // 플레이어 충돌 체크 (스치기만 해도 베임)
                        if (!enemy.hasHitFlash) {
        const dx = player.x - enemy.x;
        const dy = player.y - enemy.y;
        const distSq = dx * dx + dy * dy;
        // 판정 범위: 플레이어 반지름 + 적 반지름 + 30
        const hitRange = player.radius + enemy.radius + 30;

        if (distSq < hitRange * hitRange) {
            if (player.invincibleTimer <= 0) {
                let dmg = 40 + Math.floor(score * 0.23);
                if (enemy.nextAttackCrit) {
                    dmg *= 1.5;
                    enemy.nextAttackCrit = false;
                    showPickupEffect(player.x, player.y, "심안 치명타!!", false, true, "masakuni-text");
                }
                takeDamage(dmg, 'direct', enemy.accuracy, enemy);
                // 출혈 5중첩
                for(let k=0; k<5; k++) { addStatus('bleeding', 600, 20); }
                showPickupEffect(player.x, player.y, "베였다!", false, true, "bleeding-border");
                
                enemy.hasHitFlash = true; // 한 번만 타격
            }
        }
    }

                        // 벽 충돌 체크 (화면 밖으로 나가면 종료)
                        let hitWall = false;
                        if (enemy.x < -100 || enemy.x > canvas.width + 100 || enemy.y < -100 || enemy.y > canvas.height + 100) {
                            hitWall = true;
                        }
                // [v16] 초반 유예 프레임이 남아있으면 벽 판정 무시
                if ((enemy.cruelChargeWallGrace || 0) > 0) {
                    enemy.cruelChargeWallGrace--;
                    hitWall = false;
                }

                if (hitWall) {
                            enemy.flashState = 'idle';
                            enemy.flashTimer = 0;
                            
                            // 맵 안쪽으로 살짝 복귀 (다음 패턴 위해)
                            enemy.x = Math.max(50, Math.min(canvas.width - 50, enemy.x));
                            enemy.y = Math.max(50, Math.min(canvas.height - 50, enemy.y));
                        }
                    }

                    // [스킬 2] 흑월 (Black Moon) - 리메이크 적용
    if (enemy.blackMoonState === 'idle') {
        enemy.blackMoonTimer++;
        if (enemy.blackMoonTimer >= enemy.blackMoonCooldown) {
            // 쿨타임(10초) 되면 발동
            spawnBlackMoon(enemy.x, enemy.y, enemy.accuracy, enemy);
            
            // 타이머 리셋
            enemy.blackMoonTimer = 0; 
            
            // 시전 대사
            showPickupEffect(enemy.x, enemy.y - 60, "어둠의 달이여..", false, true, "masakuni-text");
        }
    }

                    // 3. 환영검 (Phantom Sword)
                    if (!enemy.phantomSwordsActive) {
                        enemy.phantomSwordCooldown--;
                        if (enemy.phantomSwordCooldown <= 0) {
                            enemy.phantomSwordsActive = true;
                            for(let k=0; k<3; k++) {
                                phantomSwords.push({
                                    owner: enemy,
                                    index: k,
                                    state: 'hover',
                                    x: enemy.x,
                                    y: enemy.y,
                                    angle: 0,
                                    life: 600,
                                    size: 1.35
                                });
                            }
                            showPickupEffect(enemy.x, enemy.y - 60, "환영검", false, false, "masakuni-text");
                            enemy.phantomSwordCooldown = 900;
                        }
                    }
                }
               
               // [신규] 검은 민족 카이토 패턴
                if (enemy.isKaito) {
                    // [패시브] 검은 계약: 체력 30% 이하일 때 쿨타임 감소
                    let cdReduction = 1.0;
                    if (enemy.hp <= enemy.maxHp * 0.3) {
                        cdReduction = 2.0; // 쿨타임 감소 속도 2배 (즉 50% 감소)
                        if (frameCount % 60 === 0) showDamageText(enemy.x, enemy.y, "검은 계약", false, false, "corrupted-text");
                    }

                    // [신규] 5초마다 1초간 은신 패턴
            enemy.kaitoStealthTimer = (enemy.kaitoStealthTimer || 0) + 1;
            if (enemy.kaitoStealthTimer >= 300) { // 5초(300프레임) 대기 후
                enemy.isKaitoStealth = true;
                enemy.alpha = 0.2; // 반투명 처리
                
                if (enemy.kaitoStealthTimer >= 360) { // 1초(60프레임) 지속 후 해제
                    enemy.kaitoStealthTimer = 0;
                    enemy.isKaitoStealth = false;
                    enemy.alpha = 1.0; // 투명도 복구
                    showPickupEffect(enemy.x, enemy.y - 40, "숨어서 뿌우욱♥", false);
                }
            }

                    // 1. 네더 그랩 (Nether Grab)
                   if (enemy.netherGrabActive) {
        enemy.netherGrabDuration--;
        player.netherGrabbedBy = enemy; 

        // [수정] 데스 그립과 동일한 "거리 제한" 방식: 멀어지려고 하면 카이토 쪽으로 끌려옴
        const dist = Math.hypot(player.x - enemy.x, player.y - enemy.y);
        const maxDist = 330; // 네더 그랩 사슬 길이 (원하면 숫자만 조절)

        if (dist > maxDist) {
            const angle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
            player.x = enemy.x + Math.cos(angle) * maxDist;
            player.y = enemy.y + Math.sin(angle) * maxDist;
        }

        // 데미지 틱 (기존 유지)
        enemy.netherGrabDamageTick = (enemy.netherGrabDamageTick || 0) + 1;
        if (enemy.netherGrabDamageTick >= 60) {
            let dmg = 5 + Math.floor(score * 0.08);
            takeDamage(dmg, 'direct', enemy.accuracy, enemy);
            enemy.netherGrabDamageTick = 0;
        }

        if (enemy.netherGrabDuration <= 0) {
            enemy.netherGrabActive = false;
            player.netherGrabbedBy = null;
            enemy.netherGrabCooldown = 960;
        }
                    } else {
                        enemy.netherGrabCooldown -= cdReduction;
                        if (enemy.netherGrabCooldown <= 0) {
                            enemy.netherGrabActive = true;
                            enemy.netherGrabDuration = 480; // 8초
                            showPickupEffect(enemy.x, enemy.y - 60, "네더 그랩!", false, true, "evil-purple-text");
                        }
                    }

                    // 2. 보이드 워프 (Void Warp) - 네더 그랩 중이 아닐 때만 사용
    if (!enemy.netherGrabActive) {
    enemy.voidWarpCooldown -= cdReduction;
    if (enemy.voidWarpCooldown <= 0) {
        // 이동 전 위치에 가스
        spawnDarkGas(enemy.x, enemy.y, 4.0, 1.0, enemy.accuracy, 0, enemy);

        const warpDist = 450;
        const awayAngle = Math.atan2(enemy.y - player.y, enemy.x - player.x);
        let targetX = player.x + Math.cos(awayAngle) * warpDist;
        let targetY = player.y + Math.sin(awayAngle) * warpDist;

        // 맵 밖으로 안 나가게 보정
        targetX = Math.max(50, Math.min(canvas.width - 50, targetX));
        targetY = Math.max(50, Math.min(canvas.height - 50, targetY));
        
        enemy.x = targetX;
        enemy.y = targetY;

        // 이동 후 위치에 가스 및 이펙트
        spawnDarkGas(enemy.x, enemy.y, 4.0, 1.0, enemy.accuracy, 0, enemy);
        showPickupEffect(enemy.x, enemy.y - 40, "백어택 워프!", false, true, "evil-purple-text"); // 텍스트 변경 (선택사항)
        
        enemy.voidWarpCooldown = 180; // 3초
    }
}

                    // 3. 다크 매터 (Dark Matter)
                    enemy.darkMatterCooldown -= cdReduction;
                    if (enemy.darkMatterCooldown <= 0) {
                        spawnDarkMatter(enemy.x, enemy.y, enemy);
                        enemy.darkMatterCooldown = 1080; // 18초
                    }

                    // 4. 컨페셔너 (Confessional)
                    enemy.confessionalCooldown -= cdReduction;
                    if (enemy.confessionalCooldown <= 0) {
                        // 맵 랜덤 위치
                        const tx = 50 + Math.random() * (canvas.width - 100);
                        const ty = 50 + Math.random() * (canvas.height - 100);
                        spawnConfessionalTotem(tx, ty, enemy.accuracy, enemy);
                        enemy.confessionalCooldown = 960; // 16초
                    }

                    // 기본 이동 AI (카이팅: 거리 320 유지)
                    const distToPlayer = Math.hypot(player.x - enemy.x, player.y - enemy.y);
                    const angle = Math.atan2(player.y - enemy.y, player.x - enemy.x);

                    if (!enemy.netherGrabActive) {
                        delete enemy.strafeDir;
                        if (distToPlayer < 300) { // 너무 가까우면 후퇴
                            enemy.vx = -Math.cos(angle) * enemy.speed;
                            enemy.vy = -Math.sin(angle) * enemy.speed;
                        } else if (distToPlayer > 340) { // 너무 멀면 접근
                            enemy.vx = Math.cos(angle) * enemy.speed;
                            enemy.vy = Math.sin(angle) * enemy.speed;
                        } else {
                            // 적당한 거리면 주변 배회
                            enemy.vx = Math.cos(angle + Math.PI/2) * enemy.speed;
                            enemy.vy = Math.sin(angle + Math.PI/2) * enemy.speed;
                        }
                        enemy.x += enemy.vx;
                        enemy.y += enemy.vy;
                    } else {
                        // [수정] 네더 그랩 중: 700px까지는 도주, 그 이상이면 횡이동(원형 카이팅)
                        const runSpeed = enemy.speed * 1.25;
                        const strafeSpeed = enemy.speed * 0.95;

                        if (distToPlayer < 700) {
                            // 플레이어 반대 방향으로 도주
                            enemy.vx = -Math.cos(angle) * runSpeed;
                            enemy.vy = -Math.sin(angle) * runSpeed;
                        } else {
                            // 700px 이상이면 횡이동(플레이어 둘레 회전)
                            if (enemy.strafeDir !== 1 && enemy.strafeDir !== -1) {
                                enemy.strafeDir = (Math.random() < 0.5) ? 1 : -1;
                            }

                            enemy.vx = Math.cos(angle + enemy.strafeDir * Math.PI / 2) * strafeSpeed;
                            enemy.vy = Math.sin(angle + enemy.strafeDir * Math.PI / 2) * strafeSpeed;

                            // 너무 멀어지면(760px 이상) 살짝만 안쪽으로 보정
                            if (distToPlayer > 760) {
                                enemy.vx += Math.cos(angle) * (enemy.speed * 0.20);
                                enemy.vy += Math.sin(angle) * (enemy.speed * 0.20);
                            }
                        }

                        enemy.x += enemy.vx;
                        enemy.y += enemy.vy;

                        // 맵 밖으로 안 나가게 보정
                        enemy.x = Math.max(50, Math.min(canvas.width - 50, enemy.x));
                        enemy.y = Math.max(50, Math.min(canvas.height - 50, enemy.y));
                    }
                }

           // [신규] 검은 민족 퀘스타 패턴 (수정됨: 상태 머신 적용)
if (enemy.isQuesta) {
    // ----------------------------------------------------
    // [패시브] 칠흑의 장막 효과 (회피율 증가) - 기존 유지
    // ----------------------------------------------------
    if (enemy.isVeiled) {
        enemy.veilDuration--;
        enemy.evasion = enemy.baseEvasion + 0.20; // 기본 20 + 20 = 40%
        if (enemy.veilDuration <= 0) {
            enemy.isVeiled = false;
            showDamageText(enemy.x, enemy.y, "장막 해제", false, false, "weak-text");
        }
    } else {
        enemy.evasion = enemy.baseEvasion;
        enemy.veilTimer++;
        if (enemy.veilTimer >= enemy.veilCooldown) {
            enemy.isVeiled = true;
            enemy.veilDuration = 600; // 10초
            enemy.veilTimer = 0;
            showPickupEffect(enemy.x, enemy.y - 60, "칠흑의 장막!", false, true, "shadow-text");
        }
    }

    // 스킬 사용 중인지 체크 (상태 머신 이동보다 우선순위 높음)
    const isUsingSkill = enemy.isFlickering || enemy.boneCrusherState !== 'idle';

    if (!isUsingSkill) {
        // ----------------------------------------------------
        // [이동 AI 변경] 자코(덮치기범) 스타일 상태 머신 적용
        // ----------------------------------------------------
        const dx = player.x - enemy.x;
        const dy = player.y - enemy.y;
        const dist = Math.hypot(dx, dy);

        // 1. [IDLE] 접근: 멀리서는 천천히 다가옴
        if (enemy.state === 'idle') {
            // 플레이어 방향으로 천천히 이동 (속도 2.0)
            enemy.vx = (dx / dist) * 2.0;
            enemy.vy = (dy / dist) * 2.0;
            
            enemy.x += enemy.vx;
            enemy.y += enemy.vy;

            // 거리가 350 미만으로 좁혀지면 공격 준비 태세
            if (dist < 350) {
                enemy.state = 'warmup';
                enemy.actionTimer = 30; // 30프레임(약 0.5초) 경고
            }
        } 
        // 2. [WARMUP] 공격 준비: 멈춰서 경고
        else if (enemy.state === 'warmup') {
            enemy.actionTimer--;
            // 이동 멈춤
            enemy.vx = 0;
            enemy.vy = 0;
            
            // 시각적 효과가 필요하다면 drawEnemies에서 처리하거나 여기서 이펙트 호출

            if (enemy.actionTimer <= 0) {
                // 준비 끝, 돌진 방향 확정 및 상태 전환
                enemy.state = 'dashing';
                enemy.actionTimer = 40; // 40프레임 동안 돌진
                enemy.dashDir = { x: dx / dist, y: dy / dist }; // 현재 플레이어 위치로 방향 고정
            }
        }
        // 3. [DASHING] 돌진: 고정된 방향으로 빠르게 이동
        else if (enemy.state === 'dashing') {
            enemy.actionTimer--;
            
            // 속도 8.0으로 돌진
            const dashSpeed = 8.0; 
            enemy.vx = enemy.dashDir.x * dashSpeed;
            enemy.vy = enemy.dashDir.y * dashSpeed;
            
            enemy.x += enemy.vx;
            enemy.y += enemy.vy;

            if (enemy.actionTimer <= 0) {
                enemy.state = 'cooldown';
                enemy.actionTimer = 90; // 90프레임(약 1.5초) 동안 휴식
            }
        }
        // 4. [COOLDOWN] 휴식: 제자리 멈춤
        else if (enemy.state === 'cooldown') {
            enemy.actionTimer--;
            enemy.vx = 0;
            enemy.vy = 0;

            if (enemy.actionTimer <= 0) {
                enemy.state = 'idle'; // 다시 접근 상태로 복귀
            }
        }
        // 예외 처리: state가 없는 경우(구버전 객체 등) idle로 초기화
        else {
            enemy.state = 'idle';
        }

        // ----------------------------------------------------
        // [스킬 쿨타임 관리] - 이동 로직과 병렬로 쿨타임은 계속 돔
        // ----------------------------------------------------

        // [스킬 1] 그림자 손아귀 (12초)
        enemy.shadowGripTimer++;
        if (enemy.shadowGripTimer >= enemy.shadowGripCooldown) {
            spawnShadowGrip(enemy.x, enemy.y, enemy);
            enemy.shadowGripTimer = 0;
        }

        // [스킬 2] 다크 플리커 (6초)
        enemy.flickerTimer++;
        if (enemy.flickerTimer >= enemy.flickerCooldown) {
            enemy.isFlickering = true;
            enemy.flickerCount = 0;
            enemy.flickerStepTimer = 0;
            enemy.flickerTimer = 0;
            // 스킬 시작 시 상태 초기화 (이동 AI 간섭 방지)
            enemy.state = 'idle'; 
            showPickupEffect(enemy.x, enemy.y - 60, "븃븃븃♥", false, true, "masakuni-text");
        }

        // [스킬 4] 본 크러셔 (18초)
        enemy.boneCrusherTimer++;
        if (enemy.boneCrusherTimer >= enemy.boneCrusherCooldown) {
            enemy.boneCrusherState = 'charging';
            enemy.boneCrusherChargeTimer = 120; // 2초 차지
            enemy.boneCrusherTimer = 0;
            enemy.state = 'idle';
            enemy.boneCrusherVictim = false;
            showPickupEffect(enemy.x, enemy.y - 60, "확실한 임신♥", false, true, "wicked-large-text");
        }

    } 
    // ----------------------------------------------------
    // [스킬 실행 중 로직] - 이동 AI 대신 스킬 동작 수행
    // ----------------------------------------------------
    else {
        if (enemy.isFlickering) {
            // 1. [차지 단계] 0~45프레임 (0.75초) 제자리 대기
            if (enemy.flickerStepTimer < 45) {
                enemy.vx = 0; 
                enemy.vy = 0;
            }
            // 2. [발사 준비] 45프레임 시점에 방향 및 속도 결정
            else if (enemy.flickerStepTimer === 45) {
                const angle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
                const flickerSpeed = 13;
                enemy.dashVx = Math.cos(angle) * flickerSpeed;
                enemy.dashVy = Math.sin(angle) * flickerSpeed;
                // 데스 클라우드 및 이펙트
                spawnDeathCloud(enemy.x, enemy.y, enemy.isElite, enemy.isBoss, enemy.accuracy, enemy);
            }
            // 3. [돌진 단계] 45프레임 이후 실제 이동
            else {
                enemy.x += enemy.dashVx;
                enemy.y += enemy.dashVy;

                // 돌진 중 15프레임마다 데스 클라우드 생성
                if (enemy.flickerStepTimer % 15 === 0) {
                    spawnDeathCloud(enemy.x, enemy.y, enemy.isElite, enemy.isBoss, enemy.accuracy, enemy);
                }
            }

            enemy.flickerStepTimer++;

            // 피격 쿨타임 감소
            if (enemy.flickerHitCooldown > 0) enemy.flickerHitCooldown--;

            // [최적화] 충돌 체크 (플리커) - 제곱 거리 사용
            // 공격 가능 상태(돌진 중, 쿨타임 없음)일 때만 거리 계산
            if (enemy.flickerStepTimer > 45 && enemy.flickerHitCooldown <= 0) {
                const dx = player.x - enemy.x;
                const dy = player.y - enemy.y;
                const distSq = dx * dx + dy * dy;
                const hitRadius = player.radius + enemy.radius;
                
                // 제곱 거리 비교
                if (distSq < hitRadius * hitRadius) {
                    if (player.invincibleTimer <= 0) {
                        let dmg = 15 + Math.floor(score * 0.15);
                        takeDamage(dmg, 'direct', enemy.accuracy, enemy);
                        
                        // 피격 시 0.5초간 해당 스킬 면역 (연타 방지)
                        enemy.flickerHitCooldown = 30;
                        
                        // 골절 부여
                        for(let k = 0; k < 2; k++) {
                            player.fractureTimers.push(1200); 
                        }
                        updateStatusUI();
                        showPickupEffect(player.x, player.y, "골절!", false, true, "fracture-border");
                        
                        // 패시브: 새디즘 체크
                    const sadismCritResist = getEffectiveDefenderCritResist();
                    if (sadismCritResist <= SADISM_CRITRESIST_THRESHOLD) {
                            let heal = Math.floor(dmg * SADISM_LIFESTEAL_RATIO);
                            enemy.hp = Math.min(enemy.maxHp, enemy.hp + heal);
                            showDamageText(enemy.x, enemy.y, "새디즘 +" + heal, false, false, "heal-text");
                        
                            activateSadismGas(enemy);
}
                    }
                }
            }

            // 4. [단계 종료] 65프레임 지나면 다음 돌진 준비
            if (enemy.flickerStepTimer > 65) { 
                enemy.flickerCount++;        // 돌진 횟수 증가
                enemy.flickerStepTimer = 0;  // 타이머 초기화 (다시 차지부터 시작)
                enemy.dashVx = 0; 
                enemy.dashVy = 0;
                
                // 총 3회 돌진 후 스킬 완전 종료
                if (enemy.flickerCount >= 3) {
                    enemy.isFlickering = false;
                    enemy.flickerCount = 0;  
                    // 스킬 끝나면 잠시 휴식 상태로 전환 (자연스러운 연결)
                    enemy.state = 'cooldown';
                    enemy.actionTimer = 30;
                }
            }
        }

        // [본 크러셔 실행]
        if (enemy.boneCrusherState === 'charging') {
            enemy.boneCrusherChargeTimer--;
            // 차지 중 플레이어 방향 바라보기 (조준)
            enemy.boneCrusherAngle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
            if (enemy.boneCrusherChargeTimer <= 0) {
                enemy.boneCrusherState = 'rushing';
                showPickupEffect(enemy.x, enemy.y - 60, "본 크러셔!!", false, true, "corrupted-text");
            }
       } else if (enemy.boneCrusherState === 'rushing') {
            const speed = 22;
            enemy.x += Math.cos(enemy.boneCrusherAngle) * speed;
            enemy.y += Math.sin(enemy.boneCrusherAngle) * speed;

            // [이펙트] 지나간 자리에 2배 크기 다크가스 (기존 유지)
            if (frameCount % 5 === 0) {
                spawnDarkGas(enemy.x, enemy.y, 2.0, 1.0, enemy.accuracy, 0, enemy);
            }

            // =========================================================
            // [신규 로직 1] 플레이어 드래그 (잡혔을 경우 위치 고정)
            // =========================================================
            if (enemy.boneCrusherVictim) {
                player.x = enemy.x;
                player.y = enemy.y;
            }

            // =========================================================
            // [신규 로직 2] 플레이어 충돌 체크 (데미지 대신 잡기 판정)
            // =========================================================
            // 아직 잡히지 않은 상태에서만 충돌 체크
            if (!enemy.boneCrusherVictim) {
                const dist = Math.hypot(player.x - enemy.x, player.y - enemy.y);
                // 충돌 범위 체크
                if (dist < player.radius + enemy.radius + 10) {
                    if (player.invincibleTimer <= 0) {
                        enemy.boneCrusherVictim = true; // 플레이어를 잡음
                        showPickupEffect(player.x, player.y, "잡혔다!!", false, true, "wicked-large-text");
                    }
                }
            }

            // =========================================================
            // [신규 로직 3] 벽 충돌 체크 (화면 밖으로 나갔을 때)
            // =========================================================
            let hitWall = false;
            if (enemy.x < -50 || enemy.x > canvas.width + 50 || enemy.y < -50 || enemy.y > canvas.height + 50) {
                hitWall = true;
            }

            if (hitWall) {
                enemy.boneCrusherState = 'idle';
                // 맵 안쪽으로 복귀
                enemy.x = Math.max(50, Math.min(canvas.width - 50, enemy.x));
                enemy.y = Math.max(50, Math.min(canvas.height - 50, enemy.y));
                
                // ★ 벽 충돌 시 잡힌 플레이어에게 데미지 부여 (1회)
                if (enemy.boneCrusherVictim) {
                    // 데미지 계산: 기본 데미지 + 골절 중첩당 증가
                    let baseDmg = 34 + Math.floor(score * 0.3); // 벽꽝 데미지는 강력하게 설정
                    let fractureBonus = 1 + (player.fractureTimers.length * 0.15); // 골절 하나당 15% 증폭
                    let finalDmg = baseDmg * fractureBonus;

                    takeDamage(finalDmg, 'direct', enemy.accuracy, enemy);             
                    showPickupEffect(player.x, player.y, "으어얽", false, true, "wicked-large-text");

                    // 퀘스타 패시브: 새디즘 (플레이어 치명타 저항 확률 낮을 시 회복)
                    const sadismCritResist = getEffectiveDefenderCritResist();
                    if (sadismCritResist <= SADISM_CRITRESIST_THRESHOLD) {
                        let heal = Math.floor(finalDmg * SADISM_LIFESTEAL_RATIO);
                        enemy.hp = Math.min(enemy.maxHp, enemy.hp + heal);
                        showDamageText(enemy.x, enemy.y, "새디즘 +" + heal, false, false, "heal-text");
                    
                            activateSadismGas(enemy);
}

                    // 충격파 이펙트
                    shockwaves.push({
                        x: enemy.x, y: enemy.y,
                        radius: 10, speed: 20, alpha: 1.0, fade: 0.05
                    });

                    // 잡기 상태 해제
                    enemy.boneCrusherVictim = false;
                }

                // 스킬 종료 후 휴식
                enemy.state = 'cooldown';
                enemy.actionTimer = 60;
            }
        }
    }
}

               // [신규] 테토라 업데이트 로직
            if (enemy.isTetora) {
                // 1. 카이팅 AI (거리 370 유지)
                const distToPlayer = Math.hypot(player.x - enemy.x, player.y - enemy.y);
                const angle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
                
                if (distToPlayer < 350) { // 너무 가까우면 후퇴
                    enemy.vx = -Math.cos(angle) * enemy.speed;
                    enemy.vy = -Math.sin(angle) * enemy.speed;
                } else if (distToPlayer > 390) { // 너무 멀면 접근
                    enemy.vx = Math.cos(angle) * enemy.speed;
                    enemy.vy = Math.sin(angle) * enemy.speed;
                } else { // 적정 거리면 측면 이동 (회피 기동)
                    enemy.vx = Math.cos(angle + Math.PI/2) * enemy.speed;
                    enemy.vy = Math.sin(angle + Math.PI/2) * enemy.speed;
                }
                enemy.x += enemy.vx;
                enemy.y += enemy.vy;

                // 2. 노래 (버프) 관리
                // 전역 변수 상태 업데이트 (화면 효과용)
                if (enemy.currentSong === 'requiem' && enemy.songTimer > 0) tetoraRequiemActive = true;
                if (enemy.currentSong === 'rhapsody' && enemy.songTimer > 0) tetoraRhapsodyActive = true;

                if (enemy.songTimer > 0) {
                    enemy.songTimer--;
                    // 진혼곡: 120프레임마다 아군 회복
                    if (enemy.currentSong === 'requiem' && enemy.songTimer % 120 === 0) {
                        enemies.forEach(ally => {
                            if (ally === enemy) return;
                            if (ally.hp > 0) {
                                let heal = Math.floor(ally.maxHp * 0.1);
                                ally.hp = Math.min(ally.maxHp, ally.hp + heal);
                                showDamageText(ally.x, ally.y, "+" + heal, false, false, "heal-text");
                            }
                        });
                    }
                } else {
                    // 노래 지속시간 종료 시 쿨타임 체크 후 재사용
                    // 랜덤하게 다음 곡 선정 (쿨타임이 따로 돈다면 여기서 처리)
                    // 요구사항: 쿨타임 16초. 지속 16초.
                    // 여기서는 지속이 끝나면 즉시 쿨타임 대기 상태로 간주하거나 바로 사용 (로직 단순화를 위해 즉시 재사용 패턴 적용)
                    // 만약 공백기를 두려면 별도 쿨타임 변수 필요. 여기선 바로 스위칭합니다.
                    enemy.currentSong = (enemy.currentSong === 'requiem') ? 'rhapsody' : 'requiem';
                    enemy.songTimer = 960;
                    
                    showPickupEffect(enemy.x, enemy.y - 60, enemy.currentSong === 'requiem' ? "진혼곡♥" : "광시곡♥", false, true, "evil-purple-text");
                }

                // 3. 데스메탈 크레센도
                if (enemy.crescendoTimer > 0) enemy.crescendoTimer--;
                else {
                    spawnDeathMetalNote(enemy.x, enemy.y, enemy.angle, enemy);
                    enemy.crescendoTimer = 600; // 10초
                }

                // 4. 다크니스 스포트라이트
                if (enemy.spotlightTimer > 0) enemy.spotlightTimer--;
                else {
                    spawnDarknessSpotlight(enemy.x, enemy.y, enemy);
                    enemy.spotlightTimer = 840; // 14초
                }
                
                // 패시브용 아군 카운트 (데미지 계산 시 사용)
                enemy.allyCount = enemies.filter(e => e.hp > 0).length;
            }

               if (enemy.isGawain) {
            // [스킬/패턴 완전 봉인] 잔혹한 돌진 차지/돌진 중에는 성역/단죄의 검 등 모든 패턴을 수행하지 않음
            const gawainLocked = (enemy.isCruelCharging || enemy.isCruelChargeCharging);

            // ----------------------------
            // 타락한 성역 (Locked 중 처리)
            // - 돌진 중에는 '새 발동'만 금지하고, 이미 켜져 있던 성역의 힐/버프는 계속 적용
            // ----------------------------
            if (enemy.gawainSanctuaryActive > 0) {
                enemy.gawainSanctuaryActive--;

                const sanctuaryRange = enemy.radius * 2.0;
                const sanctuaryRangeSq = sanctuaryRange * sanctuaryRange;

                // [최적화] 성역 범위 체크는 N프레임마다 수행 + 제곱거리 사용
                if (frameCount % GAWAIN_SANCTUARY_STRIDE === 0) {
                    for (let j = 0; j < enemies.length; j++) {
                        const ally = enemies[j];
                        const dx = enemy.x - ally.x;
                        const dy = enemy.y - ally.y;
                        if ((dx * dx + dy * dy) < sanctuaryRangeSq) {
                            ally.gawainSanctuaryCount = (ally.gawainSanctuaryCount || 0) + 1;

                            // 2초마다 소량 회복
                            if (frameCount % 120 === 0 && ally.hp > 0 && ally.hp < ally.maxHp) {
                                let sanctuaryHeal = 4 + Math.floor(score * 0.03);
                                sanctuaryHeal = Math.floor(sanctuaryHeal * (ally.hpRecoveryRate || 1));
                                ally.hp += sanctuaryHeal;
                                showDamageText(ally.x, ally.y, "+" + sanctuaryHeal, false, false, "heal-text");
                            }
                        }
                    }
                }
            } else {
                if (!gawainLocked) enemy.gawainSanctuaryTimer--;

                // Locked 중에는 발동 자체를 금지
                if (!gawainLocked && enemy.gawainSanctuaryTimer <= 0) {
                    enemy.gawainSanctuaryActive = 600;
                    enemy.gawainSanctuaryTimer = 900;
                    showPickupEffect(enemy.x, enemy.y - 60, "성역이여 무너져라..", false, false, "gawain-text");
                }
            }

            // ============================================================
// ============================================================
            // [신규 스킬] 잔혹한 돌진 (수정됨: 벽에 닿을 때까지 무한 돌진)
            // ============================================================
            if (enemy.isCruelCharging) {
                // 1. 돌진 중 이동 (빠른 속도)
                const chargeSpeed = 9.5; 
                enemy.x += Math.cos(enemy.cruelChargeAngle) * chargeSpeed;
                enemy.y += Math.sin(enemy.cruelChargeAngle) * chargeSpeed;
                
                // 돌진 중에는 일반 이동 정지
                enemy.vx = 0; enemy.vy = 0;
                // [v13] 돌진 중에는 스턴으로 끊기지 않도록
                enemy.stunTimer = 0;


                // [v16] 벽에서 시작하는 경우 '돌진이 안 나온 것처럼' 보이는 문제 방지: 초반 몇 프레임은 벽 판정을 유예
                enemy.cruelChargeWallGrace = Math.max(enemy.cruelChargeWallGrace || 0, 0);
                // Ghost 이펙트 (잔상)
                if (frameCount % 3 === 0) {
                     spawnGhost(enemy.x, enemy.y, enemy.radius, 0, gawainImg, true);
                }

                // 2. 플레이어 충돌 체크 (달라붙기 판정)
                if (!enemy.cruelChargeVictim) {
                    const dist = Math.hypot(player.x - enemy.x, player.y - enemy.y);
                    // 충돌 범위 체크
                    if (dist < enemy.radius + player.radius + 10) {
                        // 돌진 중 접촉하면 즉시 '잡힘' 상태로 전환 (무적 여부와 무관)
                        enemy.cruelChargeVictim = true;
                        if (player.invincibleTimer <= 0) {
                            showPickupEffect(player.x, player.y, "끌려간다..", false, true, "pink-text");
                        }
                    }
                }

                // 3. 잡힌 플레이어 강제 이동 (가웨인 위치로 고정)
                if (enemy.cruelChargeVictim) {
                    // 플레이어를 가웨인 '앞쪽'에 붙여서(약간의 오프셋) 충돌 보정/밀림 때문에 돌진이 끊기는 현상을 방지
                    const stickDist = Math.max(0, enemy.radius + player.radius - 6);
                    player.x = enemy.x + Math.cos(enemy.cruelChargeAngle) * stickDist;
                    player.y = enemy.y + Math.sin(enemy.cruelChargeAngle) * stickDist;
                }

                // 4. 벽 충돌 체크 (화면 밖으로 나가는지 확인)
                let hitWall = false;
                if (enemy.x <= enemy.radius || enemy.x >= canvas.width - enemy.radius || 
                    enemy.y <= enemy.radius || enemy.y >= canvas.height - enemy.radius) {
                    hitWall = true;
                }

                // [v16] 초반 유예 프레임이 남아있으면 벽 판정 무시
                if ((enemy.cruelChargeWallGrace || 0) > 0) {
                    enemy.cruelChargeWallGrace--;
                    hitWall = false;
                }

                if (hitWall) {
                    // 벽에 닿음 -> 돌진 종료 및 데미지 처리
                    enemy.isCruelCharging = false;
                    enemy.cruelChargeTimer = 540; // 쿨타임 9초
                    
                    if (enemy.cruelChargeVictim) {
                        // 벽 꽝 추가 데미지
                        let wallDmg = 17 + Math.floor(score * 0.25); 
                        takeDamage(wallDmg, 'direct', enemy.accuracy, enemy);
                        
                        // 디버프 부여: 카인의 좆집, 카인의 씨앗 2중첩씩
                        for (let k = 0; k < 2; k++) {
                        addStatus('darkReceiver', 900, 20); 
                        addStatus('darkSeed', 900, 20);     
                        }
                        showPickupEffect(player.x, player.y, "벽꿍자지삽입♥", false, true, "corrupted-text");
                        enemy.cruelChargeVictim = false;
                        
                        // 충격파 효과
                        shockwaves.push({
                            x: enemy.x, y: enemy.y,
                            radius: 10, speed: 20, alpha: 1.0, fade: 0.05
                        });
                    }
                }

            } else {
                // ------------------------------------------------------------
                // 차지(모으기) 상태: 돌진 직전에 잠깐 멈추고 오오라가 모이게
                // ------------------------------------------------------------
                if (enemy.isCruelChargeCharging) {
                    enemy.vx = 0; enemy.vy = 0;
                    // [v13] 차지 중에는 스턴으로 끊기지 않도록
                    enemy.stunTimer = 0;

                    // 오오라/잔광 생성
                    spawnCruelChargeAura(enemy);

                    // 차지 타이머 감소
                    enemy.cruelChargeWindup = (enemy.cruelChargeWindup || 0) - 1;

                    // 약간의 떨림(무겁지 않게)
                    enemy.x += (Math.random() - 0.5) * 0.6;
                    enemy.y += (Math.random() - 0.5) * 0.6;

                    // 차지 끝 -> 본 돌진 시작
                    if (enemy.cruelChargeWindup <= 0) {
                        enemy.isCruelChargeCharging = false;
                        enemy.isCruelCharging = true;
                        enemy.cruelChargeAngle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
                        enemy.cruelChargeVictim = false;
                        // [v16] 벽 근처에서 시작하면 즉시 종료되는 현상 방지
                        enemy.cruelChargeWallGrace = 8; // 약 0.13초(60fps)
                        // 시작 프레임에 화면 안쪽으로 살짝 클램프
                        enemy.x = Math.min(canvas.width - enemy.radius - 2, Math.max(enemy.radius + 2, enemy.x));
                        enemy.y = Math.min(canvas.height - enemy.radius - 2, Math.max(enemy.radius + 2, enemy.y));
                    }
                } else {
                    // 평상시: 쿨타임 감소
                    enemy.cruelChargeTimer = (enemy.cruelChargeTimer || 0) - 1;

                    // 돌진 발동 조건: 쿨타임 끝 -> 차지 시작
                    if (enemy.cruelChargeTimer <= 0) {
                        enemy.isCruelChargeCharging = true;
                        enemy.cruelChargeWindup = 90;
                        // 돌진은 차지 끝날 때 각도 재계산해서 더 공정하게
                        showPickupEffect(enemy.x, enemy.y - 60, "잔혹한 돌진…", false, true, "wicked-large-text");
                    }
                }
            }
        }
                
                if (enemy.isAkiClone) {
                    enemy.erectionBuffTimer++;
                    if (enemy.erectionBuffTimer >= 180) { // 180프레임(3초)마다
                        let buffedCount = 0;
                        enemies.forEach(ally => {
                            if (ally !== enemy && ally.hp > 0 && !ally.isAkiClone) {
                                const dist = Math.hypot(enemy.x - ally.x, enemy.y - ally.y);
                                if (dist < 320) { // 범위 320
                                    ally.erectionStacks = Math.min((ally.erectionStacks || 0) + 1, 20);
                                    buffedCount++;
                                }
                            }
                        });
                        if (buffedCount > 0) {
                            showDamageText(enemy.x, enemy.y, "발기해라♥", false, false, "pink-text");
                        }
                        enemy.erectionBuffTimer = 0;
                    }
                }

                if (enemy.isAgent) {
                    enemy.agentDeathTimer--;
                    if (enemy.agentDeathTimer <= 0) {
                        enemy.hp = 0; 
                        if (enemy.agentType === 'curse') {
                            for(let k=0; k<2; k++) addStatus('curse', 900, 10);
                            showPickupEffect(player.x, player.y - player.radius - 70, "저주..", false, false, "evil-purple-text");
                        } else if (enemy.agentType === 'pain') {
                            for(let k=0; k<2; k++) addStatus('gnawingLife', 1800, 5); 
                            showPickupEffect(player.x, player.y - player.radius - 70, "좀먹는 생명..", false, false, "gnawing-life-text");
                        } else if (enemy.agentType === 'blind') {
                            let applied = 0;
                            for(let k=0; k<2; k++) {
                                // [수정] 보호막 체크 제거 (실명은 막을 수 없음)
                                addStatus('blind', 900, 10);
                                applied++;
                            }
                            if(applied > 0) showPickupEffect(player.x, player.y - player.radius - 70, `실명..`, false, false, "weak-text");
                        }
                    }
                }

                enemy.passiveErectionTimer = (enemy.passiveErectionTimer || 0) + 1;
                
                let erectionInterval = 240;

                if (enemy.passiveErectionTimer >= erectionInterval) {
                    let erectionGain = 1;
                    if (enemy.isZako) {
                        erectionGain = 2;
                    } else if (enemy.isDarkDenizen) {
                        erectionGain = 2;
                    } else if (enemy.isAmbush && enemy.ambushState === 'ambush' && enemy.normalType === 'rapist') {
                        erectionGain = 3; 
                        showPickupEffect(enemy.x, enemy.y, "자지가 터질것같아♥", false, true, "condensed-milk-text");
                    } else if (enemy.normalType === 'rapist' && !enemy.isStealth && !enemy.isAmbush) {
                        erectionGain = 3; 
                    } else if (enemy.isBoss) {
                        erectionGain = 0.5;
                    }
                    enemy.erectionStacks = Math.min(enemy.erectionStacks + erectionGain, 20);
                    enemy.passiveErectionTimer = 0;
                }

                if (enemy.erectionStacks > 0) { 
                    enemy.radius = enemy.baseRadius * (1 + (enemy.erectionStacks * 0.115)); 
                }

                if ((enemy.isAttached) && ((enemy.normalType === 'rapist') || (enemy.isDarkDenizen && enemy.denizenType === 'rai'))) {
                    enemy.attachTimer++;
                    enemy.x = player.x;
                    enemy.y = player.y + 10;
                    
                    if (enemy.normalType === 'rapist' || enemy.denizenType === 'rai') attachedRapistCount++;

                    if (enemy.isDarkDenizen && enemy.denizenType === 'rai') {
                        if (enemy.attachTimer >= 900) {
                            showPickupEffect(player.x, player.y - 60, "크큭..", false, true, "choke-text");
                            for(let k=0; k<10; k++) { if(!checkShieldBlockStatus()) addStatus('malice', 900, 20); }
                            for(let k=0; k<10; k++) { if(!checkShieldBlockStatus()) addStatus('fishy', 900, 9999); }
                            showPickupEffect(player.x, player.y - 120, "헤헤..한번 더♥", false, true, "pink-text");
                            enemy.isAttached = false;
                            enemy.attachTimer = 0;
                            const margin = 50;
                            enemy.x = margin + Math.random() * (canvas.width - margin*2);
                            enemy.y = margin + Math.random() * (canvas.height - margin*2);
                            updateStatusUI();
                            continue; 
                        }
                    } else {
                        if (enemy.attachTimer >= 900) {
                             showPickupEffect(player.x, player.y - 60, "으윽..!!", false, true, "choke-text");
                             let cost = 10;
                             let totalShields = player.shieldStacks; 
                             if (totalShields >= cost) {
                                 player.shieldStacks -= cost;
                                 showPickupEffect(player.x, player.y, "아쉽게 된거지ㅋㅋ", false, true, "sticky-text");
                             } else {
                                 player.shieldStacks = 0;
                                 const debuffTypes = ['kiss', 'semen', 'oral'];
                                 const selectedDebuff = debuffTypes[Math.floor(Math.random() * debuffTypes.length)];
                                 let deficit = cost - totalShields; 
                                 for(let k=0; k<deficit; k++) { addStatus(selectedDebuff, 900, 30); }
                                 showPickupEffect(player.x, player.y, "크하하!! 임신해라♥", false, true, "sticky-large-text");
                                 impregnateAudio.currentTime = 0;
                                 impregnateAudio.play().catch(()=>{});
                                 for(let k=0; k<3; k++) { if(!checkShieldBlockStatus()) addStatus('fishy', 900, 9999); }
                                 showPickupEffect(player.x, player.y - 120, "안씻은 자지냄새♥", false, true, "unwashed-text");
                             }
                             updateStatusUI();
                             enemy.hp = -1; 
                        }
                    }
                    if (enemy.hp <= 0) {} else { continue; }
                }
                
                if (enemy.isAmbush && enemy.ambushState !== 'complete') {
                    if (enemy.ambushState === 'approach') {
                        enemy.ambushTimer++;
                        if (enemy.ambushTimer > 90) { enemy.ambushState = 'ambush'; enemy.ambushTimer = 0; }
                    } else if (enemy.ambushState === 'ambush') {
                        enemy.ambushTimer++;
                        if (enemy.ambushTimer > 420) { enemy.ambushState = 'approach'; enemy.ambushTimer = 0; }
                        const dist = Math.hypot(player.x - enemy.x, player.y - enemy.y);
                        if (dist < player.radius + enemy.radius) {
                             enemy.isAttached = true; enemy.attachTimer = 0; enemy.isAmbush = false; enemy.isStealth = false; enemy.alpha = 1.0;
                             showPickupEffect(player.x, player.y, "잡았다♥", false, true, "evil-purple-text");
                             rapistAttachAudio.currentTime = 0; rapistAttachAudio.play().catch(()=>{});
                        }
                        enemy.speed = 0;
                    }
                }
                
                if (enemy.isZako || enemy.isDarkDenizen) {
                    enemy.readyTimer = (enemy.readyTimer || 0) + 1;
                    if (enemy.readyTimer >= 360) {
                        const currentStacks = enemy.readyStacks || 0;
                        if (currentStacks < 20) {
                            const stacksToAdd = enemy.isZako ? 2 : 1;
                            const actualAdd = Math.min(stacksToAdd, 20 - currentStacks);
                            if (actualAdd > 0) {
                                enemy.readyStacks = currentStacks + actualAdd;
                                const hpBonus = actualAdd * 1.5;
                                enemy.maxHp += hpBonus; enemy.hp += hpBonus; 
                                showPickupEffect(enemy.x, enemy.y, "서버렸잖아♥", false, true, "condensed-milk-text");
                            }
                        }
                        enemy.readyTimer = 0;
                    }
                    
                    if (enemy.isZako && enemy.enraged) {
                        enemy.enrageTimer--;
                        if (enemy.enrageTimer <= 0) {
                            enemy.enraged = false;
                        }
                    }
                }
                
                if (enemy.contactStackTimer > 0) enemy.contactStackTimer--;
                
                if (enemy.isZako) {
                    let effectiveSpeed = enemy.baseSpeed;
                    // [신규] 자코에게도 광시곡 속도 버프 적용 (1.3배)
            if (isRhapsodyActive) {
                effectiveSpeed *= 1.3;
            }

            if (enemy.enraged) {
                effectiveSpeed *= 2.5;
                enemy.vx = Math.cos(Math.atan2(player.y - enemy.y, player.x - enemy.x)) * effectiveSpeed;
                enemy.vy = Math.sin(Math.atan2(player.y - enemy.y, player.x - enemy.x)) * effectiveSpeed;
                
                if (enemy.state !== 'pouncing' && enemy.state !== 'pounce_warmup' && enemy.state !== 'cooldown') {
                    enemy.x += enemy.vx;
                    enemy.y += enemy.vy;
                }
                    } else {
                         const creepSpeed = 0.2;
                         const creepAngle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
                         if (enemy.state !== 'pouncing') {
                            enemy.x += Math.cos(creepAngle) * creepSpeed;
                            enemy.y += Math.sin(creepAngle) * creepSpeed;
                         }
                    }

                    if (enemy.state === 'idle') {
                        if (!enemy.enraged) { enemy.vx = 0; enemy.vy = 0; } 
                        const d = Math.hypot(player.x - enemy.x, player.y - enemy.y);
                        if (d < 350) { enemy.state = 'pounce_warmup'; enemy.pounceTimer = 15; showPickupEffect(enemy.x, enemy.y, "!", false); }
                    } else if (enemy.state === 'wandering') {
                        if (!enemy.enraged) {
                            enemy.wanderTimer++;
                            if (enemy.wanderTimer > 60) { enemy.wanderAngle = Math.random() * Math.PI * 2; enemy.wanderTimer = 0; }
                            enemy.vx = Math.cos(enemy.wanderAngle) * enemy.baseSpeed; enemy.vy = Math.sin(enemy.wanderAngle) * enemy.baseSpeed;
                            enemy.x += enemy.vx; enemy.y += enemy.vy; 
                        }
                    } else if (enemy.state === 'pounce_warmup') {
                        enemy.pounceTimer--;
                        if (enemy.pounceTimer <= 0) { 
                            enemy.state = 'pouncing'; 
                            const angle = Math.atan2(player.y - enemy.y, player.x - enemy.x); 
                            const speed = 5 * speedMultiplier; 
                            enemy.vx = Math.cos(angle) * speed; enemy.vy = Math.sin(angle) * speed; 
                            enemy.pounceDuration = 40; 
                            showPickupEffect(enemy.x, enemy.y - 40, "한판하자♥", false, false, "dirty-pink-text");
                        }
                    } else if (enemy.state === 'pouncing') {
                        enemy.x += enemy.vx; enemy.y += enemy.vy; enemy.pounceDuration--;
                        if (enemy.pounceDuration <= 0) { enemy.state = 'cooldown'; enemy.cooldownTimer = 120; }
                    } else if (enemy.state === 'cooldown') {
                        enemy.vx = 0; enemy.vy = 0; enemy.cooldownTimer--; if (enemy.cooldownTimer <= 0) enemy.state = 'idle';
                    }
                } else {
                    let speedMult = 1.0;
                if (isRhapsodyActive && !enemy.isTetora) {
        speedMult = 1.3;
    }
                    enemy.speed = (enemy.baseSpeed * speedMultiplier * speedMult) + ecstasyFlatBonus;
                    if (enemy.isAmbush && enemy.ambushState === 'ambush') { enemy.speed = 0; }

                    if (enemy.isElite && !enemy.isBoss) {
                        if (enemy.isCassias && enemy.hp < enemy.maxHp * 0.3) { enemy.speed *= 2.2; }
                    } else if (enemy.isStealth) {
                        enemy.stealthTimer = (enemy.stealthTimer || 0) + 1;
                        const cycle = enemy.stealthTimer % 240; if(cycle > 90) enemy.alpha = 0.02; else enemy.alpha = 1.0; 
                    }

                    let angle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
                    
                    if (enemy.isAgent) {
                        const distToPlayer = Math.hypot(player.x - enemy.x, player.y - enemy.y);
                        const targetDist = 320; 
                        const buffer = 10; 
                        if (distToPlayer < targetDist - buffer) {
                            angle = Math.atan2(enemy.y - player.y, enemy.x - player.x);
                        } else if (distToPlayer > targetDist + buffer) {
                            angle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
                        } else {
                            enemy.speed = 0;
                        }
                    }
                    
                    enemy.angle = angle;
                    
                    if (enemy.dashTimer > 0) {
                        enemy.x += enemy.dashVx; enemy.y += enemy.dashVy; enemy.dashTimer--;
                        if (frameCount % 3 === 0) {
                            let img = summonerVillainImg;
                            if (enemy.isArthur) img = arthurImg;
                            else if (enemy.isBoss) img = bossVillainImg;
                            else if (enemy.isRyuon) img = corruptedHeroImg;
                            else if (enemy.isLuca) img = corruptedSniperImg; 
                            else if (enemy.isOzma) img = ozmaImg; 
                            else if (enemy.isTaro) img = taroImg; 
                            else if (enemy.isGawain) img = gawainImg; 
                            else if (enemy.isAki) img = akiImg; 
                            else if (enemy.isHiro) img = hiroImg;
                            else if (enemy.isKai) img = kaiImg;
                            else if (enemy.isJacques) img = jacquesImg;

                            else if (enemy.isElite) img = eliteVillainImg;
                            else if (enemy.isAgent) { 
                                if (enemy.agentType === 'curse') img = agentCurseImg;
                                else if (enemy.agentType === 'pain') img = agentPainImg;
                                else img = agentBlindImg;
                            }
                            else if (enemy.normalType === 'rapist') img = rapistVillainImg;

                            spawnGhost(enemy.x, enemy.y, enemy.radius, enemy.angle + Math.PI / 2, img, enemy.isElite);
                        }
                    } else {
                        if (enemy.isLuca || enemy.isAki || enemy.isOzma || enemy.isHiro || enemy.isKai || enemy.isJacques || enemy.isAkiClone || (enemy.isArchdemon && enemy.archdemonName.includes('토우야'))) { 
                            const distToPlayer = Math.hypot(player.x - enemy.x, player.y - enemy.y);
                            let maintainDist = 320;
                            if (enemy.isLuca || enemy.isAki) maintainDist = 320;
                            if (enemy.isHiro) maintainDist = 320;
                            
                            if (distToPlayer < maintainDist) {
                                enemy.vx = -Math.cos(angle) * enemy.speed;
                                enemy.vy = -Math.sin(angle) * enemy.speed;
                            } else if (distToPlayer > maintainDist + 100) {
                                enemy.vx = Math.cos(angle) * enemy.speed;
                                enemy.vy = Math.sin(angle) * enemy.speed;
                            } else {
                                enemy.vx = 0; 
                                enemy.vy = 0;
                            }
                            if (enemy.isAkiClone) {
                                // 현재 살아있는 아키 본체 찾기
                                const mainAki = enemies.find(e => e.isAki && !e.isAkiClone && e.hp > 0);
                                if (mainAki) {
                                    const distToMain = Math.hypot(enemy.x - mainAki.x, enemy.y - mainAki.y);
                                    const separationDist = 320; // 본체와 유지할 최소 거리
                                    
                                    if (distToMain < separationDist) {
                                        // 본체로부터 멀어지는 방향 계산
                                        const repelAngle = Math.atan2(enemy.y - mainAki.y, enemy.x - mainAki.x);
                                        // 현재 이동 벡터에 밀어내는 힘 추가
                                        enemy.vx += Math.cos(repelAngle) * 2; 
                                        enemy.vy += Math.sin(repelAngle) * 2;
                                    }
                                }
                            }
                        } else {
                            if (enemy.isAgent && enemy.speed === 0) {
                                enemy.vx = 0; enemy.vy = 0;
                            } else {
                                enemy.vx = Math.cos(angle) * enemy.speed; 
                                enemy.vy = Math.sin(angle) * enemy.speed;
                            }
                        }
                        
                        if (enemy.isTaro) {
                            if (enemy.transparentTimer > 0) {
                                enemy.transparentTimer--;
                                enemy.alpha = 0.2;
                            } else {
                                enemy.alpha = 1.0;
                                enemy.isTransparent = false;
                            }

                            if (enemy.speedBoostTimer > 0) {
                                enemy.speedBoostTimer--;
                                enemy.speed *= 2.5; 
                                enemy.vx *= 2.5; enemy.vy *= 2.5;
                            }

                            enemy.backstabTimer = (enemy.backstabTimer || 0) + 1;
                            if (enemy.backstabTimer > 360) {
                                const pAngle = Math.atan2(player.vy, player.vx) || player.weapon.angle; 
                                const backAngle = pAngle + Math.PI; 
                                enemy.x = player.x + Math.cos(backAngle) * 100;
                                enemy.y = player.y + Math.sin(backAngle) * 100;
                                
                                enemy.isTransparent = true;
                                enemy.transparentTimer = 120; 
                                enemy.speedBoostTimer = 120; 
                                showPickupEffect(enemy.x, enemy.y - 40, "엉덩이 들어♥", false, false, "dirty-pink-text");
                                
                                enemy.backstabTimer = 0;
                            }

                            if (enemy.sonicState === 'idle') {
                                enemy.sonicBoomTimer = (enemy.sonicBoomTimer || 0) + 1;
                                if (enemy.sonicBoomTimer > 420) {
                                    enemy.sonicState = 'warmup';
                                    enemy.sonicBoomTimer = 0;
                                    showPickupEffect(enemy.x, enemy.y - 40, "시원하게 박아주마♥", false, false, "condensed-milk-text");
                                }
                            } else if (enemy.sonicState === 'warmup') {
                                enemy.sonicBoomTimer++;
                                if (enemy.sonicBoomTimer > 90) { 
                                    enemy.sonicState = 'dash';
                                    enemy.sonicBoomTimer = 0;
                                    
                                    // [수정] 돌진 시작 시, 버프 받은 아군 목록 초기화
                                    enemy.dashBuffedAllies = []; 
                                    
                                    const dashAngle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
                                    enemy.dashVx = Math.cos(dashAngle) * 15; 
                                    enemy.dashVy = Math.sin(dashAngle) * 15;
                                }
                            } else if (enemy.sonicState === 'dash') {
                                enemy.x += enemy.dashVx;
                                enemy.y += enemy.dashVy;
                                enemy.sonicBoomTimer++;
                                
                                if (enemy.sonicHitCooldown > 0) enemy.sonicHitCooldown--;

                                // [수정] 이미 버프를 받은 아군은 제외하고 한 번만 적용
                                if (!enemy.dashBuffedAllies) enemy.dashBuffedAllies = []; // 안전 장치

                                enemies.forEach(ally => {
                                    if (ally !== enemy && !enemy.dashBuffedAllies.includes(ally)) {
                                        const dist = Math.hypot(enemy.x - ally.x, enemy.y - ally.y);
                                        if (dist < 210) {
                                            ally.erectionStacks = Math.min(ally.erectionStacks + 3, 20);
                                            enemy.dashBuffedAllies.push(ally); // 버프 받은 목록에 추가
                                            
                                            showDamageText(ally.x, ally.y, "발기해라♥", false, false, "heal-text");
                                        }
                                    }
                                });

                                const distToPlayer = Math.hypot(player.x - enemy.x, player.y - enemy.y);

                                if (distToPlayer < player.radius + enemy.radius) {
                                     if (enemy.sonicHitCooldown <= 0) {
                                         let dmg = 20 + Math.floor(score * 0.18);
                                         takeDamage(dmg, 'direct', enemy.accuracy, enemy);
                                         showPickupEffect(player.x, player.y, "크헉!", false);
                                         enemy.sonicHitCooldown = 30; 
                                     }
                                }

                                if (enemy.sonicBoomTimer > 30) { 
                                    enemy.sonicState = 'idle';
                                    enemy.sonicBoomTimer = 0;
                                }
                                return; 
                            }
                        }
                        
                        if (enemy.isGawain) {
                            // [잠금] 잔혹한 돌진 차지/돌진 중에는 다른 스킬(단죄의 검)을 사용하지 않음
                            if (enemy.isCruelCharging || enemy.isCruelChargeCharging) {
                                enemy.gawainJumpState = 'idle';
                                enemy.gawainJumpTimer = 0;
                                enemy.gawainSwordTimer = 0;
                            } else {
                            enemy.gawainSwordTimer++;
                            if (enemy.gawainSwordTimer > 900) {
                                enemy.gawainJumpState = 'warmup';
                                enemy.gawainSwordTimer = 0;
                                showPickupEffect(enemy.x, enemy.y - 60, "단죄의 검!", false, false, "gawain-text");
                            }

                            if (enemy.gawainJumpState === 'warmup') {
                                enemy.gawainJumpTimer++;
                                enemy.vx = 0; enemy.vy = 0;
                                if (enemy.gawainJumpTimer > 60) {
                                    enemy.gawainJumpState = 'jump'; 
                                    enemy.alpha = 0;
                                    enemy.gawainJumpTimer = 0;
                                    enemy.targetX = player.x;
                                    enemy.targetY = player.y;
                                }
                            } else if (enemy.gawainJumpState === 'jump') {
                                enemy.gawainJumpTimer++;
                                enemy.x = -1000; enemy.y = -1000; 
                                if (enemy.gawainJumpTimer > 60) {
                                    enemy.gawainJumpState = 'slam';
                                    enemy.gawainJumpTimer = 0;
                                    enemy.x = enemy.targetX; 
                                    enemy.y = enemy.targetY;
                                    enemy.alpha = 1;
                                    
                                    const dist = Math.hypot(player.x - enemy.x, player.y - enemy.y);
                                    if (dist < 300) {
                                        let dmg = 15 + Math.floor(score * 0.17);
                                        takeDamage(dmg, 'direct', enemy.accuracy, enemy);
                                        if (player.shieldStacks > 0) player.shieldStacks = Math.floor(player.shieldStacks * 0.75);
                                        if (player.justiceShield > 0) player.justiceShield = Math.floor(player.justiceShield * 0.75);
                                        updateStatusUI();
                                        showPickupEffect(player.x, player.y, "저항은 소용없다..", false);
                                    }
                                        spawnDarkGas(enemy.x, enemy.y, 3.5, 1.5, enemy.accuracy, 0, enemy);
                                        shockwaves.push({
                                        x: enemy.x,
                                        y: enemy.y,
                                        radius: 300,      
                                        speed: 12,       
                                        alpha: 1.0,      
                                        fade: 0.03       
                                    });

                                    for(let k=0; k<10; k++) {
                                        spawnWhiteShot(enemy.x, enemy.y, true, false, enemy); 
                                    }
                                    
                                    groundCracks.push({
                                        x: enemy.x,
                                        y: enemy.y,
                                        life: 90,
                                        maxLife: 90
                                    });

                                    enemy.gawainJumpState = 'idle';
                                }
                            }
                        
                            }
}
                        
                        if ((!enemy.isTaro || enemy.sonicState === 'idle') && (!enemy.isGawain || enemy.gawainJumpState === 'idle')) {
                            enemy.x += enemy.vx; enemy.y += enemy.vy;
                        }
                    }

                   // [수정됨] 아서는 카인의 패턴을 공유하지 않도록 조건을 추가 (!enemy.isArthur)
                      if (enemy.isBoss && !enemy.isArthur) {
            
            // [신규 수정] 아키토와 토우야(Archdemon)는 카인의 패턴(가스, 똥, 정액, 소환 등)을 사용하지 않음
            if (!enemy.isArchdemon) {
                enemy.hollowNightTimer = (enemy.hollowNightTimer || 0) + 1;
                if (enemy.hollowNightTimer > 1200) {
                    spawnHollowNight(enemy.x, enemy.y, enemy.accuracy, enemy);
                    enemy.hollowNightTimer = 0;
                }

                enemy.darkGasTimer++;
                if (enemy.darkGasTimer > 120) {
                    let sizeMult = 1.25;
                    if (enemy.bossType === 0) sizeMult = 3.5;
                    spawnDarkGas(enemy.x, enemy.y, sizeMult, 1.0, enemy.accuracy, 0, enemy);
                    spawnPoop(enemy.x, enemy.y, true, false, false, enemy.accuracy, enemy);
                    enemy.darkGasTimer = 0;
                }

                if (enemy.bossType === 0) {
                    enemy.darkGasExtraTimer = (enemy.darkGasExtraTimer || 0) + 1;
                    if (enemy.darkGasExtraTimer >= 60) {
                        spawnGas(enemy.x, enemy.y, false, false, 0, 4.0, enemy.accuracy, enemy);
                        enemy.darkGasExtraTimer = 0;
                    }
                }

                enemy.darkBigPoopTimer++;
                if (enemy.bossType === 1) {
                    if (enemy.darkBigPoopTimer % 120 === 0) {
                        spawnDarkBigPoop(enemy.x, enemy.y, false, 0, false, enemy.accuracy, enemy);
                    }
                    if (enemy.darkBigPoopTimer % 240 === 0) {
                        spawnDarkBigPoop(enemy.x, enemy.y, false, 0, true, enemy.accuracy, enemy);
                        showPickupEffect(enemy.x, enemy.y - 60, "받아라!!", false, false, "evil-shout-text");
                    }
                } else if (enemy.darkBigPoopTimer > 360) {
                    spawnDarkBigPoop(enemy.x, enemy.y, false, 0, false, enemy.accuracy, enemy);
                    enemy.darkBigPoopTimer = 0;
                }
                if (enemy.darkBigPoopTimer > 24000) enemy.darkBigPoopTimer = 0;

                if (enemy.bossType === 2) {
                    enemy.darkNormalSemenTimer = (enemy.darkNormalSemenTimer || 0) + 1;
                    if (enemy.darkNormalSemenTimer > 120) {
                        spawnDarkSemen(enemy.x, enemy.y, false, enemy.angle, 1.0, enemy.accuracy, enemy);
                        enemy.darkNormalSemenTimer = 0;
                    }
                }

                if (enemy.bossType === 2) {
                    enemy.darkTargetSemenTimer = (enemy.darkTargetSemenTimer || 0) + 1;
                    if (enemy.darkTargetSemenTimer > 360) {
                        spawnDarkSemen(enemy.x, enemy.y, true, 0, 3.0, enemy.accuracy, enemy);
                        showPickupEffect(enemy.x, enemy.y - 60, "임신시켜주마", false, false, "pregnancy-text");
                        enemy.darkTargetSemenTimer = 0;
                    }
                }

                enemy.mindBreakTimer++;
                const mbInterval = (enemy.bossType === 3) ? 60 : 480;
                if (enemy.mindBreakTimer >= mbInterval) {
                    spawnMindSkull(enemy.x, enemy.y, enemy.accuracy, enemy);
                    enemy.mindBreakTimer = 0;
                    showPickupEffect(enemy.x, enemy.y - 80, "마인드 브레이크!", false, false, "mind-break-text");
                }

                if (enemy.bossType === 4) {
                    enemy.tanetsukeTimer++;
                    if (enemy.tanetsukeTimer > 360) {
                        for (let k = 0; k < 3; k++) addStatus('darkReceiver', 900, 20);
                        showPickupEffect(player.x, player.y, "넌 내 좆집이다!", false, false, "evil-shout-text");
                        enemy.tanetsukeTimer = 0;
                    }

                    enemy.tanetsukeTeleportTimer = (enemy.tanetsukeTeleportTimer || 0) + 1;
                    if (enemy.tanetsukeTeleportTimer >= 360) {
                        const pAngle = Math.atan2(player.vy || 0, player.vx || 1);
                        const backAngle = pAngle + Math.PI;
                        const dist = 140 + Math.random() * 50;
                        enemy.x = player.x + Math.cos(backAngle) * dist;
                        enemy.y = player.y + Math.sin(backAngle) * dist;

                        const baseAngle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
                        const fan = [-0.22, 0, 0.22];
                        for (const off of fan) {
                            spawnDarkSemen(enemy.x, enemy.y, false, baseAngle + off, 1.0, enemy.accuracy, enemy);
                        }
                        showPickupEffect(enemy.x, enemy.y - 70, "후면 강습♥", false, false, "evil-shout-text");
                        enemy.tanetsukeTeleportTimer = 0;
                    }
                }

                enemy.demonSummonTimer++;
                if (enemy.demonSummonTimer > 2760) {
                    spawnArchdemons(enemy.x, enemy.y);
                    showPickupEffect(enemy.x, enemy.y - 80, "하하하하", false, false, "evil-summon-text");
                    enemy.demonSummonTimer = 0;
                }
            } // [끝] 카인 패턴 종료

            // 아키토 패턴
            if (enemy.isArchdemon && enemy.archdemonName.includes('아키토')) {
                enemy.pandemoniumTimer = (enemy.pandemoniumTimer || 0) + 1;
                if (enemy.pandemoniumTimer > 600) {
                    spawnPandemonium(enemy.x, enemy.y, enemy.accuracy, enemy);
                    showPickupEffect(enemy.x, enemy.y - 60, "판데모니움!", false, false, "wicked-large-text");
                    enemy.pandemoniumTimer = 0;
                }
                
                if (enemy.soulHarvestTimer === undefined) enemy.soulHarvestTimer = 400;
                if (enemy.catastropheTimer === undefined) enemy.catastropheTimer = 600;

                // 1. 소울 하비스트
                if (enemy.soulHarvestTimer > 0) {
                    enemy.soulHarvestTimer--;
                } else {
                    castSoulHarvest(enemy);
                    enemy.soulHarvestTimer = 840;
                }

                // 2. 커스드 카타스트로피
                if (enemy.catastropheTimer > 0) {
                    enemy.catastropheTimer--;
                } else {
                    spawnCursedCatastrophe(enemy.x, enemy.y, enemy.accuracy, enemy);
                    enemy.catastropheTimer = 960;
                }
            }

            // 토우야 패턴
            if (enemy.isArchdemon && enemy.archdemonName.includes('토우야')) {
                // 1. 프리즘 스윕 (쿨타임 21초 = 1260프레임)
                enemy.prismSweepCooldown = (enemy.prismSweepCooldown || 0) + 1;
                if (enemy.prismSweepCooldown >= 1260) {
                    spawnPrismSweep(player.x, player.y - 100, enemy.accuracy, enemy);
                    enemy.prismSweepCooldown = 0;
                }

                // 2. 오클루전 스풀 (쿨타임 15초 = 900프레임)
                enemy.occlusionSpoolCooldown = (enemy.occlusionSpoolCooldown || 0) + 1;
                if (enemy.occlusionSpoolCooldown >= 900) {
                    spawnOcclusionSpool(enemy.accuracy, enemy);
                    enemy.occlusionSpoolCooldown = 0;
                }
                enemy.evilLightTimer = (enemy.evilLightTimer || 0) + 1;
                if (enemy.evilLightTimer > 1500) {
                    triggerEvilLight(enemy);
                    enemy.evilLightTimer = 0;
                }
            }
        } else {
            let cooldownMult = 1.0;
                        if (enemy.isCassias && enemy.hp < enemy.maxHp * 0.3) { cooldownMult = 0.5; }

                        enemy.gasTimer++;
                        const currentGasInterval = Math.max(30, (enemy.gasInterval / Math.sqrt(speedMultiplier)) * cooldownMult);
                        
                        if (enemy.isRyuon) {
                            enemy.darkWaveTimer = (enemy.darkWaveTimer || 0) + 1;
                            if (enemy.darkWaveTimer > 240 * cooldownMult) {
        const angle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
        spawnDarkWave(enemy.x, enemy.y, angle, enemy.accuracy, enemy); // [수정] accuracy 전달
        showPickupEffect(enemy.x, enemy.y - 50, "타락하라!!", false, false, "corrupted-text");
        enemy.darkWaveTimer = 0;
    }
                            
                            if (enemy.chargeState === 'idle') {
                                enemy.chargeTimer = (enemy.chargeTimer || 0) + 1;
                                if (enemy.chargeTimer > 360 * cooldownMult) {
                                    enemy.chargeState = 'warmup';
                                    enemy.chargeTimer = 0;
                                    showPickupEffect(enemy.x, enemy.y - 50, "정의는 죽었다..", false, false, "corrupted-text");
                                }
                            } else if (enemy.chargeState === 'warmup') {
                                enemy.chargeTimer++;
                                enemy.vx = 0; enemy.vy = 0; 

                                // [신규] 류온 '정의의 돌진' 차지 이펙트: 검붉은 방구 구름이 류온에게 모여듦
                                spawnJusticeChargeAura(enemy);

                                if (enemy.chargeTimer > 90) {
                                    enemy.chargeState = 'charging';
                                    enemy.chargeTimer = 0;
                                    const angle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
                                    enemy.dashVx = Math.cos(angle) * 8.2;
                                    enemy.dashVy = Math.sin(angle) * 8.2;
                                }
                            } else if (enemy.chargeState === 'charging') {
                                enemy.x += enemy.dashVx;
                                enemy.y += enemy.dashVy;
                                enemy.chargeTimer++;
                                if (frameCount % 15 === 0) {
                                    spawnDeathCloud(enemy.x, enemy.y, enemy.isElite, enemy.isBoss, enemy.accuracy, enemy);
                                }
                                if (enemy.chargeTimer > 60) {
                                    if (enemy.chargeCount < 1) {
                                        enemy.chargeState = 'warmup';
                                        enemy.chargeTimer = 0;
                                        enemy.chargeCount++;
                                    } else {
                                        enemy.chargeState = 'idle';
                                        enemy.chargeTimer = 0;
                                        enemy.chargeCount = 0;
                                    }
                                }
                            }
                        }
                        
                                               if (enemy.isLuca) {
                            enemy.aimTimer = (enemy.aimTimer || 0) + 1;
                            if (enemy.aimTimer > 420 * cooldownMult) { 
                                if (enemy.aimTimer < 480 * cooldownMult) {
                                } else {
                                    const shot = {
                                        x: enemy.x, y: enemy.y,
                                        vx: Math.cos(enemy.angle) * 15,
                                        vy: Math.sin(enemy.angle) * 15,
                                        radius: 10,
                                        life: 120,
                                        isZako: false, isElite: true,
                                        isStun: true,
                                        isLucaShot: true 
                                    };
                                    whiteshots.push(shot);
                                    showPickupEffect(enemy.x, enemy.y - 50, "얼굴에 싼다!♥", false, false, "sniper-text");
                                    enemy.aimTimer = 0;
                                }
                            }
                            
                                                        // (Luca) 일반 화이트샷 패턴 제거: 빨간 조준 후 발사만 사용
                            enemy.lucaSummonTimer = (enemy.lucaSummonTimer || 0) + 1;

            // 7초(420프레임)마다 실행
            if (enemy.lucaSummonTimer >= 420) {
                // 랜덤 자코 2마리 소환 반복문
                for (let k = 0; k < 2; k++) {
                    const zakoTypes = [null, 'terrorist', 'plague']; // 자코 타입 목록 (일반, 자폭, 역병)
                    const randomZako = zakoTypes[Math.floor(Math.random() * zakoTypes.length)]; // 랜덤 선택
                    
                    // 루카 주변 랜덤한 위치에 소환
                    const spawnX = enemy.x + (Math.random() - 0.5) * 100;
                    const spawnY = enemy.y + (Math.random() - 0.5) * 100;
                    
                    spawnZako(spawnX, spawnY, randomZako);
                }

                // 대사/이펙트 출력 (원하는 멘트로 수정 가능)
                showPickupEffect(enemy.x, enemy.y - 60, "나와라 얘들아♥", false, false, "pink-text");
                
                // 타이머 초기화
                enemy.lucaSummonTimer = 0;
            }

enemy.blinkMineTimer = (enemy.blinkMineTimer || 0) + 1;
                            if (enemy.blinkMineTimer >= 360) { // 360프레임 = 6초
                            spawnBlinkMines(enemy.x, enemy.y, 3, enemy, enemy.accuracy);
                            enemy.blinkMineTimer = 0;
            }

                            enemy.pheromoneTimer = (enemy.pheromoneTimer || 0) + 1;
                            if (enemy.pheromoneTimer > 300 * cooldownMult) {
        spawnPheromoneMarker(enemy.x, enemy.y, enemy.angle, enemy.accuracy, enemy); // [수정]
        showPickupEffect(enemy.x, enemy.y - 30, "페로몬 발사!", false, false, "pink-text");
        enemy.pheromoneTimer = 0;
                            }
                        }
                        
                        if (enemy.isOzma) {
                            enemy.healPulseTimer = (enemy.healPulseTimer || 0) + 1;
                            if (enemy.healPulseTimer > 240 * cooldownMult) {
                                let healedAny = false;
                                let healAmount = 15 + Math.floor(score * 0.12);
                                for (let ally of enemies) {
                                    if (ally !== enemy && ally.hp > 0) { 
                                        const dist = Math.hypot(enemy.x - ally.x, enemy.y - ally.y);
                                        if (dist < 250) {
                                            if (ally.hp < ally.maxHp) {
                                            let finalHeal = Math.floor(healAmount * (ally.hpRecoveryRate || 1));
                                            ally.hp = Math.min(ally.maxHp, ally.hp + finalHeal);
                                            ally.erectionStacks = Math.min(ally.erectionStacks + 1, 20);
                                            showDamageText(ally.x, ally.y, "+" + finalHeal, false, false, 'heal-text');
                                            healedAny = true;
                                           }
                                        }
                                    }
                                }
                                if (healedAny) {
                                    showPickupEffect(enemy.x, enemy.y - 30, "치유♥", false, false, "heal-text");
                                }
                                enemy.healPulseTimer = 0;
                            }
                            
                            enemy.pleasureZoneTimer = (enemy.pleasureZoneTimer || 0) + 1;
                            if (enemy.pleasureZoneTimer > 480 * cooldownMult) {
        spawnPleasureZone(player.x, player.y, enemy.accuracy, enemy); // [수정]
        showPickupEffect(enemy.x, enemy.y - 50, "밟아볼래♥", false, false, "pink-text");
        enemy.pleasureZoneTimer = 0;
                            }
                            
                            // 비석 소환 타이머
                        enemy.monolithSummonTimer = (enemy.monolithSummonTimer || 0) + 1;
        
                        if (enemy.monolithSummonTimer >= 1020) {
            // 플레이어 주변 랜덤한 위치에 소환
            const angle = Math.random() * Math.PI * 2;
            const dist = 150 + Math.random() * 150; // 150~300 거리
            const mx = player.x + Math.cos(angle) * dist;
            const my = player.y + Math.sin(angle) * dist;
            
            // 맵 밖으로 나가지 않게 보정
            const finalX = Math.max(50, Math.min(canvas.width - 50, mx));
            const finalY = Math.max(50, Math.min(canvas.height - 50, my));
            
            spawnMonolith(finalX, finalY, enemy.accuracy, enemy);
            
            enemy.monolithSummonTimer = 0;
        }

                            enemy.darkBlessingTimer = (enemy.darkBlessingTimer || 0) + 1;
                            if (enemy.darkBlessingTimer > 420 * cooldownMult) {
                                let blessed = false;
                                for (let ally of enemies) {
                                    if (ally !== enemy) { 
                                        const dist = Math.hypot(enemy.x - ally.x, enemy.y - ally.y);
                                        if (dist < 600) {
                                            ally.hasShield = true;
                                            blessed = true;
                                        }
                                    }
                                }
                                if (blessed) {
                                    showPickupEffect(enemy.x, enemy.y - 50, "단단해져라♥", false, false, "evil-purple-text");
                                }
                                enemy.darkBlessingTimer = 0;
                            }
                        }
                        
                        if (enemy.gasTimer > currentGasInterval) {
                            if (enemy.isCassias) {
                                spawnGas(enemy.x, enemy.y, true, false, 1, 2, enemy.accuracy, enemy);
                                spawnPoop(enemy.x, enemy.y, { isElite: true, sizeMult: 2, speedMin: 0.50, speedMax: 2.0, accuracy: enemy.accuracy, owner: enemy });
                                enemy.dashTimer = 30; enemy.dashVx = Math.cos(enemy.angle) * 6; enemy.dashVy = Math.sin(enemy.angle) * 6;
                                showPickupEffect(enemy.x, enemy.y - 40, "뿌우욱♥", false, true, "dirty-brown-text");
                                enemy.gasTimer = 0;
                            } else if (!enemy.isRyuon && !enemy.isLuca && !enemy.isOzma && !enemy.isTaro && !enemy.isGawain && !enemy.isAki && !enemy.isHiro && !enemy.isJacques && !enemy.isKai) {
                                spawnGas(enemy.x, enemy.y, enemy.isElite, enemy.isZako, 0, 1, enemy.accuracy, enemy);
                                enemy.x -= enemy.vx * 5; enemy.y -= enemy.vy * 5;
                                enemy.gasTimer = 0;
                            }
                        }

                        enemy.whiteShotTimer++;
                        const shotInterval = (enemy.isElite ? 180 : 300) * cooldownMult;
                        if (enemy.whiteShotTimer > shotInterval) {
                            const canUseWhiteShot = enemy.isElite
                                ? enemy.isCassias
                                : (!enemy.isLuca && !enemy.isAgent && !enemy.isGawain && !enemy.isAki && !enemy.isHiro);

                            if (canUseWhiteShot) {
                                spawnWhiteShot(enemy.x, enemy.y, enemy.isElite, false, 0, false, enemy.accuracy, enemy);
                            }
                            enemy.whiteShotTimer = 0;
                        }

                        if (enemy.isDarkDenizen && enemy.denizenType === 'louie') {
                            enemy.darkHeartTimer++;
                            if (enemy.darkHeartTimer > 300) { spawnDarkHeart(enemy.x, enemy.y, enemy.accuracy, enemy); enemy.darkHeartTimer = 0; }
                        }

                        if (enemy.isElite) {
                            if (enemy.isCassias) {
                                enemy.bigPoopTimer++;
                                enemy.homingPoopTimer = (enemy.homingPoopTimer || 0) + 1;
                                enemy.homingSemenTimer = (enemy.homingSemenTimer || 0) + 1;

                                if (enemy.bigPoopTimer > 180 * cooldownMult) {
                                    spawnBigPoop(enemy.x, enemy.y, enemy.accuracy, enemy);
                                    enemy.bigPoopTimer = 0;
                                }
                                if (enemy.homingPoopTimer > 300 * cooldownMult) {
                                    spawnHomingBigPoop(enemy.x, enemy.y, enemy.accuracy, enemy);
                                    enemy.homingPoopTimer = 0;
                                }
                                if (enemy.homingSemenTimer > 420 * cooldownMult) {
                                    spawnHomingSemen(enemy.x, enemy.y, enemy.accuracy, enemy);
                                    showPickupEffect(enemy.x, enemy.y - 40, "유도 정액!", false);
                                    enemy.homingSemenTimer = 0;
                                }
                            }

                            if (!enemy.isCassias && !enemy.isSummoned && !enemy.isBoss && !enemy.isRyuon && !enemy.isLuca && !enemy.isOzma && !enemy.isTaro && !enemy.isGawain && !enemy.isAki && !enemy.isHiro && !enemy.isKai && !enemy.isJacques) {
                                enemy.darkDenizenSummonTimer = (enemy.darkDenizenSummonTimer || 0) + 1;
                                let summonThreshold = enemy.hasSummonedDenizen ? 900 : 240;
                                
                                if (enemy.darkDenizenSummonTimer > summonThreshold) { 
                                    spawnDarkDenizen(enemy.x + 40, enemy.y, 'louie');
                                    spawnDarkDenizen(enemy.x - 40, enemy.y, 'rai');
                                    showPickupEffect(enemy.x, enemy.y - 80, "어둠이여..", false, false, "evil-summon-text");
                                    darkDenizenSummonAudio.currentTime = 0;
                                    darkDenizenSummonAudio.play().catch(()=>{});
                                    enemy.darkDenizenSummonTimer = 0;
                                    enemy.hasSummonedDenizen = true; 
                                }
                            }
                        }

                        if (!enemy.isElite) {
                            if (enemy.normalType !== 'rapist' && !enemy.isDarkDenizen && !enemy.isAgent) { 
                                enemy.summonTimer++;
                                if (enemy.summonTimer > 600) {
                                    if (enemy.eliteType === 1) { spawnZako(enemy.x + 30, enemy.y, 'terrorist'); spawnZako(enemy.x - 30, enemy.y, 'terrorist'); } 
                                    else if (enemy.eliteType === 2) { spawnZako(enemy.x + 30, enemy.y, 'plague'); spawnZako(enemy.x - 30, enemy.y, 'plague'); } 
                                    else { spawnZako(enemy.x + 30, enemy.y); spawnZako(enemy.x - 30, enemy.y); }
                                    enemy.summonTimer = 0; 
                                    
                                    let summonText = "덮쳐주마♥";
                                    if (enemy.eliteType === 1) summonText = "좀 비릴거야♥";
                                    else if (enemy.eliteType === 2) summonText = "냄새에 파뭍혀라♥";
                                    showPickupEffect(enemy.x, enemy.y - 40, summonText, false, false, "evil-summon-text");
                                }
                            }
                        }
                    }
                }
                
                if (enemy.hp <= 0) {
                      let xpAmount = 1; // 기본 자코
                        if (enemy.isElite) xpAmount = 25;
                        if (enemy.isRoyal) xpAmount = 75;
                        if (enemy.isBoss) xpAmount = 120;
                        if (enemy.isAgent) xpAmount = 5;
                        // [PATCH] 대악마(아키토/토우야) 처치 경험치 기본값을 35로 조정 (기존 보스 120 대신)
                        if (enemy.isArchdemon && enemy.archdemonName && (enemy.archdemonName.includes('아키토') || enemy.archdemonName.includes('토우야'))) xpAmount = 35;
                        
                        let timeBonus = Math.floor(score / 10) * 2.5;
                        xpAmount += timeBonus;
                        gainXp(xpAmount); // 경험치 획득 함수 호출

                      if (enemy.isBoss && !enemy.isArchdemon) {
                         player.bonusAccuracy += 0.01;
                         player.bonusEvasion += 0.01;
                         showPickupEffect(player.x, player.y - 50, "명중/회피 +1% 상승!", true, true, "goddess-text");
                     }
                    let atkBonus = 0;
                    let hpBonus = 0;
                    let healAmount = 0;

                    if (enemy.isArchdemon) { atkBonus = 0.8; hpBonus = 5; healAmount = player.maxHealth * 0.01; } 
                    else if (enemy.isBoss) { atkBonus = 2.5; hpBonus = 6; healAmount = player.maxHealth * 0.01; } 
                    else if (enemy.isRoyal) { atkBonus = 1.5; hpBonus = 5.5; healAmount = player.maxHealth * 0.01; }
                    else if (enemy.isDarkDenizen) { atkBonus = 0.3; hpBonus = 2; healAmount = player.maxHealth * 0; } 
                    else if (enemy.isElite) { atkBonus = 0.6; hpBonus = 4; healAmount = player.maxHealth * 0.01; } 
                    else if (enemy.isZako) { atkBonus = 0.05; hpBonus = 0.4; healAmount = 0; } 
                    else if (enemy.isAgent) { atkBonus = 0.2; hpBonus = 1.5; healAmount = player.maxHealth * 0; } 
                    else { atkBonus = 0.2; hpBonus = 1.5; healAmount = player.maxHealth * 0; }
                    let reductionFactor = Math.min(0.5, score * 0.0005);
                    let multiplier = 1 - reductionFactor;
                    atkBonus *= multiplier;
                    hpBonus *= multiplier;

                    if (!enemy.isZako) { killCount++; killVal.innerText = killCount; }

                    if (healAmount > 0) { 
                        // [신규] 군주의 위엄 (처치 회복량 10% 감소)
                        if (player.majestyActive) {
                            healAmount *= 0.9;
                        }
                        player.health = Math.min(player.maxHealth, player.health + healAmount); 
                        updateHealthUI(); 
                    }

                    if (atkBonus > 0) { player.weapon.baseDamage += atkBonus; player.weapon.damage = player.weapon.baseDamage; }

                    if (hpBonus > 0) { player.baseMaxHealth += hpBonus; updateMaxHealth(); }

                    if (enemy.archdemonName && enemy.archdemonName.includes('토우야')) {
                        const stacksToRemove = enemy.appliedEvilLightCount || 0;
                        if (stacksToRemove > 0 && player.evilLightTimers.length > 0) {
                            const removeCount = Math.min(stacksToRemove, player.evilLightTimers.length);
                            player.evilLightTimers.splice(-removeCount, removeCount); 
                        }
                        updateMaxHealth(); updateStatusUI();
                        showPickupEffect(player.x, player.y - 50, "어둠이여 영원하라..", false, true, "evil-purple-text");
                    }
                    
                    if (enemy.isRyuon) {
                         player.corruptedOathStacks = Math.max(0, player.corruptedOathStacks - 1);
                         updateStatusUI();
                         showPickupEffect(player.x, player.y - 50, "맹세한다..", false, true);
                    }
                    if (enemy.isLuca) {
                         player.dangerousJudgmentStacks = Math.max(0, player.dangerousJudgmentStacks - 1);
                         updateStatusUI();
                         showPickupEffect(player.x, player.y - 50, "판단력이 돌아온다", false, true);
                    }
                    if (enemy.isOzma) {
                         player.deepDarknessStacks = Math.max(0, player.deepDarknessStacks - 1);
                         updateStatusUI();
                         showPickupEffect(player.x, player.y - 50, "어둠이 걷힌다", false, true);
                    }
                    if (enemy.isAki) {
                        activeAkiCount = Math.max(0, activeAkiCount - 1);
                        showPickupEffect(player.x, player.y - 50, "어둠의 기세가 꺾인다", false, true);
                    }
                    if (enemy.isJacques) {
                    // 신성 모독: 5초 (300프레임)
                    // 상태이상 방어막 무시 (checkShieldBlockStatus 호출 안함)
                    addStatus('blasphemy', 300, 1);
                    showPickupEffect(player.x, player.y, "신성 모독!!", false, true, "corrupted-text");
                }
                    if (enemy.isGawain) {
                        player.corruptedJusticeStacks = Math.max(0, player.corruptedJusticeStacks - 1);
                        updateStatusUI();
                        showPickupEffect(player.x, player.y - 50, "정의가 회복된다!", false, true);
                    }
                    if (enemy.isHiro) {
                        const remainingHiro = enemies.some(e => e !== enemy && e.isHiro && e.hp > 0);

                        if (!remainingHiro) {
                        player.skillSealTimer = 0;
                        skillSealOverlay.style.display = 'none';
                        showPickupEffect(player.x, player.y - 50, "방해 전파 차단!", false, true);
                    }
                }    
                    
                    if (enemy.isKai) {
                        items = items.filter(item => item.type !== 'fakeHealth');
                        showPickupEffect(player.x, player.y - 50, "환영이 사라졌다..", false, true);
                    }
                    if (enemy.isAkiClone) {
                        spawnDarkGas(enemy.x, enemy.y, 3.5, 1.2, enemy.accuracy, 0, enemy); // 3.5배 크기
                        showPickupEffect(enemy.x, enemy.y, "부루룩♥", false, true, "darkness-border");
                        spawnDarkBigPoop(enemy.x, enemy.y, false, 0, true, enemy.accuracy, enemy);

                    }
                 

                    if (enemy.isArthur) {
                        const remainingArthur = enemies.some(e => e !== enemy && e.isArthur && e.hp > 0);
                        if (!remainingArthur) {
                        player.majestyActive = false;
                        updateStatusUI();
                        showPickupEffect(player.x, player.y - 50, "군주의 위엄이 사라졌다..", false, true, "majesty-border");
                    }
               }

                    // 1. 기본 확률 설정 (예: 20%)
                        let baseDropChance = 0.2;

                    // 2. 감소 로직: 점수(시간)에 비례해 확률 차감
                    // 예: 점수 1점당 0.0005씩 감소 (1000점(약 8분) 도달 시 드랍율이 0%에 가까워짐.)
                        let timePenalty = score * 0.0005; 

                    // 3. 최종 확률 계산 (최소 확률 2%는 유지하도록 Math.max 사용)
                        let currentDropChance = Math.max(0.02, baseDropChance - timePenalty);

                        const dropRoll = Math.random();

                    // 4. 0.2 대신 계산된 확률(currentDropChance) 사용
                        if (dropRoll < currentDropChance) { 
                        if (Math.random() < 0.2) { spawnDroppedItem(enemy.x, enemy.y, 'health'); } 
                        else { spawnDroppedItem(enemy.x, enemy.y, 'shield'); }
                }

                    // [신규] 고대의 두루마리: 적 처치 시 1% 확률 드랍
                    if (Math.random() < 0.01) {
                        spawnDroppedItem(enemy.x, enemy.y, 'ancientScroll');
                    }

                    if (!enemy.isZako) { spawnDeathCloud(enemy.x, enemy.y, enemy.isElite, enemy.isBoss, enemy.accuracy, enemy); }

                    enemies.splice(i, 1); 
                    continue;
                }
                
                if (enemy.hitFlash > 0) enemy.hitFlash--;

                const dist = Math.hypot(player.x - enemy.x, player.y - enemy.y);
                if (dist < player.radius + enemy.radius) {
                    
                    if (player.bodyHitCooldown <= 0) {
                    if ((!enemy.isElite && enemy.normalType === 'rapist') || (enemy.isDarkDenizen && enemy.denizenType === 'rai')) {
                        if (!enemy.isAttached) {
                            enemy.isAttached = true; enemy.attachTimer = 0; enemy.isStealth = false; enemy.alpha = 1.0;
                            showPickupEffect(player.x, player.y, "잡았다♥", false, true, "evil-purple-text");
                            if (enemy.isDarkDenizen && enemy.denizenType === 'rai') { raiAttachAudio.currentTime = 0; raiAttachAudio.play().catch(()=>{}); } 
                            else { rapistAttachAudio.currentTime = 0; rapistAttachAudio.play().catch(()=>{}); }
                        }
                    } else {
                        if (player.invincibleTimer <= 0) {
                            let dmg = 0;
                                if (enemy.isBoss) dmg = 25; else if (enemy.isElite) dmg = 15; else if (enemy.isRoyal) dmg = 20; else dmg = 8; 
                                if (enemy.isBoss) dmg *= 1.25; else if (enemy.isElite) dmg *= 1.25; else if (enemy.isRoyal) dmg *= 1.25; else dmg *= 1.25;
                                dmg *= 0.25; dmg += Math.floor(score * 0.2); dmg *= 0.5;

                                if (enemy.isMasakuni && enemy.nextAttackCrit) {
                                dmg *= 1.5; // 치명타 2배
                                enemy.nextAttackCrit = false; // 소모
                                showPickupEffect(player.x, player.y, "심안 치명타!!", false, true, "masakuni-text");
                            }
                                if (enemy.isRyuon) {
                                    dmg += 1.5;
                                if (enemy.chargeState === 'charging') {
                                    dmg += 20;
    }
                                }
                                
                                if (enemy.isTaro) {
                                    dmg += 1.5; 
                                }

                                if (enemy.zakoType === 'terrorist') {
                                    dmg = 10; let applied = 0;
                                    for(let k=0; k<5; k++) { if(!checkShieldBlockStatus()) { addStatus('fishy', 900, 9999); applied++; } }
                                    if(applied > 0) showPickupEffect(player.x, player.y, "자멘샤워♥", false, true, "condensed-milk-text");
                                    showPickupEffect(enemy.x, enemy.y, "뷰르릇..받아라♥", false, true, "condensed-milk-text");
                                } else if (enemy.zakoType === 'plague') {
                                    dmg = 10; let applied = 0;
                                    for(let k=0; k<5; k++) { if (!checkShieldBlockStatus()) { addStatus('malice', 900, 20); applied++; } }
                                    if(applied > 0) showPickupEffect(player.x, player.y, `악의의 바이러스 +${applied}!`, false, true);
                                    showPickupEffect(enemy.x, enemy.y, "감염♥", false, true, "evil-purple-text");
                                }

                                takeDamage(dmg, 'direct', enemy.accuracy, enemy);
                            }
                            
                            if (enemy.isZako && enemy.state === 'pouncing' && enemy.hp > 0) {
                                if (!enemy.zakoType) { 
                                    let applied = 0; for(let k=0; k<2; k++) { if (!checkShieldBlockStatus()) { addStatus('byururut', 900, 9999); applied++; } }
                                    if(applied > 0) showPickupEffect(player.x, player.y, `뷰루룻♡ +${applied}`, false, true, "condensed-milk-text");
                                }
                                enemy.state = 'cooldown'; enemy.cooldownTimer = 120;
                                const angle = Math.atan2(player.y - enemy.y, player.x - enemy.x); enemy.x -= Math.cos(angle) * 50; enemy.y -= Math.sin(angle) * 50;
                            }
                            
                            player.bodyHitCooldown = 48;
                        }
                    }
                    
                    if (!(enemy.normalType === 'rapist') && !(enemy.isDarkDenizen && enemy.denizenType === 'rai')) {
                        if (enemy.contactStackTimer <= 0) {
                            let gained = false;
                           if (enemy.isBoss) { 
                              enemy.erectionStacks = Math.min(enemy.erectionStacks + 1, 20); // 한 번에 1스택 상승
                              enemy.contactStackTimer = 29; // 29프레임 쿨타임 (약 0.2초)
                              gained = true; 
                            } 
                            else if (!enemy.zakoType) { 
                                      enemy.erectionStacks = Math.min(enemy.erectionStacks + 1, 20); // 한 번에 1스택 상승
                                      enemy.contactStackTimer = 29; // 29프레임 쿨타임 (약 0.2초)
                                      gained = true; 
                            }
                            
                            if (gained) { 
                                showPickupEffect(enemy.x, enemy.y, "뷰르릇♥", false, true, "condensed-milk-text"); 
                                if (enemy.isTaro) {
                                    if (!checkShieldBlockStatus()) {
                                        addStatus('semen', 900, 30);
                                    }
                                }
                            }
                            
                            if (enemy.isBoss && enemy.bossType === 4) { addStatus('darkReceiver', 900, 20); }

                            if (enemy.isArchdemon) {
                                 addStatus('darkKiss', 900, 20); addStatus('darkReceiver', 900, 20); addStatus('darkSeed', 900, 20); 
                                 showPickupEffect(player.x, player.y, "츄르릅♥", false, true, "pink-text");
                            }
                        }
                    }

                    if (player.bodyHitCooldown === 30 && !(enemy.normalType === 'rapist') && !enemy.zakoType && !(enemy.isDarkDenizen && enemy.denizenType === 'rai')) { 
                        if (player.vx !== 0 || player.vy !== 0) {
                            const dx = enemy.x - player.x; const dy = enemy.y - player.y; const dotProduct = (player.vx * dx) + (player.vy * dy);
                            
                            let stacksToAdd = 1; if (enemy.isElite || enemy.isZako) { stacksToAdd = 2; }

                            if (dotProduct > 0) { 
                                // [수정] 정면 충돌: 아서가 아닌 보스(카인)만 카인의 키스 발동
                                if (enemy.isBoss && !enemy.isArthur) {
                                   addStatus('darkKiss', 900, 20); showPickupEffect(player.x, player.y, "카인과 딥키스..!", true);
                                } 
                                // 아서를 포함한 나머지 적들은 일반 속박 키스 발동
                                else if (player.kissTimers.length < 30) { 
                                    for(let k=0; k<stacksToAdd; k++) { if (!checkShieldBlockStatus()) { addStatus('kiss', 900, 30); } }
                                }
                                
                                // [수정] 구내사정: 보스가 아니거나, 보스여도 아서라면 발동
                                if ((!enemy.isBoss || enemy.isArthur) && 
                                    player.oralTimers.length < 30 && player.oralCooldown <= 0) { 
                                    for(let k=0; k<stacksToAdd; k++) { if (!checkShieldBlockStatus()) { addStatus('oral', 900, 30); } }
                                    player.oralCooldown = 48;
                                }

                            } else { 
                                // [수정] 후면 충돌: 아서가 아닌 보스(카인)만 카인의 좆집 발동
                                if (enemy.isBoss && !enemy.isArthur) {
                                   addStatus('darkReceiver', 900, 20); addStatus('darkSeed', 900, 20); player.darkReceiverCooldown = 60; showVillainSpeech(enemy.x, enemy.y, "카인의 정자 주입♥");
                                } 
                                // 아서를 포함한 나머지 적들은 일반 질내사정(점액) + 뷰루룻 동시 발동
                                else { 
                                    // 1) 기존 점액(semen) 유지
                                    if (player.semenTimers.length < 30 && player.semenCooldown <= 0) { 
                                        for(let k=0; k<stacksToAdd; k++) { if (!checkShieldBlockStatus()) { addStatus('semen', 900, 30); } }
                                        player.semenCooldown = 48;
                                    }
                                    // 2) 뷰루룻(byururut)도 함께 부여
                                    if (player.byururutTimers.length < 30 && player.byururutCooldown <= 0) { 
                                        for(let k=0; k<stacksToAdd; k++) { if (!checkShieldBlockStatus()) { addStatus('byururut', 900, 30); } }
                                        player.byururutCooldown = 48;
                                    }
                                }
                            }
                        }
                    }
                }
            
        // [패치] 히로 '안티 패싱' 차지 중: 이동/대시 완전 금지
        if (enemy.isHiro && enemy.antiPassingCharging) {
            enemy.x = _preX;
            enemy.y = _preY;
            enemy.vx = 0;
            enemy.vy = 0;
            enemy.dashTimer = 0;
            enemy.dashVx = 0;
            enemy.dashVy = 0;
            enemy.moveDashDuration = 0;
        }
}
            
            const prevHyper = player.hasHypersensitivity;
            player.hasHypersensitivity = taroExists;
            if (prevHyper !== player.hasHypersensitivity) updateStatusUI();
            
            player.geoptalCount = attachedRapistCount;
            if (player.geoptalCount > 0) updateStatusUI();

        }

        function draw() {
            ctx.fillStyle = '#c0c0c0'; 
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            poopStains.forEach(stain => {
                ctx.save(); ctx.translate(stain.x, stain.y); 
                const alpha = Math.min(0.8, stain.life / 60);
                
                if (stain.puffs) {
                    stain.puffs.forEach(p => {
                        ctx.beginPath();
                        ctx.arc(p.dx, p.dy, p.r, 0, Math.PI * 2);
                        const gradient = ctx.createRadialGradient(p.dx, p.dy, 0, p.dx, p.dy, p.r);
                        gradient.addColorStop(0, `rgba(90, 50, 10, ${alpha * 0.8})`); 
                        gradient.addColorStop(0.5, `rgba(70, 40, 5, ${alpha * 0.5})`);
                        gradient.addColorStop(1, `rgba(60, 30, 5, 0)`);
                        ctx.fillStyle = gradient;
                        ctx.fill();
                    });
                } else {
                    ctx.fillStyle = `rgba(90, 50, 10, ${alpha})`;
                    ctx.beginPath(); ctx.ellipse(0, 0, stain.radius * 1.5, stain.radius, 0, 0, Math.PI * 2); ctx.fill();
                }
                
                if (stain.life > 0) {
                    ctx.strokeStyle = 'rgba(139, 69, 19, 0.4)'; ctx.lineWidth = 1.5;
                    const time = Date.now() / 300;
                    for(let i=0; i<3; i++) {
                        ctx.beginPath();
                        const startX = (i - 1) * 20; const startY = -stain.radius * 0.5 + Math.sin(time + i) * 8;
                        ctx.moveTo(startX, startY); ctx.quadraticCurveTo(startX + 10, startY - 20, startX, startY - 40);
                        ctx.stroke();
                    }
                }
                ctx.restore();
            });
            
            darkWaves.forEach(w => {
                ctx.save();
                ctx.translate(w.x, w.y);
                ctx.rotate(w.rotation);
                
                const gradient = ctx.createLinearGradient(0, -w.radius, 0, w.radius);
                gradient.addColorStop(0, 'rgba(139, 0, 0, 0)');
                gradient.addColorStop(0.5, 'rgba(139, 0, 0, 0.8)');
                gradient.addColorStop(1, 'rgba(139, 0, 0, 0)');
                
                ctx.fillStyle = gradient;
                
                ctx.beginPath();
                ctx.arc(-20, 0, w.radius * 1.5, -Math.PI/3, Math.PI/3);
                ctx.arc(0, 0, w.radius, Math.PI/3, -Math.PI/3, true);
                ctx.fill();
                if (Math.random() < 0.5) { // 50% 확률로 프레임마다 번쩍임
                ctx.strokeStyle = '#8B0000'; // 검붉은색 (DarkRed)
                ctx.lineWidth = 2;
                ctx.shadowBlur = 10;
                ctx.shadowColor = '#DC143C'; // 붉은 광채 (Crimson)
                ctx.lineCap = 'round';
        
                ctx.beginPath();
             // 웨이브를 가로지르는 지그재그 전류
                let currentX = -w.radius;
                let currentY = (Math.random() - 0.5) * 20;
                ctx.moveTo(currentX, currentY);
        
                for(let k=0; k<5; k++) {
                currentX += (w.radius * 2 / 5);
                currentY += (Math.random() - 0.5) * 30; // Y축으로 랜덤하게 튐
                ctx.lineTo(currentX, currentY);
        }
        ctx.stroke();
        ctx.shadowBlur = 0; // 그림자 초기화
    }
                
                ctx.restore();
            });
            
            jammingWaves.forEach(w => {
                ctx.save();
                ctx.translate(w.x, w.y);
                ctx.rotate(w.angle);
                
                // [수정] 지지직거리는 전파 방해 이펙트
                // 1. 스타일: 형광 보라색 글로우 + 밝은 심지
                ctx.shadowColor = '#d000ff'; // 밝은 마젠타 글로우
                ctx.shadowBlur = 15;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';

                // 2. 여러 겹의 파동 그리기 (볼륨감)
                const layers = 3; // 파동의 겹 수
                
                for (let k = 1; k <= layers; k++) {
                    ctx.beginPath();
                    
                    // 안쪽일수록 진하고, 바깥쪽일수록 얇게
                    ctx.lineWidth = (layers - k + 1) * 1.5; 
                    
                    // 색상: 안쪽은 흰색에 가깝게, 바깥쪽은 보라색
                    if (k === 1) ctx.strokeStyle = '#FFFFFF';
                    else if (k === 2) ctx.strokeStyle = '#E0B0FF'; // 연보라
                    else ctx.strokeStyle = '#8A2BE2'; // 보라

                    // 파동의 반지름 (점점 커짐)
                    const baseRadius = w.radius * (k / 1.5);
                    
                    // 지지직거리는 노이즈 라인 생성
                    // -Math.PI/2 ~ Math.PI/2 (반원 형태)
                    const segments = 20; // 쪼개는 횟수
                    for (let j = 0; j <= segments; j++) {
                        const angle = -Math.PI / 2 + (Math.PI * j / segments);
                        
                        // 랜덤 지터(Jitter)로 지지직 효과 연출
                        // 매 프레임마다 모양이 바뀜
                        const jitter = (Math.random() - 0.5) * 15; 
                        const r = baseRadius + jitter;
                        
                        const px = Math.cos(angle) * r;
                        const py = Math.sin(angle) * r;
                        
                        if (j === 0) ctx.moveTo(px, py);
                        else ctx.lineTo(px, py);
                    }
                    ctx.stroke();
                }
                
                // 3. 중심부 스파크 (전기 튀는 효과)
                ctx.shadowBlur = 0;
                ctx.fillStyle = "#FFFFFF";
                for(let i=0; i<3; i++) {
                    const sparkAngle = (Math.random() - 0.5) * Math.PI; // 전방 부채꼴 내
                    const dist = Math.random() * w.radius;
                    const sx = Math.cos(sparkAngle) * dist;
                    const sy = Math.sin(sparkAngle) * dist;
                    ctx.beginPath();
                    ctx.arc(sx, sy, 2, 0, Math.PI*2);
                    ctx.fill();
                }

                ctx.restore();
            });
            
           neuroNeedles.forEach(n => {
                // 1. 녹색 최음 가스 트레일 그리기
                if (n.trail) {
                    n.trail.forEach(t => {
                        ctx.save();
                        ctx.translate(t.x, t.y);
                        const alpha = t.life / 20; // 서서히 사라짐
                        const r = t.size;
                        
                        // 녹색 가스 그라데이션
                        const gasGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, r);
                        gasGrad.addColorStop(0, `rgba(50, 205, 50, ${alpha * 0.8})`);   // LimeGreen
                        gasGrad.addColorStop(0.6, `rgba(0, 100, 0, ${alpha * 0.4})`);   // DarkGreen
                        gasGrad.addColorStop(1, `rgba(0, 50, 0, 0)`);                   // 투명
                        
                        ctx.fillStyle = gasGrad;
                        ctx.beginPath();
                        ctx.arc(0, 0, r, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.restore();
                    });
                }

                ctx.save();
                ctx.translate(n.x, n.y);
                ctx.rotate(n.angle);
                
                // 2. 볼륨감 있는 독바늘 본체 (원통형 그라데이션)
                const needleGrad = ctx.createLinearGradient(0, -4, 0, 4);
                needleGrad.addColorStop(0, '#4B0082');   // 위쪽: 어두운 보라
                needleGrad.addColorStop(0.4, '#E6E6FA'); // 중간: 밝은 하이라이트 (금속 질감)
                needleGrad.addColorStop(0.6, '#9370DB'); // 중간: 보라
                needleGrad.addColorStop(1, '#191970');   // 아래: 짙은 남색 그림자

                ctx.fillStyle = needleGrad;
                
                // 바늘 모양 패스
                ctx.beginPath();
                ctx.moveTo(15, 0);  // 앞 뾰족한 끝
                ctx.lineTo(-10, 4); // 뒤 아래
                ctx.lineTo(-10, -4); // 뒤 위
                ctx.closePath();
                ctx.fill();
                // 윤곽선(가시성 강화)
                ctx.lineWidth = 2.2;
                ctx.strokeStyle = 'rgba(0,0,0,0.78)';
                ctx.stroke();
// 3. 지지직 거리는 전기 이펙트
                if (Math.random() < 0.8) { // 80% 확률로 프레임마다 발생
                    ctx.strokeStyle = '#00FF00'; // 형광 연두색 전기
                    ctx.lineWidth = 1.5;
                    ctx.shadowColor = '#32CD32';
                    ctx.shadowBlur = 5;
                    ctx.beginPath();
                    
                    // 바늘 주변을 감싸는 랜덤 지그재그 선
                    let lx = -10;
                    let ly = 0;
                    ctx.moveTo(lx, ly);
                    for(let k=0; k<4; k++) {
                        lx += 7; 
                        ly = (Math.random() - 0.5) * 15; // 위아래로 튐
                        ctx.lineTo(lx, ly);
                    }
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                }

                ctx.restore();
            });
             
            

              pianissimoSnipes.forEach(p => {
    ctx.save();
    ctx.translate(p.x, p.y);
    ctx.globalAlpha = p.alpha;
    
    // 1. 사악한 검보라색 전류 이펙트
    if (Math.random() < 0.7) { // 70% 확률로 지직거림
        ctx.strokeStyle = Math.random() < 0.5 ? "#000000" : "#8A2BE2"; // 검정 또는 보라
        ctx.lineWidth = 2;
        ctx.shadowColor = "#4B0082";
        ctx.shadowBlur = 10;
        ctx.beginPath();
        
        // 전류 줄기 랜덤 생성
        for(let k=0; k<3; k++) {
            const angle = Math.random() * Math.PI * 2;
            const r = p.radius;
            ctx.moveTo(Math.cos(angle)*r*0.5, Math.sin(angle)*r*0.5);
            ctx.lineTo(Math.cos(angle)*r*1.8, Math.sin(angle)*r*1.8);
        }
        ctx.stroke();
    }

    // 2. 높은음자리표 본체
    ctx.shadowColor = "#4B0082"; // 인디고 글로우
    ctx.shadowBlur = 20;
    ctx.fillStyle = "black";
    ctx.font = "bold 60px serif"; // 크기 조절
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    
    // 흔들림 효과 (충전 중일 때 더 심하게)
    const shake = p.state === 'charging' ? 2 : 0;
    const dx = (Math.random() - 0.5) * shake;
    const dy = (Math.random() - 0.5) * shake;
    
    ctx.fillText("𝄞", dx, dy); // 높은음자리표 유니코드
    
    // 3. 내부 코어 (보라색 포인트)
    ctx.shadowBlur = 0;
    ctx.fillStyle = "#9370DB"; // MediumPurple
    ctx.font = "bold 55px serif";
    ctx.fillText("𝄞", dx, dy);

    ctx.restore();
});

            
             // [수정됨] 블러드 스웜 (피 장판) - 불규칙하고 입체적인 웅덩이
            bloodPuddles.forEach(p => {
                if (p.x === 0 && p.y === 0) return;
                ctx.save();
                ctx.translate(p.x, p.y);
                
                // 1. 입체감을 위한 방사형 그라데이션 (중앙은 밝고 외곽은 어둡게)
                const gradient = ctx.createRadialGradient(0, 0, p.radius * 0.2, 0, 0, p.radius);
                gradient.addColorStop(0, 'rgba(220, 20, 60, 0.9)');   // Crimson (중앙, 밝음)
                gradient.addColorStop(0.6, 'rgba(139, 0, 0, 0.8)');   // DarkRed (중간)
                gradient.addColorStop(1, 'rgba(50, 0, 0, 0)');        // 투명하게 퍼짐
                
                ctx.fillStyle = gradient;
                
                // 2. 불규칙한 원형 그리기 (Sin/Cos 파동을 이용해 울렁거리는 액체 표현)
                ctx.beginPath();
                const time = Date.now() / 200; // 시간 기반 애니메이션
                const vertices = 20; // 꼭짓점 개수
                
                for (let i = 0; i <= vertices; i++) {
                    const angle = (i / vertices) * Math.PI * 2;
                    
                    // 반지름을 불규칙하게 변형 (기본 반지름 + 파동)
                    // p.tickTimer 등을 이용해 웅덩이마다 다른 움직임을 줄 수도 있음
                    const noise = Math.sin(angle * 5 + time) * 5 + Math.cos(angle * 3 - time) * 5;
                    const r = p.radius + noise;
                    
                    const px = Math.cos(angle) * r;
                    const py = Math.sin(angle) * r;
                    
                    if (i === 0) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                }
                ctx.closePath();
                ctx.fill();

                // 3. 표면 광택 (액체 느낌 추가)
                ctx.globalAlpha = 0.4;
                ctx.fillStyle = '#FFaaaa';
                ctx.beginPath();
                ctx.ellipse(-p.radius * 0.3, -p.radius * 0.3, p.radius * 0.2, p.radius * 0.1, Math.PI / 4, 0, Math.PI * 2);
                ctx.fill();
                
                // 4. 외곽선 (끓어오르는 느낌)
                if (frameCount % 30 < 15) {
                    ctx.strokeStyle = 'rgba(255, 50, 50, 0.3)';
                    ctx.lineWidth = 3;
                    ctx.stroke();
                }

                ctx.restore();
            });

            groundCracks.forEach(crack => {
                ctx.save();
                ctx.translate(crack.x, crack.y);
                ctx.globalAlpha = crack.life / crack.maxLife;
                ctx.strokeStyle = '#3E2723'; 
                ctx.lineWidth = 4;
                
                for (let i = 0; i < 5; i++) {
                    ctx.save();
                    ctx.rotate((Math.PI * 2 / 5) * i);
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(15, 5);
                    ctx.lineTo(30, -5);
                    ctx.lineTo(50, 8);
                    ctx.lineTo(70, 0);
                    ctx.stroke();
                    ctx.restore();
                }
                
                ctx.fillStyle = '#1a0d00';
                ctx.beginPath();
                ctx.moveTo(-10, -5);
                ctx.lineTo(10, -5);
                ctx.lineTo(0, 20);
                ctx.fill();

                ctx.restore();
            });

            enemies.forEach(e => {
                // 기절 효과 그리기 (별)
                if (e.stunTimer > 0) {
                     ctx.save();
                     ctx.translate(e.x, e.y - e.radius - 20);
                     const time = Date.now() / 150;
                     for(let k=0; k<3; k++) {
                         const angle = (k / 3) * Math.PI * 2 + time;
                         const starX = Math.cos(angle) * 15;
                         const starY = Math.sin(angle) * 5;
                         ctx.fillStyle = "yellow";
                         ctx.beginPath();
                         ctx.arc(starX, starY, 3, 0, Math.PI*2);
                         ctx.fill();
                     }
                     ctx.restore();
                }

             if (e.isGawain && e.gawainSanctuaryActive > 0) {
                    ctx.save();
                    ctx.translate(e.x, e.y);
                    
                    const sanctuaryRadius = e.radius * 2.0; // 성역 크기
                    const time = Date.now() / 300; // 애니메이션 시간

                    // 1. [볼륨감] 반구형 돔 그라데이션 (입체적인 구체 느낌)
                    const domeGrad = ctx.createRadialGradient(0, 0, sanctuaryRadius * 0.2, 0, 0, sanctuaryRadius);
                    domeGrad.addColorStop(0, 'rgba(20, 0, 20, 0.1)');      // 중심부는 투명하게 (내부가 보이도록)
                    domeGrad.addColorStop(0.7, 'rgba(75, 0, 130, 0.4)');   // 가장자리는 짙은 보라
                    domeGrad.addColorStop(0.95, 'rgba(0, 0, 0, 0.8)');      // 외곽선 근처는 검정
                    domeGrad.addColorStop(1, 'rgba(148, 0, 211, 0.6)');     // 외곽선은 빛나는 보라

                    ctx.fillStyle = domeGrad;
                    ctx.beginPath();
                    ctx.arc(0, 0, sanctuaryRadius, 0, Math.PI * 2);
                    ctx.fill();

                    // 2. [최음 가스 효과] 성역 내부에서 소용돌이치는 가스 구름
                    const gasCount = 3; 
                    for (let k = 0; k < gasCount; k++) {
                        const angle = (Math.PI * 2 * k / gasCount) + time; // 회전함
                        const dist = sanctuaryRadius * 0.6 + Math.sin(time * 2 + k) * 20; // 안팎으로 움직임
                        
                        const gx = Math.cos(angle) * dist;
                        const gy = Math.sin(angle) * dist;
                        const gSize = 40 + Math.sin(time * 3 + k) * 10; // 크기 변화

                        // 가스 그라데이션 (검정 + 짙은 핑크/보라)
                        const gasGrad = ctx.createRadialGradient(gx, gy, 0, gx, gy, gSize);
                        gasGrad.addColorStop(0, 'rgba(0, 0, 0, 0.7)'); 
                        gasGrad.addColorStop(0.6, 'rgba(139, 0, 139, 0.5)'); // DarkMagenta
                        gasGrad.addColorStop(1, 'rgba(0, 0, 0, 0)');

                        ctx.fillStyle = gasGrad;
                        ctx.beginPath();
                        ctx.arc(gx, gy, gSize, 0, Math.PI * 2);
                        ctx.fill();
                    }

                    // [추가] 갈색의 냄새나는 더러운 수많은 방구 조각 가스들
                    const fartGasCount = 8;
                    for (let k = 0; k < fartGasCount; k++) {
                        // 위치 랜덤성 부여 (시간에 따라 부유하는 느낌)
                        const fAngle = (k * 137.5) + Math.sin(time * 0.8 + k) * 0.5; 
                        const fDist = (sanctuaryRadius * 0.7) * Math.abs(Math.sin(k * 1.1 + time * 0.3));
                        
                        const fx = Math.cos(fAngle) * fDist;
                        const fy = Math.sin(fAngle) * fDist;
                        const fSize = 25 + Math.sin(time * 2 + k) * 8; // 크기 펄럭임

                        // 더러운 갈색/똥색 그라데이션
                        const fartGrad = ctx.createRadialGradient(fx, fy, 0, fx, fy, fSize);
                        fartGrad.addColorStop(0, 'rgba(80, 50, 10, 0.9)');    // 진한 똥색
                        fartGrad.addColorStop(0.6, 'rgba(101, 67, 33, 0.6)'); // 갈색
                        fartGrad.addColorStop(1, 'rgba(60, 40, 0, 0)');       // 투명

                        ctx.fillStyle = fartGrad;
                        ctx.beginPath();
                        ctx.arc(fx, fy, fSize, 0, Math.PI * 2);
                        ctx.fill();
                    }

                    // [추가] 검정색 꾸물거리는 수많은 올챙이
                    const tadpoleCount = 10;
                    for (let k = 0; k < tadpoleCount; k++) {
                        // 성역 내부를 불규칙하게 회전
                        const tAngle = (k / tadpoleCount * Math.PI * 2) - (time * 1.5); 
                        // 거리는 사인파로 안팎 이동
                        const tDist = (sanctuaryRadius * 0.4) + (Math.sin(time * 4 + k * 10) * 30) + (k % 5) * 20;
                        const finalDist = Math.min(tDist, sanctuaryRadius * 0.9); // 성역 밖으로 안 나가게 제한

                        const tx = Math.cos(tAngle) * finalDist;
                        const ty = Math.sin(tAngle) * finalDist;

                        ctx.save();
                        ctx.translate(tx, ty);
                        ctx.rotate(tAngle + Math.PI / 2); // 진행 방향 바라보기

                        // 올챙이 머리
                        ctx.fillStyle = 'black';
                        ctx.beginPath();
                        ctx.arc(0, 0, 3.5, 0, Math.PI * 2);
                        ctx.fill();

                        // 올챙이 꼬리 (빠르게 꾸물거림)
                        ctx.strokeStyle = 'black';
                        ctx.lineWidth = 1.5;
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        const tailWiggle = Math.sin(time * 20 + k) * 4; // 꼬리 흔들림
                        ctx.quadraticCurveTo(0, 5, tailWiggle, 10);
                        ctx.stroke();

                        ctx.restore();
                    }

                    // 3. [테두리 이펙트] 바닥의 마법진 링 (회전)
                    ctx.save();
                    ctx.rotate(-time * 0.5); // 반대 방향 회전
                    ctx.strokeStyle = '#8A2BE2'; // BlueViolet
                    ctx.lineWidth = 3;
                    ctx.setLineDash([]);
                    ctx.beginPath();
                    ctx.arc(0, 0, sanctuaryRadius, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.restore();

                    // 4. [전류] 가끔씩 튀는 검은 전류
                    if (Math.random() < 0.3) {
                        ctx.strokeStyle = 'black';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        const startAngle = Math.random() * Math.PI * 2;
                        const r = sanctuaryRadius;
                        ctx.moveTo(Math.cos(startAngle) * r, Math.sin(startAngle) * r);
                        ctx.lineTo(Math.cos(startAngle + 0.5) * r * 0.8, Math.sin(startAngle + 0.5) * r * 0.8);
                        ctx.stroke();
                    }

                    ctx.restore();
                }
    });

            
            antiPassingTentacles.forEach(t => {
                _ensureAntiPassingAssets();

                ctx.save();
                ctx.translate(t.x, t.y);

                // radius가 커지면 비주얼도 같이 커지도록 스케일 적용
                const _apBaseR = 42;
                const _apScale = Math.max(0.2, (t.radius || _apBaseR) / _apBaseR);

                // 텔레그래프(그림자) 강도/맥동
                const _apWarnDen = Math.max(1, (t.hitDelay || t.riseDuration || 30));
                const _apWarnT = Math.min(1, (t.frame || 0) / _apWarnDen);
                const _apPulse = 0.94 + 0.06 * Math.sin(frameCount * 0.28 + (t.x + t.y) * 0.01);
                const _apLifeF = Math.min(1, (t.life || 0) / (t.maxLife || 72));

                // [텔레그래프] 촉수 실루엣(방향/길이) - 캐시 텍스처를 스케일/회전해서 그려 퍼포먼스 개선
                const _apDir = (typeof t.baseAngle === 'number') ? t.baseAngle : (-Math.PI / 2);
                const _apR = (t.radius || _apBaseR);
                const _apLen = _apR * (2.4 + 0.9 * _apWarnT) * _apPulse;
                const _apW = _apR * (1.00 + 0.15 * _apWarnT);

                const _apA = Math.min(0.98, (0.60 + 0.70 * _apWarnT) * (0.70 + 0.30 * _apLifeF));

                ctx.save();
                ctx.translate(0, 12 * _apScale);
                ctx.scale(1, 0.55); // 바닥 실루엣 느낌(납작하게)
                ctx.rotate(_apDir);
                ctx.globalAlpha = _apA;
                ctx.drawImage(_apTeleTex, 0, -_apTeleTex.height / 2, _apLen, _apW);
                ctx.restore();

                // [변경] 그림자 경고 동안엔 촉수/가스는 숨김(완전 지면 아래)
                const rise = (t.riseProgress || 0);
                if (rise <= 0) { ctx.restore(); return; }

                // 녹갈색 방구 구름 가스 - per-frame gradient 생성 대신 캐시 스프라이트 사용
                const gasAlpha = Math.min(1, (t.life || 0) / (t.maxLife || 52)) * (0.20 + 0.80 * Math.min(1, rise));
                const bursts = (t.gasBursts || []);
                let drawBurstN = 0;
                if (rise < 0.35) drawBurstN = 2;
                else if (rise < 0.7) drawBurstN = 3;
                else drawBurstN = Math.min(6, bursts.length);
                if (antiPassingTentacles.length > 3) drawBurstN = Math.min(drawBurstN, 3);

                if (drawBurstN > 0) {
                    ctx.save();
                    ctx.globalAlpha = 0.75 * gasAlpha;
                    for (let idx = 0; idx < drawBurstN; idx++) {
                        const g = bursts[idx];
                        const wobble = Math.sin((frameCount * 0.08) + idx) * 8 * _apScale;
                        const gDist = (g.dist || 0) * _apScale;

                        const gx = Math.cos(g.angle + frameCount * 0.01 * g.drift) * (gDist + wobble * 0.2);
                        const gy = Math.sin(g.angle + frameCount * 0.013 * g.drift) * (gDist + wobble * 0.15)
                                   - 20 * _apScale
                                   - Math.sin(frameCount * 0.06 + idx) * 6 * _apScale;

                        const rr = (g.size || 0) * _apScale * (0.85 + Math.sin(frameCount * 0.05 + idx) * 0.08);
                        const d = rr * 2;
                        ctx.drawImage(_apSmokeTex, gx - rr, gy - rr, d, d);
                    }
                    ctx.restore();
                }

                // 갈색 가시 촉수 - 상승 중에는 LOD(세그먼트/가시 줄임), 그라데이션 제거로 퍼포먼스 개선
                const segsFull = Math.max(3, (t.segCount || 7));
                const segsDraw = (rise < 1) ? Math.max(3, Math.floor(segsFull * (0.35 + 0.65 * rise))) : segsFull;

                const tipScale = 0.45 + rise * 0.55;

                for (let sIdx = 0; sIdx < segsDraw; sIdx++) {
                    const k = (segsDraw <= 1) ? 1 : (sIdx / (segsDraw - 1));
                    const segAngle = _apDir + k * 1.35;

                    const dist = k * 132 * rise * _apScale;
                    const sx = Math.cos(segAngle) * dist;
                    const sy = Math.sin(segAngle) * dist - (1 - rise) * 48 * _apScale;

                    const segR = (22 - k * 8) * tipScale * _apScale;

                    // 본체(그라데이션 대신 단색+하이라이트)
                    ctx.fillStyle = '#8b6228';
                    ctx.strokeStyle = '#1a1309';
                    ctx.lineWidth = Math.max(1, 2.2 * _apScale);
                    ctx.beginPath();
                    ctx.ellipse(sx, sy, segR * 1.05, segR * 0.9, segAngle + Math.PI * 0.4, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();

                    ctx.save();
                    ctx.globalAlpha = 0.55;
                    ctx.fillStyle = '#c39a53';
                    ctx.beginPath();
                    ctx.ellipse(sx - segR * 0.25, sy - segR * 0.3, segR * 0.55, segR * 0.45, segAngle + Math.PI * 0.4, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();

                    // 가시는 완전 출현 후, 모든 세그먼트에 그리기
                    if (rise >= 1) {
                        const spikes = (antiPassingTentacles.length > 2) ? 3 : 4;
                        for (let pIdx = 0; pIdx < spikes; pIdx++) {
                            const pa = (Math.PI * 2 / spikes) * pIdx + segAngle;
                            const px = sx + Math.cos(pa) * segR * 0.9;
                            const py = sy + Math.sin(pa) * segR * 0.75;

                            const tip = (7 - k * 2) * _apScale;

                            ctx.fillStyle = '#bfc4b5';
                            ctx.strokeStyle = '#0c0c0c';
                            ctx.lineWidth = Math.max(0.8, 1.3 * _apScale);
                            ctx.beginPath();
                            ctx.moveTo(px, py);
                            ctx.lineTo(px + Math.cos(pa) * tip, py + Math.sin(pa) * tip);
                            ctx.lineTo(px + Math.cos(pa + 0.5) * (tip * 0.35), py + Math.sin(pa + 0.5) * (tip * 0.35));
                            ctx.closePath();
                            ctx.fill();
                            ctx.stroke();
                        }
                    }
                }

                ctx.restore();
            });
shockwaves.forEach(wave => {
                ctx.save();
                ctx.translate(wave.x, wave.y);
                ctx.beginPath();
                ctx.arc(0, 0, wave.radius, 0, Math.PI * 2);
               if (wave.color) {
                ctx.strokeStyle = wave.color;
                ctx.globalAlpha = wave.alpha; // 헥사 코드 색상일 경우 투명도는 globalAlpha로 조절
            } else {
                ctx.strokeStyle = `rgba(255, 255, 255, ${wave.alpha})`;
            }

            ctx.lineWidth = 5;
            ctx.stroke();
            ctx.restore();
        });

            // [렌더 순서] 아키 발사체(드래그 샷/이블 애로우/포이즈너스 샷)는 적 이미지 위(전경)에 그리기 위해 뒤쪽에서 렌더링합니다.
pheromoneMarkers.forEach(p => {
                ctx.save(); 
                ctx.translate(p.x, p.y); 
                
                // 1. 하트 주변의 보라/핑크색 가스 이펙트 (맥동함)
                const time = Date.now() / 200;
                const pulse = 1 + Math.sin(time) * 0.2;
                
                const gasGrad = ctx.createRadialGradient(0, 0, p.radius * 0.5, 0, 0, p.radius * 2.5 * pulse);
                gasGrad.addColorStop(0, 'rgba(255, 105, 180, 0.6)');   // HotPink (중심)
                gasGrad.addColorStop(0.5, 'rgba(138, 43, 226, 0.3)'); // BlueViolet (중간)
                gasGrad.addColorStop(1, 'rgba(0, 0, 0, 0)');          // 투명 (외곽)
                
                ctx.fillStyle = gasGrad;
                ctx.beginPath();
                ctx.arc(0, 0, p.radius * 3, 0, Math.PI * 2);
                ctx.fill();

                // 2. 하트 본체 그리기 (크기 조정 및 형태)
                const scale = (p.radius / 15); // 크기 스케일
                ctx.scale(scale, scale);
                
                ctx.beginPath(); 
                ctx.moveTo(0, -10); 
                ctx.bezierCurveTo(-25, -35, -55, -15, 0, 45); 
                ctx.bezierCurveTo(55, -15, 25, -35, 0, -10); 
                ctx.closePath();
                
                // [저장] 클리핑을 위해 현재 경로 저장 (올챙이가 하트 안에만 보이게)
                ctx.save();
                ctx.clip();

                // 3. 3D 입체감 그라데이션 (빛이 왼쪽 위에서 오는 느낌)
                const heartGrad = ctx.createRadialGradient(-10, -10, 5, 0, 0, 50); 
                heartGrad.addColorStop(0, '#ff99cc');   // 하이라이트 (연분홍)
                heartGrad.addColorStop(0.4, '#FF1493'); // 본체 (DeepPink)
                heartGrad.addColorStop(1, '#4B0082');   // 그림자 (Indigo)
                
                ctx.fillStyle = heartGrad; 
                ctx.fill();

                // 4. 검정색 올챙이(정자)들이 우글거리는 효과
                ctx.fillStyle = "black";
                ctx.strokeStyle = "black";
                ctx.lineWidth = 1.5;
                
                // 하트 내부에서 움직이는 5~7마리의 올챙이 생성
                for(let i = 0; i < 6; i++) {
                    // 시간과 인덱스를 이용해 불규칙한 움직임 생성
                    const t = time * 2 + i * 15;
                    // 하트 내부를 돌아다니는 궤적 (Lissajous curve 느낌)
                    const tx = Math.sin(t * 0.7) * 20; 
                    const ty = Math.cos(t * 0.5) * 20; 
                    
                    // 올챙이 머리
                    ctx.beginPath();
                    ctx.arc(tx, ty, 2.5, 0, Math.PI*2);
                    ctx.fill();
                    
                    // 올챙이 꼬리 (머리 뒤로 흔들리며 따라옴)
                    ctx.beginPath();
                    ctx.moveTo(tx, ty);
                    // 꼬리가 진행 반대 방향으로 휘어짐
                    const tailX = tx - (Math.sin(t * 0.7) * 8);
                    const tailY = ty - (Math.cos(t * 0.5) * 8);
                    // 꼬리의 흔들림
                    const wiggle = Math.sin(t * 10) * 3;
                    
                    ctx.quadraticCurveTo(
                        (tx + tailX)/2 + wiggle, (ty + tailY)/2 + wiggle, 
                        tailX, tailY
                    );
                    ctx.stroke();
                }
                
                ctx.restore(); // 클리핑 해제

                // 5. 하트 외곽선 및 광택
                ctx.shadowColor = '#FF1493'; 
                ctx.shadowBlur = 10;
                ctx.strokeStyle = 'rgba(255, 192, 203, 0.5)';
                ctx.lineWidth = 1;
                ctx.stroke();
                
                // 상단 광택 (하이라이트)
                ctx.shadowBlur = 0; 
                ctx.fillStyle = 'rgba(255, 255, 255, 0.4)'; 
                ctx.beginPath(); 
                ctx.ellipse(-10, -15, 8, 4, -Math.PI / 4, 0, Math.PI * 2); 
                ctx.fill();
               
                ctx.restore();
            });
            
          pleasureZones.forEach(z => {
        ctx.save();
        ctx.translate(z.x, z.y);
        const time = Date.now() / 500; // 애니메이션 시간 변수

        // 1. [장판 배경] 돔 형태의 그라데이션
        const zoneGrad = ctx.createRadialGradient(0, 0, z.radius * 0.1, 0, 0, z.radius);
        zoneGrad.addColorStop(0, 'rgba(255, 192, 203, 0.2)');
        zoneGrad.addColorStop(0.6, 'rgba(255, 105, 180, 0.5)');
        zoneGrad.addColorStop(1, 'rgba(199, 21, 133, 0.0)');
        ctx.fillStyle = zoneGrad;
        ctx.beginPath();
        ctx.arc(0, 0, z.radius, 0, Math.PI * 2);
        ctx.fill();

        // 장판 테두리 (빛나는 효과)
        ctx.beginPath();
        ctx.arc(0, 0, z.radius, 0, Math.PI * 2);
        ctx.lineWidth = 6;
        ctx.strokeStyle = '#FF1493';
        ctx.shadowColor = '#FF69B4';
        ctx.shadowBlur = 15;
        ctx.stroke();
        ctx.shadowBlur = 0;
        ctx.lineWidth = 1;

        // 2. [올챙이] 꾸물거리는 검정색 올챙이들
        const tadpoleCount = 60;
        for(let i = 0; i < tadpoleCount; i++) {
            const t = time * 2 + i * 113.7; 
            const rMax = z.radius * 0.85;
            const dist = (Math.sin(t * 0.3) * 0.5 + 0.5) * rMax; 
            const angle = t * 0.5 + (i * (Math.PI * 2 / 13));
            
            const tx = Math.cos(angle) * dist;
            const ty = Math.sin(angle) * dist;

            // 머리
            const headSize = 5 + Math.sin(t * 3) * 1;
            const headGrad = ctx.createRadialGradient(tx - 1.5, ty - 1.5, 1, tx, ty, headSize);
            headGrad.addColorStop(0, '#555555');
            headGrad.addColorStop(0.4, '#000000');
            headGrad.addColorStop(1, '#000000');
            
            ctx.fillStyle = headGrad;
            ctx.beginPath();
            ctx.arc(tx, ty, headSize, 0, Math.PI * 2);
            ctx.fill();

            // 꼬리
            ctx.beginPath();
            ctx.moveTo(tx, ty);
            const moveDir = angle + Math.PI / 2; 
            const wiggle = Math.sin(t * 15) * 8;
            const tailLen = 22;
            const tailBaseAngle = moveDir + Math.PI;
            const tailEndX = tx + Math.cos(tailBaseAngle) * tailLen + Math.cos(tailBaseAngle + Math.PI/2) * wiggle;
            const tailEndY = ty + Math.sin(tailBaseAngle) * tailLen + Math.sin(tailBaseAngle + Math.PI/2) * wiggle;
            const cpX = (tx + tailEndX) / 2 + Math.cos(tailBaseAngle + Math.PI/2) * (wiggle * 0.5);
            const cpY = (ty + tailEndY) / 2 + Math.sin(tailBaseAngle + Math.PI/2) * (wiggle * 0.5);

            ctx.strokeStyle = "black";
            ctx.lineWidth = 3.5;
            ctx.lineCap = "round";
            ctx.quadraticCurveTo(cpX, cpY, tailEndX, tailEndY);
            ctx.stroke();
            ctx.strokeStyle = "#333"; 
            ctx.lineWidth = 1;
            ctx.stroke();
        }

        // 3. [기존 가스] 핑크색 최음 가스 (방구 가스 위로 살짝 섞임)
        const gasParticles = 5;
        for (let i = 0; i < gasParticles; i++) {
            const angle = (Math.PI * 2 * i / gasParticles) + time * 0.5;
            const dist = z.radius * 0.4 + Math.sin(time + i) * (z.radius * 0.2);
            const size = z.radius * 0.3 + Math.cos(time * 2 + i) * 5;
            const gx = Math.cos(angle) * dist;
            const gy = Math.sin(angle) * dist;

            const gasGrad = ctx.createRadialGradient(gx, gy, 0, gx, gy, size);
            gasGrad.addColorStop(0, 'rgba(255, 20, 147, 0.4)');
            gasGrad.addColorStop(1, 'rgba(255, 182, 193, 0)');

            ctx.fillStyle = gasGrad;
            ctx.beginPath();
            ctx.arc(gx, gy, size, 0, Math.PI * 2);
            ctx.fill();
        }

        // 4. [하트] 입체적인 하트
        const r = z.radius * 0.6;
        ctx.beginPath();
        ctx.moveTo(0, -r * 0.5);
        ctx.bezierCurveTo(-r * 1.5, -r * 1.5, -r * 1.5, r, 0, r * 1.5);
        ctx.bezierCurveTo(r * 1.5, r, r * 1.5, -r * 1.5, 0, -r * 0.5);
        
        const heartGrad = ctx.createLinearGradient(-r, -r, r, r);
        heartGrad.addColorStop(0, '#FF69B4');
        heartGrad.addColorStop(1, '#C71585');
        ctx.fillStyle = heartGrad;
        ctx.fill();
        
        ctx.strokeStyle = '#FF1493';
        ctx.lineWidth = 2;
        ctx.stroke();

        ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
        ctx.beginPath();
        ctx.ellipse(-r * 0.5, -r * 0.5, r * 0.2, r * 0.1, -Math.PI / 4, 0, Math.PI * 2);
        ctx.fill();

        // =====================================================================
        // [수정됨] 방구 가스 그리기 로직을 가장 마지막으로 이동 (위로 올라오게 함)
        // =====================================================================
        const fartParticles = 30; // 가스 덩어리 개수
        for (let i = 0; i < fartParticles; i++) {
            // 느릿하고 묵직하게 움직이는 가스
            const ft = time * 0.4 + i * 33.3; 
            
            // 위치: 장판 내부에서 불규칙하게 솟아오름
            const dist = (Math.sin(ft * 0.5) * 0.3 + 0.4) * z.radius; 
            const angle = ft + Math.sin(i * 10);
            
            const fx = Math.cos(angle) * dist;
            const fy = Math.sin(angle) * dist;

            // 크기: 몽글몽글하게 커졌다 작아졌다 함
            const fSize = z.radius * (0.25 + Math.sin(ft * 1.2) * 0.1);

            // [색상] 더러운 갈색 + 썩은 녹색 그라데이션
            const fartGrad = ctx.createRadialGradient(fx, fy, 0, fx, fy, fSize);
            fartGrad.addColorStop(0, 'rgba(101, 67, 33, 0.6)');   // 중심: 똥색 (Dark Brown)
            fartGrad.addColorStop(0.5, 'rgba(139, 69, 19, 0.4)'); // 중간: 진한 갈색
            fartGrad.addColorStop(1, 'rgba(85, 107, 47, 0.0)');   // 외곽: 썩은 올리브색 (투명하게)

            ctx.fillStyle = fartGrad;
            ctx.beginPath();
            ctx.arc(fx, fy, fSize, 0, Math.PI * 2);
            ctx.fill();
        }
        // =====================================================================

        ctx.restore();
    });
            
            ghosts.forEach(g => { ctx.save(); ctx.translate(g.x, g.y); ctx.rotate(g.rotation); ctx.globalAlpha = g.life / g.maxLife * 0.5; const size = g.radius * 2.5; ctx.beginPath();
             ctx.arc(0, 0, size / 2, 0, Math.PI * 2); 
             ctx.clip(); try { ctx.drawImage(g.img, -size/2, -size/2, size, size); } catch(e) {} ctx.restore(); });
            bigPoops.forEach(bp => { 
                ctx.save(); 
                ctx.translate(bp.x, bp.y); 
                const r = bp.radius; // 큽니다

                // 색상 팔레트 (더 진한 갈색)
                const baseColor = '#5D4037'; 
                const midColor = '#8D6E63';  
                const darkColor = '#3E2723'; 

                // 3단 쌓기 렌더링
                const drawLump = (yOffset, width, height) => {
                    ctx.beginPath();
                    // 입체감을 위한 그라데이션
                    const grad = ctx.createRadialGradient(-width*0.3, yOffset-height*0.3, width*0.1, 0, yOffset, width);
                    grad.addColorStop(0, midColor);
                    grad.addColorStop(0.4, baseColor);
                    grad.addColorStop(1, darkColor);
                    ctx.fillStyle = grad;
                    
                    // 약간 찌그러진 원형으로 자연스럽게
                    ctx.ellipse(0, yOffset, width, height, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // 더러운 덩어리 질감 (반점)
                    ctx.fillStyle = 'rgba(30, 10, 5, 0.4)';
                    for(let i=0; i<5; i++) {
                        ctx.beginPath();
                        ctx.arc((Math.random()-0.5)*width*1.2, yOffset+(Math.random()-0.5)*height, r*0.08, 0, Math.PI*2);
                        ctx.fill();
                    }
                };

                // 바닥, 중간, 끝 (크기 비율 조정)
                drawLump(r * 0.4, r, r * 0.6);
                drawLump(-r * 0.2, r * 0.8, r * 0.55);
                drawLump(-r * 0.8, r * 0.5, r * 0.5);
                
                // 꼭대기 하이라이트 (번들거림)
                ctx.fillStyle = 'rgba(255, 255, 255, 0.15)';
                ctx.beginPath();
                ctx.ellipse(r*0.2, -r*0.9, r*0.15, r*0.1, -0.5, 0, Math.PI*2);
                ctx.fill();

                // 강렬한 냄새 효과
                const time = Date.now() / 150;
                ctx.strokeStyle = 'rgba(101, 67, 33, 0.6)';
                ctx.lineWidth = 3;
                ctx.beginPath();
                for(let k=0; k<3; k++) {
                    const startX = (k-1) * r * 0.5;
                    ctx.moveTo(startX, -r);
                    ctx.bezierCurveTo(startX + 20, -r*2, startX - 20, -r*3, startX + Math.sin(time+k)*10, -r*4);
                }
                ctx.stroke();

                ctx.restore(); 
            });
            darkBigPoops.forEach(bp => {
                // [최적화] 스프라이트 캐시로 drawImage만 수행 (그라데이션/쉐도우/ellipse는 radius별 1회)
                const spr = getDarkBigPoopSprite(bp.radius);
                const half = spr.__half || (spr.width / 2);
                ctx.drawImage(spr, bp.x - half, bp.y - half);

                // 아주 가벼운 흔들림(옵션): 유도 똥만 살짝 '숨쉬기' 느낌
                // ※ 연산 최소화 위해 sin/cos 1회 + 선 1~2개만
                if (bp.isHoming) {
                    const t = frameCount * 0.06;
                    const wob = Math.sin(t + (bp.x + bp.y) * 0.01) * 4;
                    ctx.save();
                    ctx.globalAlpha = 0.45;
                    ctx.strokeStyle = 'rgba(75, 0, 130, 0.35)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(bp.x - 8, bp.y - (bp.radius * 1.2));
                    ctx.lineTo(bp.x + wob, bp.y - (bp.radius * 2.8));
                    ctx.stroke();
                    ctx.restore();
                }
            });

                        darkGases.forEach(gas => {
                // [Trail darkgas] simpler draw (avoid heavy gradients/bubbles)
                if (gas.isTrail || gas.simpleDraw) {
                    const denom = gas.isTrail ? 80 : (gas.lifeMax || 150);
                    const lifeA = Math.max(0, Math.min(1, (gas.life || 0) / denom));
                    const baseA = gas.isTrail ? (gas.alpha || 0.55) : (gas.alpha || 0.72);
                    const a = baseA * lifeA;

                    ctx.save();
                    ctx.globalAlpha = a;
                    ctx.fillStyle = gas.isTrail ? 'rgba(0, 0, 0, 0.55)' : 'rgba(0, 0, 0, 0.70)';
                    ctx.beginPath();
                    ctx.arc(gas.x, gas.y, gas.radius, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.globalAlpha = a * 0.85;
                    ctx.fillStyle = gas.isTrail ? 'rgba(50, 0, 60, 0.55)' : 'rgba(70, 0, 85, 0.60)';
                    ctx.beginPath();
                    ctx.arc(gas.x + 6, gas.y - 3, gas.radius * 0.75, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                    return;
                }

                if (gas.puffs) {
                    gas.puffs.forEach(puff => {
                        const px = gas.x + Math.cos(puff.angle) * (gas.radius * puff.distRel);
                        const py = gas.y + Math.sin(puff.angle) * (gas.radius * puff.distRel);
                        const pRadius = gas.radius * puff.sizeRel;
                        
                        const gradient = ctx.createRadialGradient(px, py, 0, px, py, pRadius);
                        gradient.addColorStop(0, `rgba(0, 0, 0, ${gas.alpha})`);          
                        gradient.addColorStop(0.5, `rgba(60, 0, 60, ${gas.alpha * 0.9})`); 
                        gradient.addColorStop(1, `rgba(0, 0, 0, 0)`); 

                        ctx.fillStyle = gradient;
                        ctx.beginPath();
                        ctx.arc(px, py, pRadius, 0, Math.PI * 2);
                        ctx.fill();
                    });
                } else {
                    const gradient = ctx.createRadialGradient(gas.x, gas.y, 0, gas.x, gas.y, gas.radius);
                    gradient.addColorStop(0, `rgba(0, 0, 0, ${gas.alpha})`);          
                    gradient.addColorStop(0.5, `rgba(60, 0, 60, ${gas.alpha * 0.9})`); 
                    gradient.addColorStop(1, `rgba(0, 0, 0, 0)`); 
                    ctx.fillStyle = gradient; ctx.beginPath(); ctx.arc(gas.x, gas.y, gas.radius, 0, Math.PI * 2); ctx.fill();
                }

            });

            gases.forEach(gas => {
                 if (gas.puffs) {
                    gas.puffs.forEach(puff => {
                        const px = gas.x + Math.cos(puff.angle) * (gas.radius * puff.distRel);
                        const py = gas.y + Math.sin(puff.angle) * (gas.radius * puff.distRel);
                        const pRadius = gas.radius * puff.sizeRel;

                        const gradient = ctx.createRadialGradient(px, py, 0, px, py, pRadius);
                        gradient.addColorStop(0, `rgba(20, 10, 0, ${gas.alpha})`); 
                        gradient.addColorStop(0.5, `rgba(80, 50, 20, ${gas.alpha * 0.7})`); 
                        gradient.addColorStop(1, `rgba(50, 40, 0, 0)`);                   
                        
                        ctx.fillStyle = gradient;
                        ctx.beginPath();
                        ctx.arc(px, py, pRadius, 0, Math.PI * 2);
                        ctx.fill();
                    });
                } else {
                    const gradient = ctx.createRadialGradient(gas.x, gas.y, 0, gas.x, gas.y, gas.radius);
                    gradient.addColorStop(0, `rgba(20, 10, 0, ${gas.alpha})`); gradient.addColorStop(0.3, `rgba(50, 35, 10, ${gas.alpha * 0.9})`); gradient.addColorStop(0.6, `rgba(80, 50, 20, ${gas.alpha * 0.7})`); gradient.addColorStop(1, `rgba(50, 40, 0, 0)`);                   
                    ctx.fillStyle = gradient; ctx.beginPath(); ctx.arc(gas.x, gas.y, gas.radius, 0, Math.PI * 2); ctx.fill();
                }
            });

            deathClouds.forEach(cloud => {
                ctx.save(); ctx.translate(cloud.x, cloud.y); const lifeRatio = cloud.life / 270;
                const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, cloud.radius); gradient.addColorStop(0, `rgba(0, 0, 0, ${lifeRatio})`); gradient.addColorStop(0.6, `rgba(75, 0, 130, ${lifeRatio * 0.8})`); gradient.addColorStop(1, `rgba(50, 0, 50, 0)`);                    
                ctx.fillStyle = gradient; ctx.beginPath(); ctx.arc(0, 0, cloud.radius, 0, Math.PI * 2); ctx.fill(); 
                if (lifeRatio > 0.1) {
                     ctx.fillStyle = `rgba(20, 20, 20, ${lifeRatio})`;
                     const bubbles = 5; const time = Date.now() / 200;
                     for(let k=0; k<bubbles; k++) {
                         ctx.beginPath(); const angle = (k / bubbles) * Math.PI * 2 + time; const dist = Math.sin(time * 2 + k) * (cloud.radius * 0.5); const bx = Math.cos(angle) * dist; const by = Math.sin(angle) * dist; const size = 15 + Math.sin(time + k) * 5; ctx.arc(bx, by, size, 0, Math.PI*2); ctx.fill();
                     }
                }
                ctx.restore();
            });
            
         poops.forEach(poop => { 
                ctx.save(); 
                ctx.translate(poop.x, poop.y); 
                // 회전은 제거하거나 약간만 주어 입체감 유지 (여기서는 제거하여 쌓인 모양 유지)
                // ctx.rotate(poop.rotation); 

                const r = poop.radius; 
                
                // 색상 팔레트 설정 (갈색 vs 녹색)
                let baseColor, midColor, darkColor;
                if (poop.isGreen) {
                    baseColor = '#556B2F'; // DarkOliveGreen
                    midColor = '#6B8E23';  // OliveDrab
                    darkColor = '#006400'; // DarkGreen
                } else {
                    baseColor = '#8B4513'; // SaddleBrown (중간)
                    midColor = '#A0522D';  // Sienna (밝은 부분)
                    darkColor = '#3e2723'; // Very Dark Brown (그림자)
                }

                // 똥 그리기 함수 (3단)
                const drawLump = (yOffset, width, height, color) => {
                    ctx.beginPath();
                    const grad = ctx.createRadialGradient(-width*0.2, yOffset-height*0.2, width*0.1, 0, yOffset, width);
                    grad.addColorStop(0, midColor);
                    grad.addColorStop(0.5, baseColor);
                    grad.addColorStop(1, darkColor);
                    ctx.fillStyle = grad;
                    ctx.ellipse(0, yOffset, width, height, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // 질감 (더러운 점)
                    ctx.fillStyle = 'rgba(0,0,0,0.3)';
                    for(let i=0; i<3; i++) {
                        ctx.beginPath();
                        ctx.arc((Math.random()-0.5)*width, yOffset+(Math.random()-0.5)*height, r*0.1, 0, Math.PI*2);
                        ctx.fill();
                    }
                };

                // 1단 (바닥 - 넙데데)
                drawLump(r * 0.3, r, r * 0.7, baseColor);
                // 2단 (중간)
                drawLump(-r * 0.3, r * 0.75, r * 0.6, baseColor);
                // 3단 (꼭대기 - 뾰족)
                drawLump(-r * 0.9, r * 0.4, r * 0.5, baseColor);

                // 냄새 아지랑이 효과 (물결)
                if (frameCount % 60 < 40) {
                    ctx.strokeStyle = poop.isGreen ? 'rgba(50, 205, 50, 0.6)' : 'rgba(139, 69, 19, 0.5)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    const time = Date.now() / 200;
                    // 왼쪽 아지랑이
                    ctx.moveTo(-r * 0.5, -r);
                    ctx.quadraticCurveTo(-r, -r * 2, -r * 0.5 + Math.sin(time) * 5, -r * 3);
                    // 오른쪽 아지랑이
                    ctx.moveTo(r * 0.5, -r);
                    ctx.quadraticCurveTo(r, -r * 2, r * 0.5 + Math.cos(time) * 5, -r * 3);
                    ctx.stroke();
                }

                ctx.restore(); 
            });

            homingSemens.forEach(shot => {
                ctx.save(); ctx.translate(shot.x, shot.y); const angle = Math.atan2(shot.vy, shot.vx); ctx.rotate(angle); const scale = shot.radius / 15; 
                ctx.shadowColor = 'rgba(230, 230, 200, 0.4)'; ctx.shadowBlur = 5; ctx.fillStyle = '#FFFDD0'; 
                ctx.beginPath(); const radius = 15 * scale; ctx.moveTo(radius, 0); for (let i = 1; i <= 8; i++) { const angle = (i / 8) * Math.PI * 2; const wobble = Math.sin(Date.now() / 100 + i * 10) * (radius * 0.2); const r = radius + wobble; const x = Math.cos(angle) * r; const y = Math.sin(angle) * r; const cpAngle = angle - (Math.PI / 8); const cpR = radius * 0.8; const cpx = Math.cos(cpAngle) * cpR; const cpy = Math.sin(cpAngle) * cpR; ctx.quadraticCurveTo(cpx, cpy, x, y); } ctx.closePath(); ctx.fill();
                ctx.fillStyle = 'rgba(255, 253, 220, 0.9)'; for(let k=0; k<3; k++) { ctx.beginPath(); const tailX = -radius * (1.2 + k * 0.5); const tailY = Math.sin(Date.now()/50 + k) * (radius * 0.4); const tailR = radius * (0.3 - k * 0.05); ctx.ellipse(tailX, tailY, tailR * 1.2, tailR * 0.8, k, 0, Math.PI*2); ctx.fill(); }
                ctx.restore();
            });

            darkSemens.forEach(shot => {
                ctx.save(); ctx.translate(shot.x, shot.y); const angle = Math.atan2(shot.vy, shot.vx); ctx.rotate(angle);
                ctx.shadowColor = 'rgba(75, 0, 130, 0.6)'; ctx.shadowBlur = 5; ctx.fillStyle = '#111111'; 
                ctx.beginPath(); const radius = shot.radius; ctx.moveTo(radius, 0); for (let i = 1; i <= 8; i++) { const angle = (i / 8) * Math.PI * 2; const wobble = Math.sin(Date.now() / 100 + i * 10) * (radius * 0.2); const r = radius + wobble; const x = Math.cos(angle) * r; const y = Math.sin(angle) * r; const cpAngle = angle - (Math.PI / 8); const cpR = radius * 0.8; const cpx = Math.cos(cpAngle) * cpR; const cpy = Math.sin(cpAngle) * cpR; ctx.quadraticCurveTo(cpx, cpy, x, y); } ctx.closePath(); ctx.fill();
                ctx.fillStyle = 'rgba(20, 0, 20, 0.9)'; for(let k=0; k<3; k++) { ctx.beginPath(); const tailX = -radius * (1.2 + k * 0.5); const tailY = Math.sin(Date.now()/50 + k) * (radius * 0.4); const tailR = radius * (0.3 - k * 0.05); ctx.ellipse(tailX, tailY, tailR * 1.2, tailR * 0.8, k, 0, Math.PI*2); ctx.fill(); }
                ctx.shadowBlur = 0; ctx.fillStyle = 'rgba(100, 100, 100, 0.3)'; ctx.beginPath(); ctx.ellipse(-radius * 0.3, -radius * 0.3, radius * 0.3, radius * 0.15, -0.5, 0, Math.PI * 2); ctx.fill();
                ctx.restore();
            });

            whiteshots.forEach(shot => {
                ctx.save(); ctx.translate(shot.x, shot.y); const angle = Math.atan2(shot.vy, shot.vx); ctx.rotate(angle);
                ctx.shadowColor = 'rgba(230, 230, 200, 0.4)'; ctx.shadowBlur = 5; ctx.fillStyle = '#FFFDD0'; 
                ctx.beginPath(); const radius = shot.radius; ctx.moveTo(radius, 0); for (let i = 1; i <= 8; i++) { const angle = (i / 8) * Math.PI * 2; const wobble = Math.sin(Date.now() / 100 + i * 10) * (radius * 0.2); const r = radius + wobble; const x = Math.cos(angle) * r; const y = Math.sin(angle) * r; const cpAngle = angle - (Math.PI / 8); const cpR = radius * 0.8; const cpx = Math.cos(cpAngle) * cpR; const cpy = Math.sin(cpAngle) * cpR; ctx.quadraticCurveTo(cpx, cpy, x, y); } ctx.closePath(); ctx.fill();
                ctx.fillStyle = 'rgba(255, 253, 220, 0.9)'; for(let k=0; k<3; k++) { ctx.beginPath(); const tailX = -radius * (1.2 + k * 0.5); const tailY = Math.sin(Date.now()/50 + k) * (radius * 0.4); const tailR = radius * (0.3 - k * 0.05); ctx.ellipse(tailX, tailY, tailR * 1.2, tailR * 0.8, k, 0, Math.PI*2); ctx.fill(); }
                ctx.shadowBlur = 0; ctx.fillStyle = 'rgba(255, 255, 255, 0.7)'; ctx.beginPath(); ctx.ellipse(-radius * 0.3, -radius * 0.3, radius * 0.3, radius * 0.15, -0.5, 0, Math.PI * 2); ctx.fill();
                ctx.restore();
            });

            darkHearts.forEach(p => {
                ctx.save(); ctx.translate(p.x, p.y); 
                const pulse = 1 + Math.sin(Date.now() / 150) * 0.1; const scale = (p.radius / 30) * pulse; ctx.scale(scale, scale);
                ctx.beginPath(); ctx.moveTo(0, -10); ctx.bezierCurveTo(-25, -35, -55, -15, 0, 45); ctx.bezierCurveTo(55, -15, 25, -35, 0, -10); ctx.closePath();
                const gradient = ctx.createRadialGradient(-15, -15, 5, 0, 0, 50); gradient.addColorStop(0, '#FF69B4'); gradient.addColorStop(0.4, '#8B008B'); gradient.addColorStop(0.8, '#4B0082'); gradient.addColorStop(1, '#1a001a'); 
                ctx.fillStyle = gradient; ctx.shadowColor = '#FF1493'; ctx.shadowBlur = 15; ctx.fill();
                ctx.shadowBlur = 0; ctx.fillStyle = 'rgba(255, 255, 255, 0.3)'; ctx.beginPath(); ctx.ellipse(-15, -15, 10, 5, -Math.PI / 4, 0, Math.PI * 2); ctx.fill();
                ctx.restore();
            });

           // [수정됨] 최음 가스 그리기 (볼륨감 있는 핑크 구름)
            pinkGases.forEach(g => {
                ctx.save();
                ctx.translate(g.x, g.y);
                
                // 등장 시 서서히 진해짐
                if (g.alpha < g.maxAlpha) g.alpha += 0.01;
                ctx.globalAlpha = g.alpha * (g.life / 480); // 사라질 때 자연스럽게

                // 구름 조각들 그리기
                if (g.puffs) {
                    g.puffs.forEach(p => {
                        // 등장 시 퐁! 하고 커지는 연출
                        if (p.scale < 1.0) p.scale += 0.05;
                        
                        const currentR = p.r * p.scale;
                        
                        // 부드러운 구름 느낌을 위한 방사형 그라데이션
                        const gradient = ctx.createRadialGradient(p.dx, p.dy, 0, p.dx, p.dy, currentR);
                        gradient.addColorStop(0, 'rgba(255, 182, 193, 0.9)'); // 중심: LightPink
                        gradient.addColorStop(0.6, 'rgba(255, 105, 180, 0.4)'); // 중간: HotPink
                        gradient.addColorStop(1, 'rgba(255, 105, 180, 0)');   // 외곽: 투명
                        
                        ctx.fillStyle = gradient;
                        ctx.beginPath();
                        ctx.arc(p.dx, p.dy, currentR, 0, Math.PI * 2);
                        ctx.fill();
                    });
                }
                ctx.restore();
            });

            // [신규] 퀘스타 '새디즘' 갈색 방구 가스 그리기 (핑크가스와 동일한 볼륨감 스타일)
            sadismBrownGases.forEach(g => {
                ctx.save();
                ctx.translate(g.x, g.y);

                if (g.alpha < g.maxAlpha) g.alpha += 0.01;
                ctx.globalAlpha = g.alpha * (g.life / (g.maxLife || 240));

                if (g.puffs) {
                    g.puffs.forEach(p => {
                        if (p.scale < 1.0) p.scale += 0.05;

                        const currentR = p.r * p.scale;

                        const gradient = ctx.createRadialGradient(p.dx, p.dy, 0, p.dx, p.dy, currentR);
                        gradient.addColorStop(0, 'rgba(198, 134, 66, 0.85)');  // 중심(더러운 연갈색)
                        gradient.addColorStop(0.6, 'rgba(101, 67, 33, 0.40)'); // 중간(짙은 갈색)
                        gradient.addColorStop(1, 'rgba(101, 67, 33, 0)');      // 외곽(투명)

                        ctx.fillStyle = gradient;
                        ctx.beginPath();
                        ctx.arc(p.dx, p.dy, currentR, 0, Math.PI * 2);
                        ctx.fill();
                    });
                }
                ctx.restore();
            });

            // [수정됨] 어둠의 음표 그리기 (볼륨감 + 사악한 전류 이펙트)
            darkNotes.forEach(n => {
                ctx.save();
                ctx.translate(n.x, n.y);

                // 1. 사악한 검보라색 전류 이펙트 (찌릿찌릿)
                ctx.strokeStyle = '#8A2BE2'; // BlueViolet
                ctx.shadowColor = '#9400D3'; // DarkViolet Glow
                ctx.shadowBlur = 15;
                ctx.lineWidth = 2;
                ctx.lineCap = 'round';
                
                // 랜덤한 번개 줄기 3개 생성
                for (let k = 0; k < 3; k++) {
                    ctx.beginPath();
                    // 음표 중심에서 시작하지 않고 약간 떨어진 곳에서 번개
                    const startAngle = Math.random() * Math.PI * 2;
                    let lx = Math.cos(startAngle) * 15;
                    let ly = Math.sin(startAngle) * 15;
                    ctx.moveTo(lx, ly);
                    
                    // 지그재그 선 그리기
                    for (let j = 0; j < 4; j++) {
                        lx += (Math.random() - 0.5) * 20;
                        ly += (Math.random() - 0.5) * 20;
                        ctx.lineTo(lx, ly);
                    }
                    ctx.stroke();
                }

                // 2. 볼륨감 있는 음표 본체
                ctx.shadowColor = '#4B0082'; // Indigo 깊은 그림자
                ctx.shadowBlur = 20;
                ctx.fillStyle = "black"; 
                ctx.font = "bold 45px Arial"; // 크기 키움
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                
                // 약간의 떨림 효과로 불안정한 에너지 표현
                const shakeX = (Math.random() - 0.5) * 2;
                const shakeY = (Math.random() - 0.5) * 2;
                ctx.fillText("♪", shakeX, shakeY);
                
                // 3. 내부 코어 (보라색으로 살짝 빛나게)
                ctx.shadowBlur = 0;
                ctx.fillStyle = "#9370DB"; // MediumPurple
                ctx.font = "bold 40px Arial";
                ctx.fillText("♪", shakeX, shakeY);

                ctx.restore();
            });

            
    // 오클루전 스풀 그리기 (바닥 장판) - [OPT] 그라데이션/랜덤 연산 최소화
occlusionSpools.forEach(s => {
    ctx.save();
    ctx.translate(s.x, s.y);

    const stride = (performanceState && performanceState.particleStride) ? performanceState.particleStride : 1;

    // 울렁거리는 검보라빛 번개 필드 (기존 느낌 유지)
    const pulse = 1 + Math.sin(Date.now() / 100) * 0.1;

    // (1) 바닥 디스크는 텍스처 캐시로 그리기 (createRadialGradient 제거)
    const disc = getOcclusionSpoolDiscTex(s.radius);
    const dw = disc.width * pulse;
    const dh = disc.height * pulse;
    ctx.drawImage(disc, -dw / 2, -dh / 2, dw, dh);

    // (2) 번개 지지직(랜덤)도 매 프레임 생성하지 않고 주기 갱신
    //     - 색/굵기 동일 유지
    ctx.strokeStyle = "#6A00FF"; // Deep Purple
    ctx.lineWidth = 2;

    // 스풀별 시드(한 번만)
    if (s._seed == null) s._seed = Math.random() * 9999;

    const updateEvery = Math.max(10, 16 * stride); // [추가 최적화] 더 드물게 갱신
    if (!s._sparkTick) s._sparkTick = 0;
    s._sparkTick++;

    if (!s._sparks || (s._sparkTick % updateEvery) === 0) {
        const lineCount = Math.max(2, Math.floor(4 / stride));
        const stepCount = 4;
        const jitter = 16;

        s._sparks = [];
        for (let k = 0; k < lineCount; k++) {
            const baseA = __hash01(s._seed + k * 13.3 + Math.floor(s._sparkTick / updateEvery) * 7.7) * Math.PI * 2;
            let lx = 0, ly = 0;
            const pts = [{ x: 0, y: 0 }];
            for (let j = 0; j < stepCount; j++) {
                lx += Math.cos(baseA) * (s.radius / stepCount);
                ly += Math.sin(baseA) * (s.radius / stepCount);

                const h1 = __hash01(s._seed * 1.7 + k * 31.1 + j * 17.9 + s._sparkTick);
                const h2 = __hash01(s._seed * 2.3 + k * 19.7 + j * 23.1 + s._sparkTick);
                lx += (h1 - 0.5) * jitter;
                ly += (h2 - 0.5) * jitter;
                pts.push({ x: lx, y: ly });
            }
            s._sparks.push(pts);
        }
    }

    ctx.beginPath();
    for (let pIdx = 0; pIdx < s._sparks.length; pIdx++) {
        const pts = s._sparks[pIdx];
        ctx.moveTo(pts[0].x, pts[0].y);
        for (let j = 1; j < pts.length; j++) ctx.lineTo(pts[j].x, pts[j].y);
    }
    ctx.stroke();

    ctx.restore();
});
// 프리즘 스윕 그리기 (공중 유닛 느낌)
        prismSweeps.forEach(p => {
            ctx.save();
            ctx.translate(p.x, p.y);
            
            // 프리즘 본체 (3색 삼각형)
            ctx.fillStyle = "black";
            ctx.shadowColor = "purple";
            ctx.shadowBlur = 20;
            ctx.beginPath();
            ctx.moveTo(0, -30);
            ctx.lineTo(25, 20);
            ctx.lineTo(-25, 20);
            ctx.closePath();
            ctx.fill();
            ctx.shadowBlur = 0;

            // 레이저 (바닥까지 빔 발사)
            if (p.laserTimer < 10) { // 발사 순간 반짝임
                ctx.strokeStyle = p.colors[Math.floor(Date.now() / 6000) % 3];
                ctx.lineWidth = 40;
                ctx.globalAlpha = 0.6;
                ctx.beginPath();
                ctx.moveTo(0, 20);
                ctx.lineTo(0, 1000); // 화면 아래까지
                ctx.stroke();
            }
            ctx.restore();
        });

            mindSkulls.forEach(skull => {
            ctx.save();
            ctx.translate(skull.x, skull.y);
            // 해골이 진행 방향을 보게 회전 (보정값 적용)
            ctx.rotate(skull.angle - Math.PI / 2);

            const s = skull.radius * 2.2; // 전체 크기 스케일

            // [오라] 사악한 보라색 후광 (더 은은하고 넓게)
            ctx.shadowColor = 'rgba(138, 43, 226, 0.8)';
            ctx.shadowBlur = 25;

            // 1. 두개골 (Cranium) - 사실적인 형태와 음영
            // 위쪽은 둥글고 아래쪽(광대)으로 갈수록 좁아지는 형태
            ctx.beginPath();
            ctx.moveTo(0, -s * 0.4); // 정수리
            // 왼쪽 두개골 라인
            ctx.bezierCurveTo(-s * 0.35, -s * 0.4, -s * 0.45, -s * 0.1, -s * 0.4, s * 0.1); 
            // 왼쪽 광대뼈 (툭 튀어나옴)
            ctx.bezierCurveTo(-s * 0.45, s * 0.25, -s * 0.25, s * 0.3, -s * 0.2, s * 0.45);
            // 턱 (Jaw)
            ctx.lineTo(-s * 0.1, s * 0.65);
            ctx.quadraticCurveTo(0, s * 0.75, s * 0.1, s * 0.65);
            ctx.lineTo(s * 0.2, s * 0.45);
            // 오른쪽 광대뼈
            ctx.bezierCurveTo(s * 0.25, s * 0.3, s * 0.45, s * 0.25, s * 0.4, s * 0.1);
            // 오른쪽 두개골 라인
            ctx.bezierCurveTo(s * 0.45, -s * 0.1, s * 0.35, -s * 0.4, 0, -s * 0.4);
            ctx.closePath();

            // [채색] 입체적인 그라데이션 (검보라빛 -> 밝은 하이라이트)
            const skullGrad = ctx.createRadialGradient(-s*0.1, -s*0.1, s*0.1, 0, 0, s*0.6);
            skullGrad.addColorStop(0, '#A9A9F5'); // 밝은 연보라 (하이라이트)
            skullGrad.addColorStop(0.4, '#4B0082'); // 중간 톤 (인디고)
            skullGrad.addColorStop(1, '#1a0033');   // 그림자 (아주 어두운 보라)
            ctx.fillStyle = skullGrad;
            ctx.fill();
            
            // 외곽선 (디테일)
            ctx.lineWidth = 1.5;
            ctx.strokeStyle = '#2a0040';
            ctx.stroke();

            // 그림자 효과 제거 (눈/코 내부는 선명하게)
            ctx.shadowBlur = 0;

            // 2. 눈 구멍 (Eye Sockets) - 깊이감 있는 어둠
            ctx.fillStyle = '#000000';
            
            // 왼쪽 눈 (약간 찌그러진 타원 + 분노한 눈썹 라인)
            ctx.beginPath();
            ctx.moveTo(-s*0.12, s*0.05);
            ctx.bezierCurveTo(-s*0.2, -s*0.05, -s*0.35, -s*0.05, -s*0.32, s*0.15);
            ctx.bezierCurveTo(-s*0.3, s*0.25, -s*0.15, s*0.25, -s*0.12, s*0.05);
            ctx.fill();

            // 오른쪽 눈
            ctx.beginPath();
            ctx.moveTo(s*0.12, s*0.05);
            ctx.bezierCurveTo(s*0.2, -s*0.05, s*0.35, -s*0.05, s*0.32, s*0.15);
            ctx.bezierCurveTo(s*0.3, s*0.25, s*0.15, s*0.25, s*0.12, s*0.05);
            ctx.fill();

            // [안광] 붉은 점 (생명력 있는 사악함)
            ctx.fillStyle = '#FF0000';
            ctx.shadowColor = 'red';
            ctx.shadowBlur = 10;
            ctx.beginPath();
            ctx.arc(-s*0.22, s*0.1, s*0.025, 0, Math.PI*2);
            ctx.arc(s*0.22, s*0.1, s*0.025, 0, Math.PI*2);
            ctx.fill();
            ctx.shadowBlur = 0;

            // 3. 코 구멍 (Nasal Cavity) - 역하트 모양
            ctx.fillStyle = '#000000';
            ctx.beginPath();
            ctx.moveTo(0, s*0.25);
            ctx.lineTo(-s*0.06, s*0.35);
            ctx.lineTo(0, s*0.32); // 중간에 살짝 올라감
            ctx.lineTo(s*0.06, s*0.35);
            ctx.fill();

            // 4. 이빨 (Teeth) & 턱 관절 디테일
            ctx.fillStyle = '#E6E6FA'; // 연한 라벤더색 치아
            ctx.beginPath();
            // 윗니 4개
            for(let i=-2; i<=1; i++) {
                const x = (i + 0.5) * (s * 0.08);
                const y = s * 0.5;
                ctx.rect(x, y, s*0.06, s*0.08);
            }
            ctx.fill();
            
            // 치아 사이 그림자 선
            ctx.strokeStyle = '#2a0033';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(-s*0.15, s*0.5);
            ctx.lineTo(s*0.15, s*0.5); // 윗니/아랫니 경계선
            for(let i=-1; i<=1; i++) {
                const x = i * (s * 0.08);
                ctx.moveTo(x, s*0.48);
                ctx.lineTo(x, s*0.60);
            }
            ctx.stroke();

            // 5. 금 간 효과 (Crack) - 이마 부분
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.4)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(s*0.2, -s*0.25);
            ctx.lineTo(s*0.15, -s*0.15);
            ctx.lineTo(s*0.22, -s*0.1);
            ctx.stroke();

            ctx.restore();
        });

            enemies.forEach(enemy => {
if (enemy.isTaro && enemy.deathGripActive) {
        ctx.save();

        const startX = enemy.x;
        const startY = enemy.y;
        const endX = player.x;
        const endY = player.y;

        // 곡선 제어점 계산 (흔들림 효과)
        const midX = (startX + endX) / 2;
        const midY = (startY + endY) / 2;
        const wiggle = Math.sin(frameCount * 0.2) * 20;
        const cpX = midX;
        const cpY = midY + wiggle;

        // 거리 계산 및 링크 개수 설정
        const dist = Math.sqrt(Math.pow(endX - startX, 2) + Math.pow(endY - startY, 2));
        const linkSize = 20; 
        const linkCount = Math.floor(dist / (linkSize * 0.6)); // 링크 간 겹침 고려

        // 사슬 전체 글로우 효과 (먼저 그림)
        ctx.beginPath();
        ctx.moveTo(startX, startY);
        ctx.quadraticCurveTo(cpX, cpY, endX, endY);
        ctx.lineWidth = 12;
        ctx.strokeStyle = 'rgba(138, 43, 226, 0.2)'; // 은은한 보라색 오라
        ctx.lineCap = 'round';
        ctx.stroke();

        // 사슬 마디 그리기 루프
        for (let i = 0; i <= linkCount; i++) {
            const t = i / linkCount;
            const t1 = 1 - t;

            // 2차 베지에 곡선 공식으로 현재 위치(curX, curY) 계산
            const curX = t1 * t1 * startX + 2 * t1 * t * cpX + t * t * endX;
            const curY = t1 * t1 * startY + 2 * t1 * t * cpY + t * t * endY;

            // 다음 위치를 예측하여 회전 각도 계산
            const tNext = Math.min(1, (i + 0.1) / linkCount);
            const t1Next = 1 - tNext;
            const nextX = t1Next * t1Next * startX + 2 * t1Next * tNext * cpX + tNext * tNext * endX;
            const nextY = t1Next * t1Next * startY + 2 * t1Next * tNext * cpY + tNext * tNext * endY;
            const angle = Math.atan2(nextY - curY, nextX - curX);

            ctx.save();
            ctx.translate(curX, curY);
            ctx.rotate(angle);

            ctx.lineWidth = 3;
            // 짝수/홀수 번갈아가며 마디 모양 변경 (사슬 느낌)
            if (i % 2 === 0) {
                // 눕혀진 타원형 마디
                ctx.strokeStyle = '#808080';
                ctx.beginPath();
                ctx.ellipse(0, 0, 10, 4, 0, 0, Math.PI * 2);
                ctx.stroke();
                // 하이라이트
                ctx.strokeStyle = '#D3D3D3';
                ctx.lineWidth = 1;
                ctx.stroke();
            } else {
                // 세워진 마디 (작은 원 혹은 두꺼운 선)
                ctx.fillStyle = '#505050';
                ctx.beginPath();
                ctx.arc(0, 0, 4, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#A9A9A9';
                ctx.lineWidth = 1;
                ctx.stroke();
            }
            ctx.restore();
        }
        ctx.restore();
    }
                if (enemy.isMonolith) {
             ctx.save();
             ctx.translate(enemy.x, enemy.y);

             // 1. 바닥의 혼돈 오라
             const pulse = 0.5 + Math.sin(Date.now() / 200) * 0.2;
             ctx.globalAlpha = pulse;
             ctx.fillStyle = "#4B0082"; // Indigo
             ctx.beginPath();
             ctx.ellipse(0, 15, 35, 15, 0, 0, Math.PI * 2);
             ctx.fill();
             ctx.globalAlpha = 1.0;

             // 2. 비석 본체
             ctx.fillStyle = "#2F4F4F"; // DarkSlateGray
             ctx.strokeStyle = "#1a1a1a";
             ctx.lineWidth = 2;
             ctx.beginPath();
             ctx.moveTo(-20, 15);
             ctx.lineTo(-15, -50);
             ctx.lineTo(15, -50);
             ctx.lineTo(20, 15);
             ctx.closePath();
             ctx.fill();
             ctx.stroke();

             // 3. 새겨진 룬 문자
             ctx.shadowBlur = 15;
             ctx.shadowColor = "#FF00FF";
             ctx.strokeStyle = "#D8BFD8";
             ctx.lineWidth = 3;
             ctx.beginPath();
             ctx.moveTo(0, -35);
             ctx.lineTo(0, -5);
             ctx.moveTo(-10, -25);
             ctx.lineTo(10, -15);
             ctx.moveTo(-10, -15);
             ctx.lineTo(10, -25);
             ctx.stroke();
             ctx.shadowBlur = 0;

           // 4. 체력바
             const hpPercent = Math.max(0, enemy.hp) / enemy.maxHp;
             ctx.fillStyle = "black";
             ctx.fillRect(-20, -enemy.radius - 15, 40, 6); 
             ctx.fillStyle = '#ff3333';
             ctx.fillRect(-20, -enemy.radius - 15, 40 * hpPercent, 6);

             ctx.restore();
             return; // 비석을 그렸으므로 아래의 기본 적 그리기 로직은 건너뜀
        }
                if (enemy.isAmbush && enemy.ambushState === 'ambush') {
                    ctx.save(); ctx.translate(enemy.x, enemy.y); const ambushAlpha = 0.3 + Math.sin(Date.now() / 200) * 0.1;
                    const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, 20); gradient.addColorStop(0, `rgba(255, 0, 0, ${ambushAlpha * 0.5})`); gradient.addColorStop(1, `rgba(255, 0, 0, 0)`);
                    ctx.fillStyle = gradient; ctx.beginPath(); ctx.arc(0, 0, 20, 0, Math.PI * 2); ctx.fill(); ctx.restore(); return; 
                }

                if (enemy.isKai && enemy.soulLinkTarget && enemy.soulLinkTarget.hp > 0) {
            ctx.save();
            ctx.translate(enemy.x, enemy.y); // 카이의 위치로 기준점 이동

            // 선 스타일 설정
            ctx.strokeStyle = '#FF0000'; // 붉은색
            ctx.lineWidth = 3;
            ctx.shadowColor = '#FF0000';
            ctx.shadowBlur = 15;
            ctx.lineCap = 'round';

            // 카이(0,0) 부터 타겟까지의 상대 좌표 계산
            const tx = enemy.soulLinkTarget.x - enemy.x;
            const ty = enemy.soulLinkTarget.y - enemy.y;
            const dist = Math.hypot(tx, ty);

            ctx.beginPath();
            ctx.moveTo(0, 0);

            // 지그재그 전류 효과
            const segments = Math.floor(dist / 20); // 20픽셀 단위로 꺾임
            for (let i = 1; i < segments; i++) {
                const t = i / segments;
                // 직선 상의 위치
                let px = tx * t;
                let py = ty * t;
                // 랜덤 떨림 추가
                px += (Math.random() - 0.5) * 15;
                py += (Math.random() - 0.5) * 15;
                ctx.lineTo(px, py);
            }
            ctx.lineTo(tx, ty); // 끝점 연결
            ctx.stroke();
            
            // 연결된 대상 강조 원
            ctx.beginPath();
            ctx.arc(tx, ty, enemy.soulLinkTarget.radius + 10, 0, Math.PI*2);
            ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            ctx.restore();
        }

                ctx.save(); ctx.translate(enemy.x, enemy.y); ctx.rotate(enemy.angle + Math.PI / 2);
                if (enemy.hitFlash > 0) { ctx.shadowColor = "white"; ctx.shadowBlur = 20; } 
                else if (enemy.isBoss) { ctx.shadowColor = "purple"; ctx.shadowBlur = 50; }
                else if (enemy.isRoyal) { ctx.shadowColor = "#00CED1"; ctx.shadowBlur = 30; }
                else if (enemy.isElite) { ctx.shadowColor = "red"; ctx.shadowBlur = 20; }
                else if (enemy.isAgent) { ctx.shadowColor = "#FFA500"; ctx.shadowBlur = 20; } 
                
                if (enemy.isLuca && enemy.aimTimer > 420 && enemy.aimTimer < 480) {
                     ctx.save();
                     ctx.strokeStyle = `rgba(255, 0, 0, ${Math.random() * 0.5 + 0.5})`;
                     ctx.lineWidth = 2;
                     ctx.beginPath();
                     ctx.moveTo(0, 0);
                     ctx.lineTo(0, -1000); 
                     ctx.stroke();
                     ctx.restore();
                }
                
                if (enemy.hasShield) {
                    ctx.save();
                    ctx.strokeStyle = '#FFFF00'; 
                    ctx.lineWidth = 4;
                    ctx.shadowColor = '#FFFF00';
                    ctx.shadowBlur = 10;
                    ctx.beginPath();
                    ctx.arc(0, 0, enemy.radius + 10, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.restore();
                }
                 if (enemy.isRyuon && enemy.firmDarknessActive > 0) {
                    ctx.save();
                    // (주의: 이미 상위 코드에서 ctx.translate(enemy.x, enemy.y)가 되어 있어야 함)
                    
                    const sanctuaryRadius = enemy.radius * 2.0; // 성역 크기
                    const time = Date.now() / 300; // 애니메이션 시간

                    const domeCanvas = getFirmDarknessDomeCanvas(sanctuaryRadius);
                    ctx.drawImage(
                    domeCanvas,
                    -Math.round(sanctuaryRadius),
                    -Math.round(sanctuaryRadius)
                  );

                    // 2. [가스 효과] 내부에서 소용돌이치는 검은 안개
                    const gasCount = 3; 
                    for (let k = 0; k < gasCount; k++) {
                        const angle = (Math.PI * 2 * k / gasCount) + time; // 회전함
                        const dist = sanctuaryRadius * 0.6 + Math.sin(time * 2 + k) * 20; // 안팎으로 움직임
                        
                        const gx = Math.cos(angle) * dist;
                        const gy = Math.sin(angle) * dist;
                        const gSize = 40 + Math.sin(time * 3 + k) * 10; // 크기 변화

                        // 가스 그라데이션 (검정 + 짙은 회색)
                        const gasGrad = ctx.createRadialGradient(gx, gy, 0, gx, gy, gSize);
                        gasGrad.addColorStop(0, 'rgba(0, 0, 0, 0.8)'); 
                        gasGrad.addColorStop(0.6, 'rgba(40, 0, 60, 0.5)'); // Dark Purple Mist
                        gasGrad.addColorStop(1, 'rgba(0, 0, 0, 0)');

                        ctx.fillStyle = gasGrad;
                        ctx.beginPath();
                        ctx.arc(gx, gy, gSize, 0, Math.PI * 2);
                        ctx.fill();
                    }

                    // 3. [입자 효과] 검보라색/검정 방구 가스 (갈색 -> 검정 변경)
                    const fartGasCount = 8;
                    for (let k = 0; k < fartGasCount; k++) {
                        // 위치 랜덤성 부여
                        const fAngle = (k * 137.5) + Math.sin(time * 0.8 + k) * 0.5; 
                        const fDist = (sanctuaryRadius * 0.7) * Math.abs(Math.sin(k * 1.1 + time * 0.3));
                        
                        const fx = Math.cos(fAngle) * fDist;
                        const fy = Math.sin(fAngle) * fDist;
                        const fSize = 25 + Math.sin(time * 2 + k) * 8; 

                        // 더러운 검정/보라 그라데이션
                        const fartGrad = ctx.createRadialGradient(fx, fy, 0, fx, fy, fSize);
                        fartGrad.addColorStop(0, 'rgba(10, 10, 10, 0.9)');    // 진한 검정
                        fartGrad.addColorStop(0.6, 'rgba(48, 25, 52, 0.6)'); // 짙은 바이올렛
                        fartGrad.addColorStop(1, 'rgba(0, 0, 0, 0)');        // 투명

                        ctx.fillStyle = fartGrad;
                        ctx.beginPath();
                        ctx.arc(fx, fy, fSize, 0, Math.PI * 2);
                        ctx.fill();
                    }

                    // 4. [추가] 검정색 꾸물거리는 올챙이 (그림자 정령 느낌)
                    const tadpoleCount = 10;
                    for (let k = 0; k < tadpoleCount; k++) {
                        const tAngle = (k / tadpoleCount * Math.PI * 2) - (time * 1.5); 
                        const tDist = (sanctuaryRadius * 0.4) + (Math.sin(time * 4 + k * 10) * 30) + (k % 5) * 20;
                        const finalDist = Math.min(tDist, sanctuaryRadius * 0.9);

                        const tx = Math.cos(tAngle) * finalDist;
                        const ty = Math.sin(tAngle) * finalDist;

                        ctx.save();
                        ctx.translate(tx, ty);
                        ctx.rotate(tAngle + Math.PI / 2); 

                        // 머리 (검정)
                        ctx.fillStyle = 'black';
                        ctx.beginPath();
                        ctx.arc(0, 0, 3.5, 0, Math.PI * 2);
                        ctx.fill();

                        // 꼬리 (어두운 회색)
                        ctx.strokeStyle = '#333';
                        ctx.lineWidth = 1.5;
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        const tailWiggle = Math.sin(time * 20 + k) * 4; 
                        ctx.quadraticCurveTo(0, 5, tailWiggle, 10);
                        ctx.stroke();

                        ctx.restore();
                    }

                    // 5. [테두리 이펙트] 바닥의 마법진 링 (회전)
                    ctx.save();
                    ctx.rotate(-time * 0.5); // 반대 방향 회전
                    ctx.strokeStyle = '#4B0082'; // Indigo
                    ctx.lineWidth = 3;
                    ctx.setLineDash([]); // 실선
                    ctx.beginPath();
                    ctx.arc(0, 0, sanctuaryRadius, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.restore();

                    // 6. [전류] 가끔씩 튀는 검은/보라 전류
                    if (Math.random() < 0.3) {
                        ctx.strokeStyle = '#8A2BE2'; // BlueViolet
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        const startAngle = Math.random() * Math.PI * 2;
                        const r = sanctuaryRadius;
                        ctx.moveTo(Math.cos(startAngle) * r, Math.sin(startAngle) * r);
                        ctx.lineTo(Math.cos(startAngle + 0.5) * r * 0.8, Math.sin(startAngle + 0.5) * r * 0.8);
                        ctx.stroke();
                    }

                    ctx.restore();
                }
// ★ [수정됨] 심연의 공명 이펙트 (빨간색 + 정사각형 테두리)
if (enemy.hasAbyssalResonance) {
    ctx.save();

    // 1. 스타일 설정 (붉은색 네온)
    ctx.strokeStyle = "rgba(255, 50, 50, 0.9)"; // 선 색상: 밝은 빨강
    ctx.lineWidth = 3;           // 선 두께
    ctx.shadowBlur = 15;         // 빛 번짐 정도
    ctx.shadowColor = "#ff0000"; // 번짐 색상: 진한 빨강
    
    // 2. 정사각형 크기 설정 (이미지에 딱 맞게)
    // 적의 radius를 절반 크기(half-size)로 사용 (여유분 +5px)
    const s = enemy.radius + 5; 
    
    // 3. 정사각형 4개 꼭짓점 정의 (상좌, 상우, 하우, 하좌)
    const corners = [
        {x: -s, y: -s}, 
        {x: s, y: -s},  
        {x: s, y: s},   
        {x: -s, y: s}   
    ];

    ctx.beginPath();
    ctx.moveTo(corners[0].x, corners[0].y); // 시작점

    // 4. 각 변을 따라가며 전류(지그재그) 그리기
    for (let i = 0; i < 4; i++) {
        const start = corners[i];
        const end = corners[(i + 1) % 4]; // 다음 꼭짓점 (마지막은 처음으로 연결)

        // 한 변을 몇 번 꺾을지 (전류 디테일)
        const segments = 4; 

        for (let j = 1; j < segments; j++) {
            const t = j / segments; // 0.25, 0.5, 0.75 ...
            
            // 직선상의 중간 지점 계산
            const mx = start.x + (end.x - start.x) * t;
            const my = start.y + (end.y - start.y) * t;

            // 랜덤하게 흔들기 (Jitter)
            const jitter = (Math.random() - 0.5) * 10; 
            
            // 가로 변인지 세로 변인지에 따라 흔들리는 방향 조정
            if (i % 2 === 0) { 
                // 상, 하 변(가로) -> Y축으로 흔들림
                ctx.lineTo(mx, my + jitter);
            } else { 
                // 좌, 우 변(세로) -> X축으로 흔들림
                ctx.lineTo(mx + jitter, my);
            }
        }
        // 다음 모서리에 연결
        ctx.lineTo(end.x, end.y);
    }

    ctx.closePath();
    ctx.stroke();

    // (선택) 더 강렬한 효과를 위해 내부에 흰색 실선 추가
    ctx.strokeStyle = "white";
    ctx.lineWidth = 1;
    ctx.globalAlpha = 0.5;
    ctx.stroke();

    ctx.restore();
}
// [신규] 마사쿠니 흑월 이펙트
if (enemy.isMasakuni && enemy.blackMoonState === 'charging') {
    ctx.save();
    
    // [핵심 변경] 이펙트 좌표를 마사쿠니가 아닌 '플레이어(player)' 중심으로 설정
    ctx.translate(player.x, player.y);
    
    // 차징 시간에 따라 점점 진해짐
    const chargeRatio = enemy.blackMoonCharge / 60;
    ctx.globalAlpha = chargeRatio;
    
    ctx.beginPath();
    ctx.arc(0, 0, 120, 0, Math.PI * 2); // 반경 120 범위
    
    // [디자인] 보라색 오오라 그라데이션 적용
    const gradient = ctx.createRadialGradient(0, 0, 60, 0, 0, 120);
    gradient.addColorStop(0, "rgba(0, 0, 0, 1)");          // 중심: 완전 검정
    gradient.addColorStop(0.7, "rgba(50, 0, 50, 0.8)");   // 중간: 어두운 보라
    gradient.addColorStop(1, "rgba(139, 0, 255, 0.6)");   // 외곽: 밝은 보라색
    
    ctx.fillStyle = gradient;
    ctx.fill();
    
    // [디자인] 강력한 보라색 글로우 (위협감 조성)
    ctx.shadowColor = "#9400D3"; // 짙은 보라색
    ctx.shadowBlur = 60;         // 오오라 범위
    
    // 내부 흰색 실선 (살짝 보이게)
    ctx.strokeStyle = "white";
    ctx.lineWidth = 1;
    ctx.globalAlpha = chargeRatio * 0.5;
    ctx.stroke();

    ctx.restore();
}
                // 마사쿠니 심안 발동 상태 표시 (눈이 빛남)
                if (enemy.isMasakuni && enemy.nextAttackCrit) {
                    ctx.save();
                    ctx.translate(enemy.x, enemy.y - 40); // 머리 위
                    ctx.fillStyle = "red";
                    ctx.shadowColor = "red";
                    ctx.shadowBlur = 10;
                    ctx.beginPath();
                    ctx.arc(-15, 0, 5, 0, Math.PI*2);
                    ctx.arc(15, 0, 5, 0, Math.PI*2);
                    ctx.fill();
                    ctx.restore();
                }

                ctx.save();
                ctx.globalAlpha = enemy.alpha; 
                const size = enemy.radius * 2.5;
                try {
                    if (enemy.hitFlash > 0) ctx.filter = 'brightness(200%)';
                    if (enemy.isBoss) ctx.filter = 'brightness(50%) contrast(120%)';
                    if (enemy.isAkiClone) ctx.filter = 'brightness(60%) sepia(30%)';

                    let imgToDraw = summonerVillainImg;
                    
                    if (enemy.isBoss) {
                        if (enemy.isArthur) {
                            imgToDraw = arthurImg;
                        } else if (enemy.isArchdemon) {
                            if (enemy.archdemonName.includes('아키토')) imgToDraw = akitoImg;
                            else if (enemy.archdemonName.includes('토우야')) imgToDraw = touyaImg;
                            else imgToDraw = bossVillainImg;
                        } else {
                            imgToDraw = bossVillainImg;
                        }
                    } else if (enemy.isDarkDenizen) {
                        if (enemy.denizenType === 'louie') imgToDraw = louieImg;
                        else if (enemy.denizenType === 'rai') imgToDraw = raiImg;
                    } else if (enemy.isAkiClone) {
                            imgToDraw = akiImg;
                    } else if (enemy.isRoyal) { 
                        if (enemy.isMasakuni) imgToDraw = masakuniImg;
                        else if (enemy.isKaito) imgToDraw = kaitoImg;
                        else if (enemy.isQuesta) imgToDraw = questaImg;
                        else if (enemy.isTetora) imgToDraw = tetoraImg;
                    } else if (enemy.isElite) {
                        if (enemy.isRyuon) imgToDraw = corruptedHeroImg;
                        else if (enemy.isLuca) imgToDraw = corruptedSniperImg; 
                        else if (enemy.isOzma) imgToDraw = ozmaImg; 
                        else if (enemy.isTaro) imgToDraw = taroImg; 
                        else if (enemy.isGawain) imgToDraw = gawainImg; 
                        else if (enemy.isAki) imgToDraw = akiImg;
                        else if (enemy.isHiro) imgToDraw = hiroImg;
                        else if (enemy.isKai) imgToDraw = kaiImg;
                        else if (enemy.isJacques) imgToDraw = jacquesImg;
                        else imgToDraw = eliteVillainImg;
                    } else if (enemy.isZako) {
                        if (enemy.zakoType === 'terrorist') imgToDraw = zakoTerroristImg;
                        else if (enemy.zakoType === 'plague') imgToDraw = zakoPlagueImg;
                        else imgToDraw = zakoVillainImg;
                    } else if (enemy.isAgent) {
                         if (enemy.agentType === 'curse') imgToDraw = agentCurseImg;
                         else if (enemy.agentType === 'pain') imgToDraw = agentPainImg;
                         else if (enemy.agentType === 'blind') imgToDraw = agentBlindImg;
                    } else if (enemy.normalType === 'rapist') {
                        imgToDraw = rapistVillainImg;
                    }
                    // [추가된 코드] 원형으로 자르기 시작
                    ctx.save(); // ✅ clip 영향 범위 제한 (이미지에만 적용)
                    ctx.beginPath();
                    ctx.arc(0, 0, size / 2, 0, Math.PI * 2); 
                    ctx.clip();
            // [추가된 코드 끝]
                    ctx.drawImage(imgToDraw, -size/2, -size/2, size, size);
                    ctx.filter = 'none';
                    ctx.restore(); // ✅ clip 해제 (이펙트가 안 잘리게)
                } catch (e) { ctx.fillStyle = '#333'; ctx.beginPath(); ctx.arc(0, 0, enemy.radius, 0, Math.PI*2); ctx.fill(); }
                  if (enemy.isQuesta) {
            if (enemy.isVeiled) {
                // [OPT] 칠흑의 장막: 기존 색감 유지 + 캐시로 최적화
                drawQuestaVeilCached(ctx, size);
            }
            // 본 크러셔 이펙트도 여기에 두면 이미지 위에 그려집니다.
            if (enemy.boneCrusherState === 'rushing') {
                ctx.save();
                ctx.rotate(enemy.boneCrusherAngle - (enemy.angle + Math.PI/2));
                ctx.strokeStyle = "#4B0082"; 
                ctx.lineWidth = 5; 
                ctx.beginPath(); 
                ctx.moveTo(0, 0); 
                ctx.lineTo(0, -100); 
                ctx.stroke(); 
                ctx.restore();
            }
        }
                ctx.restore();

                if (enemy.isEvilDigestActive) {
    ctx.save();
    
    const time = Date.now() / 40; // 전류 애니메이션 속도
    
    // (1) 메인 갈색 전류
    ctx.beginPath();
    ctx.strokeStyle = "#5D4037"; // 진한 갈색
    ctx.lineWidth = 3;
    ctx.shadowColor = "#3E2723"; // 어두운 갈색 광채
    ctx.shadowBlur = 15;
    
    for (let i = 0; i <= 360; i += 10) {
        const angle = (i * Math.PI) / 180;
        // 적 반지름보다 조금 더 크게 설정 (radius * 1.3)
        const noise = Math.sin(angle * 10 + time) * 5 + Math.cos(angle * 20 - time) * 5;
        const r = (enemy.radius * 1.3) + noise; 
        
        const px = Math.cos(angle) * r;
        const py = Math.sin(angle) * r;
        
        if (i === 0) ctx.moveTo(px, py);
        else ctx.lineTo(px, py);
    }
    ctx.closePath();
    ctx.stroke();
    
    // (2) 내부의 탁한 흐름 (디테일 추가)
    ctx.beginPath();
    ctx.strokeStyle = "rgba(160, 82, 45, 0.7)"; // 탁한 황갈색
    ctx.lineWidth = 1;
    ctx.shadowBlur = 0;
    
    for (let i = 0; i <= 360; i += 15) {
        const angle = (i * Math.PI) / 180;
        const noise = Math.sin(angle * 15 - time) * 3;
        const r = (enemy.radius * 1.25) + noise; 
        
        const px = Math.cos(angle) * r;
        const py = Math.sin(angle) * r;
        
        if (i === 0) ctx.moveTo(px, py);
        else ctx.lineTo(px, py);
    }
    ctx.stroke();
    
    ctx.restore();
}

ctx.restore(); // 적의 좌표 변환(translate/rotate) 종료

                const hpPercent = Math.max(0, enemy.hp) / enemy.maxHp;

                // [신규] 카이 그림자 스왑 차지 보호막 게이지(노란색) - HP바 바로 위
                const activeShieldValue = Math.max(enemy.shadowSwapShield || 0, enemy.antiPassingShield || 0);
                const activeShieldMax = activeShieldValue === (enemy.antiPassingShield || 0) ? (enemy.antiPassingShieldMax || 0) : (enemy.shadowSwapShieldMax || 0);
                if (activeShieldValue > 0 && activeShieldMax > 0) {
                    const shieldPercent = Math.max(0, activeShieldValue) / activeShieldMax;
                    const sy = enemy.y - enemy.radius - 22;
                    ctx.fillStyle = 'black'; ctx.fillRect(enemy.x - 20, sy, 40, 5);
                    ctx.fillStyle = '#FFD700'; ctx.fillRect(enemy.x - 20, sy, 40 * shieldPercent, 5);
                }

                ctx.fillStyle = 'black'; ctx.fillRect(enemy.x - 20, enemy.y - enemy.radius - 15, 40, 6);
                ctx.fillStyle = '#ff3333'; ctx.fillRect(enemy.x - 20, enemy.y - enemy.radius - 15, 40 * hpPercent, 6);
                
                let drawName = false;
                let nameText = "";
                let nameColor = "white";

                if (enemy.isElite) {
                    drawName = true;
                    if(enemy.isBoss) {
                        if (enemy.isArchdemon) {
                            nameText = enemy.archdemonName;
                            nameColor = "#FF4500"; 
                        } else {
                            if (enemy.isArthur) {
                                nameText = "타락한 로드 아서";
                                nameColor = "#DC143C";
                            }
                            else if(enemy.bossType === 0) nameText = "방구킹 카인 (블랙 미스트)";
                            else if(enemy.bossType === 1) nameText = "방구킹 카인 (다크 테러리스트)";
                            else if(enemy.bossType === 2) nameText = "방구킹 카인 (테러블 자멘)";
                            else if(enemy.bossType === 3) nameText = "방구킹 카인 (호러블 네크로맨서)";
                            else if(enemy.bossType === 4) nameText = "방구킹 카인 (타네츠케 데빌)";
                            
                            if (!enemy.isArthur && !nameColor) nameColor = "#9370DB";
                        }
                    } else if (enemy.isDarkDenizen) {
                    } else {
                         if (enemy.isRyuon) { nameText = "타락한 용사 류온"; nameColor = "#8B0000"; }
                         else if (enemy.isLuca) { nameText = "타락한 스나이퍼 루카"; nameColor = "#FFFFFF"; } 
                         else if (enemy.isOzma) { nameText = "타락한 마법사 오즈마"; nameColor = "#FF00FF"; }
                         else if (enemy.isTaro) { nameText = "타락한 암살자 타로"; nameColor = "#708090"; }
                         else if (enemy.isGawain) { nameText = "타락한 성기사 가웨인"; nameColor = "#9370DB"; } 
                         else if (enemy.isAki) { nameText = "타락한 사냥꾼 아키"; nameColor = "#1a1a1a"; }
                         else if (enemy.isHiro) { nameText = "타락한 첩보원 히로"; nameColor = "#9932CC"; }
                         else if (enemy.isKai) { nameText = "흑마법사 카이"; nameColor = "#4B0082"; }
                         else if (enemy.isJacques) { nameText = "타락한 바드 자크"; nameColor = "#FFFFFF"; }
                         else {
                             nameText = "카시아스";
                         }
                    }
                } 
                // ... (나머지 이름 그리기 로직) ...
                else if (!enemy.isZako) {
                    drawName = true;
                    if (enemy.isRoyal) {
                    if (enemy.isMasakuni) {
                        nameText = "검은 민족 마사쿠니";
                        nameColor = "#190000";
                   } else if (enemy.isKaito) {
                        nameText = "검은 민족 카이토";
                        nameColor = "#190000";
                   }
                     else if (enemy.isQuesta) {
                        nameText = "검은 민족 퀘스타";
                        nameColor = "#190000";
                   }
                     else if (enemy.isTetora) {
                        nameText = "검은 민족 테토라";
                        nameColor = "#190000";
                   }
              }
                   else if (enemy.isAgent) {
                         if (enemy.agentType === 'curse') { nameText = `공작원(저주) ${Math.ceil(enemy.agentDeathTimer/60)}`; nameColor = "#4B0082"; }
                         else if (enemy.agentType === 'pain') { nameText = `공작원(고통) ${Math.ceil(enemy.agentDeathTimer/60)}`; nameColor = "#6B8E23"; }
                         else { nameText = `공작원(실명) ${Math.ceil(enemy.agentDeathTimer/60)}`; nameColor = "#808080"; }
                    } else if (enemy.isDarkDenizen) {
                        if (enemy.denizenType === 'louie') nameText = "어둠의 주민 루이";
                        else nameText = "어둠의 주민 라이";
                        nameColor = "#800080";
                    } else if (enemy.normalType === 'rapist') {
                        if (enemy.isStealth) nameText = "강간범 (은신)";
                        else if (enemy.isAmbush) nameText = "강간범 (매복)";
                        else nameText = "강간범";
                        nameColor = "#FF1493";
                    } else if (enemy.normalType === 'summoner') {
                        if (enemy.eliteType === 1) nameText = "소환사(테러범)";
                        else if (enemy.eliteType === 2) nameText = "소환사(역병)";
                        else nameText = "소환사(덮치기범)";
                        nameColor = "#CCCCCC";
                    }
                } else if (enemy.isZako) {
                    drawName = true;
                    if (enemy.zakoType === 'terrorist') { nameText = "자코(테러범)"; nameColor = "#FF6347"; } 
                    else if (enemy.zakoType === 'plague') { nameText = "자코(역병)"; nameColor = "#32CD32"; } 
                    else { nameText = "자코(덮치기범)"; nameColor = "#AAAAAA"; }
                    if (enemy.enraged) { nameText = "격분한 " + nameText; nameColor = "#FF0000"; }
                }

              if (drawName) {
                ctx.font = "bold 12px Arial";
                ctx.textAlign = "center";
                ctx.fillStyle = nameColor;
                ctx.fillText(nameText, enemy.x, enemy.y - enemy.radius - 20);
            }
            ctx.restore();

            // [수정됨] 악마의 보호 마크 표시 (사악한 검보라색 방패)
            if (enemy.isProtectedByCain && enemy.hp > 0) {
                ctx.save();
                // 위치를 머리 위로 조정
                ctx.translate(enemy.x, enemy.y - enemy.radius - 40);

                // 사악한 보라색 광채
                ctx.shadowColor = "#8A2BE2"; // BlueViolet
                ctx.shadowBlur = 15;

                // 방패 모양 경로 그리기
                ctx.beginPath();
                ctx.moveTo(0, -20);
                ctx.quadraticCurveTo(20, -20, 20, 5);   // 우측 상단
                ctx.bezierCurveTo(20, 25, 0, 40, 0, 40); // 우측 하단 -> 끝점
                ctx.bezierCurveTo(0, 40, -20, 25, -20, 5); // 좌측 하단
                ctx.quadraticCurveTo(-20, -20, 0, -20);  // 좌측 상단
                ctx.closePath();

                // 내부 채우기 (어두운 보라 그라데이션)
                const shieldGrad = ctx.createLinearGradient(-10, -20, 10, 40);
                shieldGrad.addColorStop(0, "#4B0082"); // Indigo
                shieldGrad.addColorStop(1, "#000000"); // Black
                ctx.fillStyle = shieldGrad;
                ctx.fill();

                // 테두리 (검정)
                ctx.strokeStyle = "#000000";
                ctx.lineWidth = 3;
                ctx.stroke();

                // 방패 내부 문양 (V자 형광 보라)
                ctx.beginPath();
                ctx.moveTo(-10, -5);
                ctx.lineTo(0, 15);
                ctx.lineTo(10, -5);
                ctx.strokeStyle = "#D8BFD8"; // Thistle (연한 보라)
                ctx.lineWidth = 2;
                ctx.shadowColor = "#FF00FF";
                ctx.stroke();

                ctx.restore();
            }
        });

            // 네더 그랩 그리기 (선 연결)
    if (player.netherGrabbedBy && player.netherGrabbedBy.hp > 0 && player.netherGrabbedBy.netherGrabActive) {
        ctx.save();
        ctx.strokeStyle = "#120A8F"; // Ultramarine
        ctx.lineWidth = 3;
        ctx.shadowColor = "#000080";
        ctx.shadowBlur = 10;
        
        ctx.beginPath();
        ctx.moveTo(player.netherGrabbedBy.x, player.netherGrabbedBy.y);
        
        // 지그재그 전류 효과
        const segments = 10;
        const dx = (player.x - player.netherGrabbedBy.x) / segments;
        const dy = (player.y - player.netherGrabbedBy.y) / segments;
        
        for(let k=1; k<segments; k++) {
            const jitter = (Math.random()-0.5) * 20;
            ctx.lineTo(player.netherGrabbedBy.x + dx*k + jitter, player.netherGrabbedBy.y + dy*k + jitter);
        }
        ctx.lineTo(player.x, player.y);
        ctx.stroke();
        ctx.restore();
    } else {
        player.netherGrabbedBy = null; // 연결 끊김 안전장치
    }

            // ... (아이템 그리기 등 생략) ...
            hollowNight.forEach(hk => {
                renderHollowNightEffect(ctx, hk);
            });


            items.forEach(item => {
                ctx.save(); ctx.translate(item.x, item.y); if (item.life < 120 && Math.floor(item.life / 10) % 2 === 0) ctx.globalAlpha = 0.5;
                function drawHeart(color, borderColor) { ctx.fillStyle = color; ctx.beginPath(); const r = item.radius; ctx.moveTo(0, -r * 0.5); ctx.bezierCurveTo(-r * 1.5, -r * 1.5, -r * 1.5, r, 0, r * 1.5); ctx.bezierCurveTo(r * 1.5, r, r * 1.5, -r * 1.5, 0, -r * 0.5); ctx.fill(); if(borderColor) { ctx.strokeStyle = borderColor; ctx.lineWidth = 2; ctx.stroke(); } }
                if (item.type === 'health') { drawHeart('#ff4d4d', '#cc0000'); ctx.fillStyle = 'white'; ctx.font = "bold 16px Arial"; ctx.textAlign = "center"; ctx.textBaseline = "middle"; ctx.fillText("+", 0, -2); } 
                else if (item.type === 'berserk') { ctx.drawImage(berserkItemImg, -item.radius, -item.radius, item.radius*2, item.radius*2); } 
                else if (item.type === 'white') { drawHeart('#FFFFFF', '#E0E0E0'); } 
                else if (item.type === 'shield') { ctx.drawImage(shieldItemImg, -item.radius, -item.radius, item.radius*2, item.radius*2); } 
                else if (item.type === 'justice') { ctx.drawImage(justiceItemImg, -item.radius, -item.radius, item.radius*2, item.radius*2); }
                else if (item.type === 'magnet') { ctx.drawImage(magnetItemImg, -item.radius, -item.radius, item.radius*2, item.radius*2); }
                else if (item.type === 'fakeHealth') {
                    // 진짜와 똑같이 그리되 테두리만 다르게 호출
                    // 옅은 보라색 테두리 (#9370DB)
                    drawHeart('#ff4d4d', '#9370DB'); 
                    ctx.fillStyle = 'white'; ctx.font = "bold 16px Arial"; ctx.textAlign = "center"; ctx.textBaseline = "middle"; ctx.fillText("+", 0, -2);
                }
                else if (item.type === 'ancientScroll') {
                    const r = item.radius;
                    // 두루마리(양피지) 아이콘
                    ctx.fillStyle = "#F5DEB3"; // Wheat
                    ctx.strokeStyle = "#8B5A2B";
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.rect(-r*0.9, -r*0.7, r*1.8, r*1.4);
                    ctx.fill();
                    ctx.stroke();

                    // 말린 끝
                    ctx.fillStyle = "#D2B48C";
                    ctx.beginPath(); ctx.arc(-r*0.9, 0, r*0.35, 0, Math.PI*2); ctx.fill();
                    ctx.beginPath(); ctx.arc( r*0.9, 0, r*0.35, 0, Math.PI*2); ctx.fill();
                    ctx.strokeStyle = "#8B5A2B"; ctx.lineWidth = 1;
                    ctx.beginPath(); ctx.arc(-r*0.9, 0, r*0.35, 0, Math.PI*2); ctx.stroke();
                    ctx.beginPath(); ctx.arc( r*0.9, 0, r*0.35, 0, Math.PI*2); ctx.stroke();

                    // 문양
                    ctx.fillStyle = "rgba(0,0,0,0.65)";
                    ctx.font = "bold 14px Arial";
                    ctx.textAlign = "center";
                    ctx.textBaseline = "middle";
                    ctx.fillText("R+1", 0, 0);
                }
                ctx.restore();
            });

          pandemoniums.forEach(p => {
                ctx.save(); ctx.translate(p.x, p.y); const gradient = ctx.createRadialGradient(0, 0, 20, 0, 0, p.radius); gradient.addColorStop(0, '#39FF14'); gradient.addColorStop(0.6, '#0f000f'); gradient.addColorStop(1, 'rgba(0, 0, 0, 0)'); ctx.fillStyle = gradient; ctx.beginPath();
                ctx.arc(0, 0, p.radius, 0, Math.PI * 2);
                ctx.fill();
                
                // 판데모니움 내부 혼돈 효과
                const time = Date.now() / 100;
                ctx.strokeStyle = '#FFFFFF';
                ctx.lineWidth = 2;
                ctx.beginPath();
                for(let k=0; k<5; k++) {
                    const angle = (k / 5) * Math.PI * 2 + time;
                    const r = p.radius * 0.6 + Math.sin(time * 3 + k) * 10;
                    const px = Math.cos(angle) * r;
                    const py = Math.sin(angle) * r;
                    if (k===0) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                }
                ctx.closePath();
                ctx.stroke();
                
                ctx.restore();
            });
            
            // [신규] 카오스 오브 그리기
            chaosOrbs.forEach(p => {
                ctx.save(); ctx.translate(p.x, p.y);
                
                // 주황 -> 보라 -> 투명 그라데이션
                const gradient = ctx.createRadialGradient(0, 0, 20, 0, 0, p.radius);
                gradient.addColorStop(0, '#FF4500'); // OrangeRed (중심)
                gradient.addColorStop(0.6, '#800080'); // Purple (중간)
                gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(0, 0, p.radius, 0, Math.PI * 2);
                ctx.fill();
                
                // 내부 혼돈 효과 (빨간색 라인으로 위협적으로 표현)
                const time = Date.now() / 100;
                ctx.strokeStyle = '#FF0000'; // Red
                ctx.lineWidth = 2;
                ctx.beginPath();
                for(let k=0; k<5; k++) {
                    const angle = (k / 5) * Math.PI * 2 + time;
                    const r = p.radius * 0.6 + Math.sin(time * 3 + k) * 10;
                    const px = Math.cos(angle) * r;
                    const py = Math.sin(angle) * r;
                    if (k===0) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                }
                ctx.closePath();
                ctx.stroke();
                
                ctx.restore();
            });

                // [수정됨] 블러드 드레인 (박쥐 투사체) - 3D 볼륨감 있는 박쥐
                    bloodBats.forEach(b => {
                    ctx.save();
                    ctx.translate(b.x, b.y);
                    const angle = Math.atan2(player.y - b.y, player.x - b.x);
                    ctx.rotate(angle);

     // 1. 그림자 추가 (입체감)
    ctx.shadowColor = 'rgba(0, 0, 0, 0.6)';
    ctx.shadowBlur = 8;
    ctx.shadowOffsetY = 5;

    // 2. 박쥐 몸통 그라데이션
    const batGrad = ctx.createLinearGradient(0, -10, 0, 10);
    batGrad.addColorStop(0, '#ff4d4d'); // 위쪽은 밝은 빨강
    batGrad.addColorStop(1, '#500000'); // 아래쪽은 어두운 빨강
    ctx.fillStyle = batGrad;

    // 3. 곡선을 이용한 날개 모양 그리기 (기존 삼각형 -> 베지어 곡선)
    ctx.beginPath();
    ctx.moveTo(15, 0); // 머리 (앞쪽)
    
    // 오른쪽 날개 (위)
    ctx.bezierCurveTo(5, -10, -5, -25, -20, -15); 
    // 오른쪽 날개 (아래 - 갈퀴 모양)
    ctx.quadraticCurveTo(-10, -5, -5, 0);
    // 왼쪽 날개 (대칭)
    ctx.quadraticCurveTo(-10, 5, -20, 15);
    ctx.bezierCurveTo(-5, 25, 5, 10, 15, 0);
    
    ctx.fill();

    // 4. 눈 (노란색으로 포인트)
    ctx.shadowBlur = 0; // 눈에는 그림자 제거
    ctx.fillStyle = '#FFFF00';
    ctx.beginPath();
    ctx.arc(8, -3, 2, 0, Math.PI*2); // 오른쪽 눈
    ctx.arc(8, 3, 2, 0, Math.PI*2); // 왼쪽 눈
    ctx.fill();

    ctx.restore();
});

// [추가] 엑스칼리버 연기 궤적 그리기
slashTrails.forEach(t => {
    ctx.save();
    ctx.translate(t.x, t.y);
    const alpha = t.life / t.maxLife;
    // 검붉은색 그라데이션
    const grad = ctx.createRadialGradient(0, 0, 0, 0, 0, t.radius);
    grad.addColorStop(0, `rgba(50, 0, 0, ${alpha * 0.8})`); // 내부: 아주 어두운 빨강
    grad.addColorStop(1, `rgba(0, 0, 0, 0)`); // 외부: 투명
    
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.arc(0, 0, t.radius, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
});

// [추가] 엑스칼리버 참격(본체 + 전류) 그리기
excaliburSlashes.forEach(s => {
    ctx.save();
    ctx.translate(s.x, s.y);
    ctx.rotate(s.angle);

    // 1. 검은색 참격 본체 (초승달 모양)
    ctx.fillStyle = 'black';
    ctx.shadowColor = '#8B0000'; // DarkRed 그림자
    ctx.shadowBlur = 20;
    
    ctx.beginPath();
    ctx.arc(-20, 0, 60, -Math.PI/2.5, Math.PI/2.5); // 바깥쪽 호
    ctx.arc(-10, 0, 50, Math.PI/2.5, -Math.PI/2.5, true); // 안쪽 호
    ctx.closePath();
    ctx.fill();
    ctx.shadowBlur = 0; // 그림자 초기화

    // 2. 시뻘건 전류 이펙트 (무작위 지그재그 선)
    ctx.strokeStyle = '#DC143C'; // Crimson 색상
    ctx.lineWidth = 3;
    ctx.lineJoin = 'round';
    
    // 전류 3줄기 생성
    for (let k = 0; k < 3; k++) {
        ctx.beginPath();
        // 참격의 앞부분(오른쪽)을 감싸는 형태
        const startY = -40 + Math.random() * 80;
        ctx.moveTo(-20, startY); 
        
        let cx = -20;
        let cy = startY;
        // 지그재그 그리며 오른쪽으로 이동
        for(let j=0; j<5; j++) {
            cx += 10 + Math.random() * 10;
            cy += (Math.random() - 0.5) * 20;
            ctx.lineTo(cx, cy);
        }
        ctx.stroke();
    }
    
    // 3. 중심부 붉은 코어
    ctx.fillStyle = 'rgba(139, 0, 0, 0.8)';
    ctx.beginPath();
    ctx.ellipse(10, 0, 30, 5, 0, 0, Math.PI*2);
    ctx.fill();

    ctx.restore();
});

            // ==================================================================================
            // [플레이어 그리기]
            // ==================================================================================
            ctx.save();
            ctx.translate(player.x, player.y);
            
            // 무적 상태 깜빡임
            if (player.invincibleTimer > 0 && Math.floor(Date.now() / 50) % 2 === 0) {
                ctx.globalAlpha = 0.5;
            }

            // 무기 그리기 (회전)
            ctx.save();
            ctx.rotate(player.weapon.angle);
            ctx.fillStyle = player.weapon.color;
            
            // 베르세르크 상태면 무기가 붉게 빛남
            if (player.berserkTimer > 0) {
                ctx.shadowColor = 'red';
                ctx.shadowBlur = 15;
                ctx.fillStyle = '#8B0000';
            }
            
            // 무기 (긴 막대 형태)
            ctx.fillRect(0, -player.weapon.width / 2, player.weapon.length, player.weapon.width);
            ctx.fillRect(0, -player.weapon.width / 2, -player.weapon.length, player.weapon.width);
            // 공격 중 이펙트 (잔상)
            if (player.weapon.isAttacking) {
                ctx.beginPath();
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.lineWidth = 2;
                ctx.moveTo(10, 0);
                ctx.lineTo(player.weapon.length, 0);
                ctx.stroke();
            }
            ctx.restore();

            if (player.sacredFaithSkill.activeTimer > 0) {
                ctx.save();
                // 시간이 지날수록 깜빡이는 효과 (Pulse)
                const pulse = 1 + Math.sin(Date.now() / 200) * 0.1;
                
                // 빛나는 그라데이션 원
                const grad = ctx.createRadialGradient(0, 0, player.radius, 0, 0, player.radius * 2.5 * pulse);
                grad.addColorStop(0, "rgba(255, 215, 0, 0.4)"); // 안쪽 (골드)
                grad.addColorStop(1, "rgba(255, 215, 0, 0)");   // 바깥쪽 (투명)
                
                ctx.fillStyle = grad;
                ctx.beginPath();
                ctx.arc(0, 0, player.radius * 3, 0, Math.PI * 2);
                ctx.fill();
                
                // 외곽선 링
                ctx.strokeStyle = "rgba(255, 255, 0, 0.6)";
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(0, 0, player.radius * 2 * pulse, 0, Math.PI * 2);
                ctx.stroke();
                
                ctx.restore();
            }
            // 플레이어 본체
            const pSize = player.radius * 2.8;
            
            // 상태이상 시각 효과 (그림자)
            ctx.shadowBlur = 0;
            if (player.berserkTimer > 0) {
                ctx.shadowColor = 'red';
                ctx.shadowBlur = 20;
            } else if (player.justiceShield > 0) {
                 ctx.shadowColor = '#FFD700'; // 골드
                 ctx.shadowBlur = 20;
            } else if (player.shieldStacks > 0) {
                ctx.shadowColor = '#00BFFF'; // 딥 스카이 블루
                ctx.shadowBlur = 15;
            } else if (player.poisonTimers.length > 0 || player.poopPoisonTimers.length > 0) {
                ctx.shadowColor = '#00FF00';
                ctx.shadowBlur = 15;
            }

            try {
                // 스턴 상태면 회전하거나 흔들림 효과를 줄 수 있음
                if (player.stunTimer > 0) {
                    ctx.rotate(Math.sin(Date.now() / 50) * 0.2);
                }
                ctx.drawImage(playerImg, -pSize/2, -pSize/2, pSize, pSize);
                
                // 스턴 별 표시
                if (player.stunTimer > 0) {
                    ctx.font = "20px Arial";
                    ctx.fillStyle = "yellow";
                    ctx.fillText("★", 0, -player.radius - 15);
                }
                if (player.deathBrandTimers.length > 0) {
                ctx.save();
                // 플레이어 머리 위로 위치 이동 (좌표계는 이미 player.x, player.y)
                // 둥둥 떠다니는 애니메이션 효과 추가
                const floatY = Math.sin(Date.now() / 200) * 5;
                ctx.translate(0, -player.radius * 2.8 + floatY); 

                const s = 30; // 해골 크기

                // 1. 검붉은 후광 (사악한 기운)
                ctx.shadowColor = '#8B0000'; // DarkRed
                ctx.shadowBlur = 20;

                // 2. 두개골 형태 그리기 (입체적 곡선)
                ctx.beginPath();
                ctx.moveTo(0, -s * 0.4);
                ctx.bezierCurveTo(-s * 0.35, -s * 0.4, -s * 0.45, -s * 0.1, -s * 0.4, s * 0.1);
                ctx.bezierCurveTo(-s * 0.45, s * 0.25, -s * 0.25, s * 0.3, -s * 0.2, s * 0.45); // 왼쪽 광대
                ctx.lineTo(-s * 0.1, s * 0.65); // 턱
                ctx.quadraticCurveTo(0, s * 0.75, s * 0.1, s * 0.65);
                ctx.lineTo(s * 0.2, s * 0.45); // 오른쪽 광대
                ctx.bezierCurveTo(s * 0.25, s * 0.3, s * 0.45, s * 0.25, s * 0.4, s * 0.1);
                ctx.bezierCurveTo(s * 0.45, -s * 0.1, s * 0.35, -s * 0.4, 0, -s * 0.4);
                ctx.closePath();

                // 3. 입체감 있는 검붉은 그라데이션 채색
                const skullGrad = ctx.createRadialGradient(-s*0.1, -s*0.1, s*0.1, 0, 0, s*0.6);
                skullGrad.addColorStop(0, '#ff6666');   // 하이라이트 (연한 붉은색)
                skullGrad.addColorStop(0.4, '#800000'); // 중간 (진한 밤색)
                skullGrad.addColorStop(1, '#1a0000');   // 그림자 (거의 검정)
                
                ctx.fillStyle = skullGrad;
                ctx.fill();
                
                // 4. 눈 (검은 구멍 + 붉은 안광)
                ctx.fillStyle = 'black';
                ctx.shadowBlur = 0; // 눈 내부는 선명하게
                
                // 왼쪽 눈
                ctx.beginPath();
                ctx.moveTo(-s*0.12, s*0.05);
                ctx.bezierCurveTo(-s*0.2, -s*0.05, -s*0.35, -s*0.05, -s*0.32, s*0.15);
                ctx.bezierCurveTo(-s*0.3, s*0.25, -s*0.15, s*0.25, -s*0.12, s*0.05);
                ctx.fill();
                
                // 오른쪽 눈
                ctx.beginPath();
                ctx.moveTo(s*0.12, s*0.05);
                ctx.bezierCurveTo(s*0.2, -s*0.05, s*0.35, -s*0.05, s*0.32, s*0.15);
                ctx.bezierCurveTo(s*0.3, s*0.25, s*0.15, s*0.25, s*0.12, s*0.05);
                ctx.fill();

                // 붉은 안광 (포인트)
                ctx.fillStyle = '#ff0000';
                ctx.shadowColor = '#ff0000';
                ctx.shadowBlur = 10;
                ctx.beginPath();
                ctx.arc(-s*0.22, s*0.1, 2, 0, Math.PI*2);
                ctx.arc(s*0.22, s*0.1, 2, 0, Math.PI*2);
                ctx.fill();

                ctx.restore();
            }
                // 실명 표시
                if (player.blindTimers.length > 0) {
                    ctx.font = "16px Arial";
                    ctx.fillStyle = "#888";
                    ctx.fillText("?", 0, -player.radius - 5);
                }

            } catch (e) {
                // 이미지 로드 실패 시 대체 원
                ctx.fillStyle = '#4CAF50';
                ctx.beginPath();
                ctx.arc(0, 0, player.radius, 0, Math.PI * 2);
                ctx.fill();
            }

            ctx.restore();
            
            // 모바일 조작 가이드 (터치 중일 때 표시)
            if (isTouching) {
                ctx.save();
                ctx.beginPath();
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.lineWidth = 2;
                ctx.arc(touchStart.x, touchStart.y, 30, 0, Math.PI*2);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.arc(touchCurrent.x, touchCurrent.y, 30, 0, Math.PI*2);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.moveTo(touchStart.x, touchStart.y);
                ctx.lineTo(touchCurrent.x, touchCurrent.y);
                ctx.stroke();
                
                ctx.restore();
                     }
            // [Aki] Projectiles (foreground): draw AFTER enemies so they appear on top of enemy sprites
            dragShots.forEach(shot => {
                drawAkiDragShot(ctx, shot, frameCount);
            });
            evilArrows.forEach(arrow => {
                drawAkiEvilArrow(ctx, arrow, frameCount);
            });
            poisonousShots.forEach(shot => {
                drawAkiPoisonousShot(ctx, shot, frameCount);
            });


                drawFloatingTexts();
        }

        function updateHealthUI() {
            const percent = Math.max(0, player.health / player.maxHealth) * 100;
            healthBar.style.width = percent + '%';
            
            // HP 텍스트 업데이트 추가
            const currentHp = Math.ceil(Math.max(0, player.health));
            const maxHp = Math.ceil(player.maxHealth);
            document.getElementById('healthText').innerText = `HP: ${currentHp} / ${maxHp}`;
        }

        function updateMaxHealth() {
             player.maxHealth = player.baseMaxHealth;

             if (player.evilLightTimers.length > 0) {
               player.maxHealth = Math.floor(player.maxHealth * 0.85);
             }

             // 사악한 마음 스택 당 최대 체력 감소 효과 적용 (스택 당 10)
             if (player.evilMindTimers.length > 0) {
                 const reductionRatio = player.evilMindTimers.length * 0.02; 
                 const reductionAmount = Math.floor(player.baseMaxHealth * reductionRatio);
                 player.maxHealth -= reductionAmount;
             }

             // 최대 체력이 1 미만으로 떨어지지 않게 방지
             if (player.maxHealth < 1) player.maxHealth = 1;

             // 현재 체력이 최대 체력을 넘지 않도록 조정
             if (player.health > player.maxHealth) {
                 player.health = player.maxHealth;
             }

             updateHealthUI();
        }

        function updatePoopVisual() {
            if (player.poopPoisonTimers.length > 0) {
                poopOverlay.style.opacity = Math.min(0.8, player.poopPoisonTimers.length * 0.1);
            } else {
                poopOverlay.style.opacity = 0;
            }
        }

        function updateStatusUI() {
            function updateIcon(element, timers, stackElement) {
                if (timers && timers.length > 0) {
                    element.style.display = 'flex';
                    if (stackElement) stackElement.innerText = timers.length;
                } else {
                    element.style.display = 'none';
                }
            }

            // 기존 상태이상 업데이트
            updateIcon(poisonStatus, player.poisonTimers, poisonStacksText);
            updateIcon(poopStatus, player.poopPoisonTimers, poopStacksText);
            updateIcon(maliceStatus, player.maliceTimers, maliceStacksText);
            updateIcon(kissStatus, player.kissTimers, kissStacksText);
            updateIcon(semenStatus, player.semenTimers, semenStacksText);
            updateIcon(oralStatus, player.oralTimers, oralStacksText);
            updateIcon(byururutStatus, player.byururutTimers, byururutStacksText);
            updateIcon(fractureStatus, player.fractureTimers, fractureStacksText);

            // 겁탈
            if (player.geoptalCount > 0) {
                geoptalStatus.style.display = 'flex';
                geoptalStacksText.innerText = player.geoptalCount;
            } else {
                geoptalStatus.style.display = 'none';
            }
            
            // [신규] 절망, 세례 UI
            if (player.despairTimer > 0) {
                despairStatus.style.display = 'flex';
                // 남은 시간 표시는 선택사항 (여기선 생략하거나 아이콘만 표시)
            } else {
                despairStatus.style.display = 'none';
            }

            if (player.baptismStacks > 0) {
                baptismStatus.style.display = 'flex';
                baptismStacksText.innerText = player.baptismStacks;
            } else {
                baptismStatus.style.display = 'none';
            }

            // [수정] 과민 반응 (위치 이동 및 갱신 보장)
            if (player.hasHypersensitivity) {
                hypersensitivityStatus.style.display = 'flex';
            } else {
                hypersensitivityStatus.style.display = 'none';
            }

            // 출혈 UI
            if (player.bleedingTimers.length > 0) {
                bleedingStatus.style.display = 'flex';
                document.getElementById('bleedingVal').innerText = `x ${player.bleedingTimers.length}`;
            } else {
                bleedingStatus.style.display = 'none';
            }

            // 차광 UI
            if (player.shadingTimers.length > 0) {
                shadingStatus.style.display = 'flex';
            } else {
                shadingStatus.style.display = 'none';
            }

            // [추가] 신규 엘리트 디버프 4종 갱신 로직
            if (player.corruptedOathStacks > 0) {
                corruptedOathStatus.style.display = 'flex';
                corruptedOathStacksText.innerText = player.corruptedOathStacks;
            } else {
                corruptedOathStatus.style.display = 'none';
            }

            if (player.dangerousJudgmentStacks > 0) {
                dangerousJudgmentStatus.style.display = 'flex';
                dangerousJudgmentStacksText.innerText = player.dangerousJudgmentStacks;
            } else {
                dangerousJudgmentStatus.style.display = 'none';
            }

            if (player.deepDarknessStacks > 0) {
                deepDarknessStatus.style.display = 'flex';
                deepDarknessStacksText.innerText = player.deepDarknessStacks;
            } else {
                deepDarknessStatus.style.display = 'none';
            }

            if (player.corruptedJusticeStacks > 0) {
                corruptedJusticeStatus.style.display = 'flex';
                corruptedJusticeStacksText.innerText = player.corruptedJusticeStacks;
            } else {
                corruptedJusticeStatus.style.display = 'none';
            }
            if (player.serumContaminationTimers.length > 0) {
                serumContaminationStatus.style.display = 'flex';
            } else {
                serumContaminationStatus.style.display = 'none';
            }
            // -----------------------------------------------------

            updateIcon(fishyStatus, player.fishyTimers, fishyStacksText);
            updateIcon(blindStatus, player.blindTimers, blindStacksText);
            
            // [수정] 마비 아이콘 업데이트 (Timers 기반)
            updateIcon(paralysisStatus, player.paralysisTimers, paralysisStacksText);

            updateIcon(evilMindStatus, player.evilMindTimers, evilMindStacksText);
            updateIcon(curseStatus, player.curseTimers, curseStacksText);
            updateIcon(gnawingLifeStatus, player.gnawingLifeTimers, gnawingLifeStacksText);
            
            updateIcon(darkScentStatus, player.darkScentTimers, darkScentStacksText);
            updateIcon(darkSmellStatus, player.darkSmellTimers, darkSmellStacksText);
            updateIcon(darkSeedStatus, player.darkSeedTimers, darkSeedStacksText);
            updateIcon(darkKissStatus, player.darkKissTimers, darkKissStacksText);
            updateIcon(darkReceiverStatus, player.darkReceiverTimers, darkReceiverStacksText);
            updateIcon(darkEcstasyStatus, player.darkEcstasyTimers, darkEcstasyStacksText);
            // [추가] 아서 전용 디버프 UI 업데이트
            updateIcon(trueAncestorKissStatus, player.trueAncestorKissTimers, trueAncestorKissStacksText);
            updateIcon(fatalScarStatus, player.fatalScarTimers, fatalScarStacksText);
            updateIcon(corruptedBloodStatus, player.corruptedBloodTimers, corruptedBloodStacksText);

            // [신규] 암흑 및 정신착란 아이콘 업데이트
            if (darknessStatusEl) updateIcon(darknessStatusEl, player.darknessTimers, null);
            if (confusionStatusEl) updateIcon(confusionStatusEl, player.confusionTimers, null);

            // [추가] 군주의 위엄 (스택형이 아닌 활성화 여부)
            if (player.majestyActive) {
                majestyStatus.style.display = 'flex';
            } else {
                majestyStatus.style.display = 'none';
            }

            // 보호막
            if (player.shieldStacks > 0) {
                shieldStatus.style.display = 'flex';
                shieldStacksText.innerText = player.shieldStacks;
            } else {
                shieldStatus.style.display = 'none';
            }

            // 정의의 가호
            if (player.justiceShield > 0) {
                justiceStatus.style.display = 'flex';
                justiceStacksText.innerText = player.justiceShield;
            } else {
                justiceStatus.style.display = 'none';
            }
            
            // 사악한 빛
            if (player.evilLightTimers.length > 0) evilLightStatus.style.display = 'flex';
            else evilLightStatus.style.display = 'none';
            
            // 사악한 마음 오버레이
            if (player.evilMindTimers.length > 0) {
                mindOverlay.style.opacity = Math.min(0.8, player.evilMindTimers.length * 0.1);
            } else {
                mindOverlay.style.opacity = 0;
            }
            
            updatePoopVisual();
        }

        // 이펙트 업데이트 함수 (잔상 제거용)
     function updateEffects() {
    // 똥 자국 업데이트
    for (let i = poopStains.length - 1; i >= 0; i--) {
        poopStains[i].life--;
        if (poopStains[i].life <= 0) poopStains.splice(i, 1);
    }

    // 죽음 구름 업데이트 & 플레이어 충돌 체크
    let inDeathCloudThisFrame = false;
    for (let i = deathClouds.length - 1; i >= 0; i--) {
        const cloud = deathClouds[i];
        cloud.life--;

        // ★ [최적화] 제곱 거리 비교
        const dx = player.x - cloud.x;
        const dy = player.y - cloud.y;
        const distSq = dx * dx + dy * dy;
        const hitRadius = player.radius + cloud.radius;

        if (distSq < hitRadius * hitRadius) {
            player.slowedByCloud = true;
            inDeathCloudThisFrame = true;
            takeDamage(0.0005, 'dot', cloud.accuracy);
        }

        if (cloud.life <= 0) deathClouds.splice(i, 1);
    }

    if (inDeathCloudThisFrame) {
        player.deathCloudTimer = (player.deathCloudTimer || 0) + 1;
        if (player.deathCloudTimer >= 60) {
            addStatus('evilMind', 900, 15);
            player.deathCloudTimer = 0;
        }
    } else {
        player.deathCloudTimer = 0;
    }

            // 땅 갈라짐 업데이트
            for (let i = groundCracks.length - 1; i >= 0; i--) {
                groundCracks[i].life--;
                if (groundCracks[i].life <= 0) groundCracks.splice(i, 1);
            }
        }
      function updateAndDrawDarkMatters() {
    for (let i = darkMatters.length - 1; i >= 0; i--) {
        const m = darkMatters[i];
        m.life--;

        // 유도 이동
        const targetAngle = Math.atan2(player.y - m.y, player.x - m.x);
        let angleDiff = targetAngle - m.angle;
        while (angleDiff <= -Math.PI) angleDiff += Math.PI * 2;
        while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
        m.angle += angleDiff * 0.05;
        
        m.vx = Math.cos(m.angle) * 2.0;
        m.vy = Math.sin(m.angle) * 2.0;
        m.x += m.vx;
        m.y += m.vy;

        m.gasTrailTimer++;
        if (m.gasTrailTimer >= 20) {
            spawnDarkGas(m.x, m.y, 3.0, 0.5, m.accuracy, 0, m.owner);
            m.gasTrailTimer = 0;
        }

        // ★ [최적화] 충돌 체크
        const dx = player.x - m.x;
        const dy = player.y - m.y;
        const distSq = dx * dx + dy * dy;
        const radii = player.radius + m.radius;

        if (distSq < radii * radii) {
            if (player.invincibleTimer <= 0) {
                let dmg = 38 + Math.floor(score * 0.21);
                takeDamage(dmg, 'direct', m.accuracy, m);
                player.despairTimer = 600;
                updateStatusUI();
                showPickupEffect(player.x, player.y, "절망...", false, true, "evil-purple-text");
                darkMatters.splice(i, 1);
                continue;
            }
        }

        // 수명 종료 시 폭발
        if (m.life <= 0) {
            spawnDarkGas(m.x, m.y, 2.0, 1.0, m.accuracy, 0, m.owner);
            darkMatters.splice(i, 1);
            continue;
        }

        // 그리기 로직 (기존 유지)
        ctx.save();
        ctx.translate(m.x, m.y);
        const time = Date.now() / 200;
        const hairCount = 16;
        const baseRadius = m.radius;
        ctx.strokeStyle = "#2b2b2b";
        ctx.lineWidth = 1.5;
        for (let j = 0; j < hairCount; j++) {
            let angle = (j / hairCount) * Math.PI * 2;
            let wiggle = Math.sin(time * 2 + j * 132) * 0.5;
            let sx = Math.cos(angle) * baseRadius;
            let sy = Math.sin(angle) * baseRadius;
            let hairLen = 15 + Math.sin(j * 55) * 5;
            let ex = Math.cos(angle + wiggle * 0.2) * (baseRadius + hairLen);
            let ey = Math.sin(angle + wiggle * 0.2) * (baseRadius + hairLen);
            let cp1Mod = (j % 2 === 0) ? 1 : -1;
            let cp1x = Math.cos(angle + 0.5 * cp1Mod + wiggle) * (baseRadius + hairLen * 0.4);
            let cp1y = Math.sin(angle + 0.5 * cp1Mod + wiggle) * (baseRadius + hairLen * 0.4);
            let cp2Mod = (j % 3 === 0) ? -1 : 1;
            let cp2x = Math.cos(angle - 0.5 * cp2Mod - wiggle) * (baseRadius + hairLen * 0.8);
            let cp2y = Math.sin(angle - 0.5 * cp2Mod - wiggle) * (baseRadius + hairLen * 0.8);
            ctx.beginPath();
            ctx.moveTo(sx, sy);
            ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, ex, ey);
            ctx.stroke();
        }
        const orbGrad = ctx.createRadialGradient(-m.radius * 0.3, -m.radius * 0.3, m.radius * 0.1, 0, 0, m.radius);
        orbGrad.addColorStop(0, '#555');
        orbGrad.addColorStop(0.3, '#1a1a1a');
        orbGrad.addColorStop(1, '#000000');
        ctx.fillStyle = orbGrad;
        ctx.beginPath();
        ctx.arc(0, 0, m.radius, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.save();
        ctx.beginPath();
        ctx.arc(0, 0, m.radius - 2, 0, Math.PI * 2);
        ctx.clip();
        const waveHeight = 8;
        const waterLevel = Math.sin(time) * 5; 
        ctx.fillStyle = "rgba(75, 0, 130, 0.6)"; 
        ctx.beginPath();
        ctx.moveTo(-m.radius, waterLevel);
        for(let k=-m.radius; k<=m.radius; k+=10) {
            ctx.lineTo(k, waterLevel + Math.sin(k * 0.1 + time * 5) * waveHeight);
        }
        ctx.lineTo(m.radius, m.radius);
        ctx.lineTo(-m.radius, m.radius);
        ctx.fill();
        ctx.restore();
        ctx.restore();
    }
}

      function updateAndDrawShadowGrips() {
    for (let i = shadowGrips.length - 1; i >= 0; i--) {
        const g = shadowGrips[i];
        g.x += g.vx; g.y += g.vy; g.life--;

        // 플레이어 충돌
        const dist = Math.hypot(player.x - g.x, player.y - g.y);
        if (dist < player.radius + g.radius) {
            if (player.invincibleTimer <= 0) {
                let dmg = 34 + Math.floor(score * 0.17);
                takeDamage(dmg, 'direct', g.accuracy, g);
                
                // 실명 2중첩 (방어 가능)
                if (!checkShieldBlockStatus()) addStatus('blind', 900, 2);
                if (!checkShieldBlockStatus()) addStatus('blind', 900, 2); 

                // 퀘스타 앞으로 끌고 옴
                if (g.owner && g.owner.hp > 0) {
                    player.x = g.owner.x + Math.cos(g.angle + Math.PI)*60;
                    player.y = g.owner.y + Math.sin(g.angle + Math.PI)*60;
                    showPickupEffect(player.x, player.y, "이리와♥", false, true, "choke-text");
                    
                    // 패시브: 새디즘 체크
                    const sadismCritResist = getEffectiveDefenderCritResist();
                    if (sadismCritResist <= SADISM_CRITRESIST_THRESHOLD) {
                        let heal = Math.floor(dmg * SADISM_LIFESTEAL_RATIO);
                        g.owner.hp = Math.min(g.owner.maxHp, g.owner.hp + heal);
                        showDamageText(g.owner.x, g.owner.y, "새디즘 +" + heal, false, false, "heal-text");
                        activateSadismGas(g.owner);
                    }
                }
                shadowGrips.splice(i, 1);
                continue;
            }
        }

        if (g.life <= 0) {
            shadowGrips.splice(i, 1);
            continue;
        }
        // ==========================================
        // [수정됨] 그리기: 검보라색 '주먹' + 사악한 오라
        // ==========================================
        ctx.save();
        ctx.translate(g.x, g.y);
        ctx.rotate(g.angle); // 진행 방향으로 회전

        // g.radius(피격/충돌) 기반으로 그림도 같이 스케일
        const s = (g.radius / 40);
        ctx.scale(s, s);

        const t = Date.now() / 250;

        // 1) 주변 오라(볼륨감 있는 검보라 연무)
        ctx.globalAlpha = 0.40;
        ctx.fillStyle = "rgba(35, 0, 70, 0.55)";
        ctx.shadowColor = "rgba(160, 60, 255, 0.95)";
        ctx.shadowBlur = 22;
        ctx.beginPath();
        ctx.ellipse(10, 0, 46, 28, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
        ctx.globalAlpha = 1;

        // 2) 뒤로 흐르는 꼬리(그림자 잔상)
        const trail = ctx.createLinearGradient(-75, 0, -12, 0);
        trail.addColorStop(0, "rgba(0,0,0,0)");
        trail.addColorStop(0.35, "rgba(20, 0, 30, 0.35)");
        trail.addColorStop(1, "rgba(90, 0, 140, 0.65)");
        ctx.fillStyle = trail;
        ctx.beginPath();
        ctx.ellipse(-45, 0, 34, 18, 0, 0, Math.PI * 2);
        ctx.fill();

        // 3) 주먹 본체(볼륨감: 라디얼 그라데이션)
        const bodyGrad = ctx.createRadialGradient(10, -12, 6, 14, 0, 62);
        bodyGrad.addColorStop(0, "#6b2bb8");
        bodyGrad.addColorStop(0.25, "#3a0a63");
        bodyGrad.addColorStop(0.65, "#13001f");
        bodyGrad.addColorStop(1, "#000000");

        ctx.fillStyle = bodyGrad;
        ctx.strokeStyle = "rgba(190, 90, 255, 0.20)";
        ctx.lineWidth = 2;

        // 손바닥(주먹) 실루엣: 둥근 사각형에 가까운 형태
        const x0 = -18, y0 = -22, w = 62, h = 44, r = 16;
        ctx.beginPath();
        ctx.moveTo(x0 + r, y0);
        ctx.quadraticCurveTo(x0 + w, y0, x0 + w, y0 + r);
        ctx.quadraticCurveTo(x0 + w, y0 + h, x0 + w - r, y0 + h);
        ctx.lineTo(x0 + r, y0 + h);
        ctx.quadraticCurveTo(x0, y0 + h, x0, y0 + h - r);
        ctx.lineTo(x0, y0 + r);
        ctx.quadraticCurveTo(x0, y0, x0 + r, y0);
        ctx.closePath();
        ctx.shadowColor = "rgba(70, 0, 110, 0.9)";
        ctx.shadowBlur = 18;
        ctx.fill();
        ctx.shadowBlur = 0;
        ctx.stroke();

        // 4) 너클(주먹 앞부분) - 살짝 돌출된 느낌
        const knuckleGrad = ctx.createRadialGradient(40, -16, 2, 40, -16, 16);
        knuckleGrad.addColorStop(0, "rgba(220, 170, 255, 0.55)");
        knuckleGrad.addColorStop(0.35, "rgba(120, 40, 200, 0.45)");
        knuckleGrad.addColorStop(1, "rgba(0, 0, 0, 0.85)");
        ctx.fillStyle = knuckleGrad;
        ctx.globalAlpha = 0.95;

        const kx = [28, 36, 44, 52];
        for (let n = 0; n < 4; n++) {
            ctx.beginPath();
            ctx.ellipse(kx[n], -10 + ((n % 2) ? 1.2 : 0), 8.5, 7.5, 0, 0, Math.PI * 2);
            ctx.fill();
        }
        ctx.globalAlpha = 1;

        // 5) 엄지(옆 라인) - 주먹 형태 완성
        const thumbGrad = ctx.createRadialGradient(20, 12, 2, 20, 12, 18);
        thumbGrad.addColorStop(0, "rgba(180, 90, 255, 0.45)");
        thumbGrad.addColorStop(1, "rgba(0, 0, 0, 0.9)");
        ctx.fillStyle = thumbGrad;
        ctx.beginPath();
        ctx.ellipse(18, 14, 16, 10, 0.45, 0, Math.PI * 2);
        ctx.fill();

        // 6) 하이라이트/균열 같은 사악한 무늬
        ctx.strokeStyle = "rgba(200, 120, 255, 0.55)";
        ctx.lineWidth = 1.5;
        ctx.globalAlpha = 0.65;
        ctx.beginPath();
        ctx.moveTo(6, -6);
        ctx.lineTo(26, -14);
        ctx.lineTo(36, -6);
        ctx.stroke();
        ctx.globalAlpha = 1;

        // 7) 전류 이펙트(지지직)
        if (Math.random() < 0.65) {
            ctx.strokeStyle = "rgba(190, 90, 255, 0.9)";
            ctx.shadowColor = "rgba(210, 120, 255, 0.95)";
            ctx.shadowBlur = 16;
            ctx.lineWidth = 2;
            ctx.lineCap = 'round';

            ctx.beginPath();
            const baseX = 10 + Math.sin(t) * 2;
            const baseY = Math.cos(t * 1.3) * 2;
            ctx.moveTo(baseX, baseY);
            for (let j = 0; j < 6; j++) {
                const px = baseX + 10 + j * 9 + (Math.random() - 0.5) * 6;
                const py = baseY + (Math.random() - 0.5) * 22;
                ctx.lineTo(px, py);
            }
            ctx.stroke();

            ctx.shadowBlur = 0;
        }

        ctx.restore();

    }
}

      function updateAndDrawConfessionalTotems() {
    let inAnyTotemRange = false;

    for (let i = confessionalTotems.length - 1; i >= 0; i--) {
        const t = confessionalTotems[i];
        
        // =================================================================
        // [업데이트 로직 유지] (사용자 코드 보존)
        // =================================================================
        t.life--;
        if (t.life <= 0) {
            confessionalTotems.splice(i, 1);
            continue;
        }

        // 플레이어 범위 체크
        const dist = Math.hypot(player.x - t.x, player.y - t.y);
        if (dist < t.range) {
            inAnyTotemRange = true;
            
            // 데미지 및 디버프 (0.5초마다)
            t.damageTimer++;
            if (t.damageTimer >= 30) {
                if (player.invincibleTimer <= 0) {
                    let dmg = 4 + Math.floor(score * 0.12);
                    takeDamage(dmg, 'direct', t.accuracy, t);
                    
                    // 세례 중첩 (방어 불가)
                    player.baptismStacks = Math.min(5, player.baptismStacks + 1);
                    updateStatusUI();
                    showPickupEffect(player.x, player.y, "회개하라..", false, false, "weak-text");
                }
                t.damageTimer = 0;
            }
        }

        // =================================================================
        // [그리기 로직 수정] 볼륨감 있는 마법진 + 3D 돌 질감 손 토템
        // =================================================================
        ctx.save();
        ctx.translate(t.x, t.y);
        
        const time = Date.now() / 1000;

        // -----------------------------------------------------------
        // 1. 볼륨감 있는 마법진 (Volumetric Magic Circle)
        // -----------------------------------------------------------
        // (1) 바닥 오라 (입체적인 붉은 안개)
        const pulse = 1 + Math.sin(time * 3) * 0.05;
        const areaRadius = t.range * pulse;
        
        // 중심은 투명하고 가장자리가 짙어지는 도넛형 그라데이션
        const auraGrad = ctx.createRadialGradient(0, 0, areaRadius * 0.2, 0, 0, areaRadius);
        auraGrad.addColorStop(0, "rgba(20, 0, 0, 0)");
        auraGrad.addColorStop(0.6, "rgba(60, 0, 0, 0.15)");
        auraGrad.addColorStop(0.9, "rgba(100, 0, 0, 0.4)"); // 가장자리 강조
        auraGrad.addColorStop(1, "rgba(0, 0, 0, 0)");

        ctx.fillStyle = auraGrad;
        ctx.beginPath();
        ctx.arc(0, 0, areaRadius, 0, Math.PI * 2);
        ctx.fill();

        // (2) 3D 원근감이 적용된 룬 링
        ctx.save();
        ctx.scale(1, 0.4); // Y축을 눌러서 바닥에 깔린 느낌 연출
        
        // 외곽 룬 링
        ctx.strokeStyle = "rgba(139, 0, 0, 0.8)"; // 짙은 붉은색
        ctx.lineWidth = 3;
        ctx.setLineDash([15, 10, 5, 10]); 
        ctx.lineDashOffset = time * 20; // 회전
        ctx.beginPath();
        ctx.arc(0, 0, t.range * 0.9, 0, Math.PI * 2);
        ctx.stroke();

        // 내부 링 (반대 회전)
        ctx.strokeStyle = "rgba(0, 0, 0, 0.6)"; 
        ctx.lineWidth = 2;
        ctx.setLineDash([5, 5]);
        ctx.lineDashOffset = -time * 15;
        ctx.beginPath();
        ctx.arc(0, 0, t.range * 0.6, 0, Math.PI * 2);
        ctx.stroke();
        ctx.restore(); // 스케일 복구

        // -----------------------------------------------------------
        // 2. 3D 돌 느낌의 손 토템 (Hand Shape Stone Totem)
        // -----------------------------------------------------------
        ctx.translate(0, 15); // 마법진 중심보다 약간 아래서 시작 (원근감)

        // (1) 그림자
        ctx.fillStyle = "rgba(0, 0, 0, 0.6)";
        ctx.beginPath();
        ctx.ellipse(0, 0, 25, 10, 0, 0, Math.PI * 2);
        ctx.fill();

        // (2) 돌 질감 그라데이션 (입체감의 핵심)
        // 좌측(어둠) -> 중앙(하이라이트) -> 우측(어둠)으로 빛을 받은 돌 느낌
        const stoneGrad = ctx.createLinearGradient(-25, 0, 25, 0);
        stoneGrad.addColorStop(0, "#1a1a1a");   // 암부 (아주 어두운 회색)
        stoneGrad.addColorStop(0.2, "#333333"); // 중간톤
        stoneGrad.addColorStop(0.4, "#5a5a5a"); // 명부 (하이라이트, 탁한 회색)
        stoneGrad.addColorStop(0.6, "#333333"); // 중간톤
        stoneGrad.addColorStop(1, "#0d0d0d");   // 암부

        ctx.fillStyle = stoneGrad;
        ctx.strokeStyle = "#111"; // 외곽선은 아주 진하게
        ctx.lineWidth = 1;

        // --- 손 모양 Path 그리기 (하나의 덩어리로 연결) ---
        ctx.beginPath();
        
        // 손목 (바닥)
        ctx.moveTo(-18, 0); 
        
        // 손바닥 왼쪽 라인
        ctx.quadraticCurveTo(-22, -20, -25, -35); 
        
        // [엄지] 
        ctx.quadraticCurveTo(-40, -45, -30, -55); // 끝
        ctx.quadraticCurveTo(-20, -45, -20, -35); // 안쪽
        
        // [검지]
        ctx.lineTo(-15, -45); 
        ctx.quadraticCurveTo(-18, -75, -10, -85); // 끝 (더 길게 솟음)
        ctx.quadraticCurveTo(-2, -70, 0, -45);    // 안쪽

        // [중지] (가장 높음)
        ctx.lineTo(2, -45);
        ctx.quadraticCurveTo(5, -90, 10, -95);    // 끝
        ctx.quadraticCurveTo(15, -85, 12, -45);   // 안쪽

        // [약지]
        ctx.lineTo(15, -45);
        ctx.quadraticCurveTo(22, -75, 20, -80);   // 끝
        ctx.quadraticCurveTo(18, -65, 18, -40);   // 안쪽

        // [새끼]
        ctx.lineTo(20, -38);
        ctx.quadraticCurveTo(32, -50, 35, -55);   // 끝
        ctx.quadraticCurveTo(28, -35, 22, -25);   // 안쪽
        
        // 손바닥 오른쪽 라인 -> 손목
        ctx.quadraticCurveTo(25, -10, 18, 0);
        
        // 손목 바닥 마감
        ctx.lineTo(-18, 0);
        
        ctx.fill();   // 그라데이션 채우기
        ctx.stroke(); // 외곽선

        // (3) 손바닥 중앙의 붉은 룬 (음각 느낌)
        ctx.save();
        ctx.shadowColor = "#ff0000";
        ctx.shadowBlur = 10;
        ctx.fillStyle = "rgba(200, 0, 0, 0.9)";
        ctx.font = "bold 24px serif";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        // 손바닥 중앙 좌표 쯤에 위치
        ctx.fillText("†", 0, -35);
        ctx.restore();

        // (4) 사악한 기운 (손 주변 검은 아지랑이)
        ctx.shadowBlur = 0;
        ctx.strokeStyle = "rgba(0, 0, 0, 0.3)";
        ctx.lineWidth = 2;
        ctx.beginPath();
        // 손 주변을 감싸는 불규칙한 라인
        ctx.moveTo(-20, 0);
        ctx.bezierCurveTo(-30, -20, -40, -60, -10, -90);
        ctx.moveTo(20, 0);
        ctx.bezierCurveTo(30, -20, 40, -60, 10, -90);
        ctx.stroke();

        ctx.restore();
    }

    // =================================================================
    // [업데이트 로직 유지] 범위 밖 해제
    // =================================================================
    if (!inAnyTotemRange && player.baptismStacks > 0) {
        player.baptismStacks = 0;
        updateStatusUI();
        showPickupEffect(player.x, player.y, "세례 해제", false, true);
    }
}
       function handleMaliceGasParticles() {
    for (let i = maliceGasParticles.length - 1; i >= 0; i--) {
        const p = maliceGasParticles[i];
        p.life--;
        p.size += 0.3; // 가스가 점점 퍼짐
        p.y -= 0.2;    // 가스가 살짝 위로 올라감 (기체 성질)

        if (p.life <= 0) {
            maliceGasParticles.splice(i, 1);
            continue;
        }

        ctx.save();
        ctx.translate(p.x, p.y);
        ctx.rotate(p.angle);
        
        // 갈색 더러운 가스 색상
        const alpha = p.life / 60; // 서서히 투명해짐
        ctx.fillStyle = `rgba(101, 67, 33, ${alpha * 0.6})`;
        
        ctx.beginPath();
        // 뭉게구름 모양
        ctx.arc(0, 0, p.size, 0, Math.PI * 2);
        ctx.arc(p.size * 0.6, -p.size * 0.4, p.size * 0.7, 0, Math.PI * 2);
        ctx.arc(-p.size * 0.6, -p.size * 0.4, p.size * 0.7, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.restore();
    }
}

    function handlePhantomGasParticles() {
  for (let i = phantomGasParticles.length - 1; i >= 0; i--) {
    const p = phantomGasParticles[i];
    p.life--;
    p.size += 0.35;
    p.y -= 0.15;

    if (p.life <= 0) {
      phantomGasParticles.splice(i, 1);
      continue;
    }

    ctx.save();
    ctx.translate(p.x, p.y);
    ctx.rotate(p.angle);

    const a = p.life / p.maxLife;

    // "더러운 청록 가스": 청록 + 탁한 갈색을 섞은 느낌
    // (원하면 숫자만 바꿔도 분위기 바뀜)
    ctx.fillStyle = `rgba(30, 80, 70, ${a * 0.35})`;   // 청록 탁함
    ctx.beginPath();
    ctx.arc(0, 0, p.size, 0, Math.PI * 2);
    ctx.arc(p.size * 0.6, -p.size * 0.4, p.size * 0.7, 0, Math.PI * 2);
    ctx.arc(-p.size * 0.6, -p.size * 0.4, p.size * 0.7, 0, Math.PI * 2);
    ctx.fill();

    // "때" 같은 얼룩 레이어(선택)
    ctx.fillStyle = `rgba(20, 10, 5, ${a * 0.18})`;
    ctx.beginPath();
    ctx.arc(p.size*0.2, 0, p.size*0.35, 0, Math.PI*2);
    ctx.fill();

    ctx.restore();
  }
}

    function handlePhantomSparkParticles() {
  for (let i = phantomSparkParticles.length - 1; i >= 0; i--) {
    const p = phantomSparkParticles[i];
    p.life--;
    p.x += p.vx;
    p.y += p.vy;

    if (p.life <= 0) {
      phantomSparkParticles.splice(i, 1);
      continue;
    }

    const a = p.life / p.maxLife;

    ctx.save();
    ctx.strokeStyle = `rgba(0, 206, 209, ${0.9 * a})`;
    ctx.lineWidth = p.w;
    ctx.lineJoin = "round";
    ctx.shadowColor = `rgba(0, 206, 209, ${0.8 * a})`;
    ctx.shadowBlur = 8;

    // 작은 지그재그 번개
    ctx.beginPath();
    ctx.moveTo(p.x, p.y);
    let cx = p.x, cy = p.y;
    for (let k = 0; k < 3; k++) {
      cx += (Math.random() - 0.5) * 8;
      cy += (Math.random() - 0.5) * 8;
      ctx.lineTo(cx, cy);
    }
    ctx.stroke();

    ctx.restore();
  }
}

        // [신규 이펙트] 가웨인 '잔혹한 돌진' 차지(모으기) 오오라
        function handleCruelChargeAuras() {
    // v14: 더 강한 최적화
    // - 캐시를 "저해상도(0.45x)"로 렌더 후 본화면에 확대(drawImage 1회)
    // - 캐시 갱신도 더 드물게(Stride*2) + 차지 후반(모임이 강해질수록) 연산 줄임
    // - 소용돌이/가스는 텍스처(1회 생성) 기반으로 drawImage 중심
    const stride = Math.max(2, performanceState.particleStride | 0);
    const updateEvery = Math.max(2, stride * 2); // 캐시 갱신 빈도
    const doUpdate = (frameCount % updateEvery === 0);

    for (let i = cruelChargeAuras.length - 1; i >= 0; i--) {
        const a = cruelChargeAuras[i];
        const owner = a.owner;

        if (!owner || owner.hp <= 0 || !owner.isCruelChargeCharging) {
            cruelChargeAuras.splice(i, 1);
            continue;
        }

        // 파라미터
        a.ringR = owner.radius * 2.25;
        a.ringW = Math.max(14, owner.radius * 0.52);
        a.phase = (a.phase ?? 0) + 0.06;
        a.swirlT = ((a.swirlT ?? 0) + (a.swirlSpeed ?? 0.012)) % 1;

        const coreR = Math.max(14, owner.radius * 0.65);

        // 저해상도 캐시(성능 핵심)
        const cacheScale = 0.45;
        const needSize = Math.ceil((a.ringR + a.ringW + 80) * 2);
        const needSizeLo = Math.max(64, Math.ceil(needSize * cacheScale));

        if (!a.cacheCanvas || a.cacheSize < needSize) {
            a.cacheCanvas = document.createElement('canvas');
            a.cacheCanvas.width = needSizeLo;
            a.cacheCanvas.height = needSizeLo;
            a.cacheCtx = a.cacheCanvas.getContext('2d');
            a.cacheSize = needSize;
            a.cacheScale = cacheScale;

            // 텍스처 캐시
            a.swirlTex = getCruelSpiralTex(needSizeLo);
            a.gasTex = getCruelGasBlobTex(128);
        } else if (a.cacheCanvas.width !== needSizeLo) {
            a.cacheCanvas.width = needSizeLo;
            a.cacheCanvas.height = needSizeLo;
            a.cacheCtx = a.cacheCanvas.getContext('2d');
            a.swirlTex = getCruelSpiralTex(needSizeLo);
        }

        const cctx = a.cacheCtx;
        const csz = a.cacheCanvas.width;
        const cx = csz / 2;
        const cy = csz / 2;

        // 차지 후반에 모임이 강해질수록 연산/입자 수를 줄여서 프레임 드랍 방지
        const t = Math.max(0, Math.min(1, a.swirlT));
        const late = (t > 0.65);

        // -----------------------
        // 캐시 갱신 (드물게)
        // -----------------------
        if (doUpdate) {
            cctx.clearRect(0, 0, csz, csz);

            // 합성: 빛겹침
            cctx.save();
            cctx.globalCompositeOperation = 'lighter';

            // 1) 링(가벼운 왜곡)
            const seg = late ? 14 : 20;
            const wob = late ? 0.06 : 0.09;
            cctx.lineWidth = Math.max(3, (a.ringW * 0.16) * a.cacheScale);
            cctx.strokeStyle = 'rgba(140, 0, 240, 0.35)';
            cctx.beginPath();
            for (let s = 0; s <= seg; s++) {
                const u = (Math.PI * 2) * (s / seg);
                const rr = (a.ringR * a.cacheScale) * (1 + Math.sin(a.phase * 1.4 + u * 3.0) * wob);
                const x = cx + Math.cos(u) * rr;
                const y = cy + Math.sin(u) * rr;
                if (s === 0) cctx.moveTo(x, y); else cctx.lineTo(x, y);
            }
            cctx.closePath();
            cctx.stroke();

            // 2) 중심 코어(진한 검보라)
            const coreGlowR = (coreR * 2.5) * a.cacheScale;
            const grd = cctx.createRadialGradient(cx, cy, 0, cx, cy, coreGlowR);
            grd.addColorStop(0.0, 'rgba(230, 80, 255, 0.55)');
            grd.addColorStop(0.35, 'rgba(130, 0, 240, 0.38)');
            grd.addColorStop(1.0, 'rgba(0, 0, 0, 0)');
            cctx.fillStyle = grd;
            cctx.beginPath();
            cctx.arc(cx, cy, coreGlowR, 0, Math.PI * 2);
            cctx.fill();

            // 3) 소용돌이 스트릭(텍스처 회전/스케일)
            cctx.save();
            cctx.translate(cx, cy);
            cctx.rotate(a.phase * 0.65);
            const swirlScale = 1.0 + (late ? 0.10 : 0.22);
            const drawSz = csz * swirlScale;
            cctx.globalAlpha = late ? 0.65 : 0.85;
            cctx.drawImage(a.swirlTex, -drawSz / 2, -drawSz / 2, drawSz, drawSz);
            cctx.restore();

            // 4) 가스(뿜어져나와 중심으로 흡입) — 소수만, 텍스처 기반
            const gasN = late ? 4 : 6; // keep low for perf
            for (let g = 0; g < gasN; g++) {
                const ang = a.phase * 0.9 + g * (Math.PI * 2 / gasN);
                const baseR = (a.ringR * (1.10 - t * 0.55)) * a.cacheScale;
                const gx = cx + Math.cos(ang) * baseR;
                const gy = cy + Math.sin(ang) * baseR;
                const sz = (late ? 46 : 58) * a.cacheScale;
                cctx.globalAlpha = late ? 0.32 : 0.42;
                cctx.drawImage(a.gasTex, gx - sz/2, gy - sz/2, sz, sz);

                // 흡입 스트릭 1개 (짧게)
                const tx = cx + Math.cos(ang + 0.9) * (baseR * 0.55);
                const ty = cy + Math.sin(ang + 0.9) * (baseR * 0.55);
                cctx.lineWidth = 2.2 * a.cacheScale;
                cctx.strokeStyle = 'rgba(200, 60, 255, 0.42)';
                cctx.beginPath();
                cctx.moveTo(gx, gy);
                cctx.lineTo(tx, ty);
                cctx.stroke();
            }

            // 5) 번개(하드캡, 드물게)
            if (!a.bolts) a.bolts = [];
            if (a.boltCD == null) a.boltCD = 0;
            a.boltCD--;
            const boltCap = 3;
            if (a.boltCD <= 0 && a.bolts.length < boltCap) {
                a.boltCD = late ? (10 + (Math.random() * 6)) : (7 + (Math.random() * 5));
                a.bolts.push(makeMiniBolt(owner, a.ringR * (1.05 - t * 0.35)));
            }
            for (let b = a.bolts.length - 1; b >= 0; b--) {
                const bolt = a.bolts[b];
                bolt.life--;
                if (bolt.life <= 0) { a.bolts.splice(b, 1); continue; }
                // draw bolt
                cctx.save();
                cctx.translate(cx, cy);
                cctx.rotate(a.phase * 0.25);
                cctx.globalAlpha = 0.55;
                cctx.lineWidth = 2.0 * a.cacheScale;
                cctx.strokeStyle = 'rgba(210, 80, 255, 0.28)';
                cctx.beginPath();
                for (let p = 0; p < bolt.pts.length; p++) {
                    const pt = bolt.pts[p];
                    const x = pt.x * a.cacheScale;
                    const y = pt.y * a.cacheScale;
                    if (p === 0) cctx.moveTo(x, y); else cctx.lineTo(x, y);
                }
                cctx.stroke();
                cctx.restore();
            }

            cctx.restore();
        }

        // -----------------------
        // 본화면 출력 (가벼움)
        // -----------------------
        ctx.save();
        ctx.translate(owner.x, owner.y);
        ctx.globalCompositeOperation = 'lighter';

        const drawW = a.cacheSize;
        const drawH = a.cacheSize;
        const loW = a.cacheCanvas.width;
        const loH = a.cacheCanvas.height;

        // 스케일 업 (이미지 스무딩)
        ctx.imageSmoothingEnabled = true;
        ctx.globalAlpha = 1.0;
        ctx.drawImage(a.cacheCanvas, -drawW/2, -drawH/2, drawW, drawH);

        ctx.restore();
    }
}
// ============================================================
// [신규 FX] 류온 '정의의 돌진' 차지(모으기) 이펙트
// - 검붉은빛 + 사악한 냄새날 것 같은 볼륨감 있는 방구 구름이 류온에게 모여듦
// - 가웨인의 잔혹한 돌진 오오라와 동일한 "저해상도 캐시 → drawImage 1회" 방식으로 가볍게 처리
// ============================================================
function handleJusticeChargeAuras() {
    const stride = Math.max(2, performanceState.particleStride | 0);
    const updateEvery = Math.max(2, stride * 2);
    const doUpdate = (frameCount % updateEvery === 0);

    for (let i = justiceChargeAuras.length - 1; i >= 0; i--) {
        const a = justiceChargeAuras[i];
        const owner = a.owner;

        // [확장] theme별 유지 조건
        const theme = (a.theme || 'justice');
        const isActive =
            (theme === 'justice' && owner && owner.hp > 0 && owner.chargeState === 'warmup') ||
            (theme === 'kaiSwap' && owner && owner.hp > 0 && owner.shadowSwapCharging) ||
            (theme === 'hiroAntiPassing' && owner && owner.hp > 0 && owner.antiPassingCharging);

        if (!isActive) {
            justiceChargeAuras.splice(i, 1);
            continue;
        }

        // 진행도(0~1): warmup이 90프레임(1.5초) 기준
        const totalWarmup = (a.totalWarmup || 90);
        const timerVal = (theme === 'kaiSwap') ? (owner.shadowSwapChargeTimer || 0)
            : (theme === 'hiroAntiPassing') ? (owner.antiPassingChargeTimer || 0)
            : (owner.chargeTimer || 0);
        const t = Math.max(0, Math.min(1, timerVal / totalWarmup));
        const late = (t > 0.70);
        // theme 색상 팔레트
        let ringStroke, core0, core1, core2, gasA, gasB;
        if (theme === 'hiroAntiPassing') {
            // 히로 안티 패싱: 녹갈색
            ringStroke = 'rgba(151, 171, 86, 0.33)';
            core0 = 'rgba(151, 171, 86, 0.55)';
            core1 = 'rgba(98, 86, 43, 0.42)';
            core2 = 'rgba(53, 45, 22, 0.16)';
            gasA = 'rgba(151, 171, 86, 0.40)';
            gasB = 'rgba(98, 86, 43, 0.22)';
        } else if (theme === 'kaiSwap') {
            // 카이 그림자 스왑: 원래 연분홍 테마
            ringStroke = 'rgba(255, 105, 180, 0.33)';
            core0 = 'rgba(255, 182, 193, 0.55)';
            core1 = 'rgba(255, 105, 180, 0.42)';
            core2 = 'rgba(140, 0, 70, 0.15)';
            gasA = 'rgba(255, 105, 180, 0.40)';
            gasB = 'rgba(255, 182, 193, 0.20)';
        } else {
            // 류온 정의의 돌진: 기본 검붉은 테마
            ringStroke = 'rgba(170, 10, 10, 0.33)';
            core0 = 'rgba(255, 90, 70, 0.55)';
            core1 = 'rgba(170, 10, 10, 0.42)';
            core2 = 'rgba(60, 0, 0, 0.15)';
            gasA = 'rgba(120, 0, 0, 0.40)';
            gasB = 'rgba(255, 90, 70, 0.20)';
        }



        // 파라미터
        a.ringR = owner.radius * 2.15;
        a.ringW = Math.max(14, owner.radius * 0.55);
        a.phase = (a.phase ?? 0) + 0.075;
        a.swirlT = ((a.swirlT ?? 0) + (a.swirlSpeed ?? 0.018)) % 1;

        const coreR = Math.max(14, owner.radius * 0.70);

        // 저해상도 캐시
        const cacheScale = 0.45;
        const needSize = Math.ceil((a.ringR + a.ringW + 90) * 2);
        const needSizeLo = Math.max(64, Math.ceil(needSize * cacheScale));

        if (!a.cacheCanvas || a.cacheSize < needSize) {
            a.cacheCanvas = document.createElement('canvas');
            a.cacheCanvas.width = needSizeLo;
            a.cacheCanvas.height = needSizeLo;
            a.cacheCtx = a.cacheCanvas.getContext('2d');
            a.cacheSize = needSize;
            a.cacheScale = cacheScale;

            // 텍스처
            a.swirlTex = getJusticeSpiralTex(needSizeLo);
            a.gasTex = getJusticeGasBlobTex(128);
        } else if (a.cacheCanvas.width !== needSizeLo) {
            a.cacheCanvas.width = needSizeLo;
            a.cacheCanvas.height = needSizeLo;
            a.cacheCtx = a.cacheCanvas.getContext('2d');
            a.swirlTex = getJusticeSpiralTex(needSizeLo);
        }

        const cctx = a.cacheCtx;
        const csz = a.cacheCanvas.width;
        const cx = csz / 2, cy = csz / 2;

        // -----------------------
        // 캐시 갱신(드물게)
        // -----------------------
        if (doUpdate) {
            cctx.clearRect(0, 0, csz, csz);

            cctx.save();
            cctx.globalCompositeOperation = 'lighter';

            // 1) 링 (검붉은 테두리)
            const seg = late ? 14 : 20;
            const wob = late ? 0.05 : 0.085;
            cctx.lineWidth = Math.max(3, (a.ringW * 0.16) * a.cacheScale);
            cctx.strokeStyle = ringStroke;
            cctx.beginPath();
            for (let s = 0; s <= seg; s++) {
                const u = (Math.PI * 2) * (s / seg);
                const rr = (a.ringR * a.cacheScale) * (1 + Math.sin(a.phase * 1.35 + u * 3.0) * wob);
                const x = cx + Math.cos(u) * rr;
                const y = cy + Math.sin(u) * rr;
                if (s === 0) cctx.moveTo(x, y); else cctx.lineTo(x, y);
            }
            cctx.closePath();
            cctx.stroke();

            // 2) 중심 코어 (검붉은 맥동)
            const coreGlowR = (coreR * 2.7) * a.cacheScale;
            const grd = cctx.createRadialGradient(cx, cy, 0, cx, cy, coreGlowR);
            grd.addColorStop(0.0, core0);
            grd.addColorStop(0.22, core1);
            grd.addColorStop(0.52, core2);
            grd.addColorStop(1.0, 'rgba(0, 0, 0, 0)');
            cctx.fillStyle = grd;
            cctx.beginPath();
            cctx.arc(cx, cy, coreGlowR, 0, Math.PI * 2);
            cctx.fill();

            // 3) 소용돌이(텍스처)
            cctx.save();
            cctx.translate(cx, cy);
            cctx.rotate(a.phase * 0.70 + a.swirlT * 1.35);
            const swirlScale = 1.0 + (late ? 0.07 : 0.18);
            const drawSz = csz * swirlScale;
            cctx.globalAlpha = late ? 0.75 : 0.92;
            cctx.drawImage(a.swirlTex, -drawSz / 2, -drawSz / 2, drawSz, drawSz);
            cctx.restore();

            // 4) 가스(덩어리) — 바깥에서 시작해서 점점 중심으로 모이기
            const gasN = late ? 5 : 7;
            for (let g = 0; g < gasN; g++) {
                const ang = a.phase * 0.85 + g * (Math.PI * 2 / gasN);
                const baseR = (a.ringR * (1.18 - t * 0.72)) * a.cacheScale;

                const gx = cx + Math.cos(ang) * baseR;
                const gy = cy + Math.sin(ang) * baseR;

                const sz = (late ? 54 : 66) * a.cacheScale;
                cctx.globalAlpha = late ? 0.34 : 0.46;
                cctx.drawImage(a.gasTex, gx - sz / 2, gy - sz / 2, sz, sz);

                // 흡입 스트릭(짧게)
                const tx = cx + Math.cos(ang + 0.85) * (baseR * 0.55);
                const ty = cy + Math.sin(ang + 0.85) * (baseR * 0.55);
                cctx.lineWidth = 2.1 * a.cacheScale;
                cctx.strokeStyle = (theme === 'kaiSwap') ? 'rgba(255, 182, 193, 0.36)' : 'rgba(255, 90, 70, 0.36)';
                cctx.beginPath();
                cctx.moveTo(gx, gy);
                cctx.lineTo(tx, ty);
                cctx.stroke();
            }

            cctx.restore();

            // 5) 암부(냄새나는 어둠 느낌) — 소스오버로 살짝 눌러주기
            cctx.save();
            cctx.globalCompositeOperation = 'source-over';
            cctx.globalAlpha = 0.10 + t * 0.14;
            cctx.fillStyle = 'rgba(0, 0, 0, 0.35)';
            cctx.beginPath();
            cctx.arc(cx, cy, (coreR * 1.20) * a.cacheScale, 0, Math.PI * 2);
            cctx.fill();
            cctx.restore();
        }

        // -----------------------
        // 본 화면에 그리기(1회 drawImage)
        // -----------------------
        const drawW = a.cacheCanvas.width / a.cacheScale;
        const drawH = a.cacheCanvas.height / a.cacheScale;

        ctx.save();
        ctx.translate(owner.x, owner.y);
        ctx.globalCompositeOperation = 'lighter';
        ctx.globalAlpha = 0.92;

        ctx.imageSmoothingEnabled = true;
        ctx.drawImage(a.cacheCanvas, -drawW / 2, -drawH / 2, drawW, drawH);

        ctx.restore();
    }
}


// --- 텍스처 생성(1회 캐시) ---
const _cruelSpiralTexCache = new Map();
function getCruelSpiralTex(size) {
    const key = size | 0;
    if (_cruelSpiralTexCache.has(key)) return _cruelSpiralTexCache.get(key);
    const c = document.createElement('canvas');
    c.width = key; c.height = key;
    const cctx = c.getContext('2d');
    const cx = key/2, cy = key/2;

    cctx.clearRect(0,0,key,key);
    cctx.globalCompositeOperation = 'lighter';

    // 여러 개의 곡선 스트릭을 "한 번만" 그려 텍스처화
    const lines = 26;
    for (let i=0;i<lines;i++){
        const baseA = (Math.PI*2) * (i/lines);
        const turns = 2.4;
        const maxR = key*0.46;
        cctx.beginPath();
        for (let s=0;s<=24;s++){
            const tt = s/24;
            const a = baseA + tt*turns + Math.sin((i*9.7)+tt*6.0)*0.08;
            const r = maxR*(1-tt*0.88) + Math.sin(tt*10 + i)*4;
            const x = cx + Math.cos(a)*r;
            const y = cy + Math.sin(a)*r;
            if (s===0) cctx.moveTo(x,y); else cctx.lineTo(x,y);
        }
        cctx.lineWidth = 1.5 + Math.random()*1.4;
        cctx.strokeStyle = `rgba(190, 40, 255, ${0.10 + Math.random()*0.10})`;
        cctx.stroke();
    }

    // 중심 암부(검보라 느낌)
    const grd = cctx.createRadialGradient(cx,cy,0,cx,cy,key*0.35);
    grd.addColorStop(0,'rgba(40,0,60,0.25)');
    grd.addColorStop(1,'rgba(0,0,0,0)');
    cctx.fillStyle = grd;
    cctx.beginPath();
    cctx.arc(cx,cy,key*0.35,0,Math.PI*2);
    cctx.fill();

    _cruelSpiralTexCache.set(key, c);
    return c;
}

let _cruelGasBlobTex = null;
function getCruelGasBlobTex(size) {
    if (_cruelGasBlobTex) return _cruelGasBlobTex;
    const c = document.createElement('canvas');
    c.width = size; c.height = size;
    const cctx = c.getContext('2d');
    const cx = size/2, cy = size/2;

    // 부드러운 가스 블롭 1개 (캐시)
    const g = cctx.createRadialGradient(cx,cy,0,cx,cy,size*0.5);
    g.addColorStop(0.0,'rgba(230, 80, 255, 0.55)');
    g.addColorStop(0.35,'rgba(120, 0, 240, 0.38)');
    g.addColorStop(1.0,'rgba(0, 0, 0, 0)');
    cctx.fillStyle = g;
    cctx.beginPath();
    cctx.arc(cx,cy,size*0.5,0,Math.PI*2);
    
    // 추가: '방구 구름' 느낌의 덩어리(한 번만 그려서 캐시) — 성능 영향 거의 없음
    cctx.globalCompositeOperation = 'lighter';
    for (let k = 0; k < 6; k++) {
        const a = Math.random() * Math.PI * 2;
        const r = (size * 0.12) + Math.random() * (size * 0.18);
        const px = cx + Math.cos(a) * r;
        const py = cy + Math.sin(a) * r;
        const rr = (size * 0.10) + Math.random() * (size * 0.12);
        const gg = cctx.createRadialGradient(px, py, 0, px, py, rr);
        gg.addColorStop(0.0, 'rgba(180, 20, 255, 0.22)');
        gg.addColorStop(1.0, 'rgba(0, 0, 0, 0)');
        cctx.fillStyle = gg;
        cctx.beginPath();
        cctx.arc(px, py, rr, 0, Math.PI * 2);
        cctx.fill();
    }
cctx.fill();

    _cruelGasBlobTex = c;
    return c;
}



// --- [류온 정의의 돌진 차지 이펙트] 텍스처 생성(1회 캐시) ---
const _justiceSpiralTexCache = new Map();
function getJusticeSpiralTex(size) {
    const key = size | 0;
    if (_justiceSpiralTexCache.has(key)) return _justiceSpiralTexCache.get(key);

    const c = document.createElement('canvas');
    c.width = key; c.height = key;
    const cctx = c.getContext('2d');
    const cx = key / 2, cy = key / 2;

    cctx.clearRect(0, 0, key, key);
    cctx.globalCompositeOperation = 'lighter';

    // 검붉은 소용돌이 스트릭
    const lines = 26;
    for (let i = 0; i < lines; i++) {
        const baseA = (Math.PI * 2) * (i / lines);
        const turns = 2.35;
        const maxR = key * 0.46;

        cctx.beginPath();
        for (let s = 0; s <= 24; s++) {
            const tt = s / 24;
            const a = baseA + tt * turns + Math.sin((i * 9.2) + tt * 6.2) * 0.08;
            const r = maxR * (1 - tt * 0.88) + Math.sin(tt * 10 + i) * 4;
            const x = cx + Math.cos(a) * r;
            const y = cy + Math.sin(a) * r;
            if (s === 0) cctx.moveTo(x, y); else cctx.lineTo(x, y);
        }

        cctx.lineWidth = 1.5 + Math.random() * 1.4;
        cctx.strokeStyle = `rgba(255, 70, 60, ${0.08 + Math.random() * 0.10})`;
        cctx.stroke();
    }

    // 중심 암부(검붉은/검정)
    const grd = cctx.createRadialGradient(cx, cy, 0, cx, cy, key * 0.35);
    grd.addColorStop(0, 'rgba(60, 0, 0, 0.28)');
    grd.addColorStop(1, 'rgba(0, 0, 0, 0)');
    cctx.fillStyle = grd;
    cctx.beginPath();
    cctx.arc(cx, cy, key * 0.35, 0, Math.PI * 2);
    cctx.fill();

    _justiceSpiralTexCache.set(key, c);
    return c;
}

let _justiceGasBlobTex = null;
function getJusticeGasBlobTex(size) {
    if (_justiceGasBlobTex) return _justiceGasBlobTex;

    const c = document.createElement('canvas');
    c.width = size; c.height = size;
    const cctx = c.getContext('2d');
    const cx = size / 2, cy = size / 2;

    // 부드러운 검붉은 가스 블롭(캐시)
    const g = cctx.createRadialGradient(cx, cy, 0, cx, cy, size * 0.52);
    g.addColorStop(0.0, 'rgba(255, 90, 70, 0.52)');
    g.addColorStop(0.34, 'rgba(170, 10, 10, 0.36)');
    g.addColorStop(0.62, 'rgba(55, 0, 0, 0.22)');
    g.addColorStop(1.0, 'rgba(0, 0, 0, 0)');
    cctx.fillStyle = g;
    cctx.beginPath();
    cctx.arc(cx, cy, size * 0.52, 0, Math.PI * 2);

    // 덩어리(볼륨감): 냄새나는 "방구 구름" 텍스처
    cctx.globalCompositeOperation = 'lighter';
    for (let k = 0; k < 7; k++) {
        const a = Math.random() * Math.PI * 2;
        const r = (size * 0.12) + Math.random() * (size * 0.20);
        const px = cx + Math.cos(a) * r;
        const py = cy + Math.sin(a) * r;
        const rr = (size * 0.10) + Math.random() * (size * 0.14);

        const gg = cctx.createRadialGradient(px, py, 0, px, py, rr);
        gg.addColorStop(0.0, 'rgba(255, 60, 60, 0.18)');
        gg.addColorStop(0.55, 'rgba(90, 0, 0, 0.10)');
        gg.addColorStop(1.0, 'rgba(0, 0, 0, 0)');

        cctx.fillStyle = gg;
        cctx.beginPath();
        cctx.arc(px, py, rr, 0, Math.PI * 2);
        cctx.fill();
    }

    cctx.fill();

    _justiceGasBlobTex = c;
    return c;
}
function makeMiniBolt(owner, radius) {
    const pts = [];
    const seg = 6 + (Math.random()*3)|0;
    const baseA = Math.random()*Math.PI*2;
    const baseR = Math.max(30, radius*0.55);
    for (let i=0;i<seg;i++){
        const t = i/(seg-1);
        const a = baseA + t*0.7 + (Math.random()-0.5)*0.35;
        const r = baseR*(1-t*0.75) + (Math.random()-0.5)*14;
        pts.push({x: Math.cos(a)*r, y: Math.sin(a)*r});
    }
    return {pts, life: 14};
}

        // ---- [캐시 캔버스] 중심 코어 / 링 ----
        const cruelChargeFxCache = { core: new Map(), ring: new Map(), gas: new Map() };

        function getCruelChargeCoreCanvas(r) {
            const key = r;
            if (cruelChargeFxCache.core.has(key)) return cruelChargeFxCache.core.get(key);

            const s = r * 4;
            const c = document.createElement('canvas');
            c.width = s; c.height = s;
            const g = c.getContext('2d');

            const cx = s / 2, cy = s / 2;

            // 외곽 글로우
            const grad = g.createRadialGradient(cx, cy, r * 0.2, cx, cy, r * 1.8);
            grad.addColorStop(0.0, 'rgba(255,220,255,0.55)');
            grad.addColorStop(0.25, 'rgba(190,80,255,0.55)');
            grad.addColorStop(0.55, 'rgba(110,20,180,0.25)');
            grad.addColorStop(1.0, 'rgba(0,0,0,0)');
            g.fillStyle = grad;
            g.beginPath();
            g.arc(cx, cy, r * 1.8, 0, Math.PI * 2);
            g.fill();

            // 중심 코어(작은 진한 구체)
            const grad2 = g.createRadialGradient(cx, cy, 0, cx, cy, r * 0.75);
            grad2.addColorStop(0.0, 'rgba(255,240,255,0.85)');
            grad2.addColorStop(0.4, 'rgba(210,120,255,0.75)');
            grad2.addColorStop(1.0, 'rgba(120,20,180,0.0)');
            g.fillStyle = grad2;
            g.beginPath();
            g.arc(cx, cy, r * 0.75, 0, Math.PI * 2);
            g.fill();

            cruelChargeFxCache.core.set(key, c);
            return c;
        }

        function getCruelChargeRingCanvas(ringR, ringW) {
            const key = ringR + 'x' + ringW;
            if (cruelChargeFxCache.ring.has(key)) return cruelChargeFxCache.ring.get(key);

            const s = Math.round((ringR + ringW) * 2.2);
            const c = document.createElement('canvas');
            c.width = s; c.height = s;
            const g = c.getContext('2d');
            const cx = s / 2, cy = s / 2;

            // 링 기본(그라데이션)
            g.globalCompositeOperation = 'source-over';
            g.lineCap = 'round';

            // 여러 겹으로 얇게 그려서 "왜곡 링"처럼
            for (let k = 0; k < 4; k++) {
                const w = Math.max(2, ringW * (0.22 - k * 0.035));
                g.lineWidth = w;
                const a = 0.18 - k * 0.03;
                g.strokeStyle = `rgba(180, 70, 255, ${Math.max(0.05, a)})`;
                g.beginPath();
                g.arc(cx, cy, ringR + (k - 1.5) * 2, 0, Math.PI * 2);
                g.stroke();
            }

            // 링에 짧은 스트릭(소용돌이/왜곡 느낌) - 개수 하드캡
            const streakN = 14;
            for (let i = 0; i < streakN; i++) {
                const ang = (i / streakN) * Math.PI * 2 + (Math.random() - 0.5) * 0.25;
                const r0 = ringR + (Math.random() - 0.5) * ringW * 0.45;
                const r1 = r0 - (10 + Math.random() * 18);
                g.lineWidth = 1.6;
                g.strokeStyle = `rgba(255, 220, 255, ${0.18 + Math.random() * 0.12})`;
                g.beginPath();
                g.moveTo(cx + Math.cos(ang) * r0, cy + Math.sin(ang) * r0);
                g.lineTo(cx + Math.cos(ang + 0.12) * r1, cy + Math.sin(ang + 0.12) * r1);
                g.stroke();
            }

            cruelChargeFxCache.ring.set(key, c);
            return c;
        }

        function getCruelChargeGasCanvas(sz) {
            const key = sz;
            if (cruelChargeFxCache.gas.has(key)) return cruelChargeFxCache.gas.get(key);

            const s = Math.max(32, Math.round(sz));
            const c = document.createElement('canvas');
            c.width = s; c.height = s;
            const g = c.getContext('2d');
            const cx = s / 2, cy = s / 2;

            const grad = g.createRadialGradient(cx, cy, 1, cx, cy, s * 0.48);
            grad.addColorStop(0.0, 'rgba(190, 60, 255, 0.55)');
            grad.addColorStop(0.35, 'rgba(110, 0, 200, 0.35)');
            grad.addColorStop(1.0, 'rgba(0, 0, 0, 0.0)');
            g.fillStyle = grad;
            g.beginPath();
            g.arc(cx, cy, s * 0.48, 0, Math.PI * 2);
            g.fill();

            g.globalCompositeOperation = 'lighter';
            for (let i = 0; i < 5; i++) {
                const rr = s * (0.10 + Math.random() * 0.14);
                const ax = cx + (Math.random() - 0.5) * s * 0.30;
                const ay = cy + (Math.random() - 0.5) * s * 0.30;
                const a = 0.10 + Math.random() * 0.14;
                g.fillStyle = `rgba(150, 0, 220, ${a})`;
                g.beginPath();
                g.arc(ax, ay, rr, 0, Math.PI * 2);
                g.fill();
            }

            cruelChargeFxCache.gas.set(key, c);
            return c;
        }


        function spawnCruelChargeAura(enemy) {
            // 성능 옵션(프레임 스트라이드) 반영
            const doFx = frameCount % performanceState.particleStride === 0;
            if (!doFx) return;

            // 이미 컨트롤러가 있으면 수명만 갱신
            for (let i = 0; i < cruelChargeAuras.length; i++) {
                const a = cruelChargeAuras[i];
                if (a && a.type === 'controller' && a.owner === enemy) {
                    a.life = a.maxLife; // 유지
                    return;
                }
            }

            // [컨트롤러 1개] 가웨인 1명당 1개의 오오라만 유지 (프레임드랍 방지)
            cruelChargeAuras.push({
                type: 'controller',
                owner: enemy,
                life: 999999,      // 오너 상태로 관리(죽으면 제거)
                maxLife: 999999,
                phase: Math.random() * Math.PI * 2,
                ringR: enemy.radius * 2.25,
                ringW: Math.max(18, enemy.radius * 0.55),
                // 소용돌이 스트릭(파티클 대신 절약형)
                swirlT: Math.random(),
                swirlSpeed: 0.028 + Math.random() * 0.01,
                streakAngles: Array.from({ length: 16 }, (_, k) => (Math.PI * 2 * k / 16) + (Math.random() - 0.5) * 0.35),
                streakOffsets: Array.from({ length: 16 }, () => Math.random()),
                boltCD: 0,
                bolts: [],
                gases: [],
                gasCD: 0,
            });
        }


function spawnJusticeChargeAura(enemy, theme = 'justice') {
    // 성능 옵션(프레임 스트라이드) 반영
    const doFx = frameCount % performanceState.particleStride === 0;
    if (!doFx) return;

    // 이미 컨트롤러가 있으면 유지 (owner + theme 기준)
    for (let i = 0; i < justiceChargeAuras.length; i++) {
        const a = justiceChargeAuras[i];
        if (a && a.type === 'controller' && a.owner === enemy && (a.theme || 'justice') === theme) {
            a.life = a.maxLife;
            return;
        }
    }

    // 1명당 theme별 1개만 유지
    const totalWarmup = (theme === 'kaiSwap') ? 240 : (theme === 'hiroAntiPassing') ? (enemy.antiPassingChargeMax || 360) : 90;

    justiceChargeAuras.push({
        type: 'controller',
        theme: theme,
        owner: enemy,
        life: 999999,
        maxLife: 999999,
        phase: Math.random() * Math.PI * 2,
        ringR: enemy.radius * 2.15,
        ringW: Math.max(18, enemy.radius * 0.55),
        swirlT: Math.random(),
        swirlSpeed: 0.020 + Math.random() * 0.010,
        totalWarmup: totalWarmup,
    });
}


    function updateAndDrawPhantomSwords() {
  for (let i = phantomSwords.length - 1; i >= 0; i--) {
    const s = phantomSwords[i];

    // 주인이 죽으면 제거
    if (!s.owner || s.owner.hp <= 0) {
      phantomSwords.splice(i, 1);
      continue;
    }

    // 1. 대기 상태 (주인 주변 회전)
    if (s.state === 'hover') {
      const orbitSpeed = Date.now() / 500;
      const offsetX = Math.cos(orbitSpeed + (s.index * 2.09)) * 60;
      const offsetY = Math.sin(orbitSpeed + (s.index * 2.09)) * 60;
      const targetX = s.owner.x + offsetX;
      const targetY = s.owner.y + offsetY;

      s.x += (targetX - s.x) * 0.1;
      s.y += (targetY - s.y) * 0.1;
      s.angle = Math.atan2(s.y - s.owner.y, s.x - s.owner.x);

      // ★ [최적화] 발사 감지 거리 체크 (400px)
      const dx = player.x - s.owner.x;
      const dy = player.y - s.owner.y;
      if (dx * dx + dy * dy < 160000) { // 400 * 400
        s.state = 'fire';
        const fireAngle = Math.atan2(player.y - s.y, player.x - s.x);
        s.vx = Math.cos(fireAngle) * 12;
        s.vy = Math.sin(fireAngle) * 12;
        s.angle = fireAngle;
      }
    }

    // 2. 발사 상태
    else if (s.state === 'fire') {
      s.x += s.vx;
      s.y += s.vy;
      s.life--;

      const backX = s.x - s.vx * 0.6;
      const backY = s.y - s.vy * 0.6;
      // (1) 더러운 가스: 1~2개씩
      const gasCount = 1 + (Math.random() < 0.35 ? 1 : 0);
      for (let g = 0; g < gasCount; g++) {
        phantomGasParticles.push({
           x: backX + (Math.random() - 0.5) * 10,
           y: backY + (Math.random() - 0.5) * 10,
           vx: (Math.random() - 0.5) * 0.6,
           vy: (Math.random() - 0.5) * 0.6,
           size: (3 + Math.random() * 4) * (s.size ?? 1),
           life: 28 + Math.floor(Math.random() * 10),
           maxLife: 38
          });
       }

         // (2) 전류 스파크: 너무 많으면 시끄러우니 확률로
       if (Math.random() < 0.6) {
       phantomSparkParticles.push({
          x: backX + (Math.random() - 0.5) * 6,
          y: backY + (Math.random() - 0.5) * 6,
          vx: (Math.random() - 0.5) * 1.8 - s.vx * 0.05,
          vy: (Math.random() - 0.5) * 1.8 - s.vy * 0.05,
          life: 10 + Math.floor(Math.random() * 8),
          maxLife: 18,
         // 번쩍이는 길이/굵기 느낌용
          len: 10 + Math.random() * 12,
          w: 1 + Math.random() * 1.5
        });
      }

      if (s.life <= 0 || s.x < -100 || s.x > canvas.width + 100) {
        phantomSwords.splice(i, 1);
        continue;
      }

      // ★ [최적화] 충돌 체크 (검 크기 약 20) + size 반영
      const dx = player.x - s.x;
      const dy = player.y - s.y;
      const sc = (s.size ?? 1);
      const hitR = 20 * sc;
      const distSq = dx * dx + dy * dy;

      if (distSq < hitR * hitR) {
        if (player.invincibleTimer <= 0) {
          let dmg = 20 + Math.floor(score * 0.19);
          if (s.owner.nextAttackCrit) {
            dmg *= 1.5;
            s.owner.nextAttackCrit = false;
            showPickupEffect(player.x, player.y, "치명상!", false, true, "masakuni-text");
          }
          takeDamage(dmg, 'direct', s.owner.accuracy, s.owner);
          for (let k = 0; k < 2; k++) addStatus('bleeding', 600, 20);
          showPickupEffect(player.x, player.y, "환영의 검..", false, true, "bleeding-border");
          phantomSwords.splice(i, 1);
          continue;
        }
      }
    }

    // 3. 그리기 로직 (size 반영)
    ctx.save();
    ctx.translate(s.x, s.y);
    ctx.rotate(s.angle);

    const drawSc = (s.size ?? 1);
    ctx.scale(drawSc, drawSc);

    ctx.shadowColor = "#00CED1";
    ctx.shadowBlur = 10;

    ctx.beginPath();
    ctx.moveTo(0, -25);
    ctx.lineTo(5, 5);
    ctx.lineTo(0, 10);
    ctx.lineTo(-5, 5);
    ctx.closePath();

    ctx.fillStyle = "black";
    ctx.fill();

    ctx.strokeStyle = "#2F4F4F";
    ctx.lineWidth = 2;
    ctx.stroke();

    ctx.restore();
  }

  // 4. 사후 정리 로직 (기존 유지)
  if (phantomSwords.length > 0) {
    phantomSwords = phantomSwords.filter(s => s.owner && s.owner.hp > 0);
    enemies.forEach(e => {
      if (e.isMasakuni && phantomSwords.filter(s => s.owner === e).length === 0) {
        e.phantomSwordsActive = false;
      }
    });
  }
}

function animate() {
    // 1. 게임 실행 여부 및 일시정지 체크
    if (!isGameRunning) return;
    if (isLevelUpPaused) return;

    // 2. 시간(dt) 계산
    const now = Date.now();
    let dt = now - lastTime;
    lastTime = now;
    if (dt > 100) dt = 1000 / 60; // 렉 방지

    // [프레임 보정] 60fps 기준 dt 스케일 (유도/진동 등에 사용)
    frameDt = dt;
    frameDtScale = dt / (1000 / 60);
    if (frameDtScale < 0.25) frameDtScale = 0.25;
    if (frameDtScale > 2.5) frameDtScale = 2.5;

    updatePerformanceState();
    const doEffects = frameCount % performanceState.effectsStride === 0;
    const doParticles = frameCount % performanceState.particleStride === 0;
    const doProjectiles = frameCount % performanceState.projectileStride === 0;

    // 3. 일반 적(Zako) 생성 타이머 (일반 적은 자주 나오므로 dt로 계속 계산)
    enemyTimer += dt;
    let spawnInterval = Math.max(1000, 2500 - (score * 2.5));
    spawnInterval *= performanceState.enemySpawnMultiplier;
    if (enemyTimer >= spawnInterval) {
        spawnEnemy(false); // 일반 적 소환
        enemyTimer = 0;    // 타이머 리셋
    }

    // 4. 프레임 증가
    frameCount++;
     
   // 5. [핵심] 1초마다 점수 증가 및 엘리트/보스 스폰 체크
if (now - lastScoreTime >= 1000) {
    score++;
    scoreVal.innerText = score;
    lastScoreTime = now;

    // (1) 마사쿠니: 점수가 50의 배수일 때 (50, 100, 150...) [25 -> 50 변경]
  if (score % 50 === 0) {
                const bossExists = enemies.some(e => e.isBoss && e.hp > 0);
                if (!bossExists) {
                    const rand = Math.random();
                    // 4등분하여 25% 확률로 각각 소환
                    if (rand < 0.25) {
                        spawnMasakuni();
                    } else if (rand < 0.50) {
                        spawnKaito();
                    } else if (rand < 0.75) {
                        spawnQuesta();
                    } else {
                        spawnTetora(); // [추가] 테토라 등장
                    }
                }
            }
    // (2) 보스 빌런: 점수가 90의 배수일 때
    if (score % 90 === 0) {
        spawnBoss();
    }
    // (3) 엘리트 빌런: 15의 배수이면서, 50의 배수(마사쿠니)는 아닐 때
    else if (score % 15 === 0 && score % 50 !== 0) {
        const cainExists = enemies.some(e => e.isBoss && !e.isArchdemon);
        if (!cainExists) {
            for (let i = 0; i < 2; i++) { spawnEnemy(true); }
        }
    }
}

            updatePlayer();
            updateGeoptalHeal();
            
            updateGases();
            updateDarkGases();
            
            updatePoops();
            updateBigPoops();
            updateDarkBigPoops();
            updateDarkWaves();
            updatePleasureZones();
            updatePheromoneMarkers();
            updateHollowNight();
            updateBloodBats();
            updateBloodPuddles();
            updateShockwaves();
            updatePinkGases();
            updateSadismGasEmitters();
            updateSadismBrownGases();
            updateDarkNotes();
            updatePianissimoSnipes();
            updatePrismSweeps();
            updateOcclusionSpools();
            updateBlackMoons();
            updateMaliceBallistics();
            updateDeathMetalNotes();
            updateDarknessSpotlights();
            updatePlayerBleeding(); // 도트뎀 및 상태이상 시간 감소
            updateEffects(); 
            updateFloatingTexts();
            // 기타 투사체 업데이트 통합 처리
            const projectiles = [
                { arr: homingSemens, baseDmg: 8, status: 'semen' }, 
                { arr: darkSemens, baseDmg: 11, status: 'darkSemens' }, 
                { arr: whiteshots, baseDmg: 6, status: null }, 
                { arr: darkHearts, baseDmg: 15, status: 'curse' }, 
                { arr: mindSkulls, baseDmg: 11, status: 'evilMind' },
            ];

            if (doProjectiles) {
                projectiles.forEach(type => {
                    for (let i = type.arr.length - 1; i >= 0; i--) {
                        const p = type.arr[i];
                        
                        if (p.isHoming) {
                             const angle = Math.atan2(player.y - p.y, player.x - p.x);
                             const speed = p.speed || 3;
                             p.vx = Math.cos(angle) * speed;
                             p.vy = Math.sin(angle) * speed;
                        }
                        
                        p.x += p.vx; p.y += p.vy; p.life--;

                        if (type.arr === darkSemens) {
                            p.stickyTrailTimer = (p.stickyTrailTimer || 0) + 1;
                            if (p.owner && p.owner.isBoss && p.owner.bossType === 2 && p.stickyTrailTimer >= 12) {
                                stickyCreamPuddles.push({ x: p.x, y: p.y, radius: 36, life: 240 });
                                p.stickyTrailTimer = 0;
                            }
                        }
                        
                        if (p.life <= 0 || p.x < -200 || p.x > canvas.width + 200 || p.y < -200 || p.y > canvas.height + 200) {
                            type.arr.splice(i, 1);
                            continue;
                        }
                        
                        const dx = player.x - p.x;
                        const dy = player.y - p.y;
                        const distSq = dx * dx + dy * dy; // 현재 거리의 제곱
                        const radii = player.radius + p.radius; // 충돌 범위 합
                        if (distSq < radii * radii) {
                        if (player.invincibleTimer > 0) continue;
                            
                            let damage = 0;
                            if (p.isLucaShot) {
                            damage = 38 + Math.floor(score * 0.22);
                            if (!checkShieldBlockStatus()) addStatus('blind', 900, 1);
                            showPickupEffect(player.x, player.y, "크헉!", false, true, "sniper-text");
                } else {
                            damage = type.baseDmg + Math.floor(score * 0.17);
                }
                            takeDamage(damage, 'direct', p.accuracy, p);

                            if (type.status === 'evilMind') {
                                 addStatus('evilMind', 900, 15);
                                 showPickupEffect(player.x, player.y, "정신 오염♥", false, true, "mind-break-text");
                            } else if (type.status === 'darkReceiver') {
                                 addStatus('darkReceiver', 900, 10);
                                 showPickupEffect(player.x, player.y, "타락한 사랑♥", false, true, "pink-text");
                            } else if (type.status === 'curse') {
                                 addStatus('curse', 900, 10); // 15초(900프레임) 지속, 최대 10중첩
                                 showPickupEffect(player.x, player.y, "저주..", false, true, "curse-border");
                            } else if (type.status === 'semen') {
                                if (!checkShieldBlockStatus()) addStatus('semen', 900, 30);
                            } else if (type.status === 'darkSemens') {
                                if (!checkShieldBlockStatus()) {
                                    addStatus('darkReceiver', 900, 20);
                                    addStatus('darkSeed', 900, 20);
                                }
                            } else if (type.status === 'darkness') {
                                    addStatus('darkness', 360, 1); // 6초 암흑
                                    showPickupEffect(player.x, player.y, "앞이 안보여!", false, true, "darkness-border");
                            } else if (p.isLucaShot) {
                                // [수정] 보호막 체크 제거 (루카의 실명 탄환은 막을 수 없음)
                                addStatus('blind', 900, 10);
                            }
                            
                            type.arr.splice(i, 1);
                        }
                    }
                });
            }
            
            updateDragShots();
            updateEvilArrows();
            updatePoisonousShots();
            updateExcaliburSlashes();
            updateSlashTrails();
            updateJammingWaves();
            updateNeuroNeedles();
            updateAntiPassingTentacles();
            updateChaosOrbs();
            updateGhosts();
            updateItems();
            updateEnemies();
            updateMovingGases();
            updateStickyCreamPuddles();
            updateExplosions();

            // [최적화] 판데모니움 업데이트 (유도 및 단발성 피해)
    for (let i = pandemoniums.length - 1; i >= 0; i--) {
        const p = pandemoniums[i];
        const angle = Math.atan2(player.y - p.y, player.x - p.x);
        p.vx = Math.cos(angle) * p.speed;
        p.vy = Math.sin(angle) * p.speed;
        p.x += p.vx;
        p.y += p.vy;
        p.life--;

        if (p.life <= 0) {
            pandemoniums.splice(i, 1);
            continue;
        }

        // ★ [최적화] 제곱 거리 계산
        const dx = player.x - p.x;
        const dy = player.y - p.y;
        const distSq = dx * dx + dy * dy;
        const radii = player.radius + p.radius;

        if (distSq < radii * radii) {
            if (player.invincibleTimer <= 0) {
                let dmg = 26 + Math.floor(score * 0.21);
                takeDamage(dmg, 'direct', p.accuracy, p);
                for(let k=0; k<3; k++) {
                    addStatus('gnawingLife', 1800, 5);
                }
                showPickupEffect(player.x, player.y, "생명이 좀먹힌다..", false, true, "poop-text");
                pandemoniums.splice(i, 1);
            }
        }
    }

            draw();
            updateAndDrawBlinkMines();
            updateAndDrawBlackHolyBloods();
            updateAndDrawCursedCatastrophes();
            updateAndDrawSoulHarvestSlashes();
            updateAndDrawPhantomSwords();
            if (doParticles) {
                handlePhantomGasParticles();
                handlePhantomSparkParticles();
                handleCruelChargeAuras();
                handleJusticeChargeAuras();
            }
            updateAndDrawDarkMatters();
            updateAndDrawConfessionalTotems();
            updateAndDrawShadowGrips();
            if (doEffects) {
                drawBlackMoons();
                drawMovingGases();
                drawStickyCreamPuddles();
                drawExplosions();
                drawMaliceBallistics();
                drawTetoraEffects();
            }
            if (doParticles) {
                handleMaliceGasParticles();
            }
            if (tetoraRequiemActive) {
            // 새빨간 오버레이 (bloodOverlay 재활용 또는 tint)
            // 여기서는 bloodOverlay를 약하게 적용
            if (bloodOverlay.style.opacity < 0.7) bloodOverlay.style.opacity = 0.7;
        } else {
             // 다른 효과가 없을 때만 0으로 (기존 로직과 충돌 주의)
             // 군주의 위엄(majesty), 더럽혀진 피(corruptedBlood), 페로몬 오버로드(pheromone)가 없을 때만 끄기
             if (!player.majestyActive && player.corruptedBloodTimers.length === 0 && player.pheromoneOverloadTimer <= 0) {
                 bloodOverlay.style.opacity = 0;
             }
        }
        
        // [최적화] 데미지 오버레이 감쇠(히트당 setTimeout 제거)
        if (damageFlashOpacity > 0.001) {
            if (damageFlashDirty) {
                damageOverlay.style.background = `radial-gradient(circle, transparent 50%, rgba(${damageFlashColor}, ${damageFlashAlpha}) 100%)`;
                damageFlashDirty = false;
            }
            damageOverlay.style.opacity = damageFlashOpacity;
            damageFlashOpacity *= DAMAGE_FLASH_DECAY;
        } else {
            if (damageOverlay.style.opacity !== '0') damageOverlay.style.opacity = 0;
            damageFlashOpacity = 0;
        }

        // 광시곡 오버레이 (mindOverlay 재활용 - 보라색)
        if (tetoraRhapsodyActive) {
             mindOverlay.style.opacity = 0.7;
        } else {
             mindOverlay.style.opacity = 0;
        }
        // 매 프레임 초기화 (테토라가 없으면 꺼지도록)
        tetoraRequiemActive = false;
        tetoraRhapsodyActive = false;
            animationId = requestAnimationFrame(animate);
        }
        // [신규] 악의의 탄도 생성 함수
    function spawnMaliceBallistic(x, y, angle, accuracy, owner = null) {
        // 팬(부채꼴) 발사 후 유도 구간에서 "불규칙한" 탄도를 만들기 위해
        // 투사체마다 다른 웨이브(부드러운 요동) 파라미터를 부여
        const seed = Math.random() * 1000;
        maliceBallistics.push({
            x: x, y: y,
            vx: Math.cos(angle) * 5,
            vy: Math.sin(angle) * 5,
            angle: angle,
            life: 360, // 6초 지속
            accuracy: accuracy,
            owner: owner,

            // 불규칙 탄도 파라미터(부드러운 요동 + 느린 랜덤 드리프트)
            wobbleSeed: seed,
            wobblePhase: Math.random() * Math.PI * 2,
            wobbleDrift: 0, // 프레임마다 천천히 변하는 랜덤값(필터링)
            wobbleFreq1: 0.12 + Math.random() * 0.10,
            wobbleFreq2: 0.04 + Math.random() * 0.06,
            wobbleAmpFar: 0.52 + Math.random() * 0.06, // 멀 때(라디안)
            wobbleAmpNear: 0.36 + Math.random() * 0.04, // 가까울 때(라디안)

            // 속도 변동
            speedBase: 5.0 + Math.random() * 1.2,
            speedAmp:  2.0 + Math.random() * 1.8,

            trailInterval: 0
        });
    }

   function updateMaliceBallistics() {
        for (let i = maliceBallistics.length - 1; i >= 0; i--) {
            const b = maliceBallistics[i];
            b.life--;

            // 1. 방구 가스 생성 (3프레임마다 하나씩 흔적을 남김)
            if (frameCount % 3 === 0) {
                maliceGasParticles.push({
                    x: b.x + (Math.random() - 0.5) * 20,
                    y: b.y + (Math.random() - 0.5) * 20,
                    life: 50 + Math.random() * 20,
                    size: 10 + Math.random() * 10,
                    angle: Math.random() * Math.PI * 2
                });
            }

            // 2. 이동 로직 (유도 + 불규칙 탄도)
            const targetAngle = Math.atan2(player.y - b.y, player.x - b.x);
            const distToPlayer = Math.hypot(player.x - b.x, player.y - b.y);

            // 주사율/프레임 영향 완화용(60fps 기준 스케일)
            const dtScale = (typeof frameDtScale === 'number' ? frameDtScale : 1);
            const t60 = frameCount * dtScale; // 60fps 기준 시간축

            // --- (A) 불규칙 탄도: "부드러운" 요동 + 느린 랜덤 드리프트 ---
            // 랜덤 드리프트는 저역통과 필터로 부드럽게(불규칙하지만 지터는 최소)
            b.wobbleDrift = (b.wobbleDrift ?? 0) * 0.98 + (Math.random() - 0.5) * 0.02;
            b.wobblePhase += b.wobbleDrift * dtScale;

            // 거리 기반 요동 강도(가까울수록 조금 줄이되 0으로 만들지 않음)
            const near = 140;
            const far  = 420;
            const k = Math.max(0, Math.min(1, (distToPlayer - near) / (far - near))); // 0(근접)~1(원거리)
            const wobbleAmp = (b.wobbleAmpNear ?? 0.10) + ((b.wobbleAmpFar ?? 0.20) - (b.wobbleAmpNear ?? 0.10)) * k;

            const f1 = (b.wobbleFreq1 ?? 0.16);
            const f2 = (b.wobbleFreq2 ?? 0.06);
            const wobble =
                Math.sin(t60 * f1 + (b.wobblePhase ?? 0)) +
                0.6 * Math.sin(t60 * f2 + (b.wobbleSeed ?? 0));

            // 목표각에 요동을 섞어서 "유도는 되지만 곧장 직진하지 않게"
            const wobbleNearStart = 180; // 이 거리부터 감쇠 시작
            const wobbleMinMul = 0.70;   // 근접 최소 배율(= 30% 감소)
            const wobbleMul = (distToPlayer < wobbleNearStart)
            ? (wobbleMinMul + (1 - wobbleMinMul) * (distToPlayer / wobbleNearStart))
            : 1;  
            const desiredAngle = targetAngle + wobble * wobbleAmp * 0.5 * wobbleMul;
            // --- (B) 유도: 프레임당 최대 회전량으로 clamp (근접 급유도 방지) ---
            let maxTurn = 0.05;   // 60fps 기준
            if (distToPlayer < 220) {
                maxTurn = 0.035;   // 근접에서는 더 완만하게(하지만 요동은 유지)
            }

            let angleDiff = desiredAngle - b.angle;
            while (angleDiff <= -Math.PI) angleDiff += Math.PI * 2;
            while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;

            const turnStep = Math.max(-maxTurn * dtScale, Math.min(maxTurn * dtScale, angleDiff));
            b.angle += turnStep;

            // --- (C) 속도 변동(기존의 '카오스' 느낌 유지) ---
            const speedBase = (b.speedBase ?? 7);
            const speedAmp  = (b.speedAmp ?? 3);
            const speedVariation = speedBase + Math.sin(t60 * 0.22 + (b.wobbleSeed ?? 0)) * speedAmp;

            b.vx = Math.cos(b.angle) * speedVariation;
            b.vy = Math.sin(b.angle) * speedVariation;

            b.x += b.vx;
            b.y += b.vy;

            // 3. 화면 밖 제거
            if (b.life <= 0 || b.x < -100 || b.x > canvas.width + 100 || b.y < -100 || b.y > canvas.height + 100) {
                maliceBallistics.splice(i, 1);
                continue;
            }

            // 4. 충돌 처리
            const dx = player.x - b.x;
            const dy = player.y - b.y;
            const distSq = dx * dx + dy * dy;

            if (distSq < (player.radius + 25) ** 2) {
                if (player.invincibleTimer <= 0) {
                    let dmg = 11 + Math.floor(score * 0.12);
                    takeDamage(dmg, 'direct', b.accuracy, b);
                    // [변경] 피격 디버프: 저주 / 좀먹는 생명 중 1개 랜덤
                    const _maliceDebuff = (Math.random() < 0.5) ? 'curse' : 'gnawingLife';
                    if (_maliceDebuff === 'curse') {
                        addStatus('curse', 900, 10); // 15초, 최대 10중첩 (원하는 값으로 조정 가능)
                        showPickupEffect(player.x, player.y, "저주..", false, true, "curse-border");
                    } else {
                        addStatus('gnawingLife', 1800, 10); // 30초, 최대 10중첩 (원하는 값으로 조정 가능)
                        showPickupEffect(player.x, player.y, "좀먹힌다..", false, true, "gnawing-life-border");
                    }
                    maliceBallistics.splice(i, 1);
                    continue;
                }
            }
        }
    }


        // [신규] 악의의 탄도 그리기 전용 함수
       function drawMaliceBallistics() {
        maliceBallistics.forEach(b => {
        ctx.save();
        ctx.translate(b.x, b.y);
        ctx.rotate(Math.atan2(b.vy, b.vx) + Math.PI / 2);

        // 1. 검보라색 전류 효과 (지지직거림)
        ctx.strokeStyle = "#8A2BE2"; // 보라색 전류
        ctx.lineWidth = 2;
        ctx.lineJoin = "round";
        ctx.beginPath();
        for(let k=0; k<3; k++) { // 전류 줄기 3개
            let startX = (Math.random() - 0.5) * 10;
            let startY = (Math.random() - 0.5) * 10;
            ctx.moveTo(startX, startY);
            ctx.lineTo(startX + (Math.random()-0.5)*50, startY + (Math.random()-0.5)*50);
        }
        ctx.stroke();

        // 2. 검보라색 악마 본체
        // 몸통 (어두운 보라색)
        ctx.fillStyle = "#240046"; 
        ctx.beginPath();
        ctx.arc(0, 0, 22, 0, Math.PI * 2);
        ctx.fill();
        
        // 테두리 (밝은 보라색)
        ctx.strokeStyle = "#4B0082";
        ctx.lineWidth = 3;
        ctx.stroke();

        // 뿔 (검정)
        ctx.fillStyle = "black";
        ctx.beginPath();
        ctx.moveTo(-15, -10); ctx.lineTo(-25, -25); ctx.lineTo(-5, -18);
        ctx.moveTo(15, -10); ctx.lineTo(25, -25); ctx.lineTo(5, -18);
        ctx.fill();

        // 눈 (형광 보라/빨강 - 사악함 강조)
        ctx.fillStyle = "#FF0055";
        ctx.beginPath();
        // 왼쪽 눈 (화난 눈매)
        ctx.moveTo(-15, -5); ctx.lineTo(-5, 2); ctx.lineTo(-15, 5);
        // 오른쪽 눈
        ctx.moveTo(15, -5); ctx.lineTo(5, 2); ctx.lineTo(15, 5);
        ctx.fill();

        // 입 (찢어진 웃음)
        ctx.strokeStyle = "black";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(0, 8, 10, 0, Math.PI, false);
        ctx.stroke();
        
        // 이빨
        ctx.fillStyle = "#E0E0E0";
        ctx.beginPath();
        ctx.moveTo(-8, 8); ctx.lineTo(-5, 13); ctx.lineTo(-2, 8);
        ctx.moveTo(2, 8); ctx.lineTo(5, 13); ctx.lineTo(8, 8);
        ctx.fill();

        ctx.restore();
    });
}

        function spawnBlinkMines(startX, startY, count, owner = null, accuracy = 0) {
    for(let i=0; i<count; i++) {
        // 맵 랜덤 위치 (화면 안쪽 50px 여유)
        const mx = 50 + Math.random() * (canvas.width - 100);
        const my = 50 + Math.random() * (canvas.height - 100);
        
        blinkMines.push({
            x: mx, 
            y: my,
            radius: 50,
            life: 600,  // 10초 (60fps 기준)
            maxLife: 480,
            accuracy: accuracy,
            owner: owner,
        });
    }
    // 스킬 시전 이펙트
   showPickupEffect(startX, startY - 50, "지뢰조심♥", false, true, "pink-text");
}

      function updateAndDrawBlackHolyBloods() {
    for (let i = blackHolyBloods.length - 1; i >= 0; i--) {
        const b = blackHolyBloods[i];
        b.life--;

        // 1. 유도 로직 (각도 계산은 필수이므로 유지)
        const targetAngle = Math.atan2(player.y - b.y, player.x - b.x);
        let angleDiff = targetAngle - b.angle;
        while (angleDiff <= -Math.PI) angleDiff += Math.PI * 2;
        while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
        b.angle += angleDiff * b.homingPower;

        b.x += Math.cos(b.angle) * b.speed;
        b.y += Math.sin(b.angle) * b.speed;

        if (b.life <= 0) {
            blackHolyBloods.splice(i, 1);
            continue;
        }

        // ★ [최적화] 제곱 거리 계산
        const dx = player.x - b.x;
        const dy = player.y - b.y;
        const distSq = dx * dx + dy * dy;
        const radii = player.radius + b.radius;

        if (distSq < radii * radii) {
            if (player.invincibleTimer <= 0) {
                let dmg = 12 + Math.floor(score * 0.13);
                player.serumContaminationTimers.push(480); // 8초
                // [PATCH] 히로 '검은 성혈' 피격 시 악의의 바이러스(말리스) 3중첩
                for (let k = 0; k < 3; k++) { if (!checkShieldBlockStatus()) addStatus('malice', 900, 20); }

                updateStatusUI();
                showPickupEffect(player.x, player.y, "혈청 오염!", false, true, "corrupted-text");
                takeDamage(dmg, 'direct', b.accuracy, b);
                blackHolyBloods.splice(i, 1);
                continue;
            }
        }

        // 3. 그리기 로직 (기존 유지)
        ctx.save();
        ctx.translate(b.x, b.y);
        ctx.rotate(b.angle);
        
        const spikes = 10;
        const outerRadius = b.radius;
        const innerRadius = b.radius * 0.75;
        const grd = ctx.createRadialGradient(0, 0, innerRadius * 0.3, 0, 0, outerRadius);
        grd.addColorStop(0, '#8B0000');
        grd.addColorStop(0.6, '#4B0082');
        grd.addColorStop(1, '#000000');

        ctx.beginPath();
        for (let j = 0; j <= spikes * 2; j++) {
            const r = (j % 2 === 0) ? outerRadius : innerRadius;
            const wobble = Math.sin(frameCount * 0.2 + b.wobbleOffset + j) * 2;
            const currAngle = (Math.PI * j / spikes);
            const px = Math.cos(currAngle) * (r + wobble);
            const py = Math.sin(currAngle) * (r + wobble);
            if (j === 0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
        }
        ctx.closePath();
        ctx.fillStyle = grd;
        ctx.fill();
        ctx.strokeStyle = '#8A2BE2';
        ctx.lineWidth = 1.5;
        ctx.stroke();

        ctx.fillStyle = '#9400D3';
        for (let j = 0; j < spikes; j++) {
            const currAngle = (Math.PI * j * 2 / spikes) + (frameCount * 0.05);
            const knobDist = outerRadius * 0.9;
            const kx = Math.cos(currAngle) * knobDist;
            const ky = Math.sin(currAngle) * knobDist;
            ctx.beginPath();
            ctx.arc(kx, ky, 3.5, 0, Math.PI * 2);
            ctx.fill();
        }
        ctx.restore();
    }
}

function updateAndDrawBlinkMines() {
    for (let i = blinkMines.length - 1; i >= 0; i--) {
        const m = blinkMines[i];
        m.life--;

        if (m.life <= 0) {
            blinkMines.splice(i, 1);
            continue;
        }

        // ★ [최적화] 제곱 거리 비교
        const dx = player.x - m.x;
        const dy = player.y - m.y;
        const distSq = dx * dx + dy * dy;
        const hitRadius = m.radius + player.radius; // 지뢰 범위 + 플레이어

        // 밟았을 때
        if (distSq < hitRadius * hitRadius) {
            explosions.push({
                x: m.x, y: m.y,
                radius: 100, // 폭발 범위
                life: 30,
                damage: 20 + Math.floor(score * 0.19),
                accuracy: m.accuracy,
                owner: m.owner,
                hasHit: false
            });
            blinkMines.splice(i, 1);
            continue;
        }

        // [수정됨] 그리기 로직: 볼륨감 있는 검정 올챙이 + 끈적한 검정 연유
        ctx.save();
        ctx.translate(m.x, m.y);

        const time = Date.now() / 150; // 애니메이션 속도
        
        // ★ [신규] 깜빡임 효과 (투명도 0.5 ~ 1.0 반복)
        // Math.sin을 사용하여 시간에 따라 투명도가 변하게 함
        const blinkAlpha = 0.75 + 0.25 * Math.sin(Date.now() / 100); 
        ctx.globalAlpha = blinkAlpha;

        // 1. 끈적한 검정 연유 (바닥에 뿌려짐)
        // ★ [신규] 지뢰의 좌표(x, y)를 시드로 사용하여 매번 다른 불규칙한 모양 생성
        // 좌표가 고정되어 있으므로 모양이 계속 변하지 않고(떨리지 않고) 고유한 형태를 유지함
        const seed = m.x * 0.13 + m.y * 0.27; 
        
        const puddles = [
            { ang: 0 + (seed % 1.5), dist: 25, r: 20 },
            { ang: 2.1 + (seed % 2.5), dist: 30, r: 16 },
            { ang: 4.2 + (seed % 3.5), dist: 22, r: 24 }
        ];

        puddles.forEach((p, idx) => {
            const px = Math.cos(p.ang) * p.dist;
            const py = Math.sin(p.ang) * p.dist;
            
            ctx.beginPath();
            
            // ★ 원형 대신 불규칙한 다각형(Blob)으로 액체 표현
            const vertexCount = 10; // 꼭지점 개수
            for (let k = 0; k <= vertexCount; k++) {
                const a = (k / vertexCount) * Math.PI * 2;
                // 각도와 시드값을 조합하여 반지름을 불규칙하게 변형
                // idx를 더해 웅덩이마다 다른 모양이 나오게 함
                const noise = Math.sin(a * 3 + seed + idx) * 5 + Math.cos(a * 2 + idx) * 3;
                
                // 액체가 살아있는 것처럼 아주 살짝 꿈틀거리게 (time 요소 추가)
                const breathing = Math.sin(time + idx) * 2;
                
                const r = p.r + noise + breathing;
                
                const vx = px + Math.cos(a) * r;
                const vy = py + Math.sin(a) * r;
                
                if (k === 0) ctx.moveTo(vx, vy);
                else ctx.lineTo(vx, vy);
            }
            
            ctx.closePath();
            // 색상: 반투명한 검정 (검정 연유)
            ctx.fillStyle = "rgba(10, 10, 10, 0.85)"; 
            ctx.fill();

            // 연유 광택 (하이라이트) - 젖은 질감 표현
            // 하이라이트 위치도 시드값에 따라 약간 이동
            ctx.fillStyle = "rgba(255, 255, 255, 0.15)";
            ctx.beginPath();
            const hx = px - 4 + Math.cos(seed * 2) * 3;
            const hy = py - 4 + Math.sin(seed * 2) * 3;
            ctx.ellipse(hx, hy, 6, 3, 0.5, 0, Math.PI * 2);
            ctx.fill();
        });

        // 2. 검정 올챙이 본체 (중앙)
        // 전체적으로 살짝 회전하며 꿈틀거리는 느낌
        ctx.rotate(Math.sin(time * 0.5) * 0.1); 

        // 머리 (Head) - 볼륨감 있는 그라데이션
        const headR = 22;
        // 빛이 왼쪽 상단에서 오는 듯한 방사형 그라데이션
        const grad = ctx.createRadialGradient(-6, -6, 4, 0, 0, headR);
        grad.addColorStop(0, "#444");   // 하이라이트 (진회색)
        grad.addColorStop(0.4, "#111"); // 본체 (거의 검정)
        grad.addColorStop(1, "#000");   // 그림자 (완전 검정)

        ctx.fillStyle = grad;
        ctx.beginPath();
        // 머리 모양 (약간 납작한 타원)
        ctx.ellipse(0, 0, headR, headR * 0.85, 0, 0, Math.PI * 2);
        ctx.fill();

        // 꼬리 (Tail) - 베지에 곡선으로 꾸물거림 표현
        const tailWiggle = Math.sin(time * 2) * 15; // 꼬리 흔들림 폭
        
        ctx.beginPath();
        ctx.moveTo(headR * 0.6, 0); // 머리 뒤쪽에서 시작
        // 제어점을 흔들어서 S자 곡선 애니메이션 생성
        ctx.quadraticCurveTo(headR + 10, tailWiggle, headR + 35, tailWiggle * 0.5);
        
        // 꼬리 스타일 (검정색)
        ctx.strokeStyle = "#000";
        ctx.lineWidth = 9;
        ctx.lineCap = "round";
        ctx.stroke();

        // 꼬리 윗부분 하이라이트 (입체감 추가)
        ctx.strokeStyle = "#333";
        ctx.lineWidth = 2;
        ctx.stroke();

        // 눈 (작고 빨간 눈으로 위협적인 느낌)
        ctx.fillStyle = "#FF0000";
        ctx.shadowColor = "#FF0000";
        ctx.shadowBlur = 6; // 붉은 안광
        ctx.beginPath();
        ctx.arc(8, -8, 3, 0, Math.PI*2); // 오른쪽 눈
        ctx.arc(8, 8, 3, 0, Math.PI*2);  // 왼쪽 눈 (회전했으므로 좌표 조정)
        ctx.fill();
        ctx.shadowBlur = 0; // 그림자 효과 초기화

        ctx.restore();
    }
}
   function drawTetoraEffects() {
            // 스포트라이트 그리기
            darknessSpotlights.forEach(spot => {
                ctx.save();
                ctx.translate(spot.x, spot.y);
                ctx.setLineDash([]);
                ctx.lineDashOffset = 0;

                const time = Date.now() / 300; // 애니메이션 시간

                // 1. [볼륨감] 반구형 돔 그라데이션 (가웨인 성역 스타일)
                // 사악한 검보라색 테마
                const domeGrad = ctx.createRadialGradient(0, 0, spot.radius * 0.2, 0, 0, spot.radius);
                domeGrad.addColorStop(0, 'rgba(10, 0, 10, 0.1)');      // 중심부 투명
                domeGrad.addColorStop(0.6, 'rgba(40, 0, 60, 0.3)');    // 중간: 어두운 보라
                domeGrad.addColorStop(0.9, 'rgba(20, 0, 40, 0.7)');    // 외곽: 짙은 남보라
                domeGrad.addColorStop(1, 'rgba(75, 0, 130, 0.5)');     // 테두리: 인디고

                ctx.fillStyle = domeGrad;
                ctx.beginPath();
                ctx.arc(0, 0, spot.radius, 0, Math.PI * 2);
                ctx.fill();

                // 2. [사악한 전류] 볼륨감 있는 검보라색 전류
                // 선 사이사이에 배치하기 위해 여러 겹으로 그림
                const electricityLayers = 5;
                
                ctx.shadowBlur = 15;
                ctx.shadowColor = "#800080"; // Purple Glow
                ctx.lineCap = 'round';

                for(let i=0; i<electricityLayers; i++) {
                    ctx.beginPath();
                    // 레이어마다 색상 농도 조절
                    if(i % 2 === 0) ctx.strokeStyle = "rgba(48, 0, 48, 0.8)"; // 아주 어두운 보라
                    else ctx.strokeStyle = "rgba(75, 0, 130, 0.6)"; // 인디고

                    ctx.lineWidth = 3 + Math.random() * 2; // 두께 불규칙

                    // 스포트라이트 내부를 가로지르는 지그재그 선
                    const startAngle = (Math.PI * 2 * i / electricityLayers) + time;
                    let lx = Math.cos(startAngle) * (spot.radius * 0.2);
                    let ly = Math.sin(startAngle) * (spot.radius * 0.2);
                    ctx.moveTo(lx, ly);

                    // 바깥쪽으로 뻗어나가는 전류
                    for(let j=0; j<6; j++) {
                        const dist = (spot.radius / 6) * j;
                        const angleNoise = (Math.random() - 0.5) * 1.5; // 각도 흔들림
                        
                        lx += Math.cos(startAngle + angleNoise) * 20;
                        ly += Math.sin(startAngle + angleNoise) * 20;
                        
                        ctx.lineTo(lx, ly);
                    }
                    ctx.stroke();
                }
                ctx.shadowBlur = 0; // 초기화

                // 3. [음표] 선 사이사이에 떠다니는 밝은 보라색 음표들
                ctx.fillStyle = "#E0B0FF"; // Mauve (밝은 보라)
                ctx.font = "bold 24px Arial";
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.shadowColor = "#FFFFFF"; // 흰색 글로우로 밝게 표현
                ctx.shadowBlur = 5;

                const noteCount = 12;
                const noteSymbols = ["♪", "♫", "♬", "♩"];

                for(let k=0; k<noteCount; k++) {
                    // 궤도 회전 애니메이션
                    const noteAngle = (k / noteCount * Math.PI * 2) - time * 0.5;
                    // 안팎으로 부유하는 움직임
                    const floatDist = (spot.radius * 0.4) + Math.sin(time * 2 + k) * (spot.radius * 0.3);
                    
                    const nx = Math.cos(noteAngle) * floatDist;
                    const ny = Math.sin(noteAngle) * floatDist;

                    // 흔들림 추가
                    const wobbleX = Math.cos(time * 3 + k) * 5;
                    const wobbleY = Math.sin(time * 3 + k) * 5;

                    const symbol = noteSymbols[k % noteSymbols.length];
                    
                    ctx.fillText(symbol, nx + wobbleX, ny + wobbleY);
                }
                ctx.shadowBlur = 0;

                // 4. [테두리] 회전하는 마법진 링
                ctx.save();
                ctx.rotate(time * 0.2);
                ctx.strokeStyle = "#9370DB"; // MediumPurple
                ctx.lineWidth = 3;
                ctx.setLineDash([20, 15, 5, 15]); // 룬 문자 느낌의 점선
                ctx.beginPath();
                ctx.arc(0, 0, spot.radius, 0, Math.PI*2);
                ctx.stroke();
                ctx.restore();
                
                ctx.restore();
            });

            // 데스메탈 음표 그리기
            deathMetalNotes.forEach(note => {
                ctx.save();
                ctx.translate(note.x, note.y);


                // [수정] note.radius(=히트박스 반경)에 비례해서 화면에서도 같이 커지도록 스케일 적용
                // 기존 데스메탈 음표 도형은 픽셀 단위로 하드코딩되어 있어 radius를 바꿔도 화면 크기는 안 변했음
                const dmBaseVisualR = 120; // 기존 도형 기준 '시각적 반경' (대략값)
                const dmR = (note.radius || dmBaseVisualR);
                const dmScale = dmR / dmBaseVisualR;
                ctx.scale(dmScale, dmScale);

                // 1. [전류 이펙트] 사악한 검보라색 지지직 거리는 효과
                // 음표 주변으로 불규칙하게 뻗어나가는 전기
                ctx.shadowBlur = 15 * dmScale;
                ctx.shadowColor = "#9400D3"; // DarkViolet Glow (네온 광채)
                ctx.strokeStyle = "#6A00FF"; // Deep Purple (전류 색상)
                ctx.lineWidth = 2;
                ctx.lineCap = 'round';
                
                // 랜덤한 번개 줄기 3개 생성
                for (let k = 0; k < 3; k++) {
                    ctx.beginPath();
                    // 음표 중심에서 약간 떨어진 곳에서 시작
                    let lx = (Math.random() - 0.5) * 10;
                    let ly = (Math.random() - 0.5) * 10;
                    ctx.moveTo(lx, ly);
                    
                    // 지그재그 선 그리기 (3단계)
                    for (let j = 0; j < 3; j++) {
                        lx += (Math.random() - 0.5) * 25; // X축으로 불규칙하게 튐
                        ly += (Math.random() - 0.5) * 25; // Y축으로 불규칙하게 튐
                        ctx.lineTo(lx, ly);
                    }
                    ctx.stroke();
                }

                // 2. [음표 머리] 볼륨감 있는 구체 (Radial Gradient)
                ctx.shadowBlur = 0; // 본체는 선명하게
                
                // 빛이 왼쪽 상단에서 오는 듯한 입체감
                const headGrad = ctx.createRadialGradient(-3, 7, 2, 0, 10, 12);
                headGrad.addColorStop(0, "#D8BFD8");   // 하이라이트 (Thistle - 밝은 보라)
                headGrad.addColorStop(0.3, "#9370DB"); // 중간톤 (MediumPurple)
                headGrad.addColorStop(1, "#190033");   // 그림자 (아주 어두운 보라/검정)
                
                ctx.fillStyle = headGrad;
                ctx.beginPath();
                ctx.arc(0, 10, 11, 0, Math.PI*2); // 머리
                ctx.fill();

                // 3. [음표 기둥 & 꼬리] 입체감 있는 기둥 (Linear Gradient)
                const stemGrad = ctx.createLinearGradient(6, 0, 14, 0);
                stemGrad.addColorStop(0, "#AB82FF");   // 밝은 면
                stemGrad.addColorStop(0.5, "#4B0082"); // 중간 면
                stemGrad.addColorStop(1, "#000000");   // 어두운 면

                ctx.fillStyle = stemGrad;
                
                // 기둥 (Stem)
                ctx.beginPath();
                ctx.moveTo(8, -15);
                ctx.lineTo(12, -15);
                ctx.lineTo(12, 10);
                ctx.lineTo(8, 10);
                ctx.fill();

                // 꼬리 (Flag) - 곡선으로 부드럽게 표현
                ctx.beginPath();
                ctx.moveTo(12, -15);
                ctx.quadraticCurveTo(24, -5, 24, 5); // 둥근 꼬리
                ctx.lineTo(12, -5); // 안쪽 라인
                ctx.fill();

                ctx.restore();
            });
        }
   
function updateAndDrawCursedCatastrophes() {
    const stride = (performanceState && performanceState.particleStride) ? performanceState.particleStride : 1;
    const timeKey = Math.floor(Date.now() / (83 * stride)); // 12fps 캐시 버킷(성능에 따라 더 느리게)

    for (let i = cursedCatastrophes.length - 1; i >= 0; i--) {
        let p = cursedCatastrophes[i];

        const dtScale = (typeof frameDtScale === 'number' ? frameDtScale : 1);
        const outerR = Math.max(15, (p.radius ?? 30));
        const coreR  = outerR * 0.5;

        p.life--;
        if (p.life <= 0) {
            cursedCatastrophes.splice(i, 1);
            continue;
        }

        // 1. 유도 로직 (플레이어 쪽으로 방향 전환)
        let angleToPlayer = Math.atan2(player.y - p.y, player.x - p.x);

        // 현재 이동 각도
        let currentAngle = Math.atan2(p.vy, p.vx);

        // 각도 차이 계산 (최단 경로)
        let angleDiff = angleToPlayer - currentAngle;
        while (angleDiff <= -Math.PI) angleDiff += Math.PI * 2;
        while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;

        // 유도 성능만큼 회전
        let turnRate = 0.04 * dtScale; // 유도 성능 (dt 보정)
        if (Math.abs(angleDiff) < turnRate) {
            currentAngle = angleToPlayer;
        } else {
            currentAngle += (angleDiff > 0) ? turnRate : -turnRate;
        }

        // 속도 갱신
        let speed = Math.sqrt(p.vx * p.vx + p.vy * p.vy);
        p.vx = Math.cos(currentAngle) * speed;
        p.vy = Math.sin(currentAngle) * speed;

        // 위치 이동
        p.x += p.vx;
        p.y += p.vy;

        // 화면 밖으로 너무 멀어지면 제거 (메모리 관리)
        if (p.x < -200 || p.x > canvas.width + 200 || p.y < -200 || p.y > canvas.height + 200) {
            cursedCatastrophes.splice(i, 1);
            continue;
        }

        // 2. 충돌 판정
        let dist = Math.hypot(p.x - player.x, p.y - player.y);
        const hitR = Math.max(25, coreR * 0.9);
        if (dist < hitR) {
            let damage = 22 + Math.floor(score * 0.17);
            takeDamage(damage, "cursed_catastrophe");

            // 디버프 '죽음의 낙인' 부여 (10초)
            addStatus('deathBrand', 600, 1);

            showPickupEffect(p.x, p.y, "☠️", false, true, "evil-text");
            cursedCatastrophes.splice(i, 1);
            continue;
        }

        // 3. 그리기 - [OPT] 스프라이트 캐시 사용(색감 유지 + 연산 감소)
        const spr = getCursedCatastropheSprite(outerR, timeKey, stride);
        ctx.drawImage(spr.canvas, p.x - spr.w / 2, p.y - spr.h / 2);
    }
}



function updateStickyCreamPuddles() {
    player.slowedByStickyCream = false;
    for (let i = stickyCreamPuddles.length - 1; i >= 0; i--) {
        const p = stickyCreamPuddles[i];
        p.life--;
        if (p.life <= 0) {
            stickyCreamPuddles.splice(i, 1);
            continue;
        }
        const dx = player.x - p.x;
        const dy = player.y - p.y;
        const rr = player.radius + p.radius;
        if (dx * dx + dy * dy < rr * rr) {
            player.slowedByStickyCream = true;
        }
    }
}

function drawStickyCreamPuddles() {
    stickyCreamPuddles.forEach(p => {
        const grad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.radius);
        grad.addColorStop(0, 'rgba(20,20,20,0.8)');
        grad.addColorStop(0.7, 'rgba(40,25,25,0.55)');
        grad.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
        ctx.fill();
    });
}

function updateMovingGases() {
    for (let i = movingGases.length - 1; i >= 0; i--) {
        const g = movingGases[i];
        g.x += g.vx;
        g.y += g.vy;
        g.life--;

        // [최적화] 플레이어 충돌 체크 (제곱 거리 사용)
        const dx = player.x - g.x;
        const dy = player.y - g.y;
        const distSq = dx * dx + dy * dy;
        const hitRadius = player.radius + g.radius;

        if (distSq < hitRadius * hitRadius) {
            player.slowedByCloud = true;
            // 가스 데미지
            takeDamage(0.0002, 'dot', 0);
            
            // 60프레임마다 카인의 향기 디버프 1중첩
            if (frameCount % 60 === 0 && player.invincibleTimer <= 0) {
                addStatus('darkScent', 900, 30);
            }
        }

        // 중앙 도달 체크 (거리가 10 이하이면 폭발) -> 제곱 거리 100 이하
        const cdx = g.centerX - g.x;
        const cdy = g.centerY - g.y;
        const centerDistSq = cdx * cdx + cdy * cdy;

        if (centerDistSq < 100 || g.life <= 0) { // 10 * 10 = 100
            // 폭발 발생!
            spawnExplosion(g.centerX, g.centerY, (g.accuracy || 0), (g.owner || null));
            movingGases.splice(i, 1);
        }
    }
}

// [수정] 이동하는 가스 그리기 (기존 DarkGas와 동일한 비주얼)
function drawMovingGases() {
    movingGases.forEach(g => {
        ctx.save();
        ctx.translate(g.x, g.y);
        
        // DarkGas 고유의 검정+진보라 그라데이션 적용
        const alpha = 0.8; // 기본 투명도
        const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, g.radius);
        
        // 중심부: 검정
        gradient.addColorStop(0, `rgba(0, 0, 0, ${alpha})`);          
        // 중간: 진한 보라색 (DarkGas 컬러)
        gradient.addColorStop(0.5, `rgba(60, 0, 60, ${alpha * 0.9})`); 
        // 외곽: 투명
        gradient.addColorStop(1, `rgba(0, 0, 0, 0)`); 

        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(0, 0, g.radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
    });
}

function spawnExplosion(x, y, accuracy = 0, owner = null) {
    // 폭발 데미지 미리 계산
    let explosionDamage = 16 + Math.floor(score * 0.17);

    // [수정] spawnDarkGas 호출 시, 마지막 인자로 explosionDamage를 전달합니다.
    // (기존: spawnDarkGas(x, y, 3.0, 1.5, 0); )
    spawnDarkGas(x, y, 3.8, 1.5, accuracy, explosionDamage, owner);

    // [삭제] 여기서 explosions.push({...}) 하는 코드는 모두 지웁니다.
    // 이제 데미지는 다크 가스가 다 커졌을 때 발생합니다.

    showPickupEffect(x, y - 50, "뿌우욱♥", false, true, "wicked-large-text");
}

function updateExplosions() {
    for (let i = explosions.length - 1; i >= 0; i--) {
        const e = explosions[i];
        e.life--;
        if (e.life <= 0) {
            explosions.splice(i, 1);
            continue;
        }

        // 플레이어 피격 체크 (이미 맞지 않았고, 무적 아닐 때)
        if (!e.hasHit) {
            // [최적화] 제곱 거리 판정
            const dx = player.x - e.x;
            const dy = player.y - e.y;
            const distSq = dx * dx + dy * dy;
            const hitRadius = e.radius + player.radius;

            if (distSq < hitRadius * hitRadius) {
                if (player.invincibleTimer <= 0) {
                    // 데미지 적용
                    takeDamage(e.damage, 'direct', (e.accuracy || 0), (e.owner || null));
                    // [요청사항] 실명 1중첩 부여
                    addStatus('blind', 900, 1);
                    showPickupEffect(player.x, player.y, "눈이 멀었다..", false, true, "darkness-border");
                    e.hasHit = true; // 피격 처리 완료
                }
            }
        }
    }
}
function drawBlackMoons() {
    blackMoons.forEach(moon => {
        ctx.save();
        ctx.translate(moon.x, moon.y);
        ctx.rotate(moon.angle);

        // 1. 흑월 본체 (입체감 있는 어두운 구체)
        // 빛이 왼쪽 위에서 오는 듯한 그라데이션
        const grad = ctx.createRadialGradient(-15, -15, 10, 0, 0, moon.radius);
        grad.addColorStop(0, '#555555');   // 하이라이트 (어두운 회색)
        grad.addColorStop(0.3, '#222222'); // 중간톤
        grad.addColorStop(1, '#000000');   // 외곽 (완전 검정)
        
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(0, 0, moon.radius, 0, Math.PI * 2);
        ctx.fill();

        // 2. 크레이터 (달 무늬) 그리기
        ctx.fillStyle = 'rgba(0, 0, 0, 0.6)'; // 본체보다 더 어두운 색으로 움푹 패인 느낌
        if (moon.craters) {
            moon.craters.forEach(c => {
                ctx.beginPath();
                ctx.arc(c.dx, c.dy, c.r, 0, Math.PI * 2);
                ctx.fill();
                
                // 크레이터 가장자리 살짝 밝게 (입체감)
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
                ctx.lineWidth = 1;
                ctx.stroke();
            });
        }

        // 3. 사악한 전류 이펙트 (지지직)
        // 보라색/검붉은색 전류가 달 표면에서 불규칙하게 튐
        ctx.shadowBlur = 15;
        ctx.shadowColor = '#9400D3'; // 보라색 광채 (Neon Purple)
        ctx.strokeStyle = '#E0B0FF'; // 연한 보라 (전류 심지)
        ctx.lineWidth = 2;
        ctx.lineJoin = 'round';
        ctx.lineCap = 'round';

        // 프레임마다 랜덤하게 번개 생성 (지지직거리는 느낌)
        const lightningCount = 4 + Math.floor(Math.random() * 3); 
        
        for(let i=0; i<lightningCount; i++) {
            if(Math.random() < 0.2) continue; // 가끔 깜빡임

            ctx.beginPath();
            const angle = Math.random() * Math.PI * 2;
            
            // 달 표면 근처에서 시작
            let startR = moon.radius * 0.9;
            let currX = Math.cos(angle) * startR;
            let currY = Math.sin(angle) * startR;
            ctx.moveTo(currX, currY);

            // 바깥으로 뻗어나가는 지그재그 선
            for(let j=0; j<5; j++) {
                // 진행 방향 + 랜덤 지터
                currX += (Math.cos(angle) * 12) + (Math.random()-0.5) * 20;
                currY += (Math.sin(angle) * 12) + (Math.random()-0.5) * 20;
                ctx.lineTo(currX, currY);
            }
            ctx.stroke();
        }
        
        // 4. 외곽 글로우 (사악한 기운 펄스)
        const pulse = 1 + Math.sin(Date.now() / 100) * 0.05;
        ctx.shadowColor = '#4B0082'; // Indigo
        ctx.shadowBlur = 20;
        ctx.strokeStyle = `rgba(75, 0, 130, ${0.4 + Math.random()*0.2})`;
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(0, 0, moon.radius * pulse, 0, Math.PI * 2);
        ctx.stroke();

        ctx.restore();
    });
}
function drawExplosions() {
    explosions.forEach(e => {
        ctx.save();
        ctx.translate(e.x, e.y);
        ctx.globalAlpha = e.life / 20; // 서서히 사라짐
        
        ctx.beginPath();
        ctx.arc(0, 0, e.radius, 0, Math.PI * 2);
        ctx.fillStyle = "rgba(138, 43, 226, 0.5)"; // 보라색 폭발
        ctx.fill();
        
        ctx.strokeStyle = "white";
        ctx.lineWidth = 3;
        ctx.stroke();
        ctx.restore();
    });
}

    function updateAndDrawSoulHarvestSlashes() {
        for (let i = soulHarvestSlashes.length - 1; i >= 0; i--) {
            let s = soulHarvestSlashes[i];
            s.life--;
            if (s.life <= 0) {
                soulHarvestSlashes.splice(i, 1);
                continue;
            }

            ctx.save();
            ctx.translate(s.x, s.y);
            // 낫이 베는 애니메이션
            let progress = 1 - (s.life / 45);
            ctx.rotate(s.angle + (progress * Math.PI)); 
            ctx.scale(5, 5); // 크기 키움

            // 낫 날 (은색 + 보라빛 오라)
            ctx.shadowColor = "#8A2BE2"; // 보라색 오라
            ctx.shadowBlur = 20;
            
            let grad = ctx.createLinearGradient(0, -40, 0, 40);
            grad.addColorStop(0, "#C0C0C0"); // 은색
            grad.addColorStop(0.5, "#FFFFFF");
            grad.addColorStop(1, "#808080");

            ctx.beginPath();
            ctx.arc(0, 0, 40, Math.PI * 1.2, Math.PI * 1.8); // 초승달 모양
            ctx.strokeStyle = grad;
            ctx.lineWidth = 4;
            ctx.lineCap = "round";
            ctx.stroke();

            // 해골 장식 (검보라색)
            ctx.shadowBlur = 0;
            ctx.fillStyle = "#2e003e";
            ctx.beginPath();
            ctx.arc(0, -35, 8, 0, Math.PI*2); // 해골 머리
            ctx.fill();
            ctx.fillStyle = "red"; // 눈
            ctx.beginPath();
            ctx.arc(-2, -35, 1, 0, Math.PI*2);
            ctx.arc(2, -35, 1, 0, Math.PI*2);
            ctx.fill();

            ctx.restore();
        }
    }

     function gainXp(amount) {
            if (level >= MAX_LEVEL) return; // 만렙 제한
            amount = amount * (1 + player.bonusXpGain);
            xp += amount;
            // XP바 UI 갱신
            const percent = Math.min(100, (xp / maxXp) * 100);
            document.getElementById('xp-bar').style.width = percent + '%';

            if (xp >= maxXp) {
                levelUp();
            }
        }

        function levelUp() {
            xp -= maxXp;
            level++;
             // [밸런스] 레벨업 필요 XP: 구간별 증가 배율
let xpMult = XP_GROWTH_SEG4_MULT; // 기본(후반)
if (level <= XP_GROWTH_SEG1_END_LV) xpMult = XP_GROWTH_SEG1_MULT;
else if (level <= XP_GROWTH_SEG2_END_LV) xpMult = XP_GROWTH_SEG2_MULT;
else if (level <= XP_GROWTH_SEG3_END_LV) xpMult = XP_GROWTH_SEG3_MULT;
// else: seg4 (Lv 301~)
maxXp = Math.ceil(maxXp * xpMult); 
            
            document.getElementById('level-text').innerText = 'Lv.' + level;
            document.getElementById('xp-bar').style.width = '0%';

            if (level % 10 === 0) {
               rerollCount++;
               showPickupEffect(player.x, player.y - 80, "리로드 기회 획득!", false, true, "justice-border");
            }
            
            // 게임 일시정지 및 UI 호출
            isLevelUpPaused = true;
            showLevelUpUI();
            
            // 레벨업 효과음 (기존 사운드 재활용 또는 추가)
            showPickupEffect(player.x, player.y - 50, "Level Up!", false, true, "goddess-text");
        }

       function showLevelUpUI() {
       uiLayer.style.zIndex = UI_LAYER_LEVELUP_Z;
    const modal = document.getElementById('levelUpModal');
    const container = document.getElementById('cardContainer');
    container.innerHTML = '';
    
    // 기존 카드 초기화 
    const selectedCards = [];
    let attempts = 0;
    
    // 무한 루프 방지용 안전장치 
    while(selectedCards.length < 3 && attempts < 100) {
        attempts++;
        const newCard = generateRandomCard();
        // 이미 뽑은 카드 중에 타입과 수치가 같은 것이 있는지 확인 
        const isDuplicate = selectedCards.some(card => card.type === newCard.type && card.value === newCard.value);
        if (!isDuplicate) {
            selectedCards.push(newCard);
        }
    }
    
    // 수집된 카드 렌더링 
    selectedCards.forEach(cardData => {
        const card = document.createElement('div');
        card.className = `upgrade-card rarity-${cardData.rarity}`;
        let rarityText = cardData.rarity.toUpperCase();
        card.innerHTML = ` <div class="card-rarity rarity-text-${cardData.rarity}">${rarityText}</div> <div class="card-name">${cardData.name}</div> <div class="card-desc">${cardData.desc}</div> <div class="card-stat rarity-text-${cardData.rarity}">${cardData.statDisplay}</div> `;
        card.onclick = () => {
            selectUpgrade(cardData);
        };
        container.appendChild(card);
    });

    // ============================================================
    // [신규] 리로드 버튼 로직
    // ============================================================
    let rerollBtn = document.getElementById('rerollCardBtn');
    
    // 버튼이 없으면 새로 생성 (showStatsBtn 옆이나 모달 하단에 추가)
    if (!rerollBtn) {
        rerollBtn = document.createElement('button');
        rerollBtn.id = 'rerollCardBtn';
        rerollBtn.style.marginTop = '20px';
        rerollBtn.style.marginLeft = '10px';
        rerollBtn.style.padding = '10px 20px';
        rerollBtn.style.fontSize = '20px';
        rerollBtn.style.background = '#4B0082'; // 보라색 계열
        rerollBtn.style.color = '#fff';
        rerollBtn.style.border = '2px solid #fff';
        rerollBtn.style.borderRadius = '10px';
        rerollBtn.style.cursor = 'pointer';
        rerollBtn.style.fontFamily = "'Black Han Sans', sans-serif";
        rerollBtn.style.transition = '0.2s';
        
        rerollBtn.onmouseover = () => { rerollBtn.style.background = '#6A0DAD'; };
        rerollBtn.onmouseout = () => { rerollBtn.style.background = '#4B0082'; };

        // 버튼 위치 잡기 (스탯 확인 버튼 뒤에 붙이기)
        const statsBtn = document.getElementById('showStatsBtn');
        if(statsBtn && statsBtn.parentNode === modal) {
            modal.insertBefore(rerollBtn, statsBtn.nextSibling);
        } else {
            modal.appendChild(rerollBtn);
        }

        // 클릭 이벤트
        rerollBtn.onclick = () => {
            if (rerollCount > 0) {
                rerollCount--;
                // 효과음이나 이펙트를 넣고 싶다면 여기에 추가
                showLevelUpUI(); // UI 재호출로 카드 갱신
            }
        };
    }

    // 리로드 횟수가 있을 때만 버튼 표시
    if (rerollCount > 0) {
        rerollBtn.style.display = 'inline-block';
        rerollBtn.innerText = `카드 리로드 (${rerollCount})`;
    } else {
        rerollBtn.style.display = 'none';
    }
    // ============================================================

    modal.style.display = 'flex';
}


// [UI] 카드 수치 표기: 표시만 정수(반올림) + 부동소수점 꼬리 제거
function fmtCardNumber(n, digits = 0) {
    if (!Number.isFinite(n)) return String(n);
    const fixed = Number(n.toFixed(digits));
    // 정수에 매우 가까우면 정수로 표기
    if (Math.abs(fixed - Math.round(fixed)) < 1e-9) return String(Math.round(fixed));
    return String(fixed);
}


        function generateRandomCard() {
            // 1. 등급 결정 로직 (수정됨)
            // 행운 1당 노멀 확률 1% 감소, 나머지 3개 등급에 1/3%씩 분배
            const rand = Math.random(); // 행운을 더하지 않은 순수 0~1 랜덤값 사용
            
            // 감소시킬 노멀 확률 계산 (최대 60%까지만 감소)
            const reduceCommon = Math.min(0.60, luck * 0.01);
            
            // 다른 등급들이 나눠 가질 추가 확률 (N분의 1)
            const bonusPerTier = reduceCommon / 3;

            // 확률 경계값 재계산
            // [기본] 노멀(~60%) / 레어(~85%) / 유니크(~98%) / 레전더리(나머지)
            // [변경] 경계값이 낮아져서 상위 등급의 구간이 넓어짐
            const cutRare = 0.60 - reduceCommon;                     // 노멀 끝, 레어 시작 지점
            const cutUnique = 0.85 - (reduceCommon - bonusPerTier);  // 레어 끝, 유니크 시작 지점 (0.85 - 2*bonus)
            const cutLegendary = 0.98 - bonusPerTier;                // 유니크 끝, 레전더리 시작 지점

            let rarity = 'common';

            // 레벨이 10의 배수(10, 20, 30...)일 경우 무조건 레전더리 등급 고정
            if (level % 10 === 0) {
                rarity = 'legendary';
            } else {
                // 새로운 확률 구간 적용
                if (rand > cutLegendary) rarity = 'legendary';
                else if (rand > cutUnique) rarity = 'unique';
                else if (rand > cutRare) rarity = 'rare';
                else rarity = 'common';
            }

            // 2. 능력치 종류 결정 (기존 동일)
            const types = ['atk', 'atkSpeed', 'range', 'hp', 'defense', 'moveSpeed', 'luck', 'accuracy', 'evasion', 'stunChance', 'critChance', 'critDamage', 'critResist', 'xpGain', 'regen'];
            const type = types[Math.floor(Math.random() * types.length)];

            let name = "";
            let desc = "";
            let statDisplay = "";
            let value = 0;

            // 등급별 배율 (기존 동일)
            let multiplier = 1;
            if (rarity === 'rare') multiplier = 2;
            if (rarity === 'unique') multiplier = 3;
            if (rarity === 'legendary') multiplier = 4;

            switch(type) {
                case 'atk':
                    name = "근력 강화";
                    desc = "공격력이 증가합니다.";
                    value = 1 * multiplier;
                    statDisplay = `+${fmtCardNumber(value, 0)}`;
                    break;
                case 'atkSpeed':
                    name = "광속 공격";
                    desc = "공격 속도가 증가합니다.";
                    value = 0.05 * multiplier; 
                    statDisplay = `+${(value * 100).toFixed(0)}%`;
                    break;
                case 'range':
                    name = "용이한 무기";
                    desc = "공격 범위가 증가합니다.";
                    value = 1.2 * multiplier;
                    statDisplay = `+${fmtCardNumber(value, 0)}`;
                    break;
                case 'hp':
                    name = "건강한 신체";
                    desc = "최대 체력이 증가합니다.";
                    value = 12 * multiplier;
                    statDisplay = `+${fmtCardNumber(value, 0)}`;
                    break;
                case 'defense':
                    name = "단단한 피부";
                    desc = "방어력이 증가합니다.";
                    value = 1.2 * multiplier;
                    statDisplay = `+${fmtCardNumber(value, 0)}`;
                    break;
                case 'moveSpeed':
                    name = "가벼운 발걸음";
                    desc = "이동 속도가 증가합니다.";
                    value = 0.1 * multiplier;
                    statDisplay = `+${value.toFixed(1)}`;
                    break;
                case 'luck':
                    name = "행운";
                    desc = "더 좋은 선택지가 나올 확률이 증가합니다.";
                    value = 1 * multiplier;
                    statDisplay = `+${fmtCardNumber(value, 0)}`;
                    break;
                case 'accuracy':
                    name = "정밀 타격";
                    desc = "명중률이 증가합니다.";
                    value = 0.02 * multiplier; 
                    statDisplay = `+${(value * 100).toFixed(1)}%`;
                    break;
                case 'evasion':
                    name = "민첩한 몸놀림";
                    desc = "회피율이 증가합니다.";
                    value = 0.02 * multiplier; 
                    statDisplay = `+${(value * 100).toFixed(1)}%`;
                    break;
                case 'stunChance':
                    name = "급소 일격";
                    desc = "공격 시 적을 기절시킬 확률이 증가합니다.";
                    value = 0.01 * multiplier;
                    statDisplay = `+${(value * 100).toFixed(0)}%`;
                    break;
                case 'critChance':
                    name = "예리한 일격";
                    desc = "치명타 확률이 증가합니다.";
                    value = 1 * multiplier;
                    statDisplay = `+${value.toFixed(1)}%`;
                    break;
                case 'critDamage':
                    name = "집중 공격";
                    desc = "치명타 피해 배율이 증가합니다.";
                    value = 0.1 * multiplier;
                    statDisplay = `+${(value * 100).toFixed(0)}%`;
                    break;
                case 'critResist':
                    name = "굳건한 의지";
                    desc = "치명타 저항률이 증가합니다.";
                    value = 2 * multiplier;
                    statDisplay = `+${value.toFixed(1)}%`;
                    break;
                case 'xpGain':
                    name = "학습 능력";
                    desc = "경험치 획득량이 증가합니다.";
                    value = 0.05 * multiplier; 
                    statDisplay = `+${(value * 100).toFixed(1)}%`;
                    break;
                 case 'regen':
                    name = "자연 치유";
                    desc = "초당 체력 회복량이 증가합니다.";
                    value = 2.5 * multiplier;
                    statDisplay = `+${fmtCardNumber(value, 0)}`;
                    break;
            }

            return { type, name, desc, value, rarity, statDisplay };
        }

        function selectUpgrade(data) {
            switch(data.type) {
                case 'atk':
                    player.weapon.baseDamage += data.value;
                    player.weapon.damage = player.weapon.baseDamage;
                    break;
                case 'atkSpeed':
                    player.bonusAttackSpeed += data.value;
                    player.weapon.baseAutoAttackInterval = player.weapon.originalAutoAttackInterval / (1 + player.bonusAttackSpeed);
                    player.weapon.baseAutoAttackInterval = Math.max(5, player.weapon.baseAutoAttackInterval);
                    if(player.weapon.autoAttackInterval > player.weapon.baseAutoAttackInterval) {
                        player.weapon.autoAttackInterval = player.weapon.baseAutoAttackInterval;
                    }
                    break;
                case 'range':
                    player.weapon.baseLength += data.value;
                    player.weapon.length = player.weapon.baseLength;
                    break;
                case 'hp':
                    player.baseMaxHealth += data.value;
                    updateMaxHealth();
                    player.health += data.value; // 체력 회복도 같이
                    updateHealthUI();
                    break;
                case 'defense':
                    player.defense += data.value;
                    break;
                case 'moveSpeed':
                    player.baseSpeed += data.value;
                    player.speed = player.baseSpeed;
                    break;
                case 'luck':
                    luck += data.value;
                    break;

                // [신규] 명중, 회피, 치명타 저항 확률 적용 로직
                case 'accuracy':
                    player.bonusAccuracy += data.value;
                    break;
                case 'evasion':
                    player.bonusEvasion += data.value;
                    break;
                case 'stunChance':
                    player.bonusStunChance += data.value;
                    break;
                case 'critChance':
                    player.baseCritChance += data.value;
                    player.critChance = player.baseCritChance;
                    break;
                case 'critDamage':
                    player.baseCritDamageMultiplier += data.value;
                    player.critDamageMultiplier = player.baseCritDamageMultiplier;
                    break;
                case 'critResist':
                    player.baseCritResist += data.value;
                    player.critResist = player.baseCritResist;
                    break;
                case 'xpGain':
                    player.bonusXpGain += data.value;
                    break;
                case 'regen':
                    player.baseRegen += data.value;
                    player.regen = player.baseRegen;
                    break;
            }

            // 모달 닫기 및 게임 재개
            document.getElementById('levelUpModal').style.display = 'none';
            uiLayer.style.zIndex = UI_LAYER_DEFAULT_Z;
            isLevelUpPaused = false;
            
            // 멈춰있던 루프 재가동
            requestAnimationFrame(animate);
        }
            // =========================================================
        // [신규] 스탯 확인 기능 스크립트
        // =========================================================
        const showStatsBtn = document.getElementById('showStatsBtn');
        const statsInfoBox = document.getElementById('statsInfoBox');
        const closeStatsBtn = document.getElementById('closeStatsBtn');
        const statsContent = document.getElementById('statsContent');

        showStatsBtn.addEventListener('click', () => {
            updateStatsContent();
            statsInfoBox.style.display = 'block';
        });

        closeStatsBtn.addEventListener('click', () => {
            statsInfoBox.style.display = 'none';
        });

function updateStatsContent() {
    // 1. 체력 & 최대 체력 감소 정보
    let maxHpInfo = "";
    if (player.evilLightTimers.length > 0) maxHpInfo += " (빛 -15%)";
    if (player.evilMindTimers.length > 0) {
        const mindReduc = (player.evilMindTimers.length * 2).toFixed(1);
        maxHpInfo += ` (마음 -${mindReduc}%)`;
    }
    const hpStr = Math.floor(player.health) + " / " + Math.floor(player.maxHealth) + 
                  (maxHpInfo ? `<span style="color:#ff4444; font-size:0.8em;">${maxHpInfo}</span>` : "");
    
    // 2. 공격력
    let displayDamage = player.weapon.damage;
    let dmgExtraInfo = "";
    
    // [감소] 카인의 씨앗
    if (player.darkSeedTimers.length > 0) {
        const seedReduction = player.weapon.damage * (player.darkSeedTimers.length * 0.02);
        displayDamage -= seedReduction; 
        if (displayDamage < 0.1) displayDamage = 0.1; 
        dmgExtraInfo += ` <span style="color:#ff4444;">(-${seedReduction.toFixed(1)})</span>`;
    }
    // [패널티] 어둠의 수신자 (적 방어력 증가)
    if (player.darkReceiverTimers.length > 0) {
        const receiverPenalty = (player.darkReceiverTimers.length * 2).toFixed(1);
        dmgExtraInfo += ` <span style="color:#ff4444;">(적 방어 +${receiverPenalty}%)</span>`;
    }
    const atkStr = displayDamage.toFixed(1) + dmgExtraInfo;
    
    // 3. 방어력 & 받는 피해
    let displayDefense = player.defense;
    if (player.defenseBroken) displayDefense = 0;
    if (player.stunTimer > 0) displayDefense *= 0.5; // [신규] 기절 중 방어 50% 감소(표시)
    
    let defStr = displayDefense.toFixed(1);
    if (player.defenseBroken) defStr += " <span style='color:#ff0000;'>(파괴됨!)</span>";

    let takenInfo = "";
    if (player.corruptedBloodTimers.length > 0) {
        const bloodAmp = (player.corruptedBloodTimers.length * 2.5).toFixed(1);
        takenInfo += `<div>피해 +${bloodAmp}% (피)</div>`;
    }
    if (player.maliceTimers.length > 0) {
        const maliceAmp = (player.maliceTimers.length * 10).toFixed(0);
        takenInfo += `<div>독/함정 피해 +${maliceAmp}% (악의)</div>`;
    }
    if (takenInfo) defStr += ` <span style="color:#ff4444; font-size:0.8em;">${takenInfo}</span>`;

    // 4. 명중률 (플레이어 감소 + 적 회피 증가 통합)
    let currentAccuracy = player.bonusAccuracy;
    if (player.limitFocusSkill.activeTimer > 0) currentAccuracy += (0.05 + (level * 0.0015));
    if (player.deepDarknessStacks > 0) currentAccuracy -= (player.deepDarknessStacks * 0.1);
    if (player.blindTimers.length > 0) currentAccuracy -= (player.blindTimers.length * 0.05);
    if (player.evilLightTimers.length > 0) currentAccuracy -= 0.05;
    
    let enemyEvasionBonus = 0;
    if (player.semenTimers.length > 0) enemyEvasionBonus += (player.semenTimers.length * 0.005);
    if (typeof activeAkiCount !== 'undefined' && activeAkiCount > 0) enemyEvasionBonus += (activeAkiCount * 0.02);

    let accStr = (currentAccuracy > 0 ? "+" : "") + (currentAccuracy * 100).toFixed(1) + "%";
    if (enemyEvasionBonus > 0) {
        accStr += ` <span style="color:#ff4444;">(적 회피 +${(enemyEvasionBonus * 100).toFixed(1)}%)</span>`;
    }

    // 5. 회피율 (총 회피 = 기본 2% + 보너스)
    let displayEvasionTotal = 0.02 + (player.bonusEvasion || 0);
    if (player.stunTimer > 0) displayEvasionTotal *= 0.5; // [신규] 기절 중 총 회피 50% 감소(표시)
    if (player.deathBrandTimers.length > 0) displayEvasionTotal *= 0.5;
    const evaStr = (displayEvasionTotal * 100).toFixed(0) + "%" + (player.deathBrandTimers.length > 0 ? " (▼)" : "") + (player.stunTimer > 0 ? " (기절▼)" : "");

    // 5-1. 기절 확률
    const stunStr = "+" + (((player.bonusStunChance || 0) * 100).toFixed(0)) + "%";


    // 6. 치명타 확률 & 치명타 저항 확률
    let displayCritResist = player.critResist;
    let displayCritChance = player.critChance;


    let displayCritDamageMultiplier = (player.critDamageMultiplier || 1.5);
    if (player.sacredFaithSkill.activeTimer > 0) {
        let sfBonus = 5 + (level * 0.25);
        displayCritResist += sfBonus;
        displayCritChance -= sfBonus;
    }
    if (player.corruptedOathStacks > 0) displayCritChance += (player.corruptedOathStacks * 10);
    if (player.trueAncestorKissTimers.length > 0) displayCritChance += (player.trueAncestorKissTimers.length * 3);
    if (player.shadingTimers.length > 0) displayCritChance += 15;
    
    if (player.dangerousJudgmentStacks > 0) displayCritResist -= (player.dangerousJudgmentStacks * 10);
    if (player.fatalScarTimers.length > 0) displayCritResist -= (player.fatalScarTimers.length * 3);
    if (player.inPinkGas) displayCritResist *= 0.5;
    if (player.deathBrandTimers.length > 0) displayCritResist *= 0.5;
    if (player.fractureTimers.length > 0) displayCritResist -= (player.fractureTimers.length * 5);

    // 7. 공격 속도
    let attackInterval = player.weapon.autoAttackInterval;
    let atkSpeedReduction = 0;
    if (player.darkKissTimers.length > 0) atkSpeedReduction += (player.darkKissTimers.length * 0.011);
    if (player.darknessOverwhelmActive) atkSpeedReduction += 0.05;
    
    if (atkSpeedReduction > 0) {
        let speedFactor = 1 - atkSpeedReduction;
        if (speedFactor > 0.1) attackInterval = attackInterval / speedFactor;
    }

    // [수정] 퍼센트 표기 추가
    let bonusStr = (player.bonusAttackSpeed * 100).toFixed(0);
    const aspdStr = `${bonusStr}% 증가 ` + 
                    (atkSpeedReduction > 0 ? " <span style='color:#ff4444;'>(느려짐)</span>" : "");

    // 8. 공격 범위
    let rangeStr = player.weapon.length.toFixed(0);
    let rangeReduced = false;
    if (player.oralTimers.length > 0) rangeReduced = true;
    if (player.evilLightTimers.length > 0) rangeReduced = true;
    if (rangeReduced) rangeStr += " <span style='color:#ff4444;'>(단축됨)</span>";

    // 9. HP 회복
    let displayRegen = player.regen;
    if (player.gnawingLifeTimers.length > 0) displayRegen *= (1 - player.gnawingLifeTimers.length * 0.03);
    if (player.majestyActive) displayRegen *= 0.9;
    if (player.bleedingTimers.length > 0) displayRegen *= (1 - player.bleedingTimers.length * 0.02);

    let regenStr = (displayRegen / 2).toFixed(1);
    let regenInfo = "";

    if ((player.serumContaminationTimers && player.serumContaminationTimers.length > 0) || 
        (player.blasphemyTimers && player.blasphemyTimers.length > 0)) {
        regenStr = "0.0";
        regenInfo += " (회복 불가!)";
    } else if (player.bleedingTimers.length > 0) {
        regenInfo += ` (출혈:효율-${(player.bleedingTimers.length * 2).toFixed(0)}%)`;
    }

    if (player.poisonTimers.length > 0 || player.darkScentTimers.length > 0 || player.darkSmellTimers.length > 0 || player.poopPoisonTimers.length > 0) {
        regenInfo += " <span style='color:#ff4444;'>(독/지속피해 중!)</span>";
    }
    if (player.curseTimers.length > 0) {
        regenInfo += " <span style='color:#800080;'>(저주:종료시 피해)</span>";
    }
    if (regenInfo) regenStr += `<span style="font-size:0.8em; color:#ff4444;">${regenInfo}</span>`;

    // 10. 이동 속도
    let totalSlowFactor = 0;
    if (player.slowedByCloud) totalSlowFactor += 0.5;
                if (player.slowedByStickyCream) totalSlowFactor += 0.25;
    if (player.darknessOverwhelmActive) totalSlowFactor += 0.05;
    if (player.paralysisTimers.length > 0) totalSlowFactor += (player.paralysisTimers.length * 0.025);
    totalSlowFactor = Math.min(0.9, totalSlowFactor);
    
    let displaySpeed = player.baseSpeed * (1 - totalSlowFactor);
    let speedExtraInfo = "";
    if (player.stunTimer > 0) { displaySpeed = 0; speedExtraInfo = " (기절)"; } 
    else if (player.rootTimer > 0) { displaySpeed = 0; speedExtraInfo = " (속박)"; }
    else if (player.kissTimers.length > 0) { speedExtraInfo = " (키스중)"; }
    else if (player.confusionTimers.length > 0) { speedExtraInfo = " (혼란)"; }

    const speedStr = displaySpeed.toFixed(1) + speedExtraInfo;

    // 11. 쿨타임 회복
    let cdRecovery = 1.0;
    if (player.majestyActive) cdRecovery *= 0.75; 
    if (player.corruptedJusticeStacks > 0) cdRecovery -= (player.corruptedJusticeStacks * 0.25);
    if (cdRecovery < 0.1) cdRecovery = 0.1;

    let cooldownStr = (cdRecovery * 100).toFixed(0) + "%";
    if (cdRecovery < 1.0) cooldownStr += " <span style='color:#ff4444;'>(저하됨)</span>";

    // UI 업데이트
    statsContent.innerHTML = `
        <div class="stat-row"><span class="stat-label">체력</span> <span class="stat-value">${hpStr}</span></div>
        <div class="stat-row"><span class="stat-label">공격력</span> <span class="stat-value">${atkStr}</span></div>
        <div class="stat-row"><span class="stat-label">방어력</span> <span class="stat-value">${defStr}</span></div>
        <div class="stat-row"><span class="stat-label">명중률</span> <span class="stat-value">${accStr}</span></div>
        <div class="stat-row"><span class="stat-label">회피율</span> <span class="stat-value">${evaStr}</span></div>
        <div class="stat-row"><span class="stat-label">기절 확률</span> <span class="stat-value">${stunStr}</span></div>
        <div class="stat-row"><span class="stat-label">치명타 확률</span> <span class="stat-value">${displayCritChance.toFixed(1)}</span></div>
        <div class="stat-row"><span class="stat-label">치명타 데미지</span> <span class="stat-value">x${displayCritDamageMultiplier.toFixed(2)}</span></div>
        <div class="stat-row"><span class="stat-label">치명타 저항 확률</span> <span class="stat-value">${displayCritResist.toFixed(1)}</span></div>
        <div class="stat-row"><span class="stat-label">공격속도</span> <span class="stat-value">${aspdStr}</span></div>
        <div class="stat-row"><span class="stat-label">공격범위</span> <span class="stat-value">${rangeStr}</span></div>
        <div class="stat-row"><span class="stat-label">쿨타임 회복</span> <span class="stat-value">${cooldownStr}</span></div>
        <div class="stat-row"><span class="stat-label">경험치 증가</span> <span class="stat-value">+${(player.bonusXpGain*100).toFixed(0)}%</span></div>
        <div class="stat-row"><span class="stat-label">초당 HP회복</span> <span class="stat-value">${regenStr}</span></div>
        <div class="stat-row"><span class="stat-label">이동속도</span> <span class="stat-value">${speedStr}</span></div>
    `;
}
    </script>
</div></body>
</html>
