<!DOCTYPE html>

<html lang="ko">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" name="viewport"/>
<title>가죽바지 빌런 서바이벌</title>
<script src="https://cdn.tailwindcss.com"></script>
<style>
        @import url('https://fonts.googleapis.com/css2?family=Black+Han+Sans&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=Gugi&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;500;700;800&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=Noto+Serif+KR:wght@600;700;800&display=swap');

                :root {
            --ui-font-clean: 'Noto Sans KR', system-ui, -apple-system, 'Segoe UI', 'Apple SD Gothic Neo', 'Malgun Gothic', sans-serif;
            --ui-font-title: 'Noto Serif KR', 'Noto Sans KR', system-ui, -apple-system, 'Segoe UI', 'Apple SD Gothic Neo', 'Malgun Gothic', sans-serif;
            --ui-font-display: 'Black Han Sans', 'Noto Sans KR', system-ui, -apple-system, 'Segoe UI', 'Apple SD Gothic Neo', 'Malgun Gothic', sans-serif;
        }

body {
            margin: 0;
            overflow: hidden;
            background-color: #c0c0c0;
            font-family: var(--ui-font-clean);
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
        }

        #gameCanvas {
            display: block;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
            z-index: 20; 
        }

        /* 데미지 텍스트 애니메이션 */
        @keyframes float-up {
            0% { transform: translateY(0) scale(1); opacity: 1; }
            100% { transform: translateY(-30px) scale(1.2); opacity: 0; }
        }
        .damage-text {
            position: absolute;
            color: #ffcc00;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 2px 2px 0 #000;
            pointer-events: none;
            animation: float-up 0.8s ease-out forwards;
            z-index: 25;
            white-space: nowrap;
        }

        /* 크리티컬 데미지 말풍선 스타일 */
        .crit-damage-text {
            position: absolute;
            color: #FFFF00 !important; /* 노란색 글씨 */
            background: #FF0000; /* 빨간색 배경 */
            padding: 8px 12px;
            border-radius: 20px;
            font-weight: bold;
            font-size: 32px !important;
            text-shadow: 2px 2px 0 #000;
            z-index: 50;
            animation: float-up 0.8s ease-out forwards;
            border: 3px solid #8B0000;
            box-shadow: 0 0 10px rgba(255, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
        }
        /* 말풍선 꼬리 */
        .crit-damage-text::after {
            content: '';
            position: absolute;
            bottom: -8px;
            left: 50%;
            transform: translateX(-50%);
            border-width: 8px 8px 0;
            border-style: solid;
            border-color: #FF0000 transparent transparent transparent;
        }

        .crit-text {
            color: #ff3333 !important;
            font-size: 32px !important;
        }
        
        .weak-text {
            color: #cccccc !important;
            font-size: 18px !important;
            text-shadow: 1px 1px 0 #000;
            opacity: 0.8;
        }
        
        .heal-text {
            color: #7FFF00 !important;
            font-size: 24px !important;
            text-shadow: 1px 1px 2px #000;
        }
        
        .block-text {
            color: #FFFF00 !important;
            font-size: 26px !important;
            text-shadow: 2px 2px 0 #000;
            font-weight: bold;
            z-index: 30;
        }
        
        #poopOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, rgba(60, 40, 10, 0.4) 10%, rgba(30, 15, 0, 0.98) 100%);
            opacity: 0;
            pointer-events: none;
            z-index: 14; 
            transition: opacity 0.5s ease;
            mix-blend-mode: multiply; 
        }

        #mindOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, transparent 30%, rgba(75, 0, 130, 0.8) 100%);
            opacity: 0;
            pointer-events: none;
            z-index: 16;
            transition: opacity 0.3s ease;
        }
        
        #darknessOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: black;
            opacity: 0;
            pointer-events: none;
            z-index: 999; 
            transition: opacity 0.1s ease-in-out;
        }

        #sacredFaithOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, transparent 40%, rgba(255, 215, 0, 0.3) 100%);
            opacity: 0;
            pointer-events: none;
            z-index: 15;
            transition: opacity 0.5s ease;
        }
        
        /* [신규] 아서 등장용 블러드 오버레이 */
        #bloodOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, rgba(255, 0, 0, 0.1) 20%, rgba(139, 0, 0, 0.8) 100%);
            opacity: 0;
            pointer-events: none;
            z-index: 17; /* 장판보다 위, UI보다 아래 */
            transition: opacity 1.5s ease-in-out;
            mix-blend-mode: multiply;
        }
        
        /* 정신착란(Confusion) 노란 점멸 오버레이 */
        #confusionOverlay {
           position: absolute;
           top: 0;
           left: 0;
           width: 100%;
           height: 100%;
           pointer-events: none;

    /* 노란색이 화면 가장자리쪽에서 더 강하게 보이게 */
    background: radial-gradient(circle, rgba(255,200,0,0.0) 35%, rgba(255,200,0,0.90) 100%);

    opacity: 0;
    z-index: 18; /* bloodOverlay(17) 위, UI(20) 아래 정도로 */
}

/* active일 때만 깜빡이기 */
#confusionOverlay.active {
    animation: confusionBlink 0.45s infinite;
}

/* 0 -> (최대값) -> 0 */
@keyframes confusionBlink {
    0%, 100% { opacity: 0; }
    50%      { opacity: var(--confusionAlpha, 0.45); }
}

        #visionOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, transparent 150px, black 300px);
            opacity: 0;
            pointer-events: none;
            z-index: 998; /* UI 바로 아래 */
            transition: opacity 0.5s ease;
        }

        #skillSealOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.3);
            display: none;
            justify-content: center;
            align-items: center;
            pointer-events: none;
            z-index: 200;
        }
        
        #skillSealText {
            font-family: var(--ui-font-title);
            font-size: 80px;
            color: #800080;
            text-shadow: 2px 2px 0 #000, 0 0 20px #FF00FF;
            animation: pulse-seal 1s infinite;
        }
        
        @keyframes pulse-seal {
            0% { transform: scale(1); opacity: 0.8; }
            50% { transform: scale(1.1); opacity: 1; }
            100% { transform: scale(1); opacity: 0.8; }
        }

        .hud-top {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            width: 100%;
        }

        .status-container-left {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .status-container-right {
            display: flex;
            flex-direction: column;
            gap: 10px;
            align-items: flex-end;
        }

       .score-box {
    position: absolute;
    left: 50%;
    transform: translateX(-50%);
    
    /* [수정] 하단으로 이동 */
    top: auto; 
    bottom: 20px; 
    
    color: white;
    font-size: 24px;
    text-shadow: 2px 2px 0 #000;
    white-space: nowrap;
    z-index: 50; /* 다른 요소 위에 보이도록 z-index 추가 권장 */
}

        /* HP바와 스킬 아이콘을 가로로 배치하기 위한 컨테이너 */
        .hp-skill-row {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 20px;
        }

        .health-container {
            width: 300px;
            height: 25px;
            background: #333;
            border: 2px solid #fff;
            border-radius: 12px;
            overflow: hidden;
            position: relative;
        }

        .health-bar {
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, #ff4d4d, #ff9900);
            transition: width 0.1s linear;
        }

        .health-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 14px;
            text-shadow: 1px 1px 1px #000;
        }

        /* 스킬 아이콘 스타일 */
        .skill-icon-box {
            position: relative;
            width: 40px;
            height: 40px;
            background: #222;
            border: 2px solid #FFD700;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 0 5px #FFD700;
        }
        .skill-img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        .cooldown-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 0%; /* 쿨타임 중일 때 높이 조절 */
            background: rgba(0, 0, 0, 0.75);
            transition: height 0.1s linear;
        }
        .seal-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(80, 0, 80, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            color: red;
            font-weight: bold;
            z-index: 10;
        }
        
        .key-hint {
            position: absolute;
            top: 0;
            left: 2px;
            font-size: 12px;
            color: #fff;
            font-weight: bold;
            text-shadow: 1px 1px 0 #000;
            pointer-events: none;
        }
        .cooldown-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #fff;
            font-size: 16px;
            font-weight: bold;
            text-shadow: 1px 1px 0 #000;
            pointer-events: none;
            display: none;
        }

        .status-icon-box {
            display: flex;
            align-items: center;
            background: rgba(0, 0, 0, 0.6);
            padding: 4px 9px;
            border-radius: 9px;
            width: fit-content;
            margin-bottom: 4px;
        }

        .status-container-right .status-icon-box {
            flex-direction: row-reverse; 
        }
        .status-container-right .status-img {
            margin-right: 0;
            margin-left: 10px;
        }

        .poison-border { border: 2px solid #00ff00; } 
        .poop-border { border: 2px solid #8B4513; }   
        .kiss-border { border: 2px solid #FF1493; }   
        .semen-border { border: 2px solid #FFFFFF; } 
        .oral-border { border: 2px solid #FFFDD0; }
        .byururut-border { border: 2px solid #FFFDD0; }
        .shield-border { border: 2px solid #00BFFF; }
        .evil-mind-border { border: 2px solid #800080; }
        .curse-border { border: 2px solid #4B0082; } 
        .justice-border { border: 2px solid #FFD700; }
        .blind-border { border: 2px solid #808080; }
        .geoptal-border { border: 2px solid #ff0055; box-shadow: 0 0 5px #ff0055; }
        .fishy-border { border: 2px solid #7FFFD4; box-shadow: 0 0 5px #7FFFD4; }
        .malice-border { border: 2px solid #4B0082; box-shadow: 0 0 5px #8A2BE2; }
        .hyper-border { border: 2px solid #FFFF00; box-shadow: 0 0 5px #FFD700; animation: blink-border 1s infinite; }
        .paralysis-border { border: 2px solid #9370DB; box-shadow: 0 0 5px #8A2BE2; }
        
        @keyframes blink-border { 50% { border-color: #FF0000; } }

        /* 신규 디버프 테두리 */
        .corrupted-oath-border { border: 2px solid #8B0000; box-shadow: 0 0 5px #ff0000; }
        .dangerous-judgment-border { border: 2px solid #FFA500; box-shadow: 0 0 5px #ffcc00; }
        .deep-darkness-border { border: 2px solid #000000; box-shadow: 0 0 5px #333333; }
        .corrupted-justice-border { border: 2px solid #555555; box-shadow: 0 0 5px #aaaaaa; }
        .serum-contamination-border { border: 2px solid #8B0000; box-shadow: 0 0 10px #FF4500; animation: blink-border 0.5s infinite; }
        .death-brand-border { border: 2px solid #2F4F4F; box-shadow: 0 0 15px #000000, inset 0 0 10px #8B0000; animation: blink-border 0.5s infinite; }
        .darkness-border { border: 2px solid #000000; box-shadow: 0 0 15px #000000; }
        .confusion-border { border: 2px solid #FF4500; box-shadow: 0 0 10px #FF8C00; animation: blink-border 0.5s infinite; }
        .fake-item-border { border: 2px solid #9370DB; box-shadow: 0 0 5px #BA55D3; }
        .bleeding-border { border: 2px solid #DC143C; box-shadow: 0 0 5px #FF0000; animation: blink-border 1s infinite; }
        .shading-border { border: 2px solid #000000; box-shadow: 0 0 10px #4B0082; }
        .true-ancestor-border { border: 2px solid #DC143C; box-shadow: 0 0 5px #FF0000; }
        .fatal-scar-border { border: 2px solid #000000; box-shadow: 0 0 5px #8B0000; }
        .corrupted-blood-border { border: 2px solid #8B0000; box-shadow: 0 0 5px #800000; }
        .majesty-border { border: 2px solid #DAA520; box-shadow: 0 0 5px #FFD700; }
        .pheromone-overload-border { border: 2px solid #FF0000; box-shadow: 0 0 15px #FF0000; animation: blink-border 0.5s infinite; }
        .darkness-overwhelm-border { border: 2px solid #483d8b; box-shadow: 0 0 10px #483d8b; }
        .fracture-border { border: 2px solid #555555; box-shadow: 0 0 10px #000000, inset 0 0 5px #ff0000; animation: blink-border 1s infinite; }
        .dark-scent-border { border: 2px solid #2F4F4F; }
        .dark-smell-border { border: 2px solid #3e2723; }
        .dark-seed-border { border: 2px solid #4a4a4a; }
        .dark-kiss-border { border: 2px solid #880e4f; }
        .dark-receiver-border { border: 2px solid #1a237e; }
        .evil-light-border { border: 2px solid #220022; box-shadow: 0 0 10px #800080; }
        .dark-ecstasy-border { border: 2px solid #9932CC; box-shadow: 0 0 10px #8A2BE2; }
        .gnawing-life-border { border: 2px solid #556B2F; box-shadow: 0 0 10px #6B8E23; }
        .berserk-border { border: 2px solid #FF0000; box-shadow: 0 0 10px #FF0000; }
        .despair-border { border: 2px solid #2F4F4F; box-shadow: 0 0 10px #000000; animation: blink-border 0.5s infinite; }
        .baptism-border { border: 2px solid #191970; box-shadow: 0 0 10px #4169E1; }

        .status-img {
            width: 35px;
            height: 35px;
            border-radius: 7px;
            margin-right: 9px;
            object-fit: cover;
            background: #fff;
        }
        
        .dark-icon {
            filter: none;
        }

        .status-text {
            font-size: 18px;
            text-shadow: 1px 1px 0 #000;
            font-weight: bold;
        }

        #screen-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            pointer-events: auto;
            z-index: 30; 
        }

        .title {
            font-size: 48px;
            color: #ffd700;
            text-align: center;
            margin-bottom: 20px;
            text-shadow: 3px 3px 0 #5a3e1b;
        }

        .subtitle {
            font-size: 18px;
            color: #ddd;
            text-align: center;
            margin-bottom: 40px;
            line-height: 1.5;
        }

        .btn {
            padding: 15px 40px;
            font-size: 24px;
            background: #5a3e1b;
            color: white;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            font-family: var(--ui-font-clean);
            box-shadow: 0 4px 0 #3e2b12;
            transition: transform 0.1s;
        }

        .btn:active {
            transform: translateY(4px);
            box-shadow: none;
        }

        .damage-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, transparent 50%, rgba(101, 67, 33, 0.6) 100%);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s;
            z-index: 5;
        }

        .mobile-hint {
            display: none;
            position: absolute;
            bottom: 50px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.5);
            font-size: 14px;
            pointer-events: none;
        }
        
        @media (hover: none) and (pointer: coarse) {
            .mobile-hint {
                display: block;
            }
        }
        
        @keyframes item-pickup {
            0% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
            100% { transform: translate(-50%, -150%) scale(1.5); opacity: 0; }
        }
        .pickup-effect {
            position: absolute;
            font-size: 30px;
            color: #ff4d4d;
            animation: item-pickup 0.8s ease-out forwards;
            pointer-events: none;
            z-index: 25;
        }

        @keyframes speech-float {
            0% { transform: translate(-50%, 0) scale(1); opacity: 1; }
            50% { transform: translate(-50%, -15px) scale(1.1); opacity: 0.9; }
            100% { transform: translate(-50%, -30px) scale(1); opacity: 0; }
        }
        .villain-speech {
            position: absolute;
            color: #fffdd0; 
            font-family: var(--ui-font-title); 
            font-size: 24px;
            font-weight: bold;
            white-space: nowrap;
            pointer-events: none;
            z-index: 26;
            animation: speech-float 1.5s ease-out forwards;
            text-shadow: 1px 1px 0px #ccc, 0 0 5px rgba(255, 255, 200, 0.8); 
        }
        
        .sticky-text {
            color: #fffdd0 !important; 
            font-family: var(--ui-font-title);
            text-shadow: 1px 1px 2px #555, 0 0 5px rgba(255,255,255,0.8);
        }
        
        .sticky-large-text {
            color: #fffdd0 !important;
            font-family: var(--ui-font-title);
            font-size: 50px !important;
            font-weight: bold;
            text-shadow: 2px 2px 5px rgba(0,0,0,0.5), 0 0 10px rgba(255,255,255,0.8);
            animation: float-up 2.0s ease-out forwards;
            z-index: 101 !important;
        }

        .unwashed-text {
            color: #F0F8FF !important; 
            font-family: var(--ui-font-title);
            font-size: 45px !important;
            font-weight: bold;
            text-shadow: 2px 2px 2px #aaa, 0 0 10px rgba(255, 255, 240, 0.9);
            animation: float-up 2.5s ease-out forwards;
            z-index: 102 !important;
        }

        .condensed-milk-text {
            color: #FFFDD0 !important;
            font-family: var(--ui-font-title);
            font-size: 30px !important;
            font-weight: bold;
            text-shadow: 1px 1px 2px #555, 0 0 8px rgba(255,255,220,0.9);
            animation: float-up 2.0s ease-out forwards;
            z-index: 100 !important;
        }

        .dirty-pink-text {
            color: #d45d7d !important;
            font-family: var(--ui-font-title);
            font-size: 50px !important;
            font-weight: bold;
            text-shadow: 2px 2px 0px #330011, 0 0 10px #ff0066;
            animation: float-up 1.0s ease-out forwards;
            z-index: 102 !important;
        }
        
        .dirty-brown-text { 
            color: #8B4513 !important; 
            font-family: var(--ui-font-title); 
            font-size: 26px !important; 
            font-weight: bold; 
            text-shadow: 1px 1px 2px #000; 
            animation: float-up 1.0s ease-out forwards; 
            z-index: 102 !important; 
        }

        .pink-text { 
            color: #FF69B4 !important; 
            font-family: var(--ui-font-title); 
            font-size: 40px !important; 
            font-weight: bold; 
            text-shadow: 1px 1px 2px #000; 
            animation: float-up 1.5s ease-out forwards; 
            z-index: 102 !important; 
        }
        
        .deep-pink-text {
            color: #FF1493 !important;
            font-family: var(--ui-font-title);
            font-size: 40px !important;
            font-weight: bold;
            text-shadow: 2px 2px 0px #8B008B, 0 0 15px #FF69B4;
            animation: float-up 1.5s ease-out forwards;
            z-index: 102 !important;
        }
        
        .evil-purple-text {
            color: #8A2BE2 !important;
            font-family: var(--ui-font-title);
            font-size: 50px !important;
            font-weight: bold;
            text-shadow: 2px 2px 0px #2a0033, 0 0 15px #4B0082;
            animation: float-up 1.2s ease-out forwards;
            z-index: 102 !important;
        }

        .shadow-text {
            color: #2F4F4F !important;
            font-family: var(--ui-font-title);
            font-size: 45px !important;
            font-weight: bold;
            text-shadow: 2px 2px 0 #000, 0 0 10px #708090;
            animation: float-up 1.0s ease-out forwards;
            z-index: 102 !important;
        }

        .poop-text {
            color: #5c4033 !important; 
            font-family: var(--ui-font-title);
            font-size: 45px !important; 
            font-weight: bold;
            text-shadow: 3px 3px 0px #2a1a0a, 0 0 15px rgba(60, 40, 0, 0.9);
            animation: float-up 1.8s ease-out forwards;
            z-index: 100 !important;
        }

        .evil-summon-text {
            color: #9400D3 !important; 
            font-family: var(--ui-font-title);
            font-size: 60px !important; 
            font-weight: bold;
            text-shadow: 5px 5px 0px #000000, 0 0 30px rgba(75, 0, 130, 1);
            animation: float-up 3s ease-out forwards; 
            z-index: 100 !important;
        }
        
        .wicked-large-text {
            color: #3d004d !important;
            font-family: var(--ui-font-title);
            font-size: 90px !important;
            font-weight: bold;
            text-shadow: 4px 4px 0px #000000, 0 0 30px #800080;
            animation: float-up 3.5s ease-out forwards;
            z-index: 102 !important;
        }
        
        .boss-warning-text {
            color: #ff0000 !important;
            font-family: var(--ui-font-title);
            font-size: 40px !important;
            text-shadow: 3px 3px 0px #000, 0 0 20px rgba(255, 0, 0, 0.8);
            animation: float-up 2s ease-out forwards;
        }
        
        .mind-break-text {
            color: #800080 !important;
            font-family: var(--ui-font-title);
            font-size: 30px !important;
            text-shadow: 2px 2px 0px #000, 0 0 15px rgba(128, 0, 128, 0.8);
            animation: float-up 1.5s ease-out forwards;
        }

        .pregnancy-text, .evil-shout-text {
            color: #8A2BE2 !important; 
            font-family: var(--ui-font-title);
            font-size: 70px !important; 
            font-weight: bold;
            text-shadow: 4px 4px 0px #000000, 0 0 20px rgba(75, 0, 130, 1);
            animation: float-up 2.5s ease-out forwards;
            z-index: 101 !important;
        }

        .choke-text {
            color: #2F4F4F !important; 
            font-family: var(--ui-font-title);
            font-size: 40px !important;
            font-weight: bold;
            text-shadow: 2px 2px 0px #000, 0 0 10px rgba(50, 205, 50, 0.6);
            animation: float-up 2.0s ease-out forwards;
            z-index: 100 !important;
        }

        .fishy-text {
            color: #7FFFD4 !important;
            font-family: var(--ui-font-title);
            font-size: 40px !important;
            font-weight: bold;
            text-shadow: 2px 2px 0px #008080, 0 0 15px rgba(127, 255, 212, 0.8);
            animation: float-up 2.0s ease-out forwards;
            z-index: 101 !important;
        }
        
        .hollow-night-text {
            color: #9370DB !important;
            font-family: var(--ui-font-title);
            font-size: 60px !important;
            text-shadow: 0 0 10px #8A2BE2, 0 0 20px #4B0082;
            animation: float-up 2.5s ease-out forwards;
            z-index: 100 !important;
        }

        .malice-text {
            color: #8A2BE2 !important;
            font-family: var(--ui-font-title);
            font-size: 35px !important;
            font-weight: bold;
            text-shadow: 2px 2px 0px #4B0082, 0 0 15px rgba(138, 43, 226, 0.8);
            animation: float-up 2.0s ease-out forwards;
            z-index: 101 !important;
        }

        .corrupted-text {
            color: #8B0000 !important;
            font-family: var(--ui-font-title);
            font-size: 40px !important;
            font-weight: bold;
            text-shadow: 2px 2px 0px #000000, 0 0 15px #3f0000;
            animation: float-up 2.0s ease-out forwards;
            z-index: 102 !important;
        }
        
        .sniper-text {
            color: #FFFFFF !important;
            font-family: var(--ui-font-title);
            font-size: 35px !important;
            font-weight: bold;
            text-shadow: 1px 1px 0px #000, 0 0 10px rgba(255, 255, 255, 0.8);
            animation: float-up 1.5s ease-out forwards;
            z-index: 102 !important;
        }
        
        .ozma-text {
            color: #FF00FF !important;
            font-family: var(--ui-font-title);
            font-size: 40px !important;
            font-weight: bold;
            text-shadow: 2px 2px 0px #4B0082, 0 0 15px #FF1493;
            animation: float-up 1.5s ease-out forwards;
            z-index: 102 !important;
        }

        .gawain-text {
            color: #9370DB !important; /* MediumPurple */
            font-family: var(--ui-font-title);
            font-size: 40px !important;
            font-weight: bold;
            text-shadow: 2px 2px 0 #4B0082, 0 0 15px #FFFFFF;
            animation: float-up 1.5s ease-out forwards;
            z-index: 102 !important;
        }
        
        .aki-text {
            color: #1a1a1a !important; /* Very Dark Gray */
            font-family: var(--ui-font-title);
            font-size: 40px !important;
            font-weight: bold;
            text-shadow: 2px 2px 0 #4B0082, 0 0 15px #000000;
            animation: float-up 1.5s ease-out forwards;
            z-index: 102 !important;
        }

        .hiro-text {
            color: #9932CC !important; /* DarkOrchid */
            font-family: var(--ui-font-title);
            font-size: 40px !important;
            font-weight: bold;
            text-shadow: 2px 2px 0 #000, 0 0 15px #8B008B;
            animation: float-up 1.5s ease-out forwards;
            z-index: 102 !important;
        }
        
        .arthur-text {
            color: #DC143C !important; /* Crimson */
            font-family: var(--ui-font-title);
            font-size: 45px !important;
            font-weight: bold;
            text-shadow: 2px 2px 0 #000, 0 0 15px #8B0000;
            animation: float-up 1.5s ease-out forwards;
            z-index: 102 !important;
        }

        .goddess-text {
            color: #FFD700 !important;
            font-family: var(--ui-font-title);
            font-size: 50px !important;
            font-weight: bold;
            text-shadow: 2px 2px 0 #000, 0 0 20px #FFA500;
            animation: float-up 2s ease-out forwards;
            z-index: 200 !important;
        }
         #xp-bar-container {
            position: absolute;
            top: 60px; /* HP바 아래 */
            left: 20px;
            width: 300px;
            height: 15px;
            background: #222;
            border: 2px solid #fff;
            border-radius: 8px;
            overflow: hidden;
            z-index: 20;
        }
        #xp-bar {
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #8BC34A);
            transition: width 0.2s;
        }
        #level-text {
            position: absolute;
            top: 58px;
            left: 330px;
            color: #fff;
            font-size: 20px;
            font-weight: bold;
            text-shadow: 1px 1px 0 #000;
            z-index: 20;
        }

        #levelUpModal {
            display: none;
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.85);
            z-index: 9999;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            pointer-events: auto;
        }
        #levelUpTitle {
            font-family: var(--ui-font-title);
            font-size: 50px;
            color: #FFD700;
            margin-bottom: 30px;
            text-shadow: 0 0 10px #FFA500;
            animation: float-up 1s infinite alternate;
        }
        .card-container {
            display: flex;
            gap: 20px;
        }
        .upgrade-card {
            width: 220px;
            height: 300px;
            background: #333;
            border-radius: 15px;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: space-between;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            border: 3px solid #555;
            text-align: center;
            color: white;
            font-family: var(--ui-font-clean);
        }
        .upgrade-card.selected {
            transform: translateY(-10px);
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
            border-color: #ffffff; /* 선택됨을 명확히 하기 위해 흰색 테두리 */
            background-color: #444; /* 배경도 살짝 밝게 */
        }
        .upgrade-card:hover {
            transform: translateY(-10px);
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.3);
        }
        .card-rarity { font-size: 18px; margin-bottom: 10px; }
        .card-name { font-size: 24px; color: #fff; margin-bottom: 10px; }
        .card-desc { font-size: 16px; color: #ccc; word-break: keep-all; }
        .card-stat { font-size: 30px; font-weight: bold; margin-top: 10px; }

        /* 등급별 스타일 */
        .rarity-common { border-color: #b0b0b0; box-shadow: 0 0 5px #b0b0b0; }
        .rarity-rare { border-color: #00BFFF; box-shadow: 0 0 10px #00BFFF; }
        .rarity-unique { border-color: #9370DB; box-shadow: 0 0 15px #9370DB; }
        .rarity-legendary { border-color: #FFD700; box-shadow: 0 0 20px #FFD700; animation: blink-border 1s infinite; }
        
        .rarity-text-common { color: #b0b0b0; }
        .rarity-text-rare { color: #00BFFF; }
        .rarity-text-unique { color: #9370DB; }
        .rarity-text-legendary { color: #FFD700; }
        
        /* [신규] 로열 빌런 텍스트 스타일 (검정/청록 테마) */
        .masakuni-text {
            color: #2F4F4F !important; /* DarkSlateGray */
            font-family: var(--ui-font-title);
            font-size: 45px !important;
            font-weight: bold;
            text-shadow: 2px 2px 0px #000000, 0 0 15px #00CED1;
            animation: float-up 1.5s ease-out forwards;
            z-index: 105 !important;
        }

        /* [신규] 스탯 확인 버튼 스타일 */
        #showStatsBtn {
            margin-top: 20px;
            padding: 10px 20px;
            font-size: 20px;
            background: #444;
            color: #fff;
            border: 2px solid #fff;
            border-radius: 10px;
            cursor: pointer;
            font-family: var(--ui-font-clean);
            transition: 0.2s;
        }
        #showStatsBtn:hover {
            background: #666;
        }

        /* [신규] 스탯 정보창 스타일 */
        #statsInfoBox {
            display: none; /* 기본적으로 숨김 */
            position: fixed;
            pointer-events: auto;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 350px;
            background: rgba(0, 0, 0, 0.95);
            border: 3px solid #FFD700;
            border-radius: 15px;
            padding: 20px;
            color: white;
            font-family: var(--ui-font-clean);
            z-index: 10000;
            box-shadow: 0 0 20px rgba(0,0,0,0.8);
            text-align: left;
        }
        .stat-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 18px;
            border-bottom: 1px solid #444;
            padding-bottom: 4px;
        }
        .stat-label { color: #ccc; }
        .stat-value { color: #FFD700; font-weight: bold; }
        #closeStatsBtn {
            margin-top: 15px;
            width: 100%;
            padding: 10px;
            background: #8B0000;
            color: white;
            border: none;
            font-size: 18px;
            cursor: pointer;
            font-family: var(--ui-font-clean);
        }
    
        /* =========================================================
           [신규] 인벤토리 / 장비 강화 UI
        ========================================================= */
        #gearPanel {
            display: none;
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.80);
            z-index: 15000;
            justify-content: center;
            align-items: center;
            pointer-events: auto;
        }
        .modal-panel {
            width: min(1120px, 96vw);
            max-height: 92vh;
            background: rgba(20, 20, 24, 0.95);
            color: rgba(255,255,255,0.92);
            font-family: var(--ui-font-clean);
            border: 2px solid rgba(255, 255, 255, 0.12);
            border-radius: 16px;
            box-shadow: 0 0 30px rgba(0,0,0,0.7), 0 0 20px rgba(255,255,255,0.08) inset;
            padding: 18px 18px 16px 18px;
            overflow: hidden;
        }
        .modal-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            margin-bottom: 14px;
        }
        .modal-title {
            font-family: var(--ui-font-title);
            font-size: 32px;
            color: #ffffff;
            text-shadow: 0 0 12px rgba(255,255,255,0.18);
            line-height: 1.1;
        }
        .modal-sub {
            margin-top: 4px;
            font-size: 14px;
            color: rgba(255,255,255,0.7);
        }
        .modal-close {
            pointer-events: auto;
            padding: 10px 14px;
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.18);
            border-radius: 12px;
            color: #fff;
            font-family: var(--ui-font-clean);
            font-size: 16px;
            cursor: pointer;
            transition: transform 0.12s ease, box-shadow 0.12s ease;
        }
        .modal-close:hover {
            transform: translateY(-1px);
            box-shadow: 0 0 14px rgba(255,255,255,0.10);
        }

        /* Inventory grid */
        .inventory-grid {
            /* slot size scales with viewport; columns auto-adjust via --inv-cols */
            --inv-cols: 8;
            --inv-gap: 10px;
            display: grid;
            grid-template-columns: repeat(var(--inv-cols), minmax(0, 1fr));
            gap: var(--inv-gap);
            padding: 8px 6px;
            background: rgba(255,255,255,0.03);
            border: 1px solid rgba(255,255,255,0.10);
            border-radius: 14px;
            max-height: calc(88vh - 120px);
            overflow: auto;
            align-content: start;
            align-items: start;
        }
        .inv-slot {
            position: relative;
            /* RPG 코너 장식(룬/리벳)용 변수 */
            --slot-orn: rgba(255,255,255,0.10);
            --slot-orn-strong: rgba(255,255,255,0.18);
            --slot-rivet: rgba(255,255,255,0.26);
            width: 100%;
            padding-top: 100%;
            border-radius: 14px;
            background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.08), rgba(0,0,0,0.35));
            border: 1px solid rgba(255,255,255,0.14);
            box-shadow: 0 0 12px rgba(0,0,0,0.35) inset;
            overflow: hidden;
        }

        .inv-slot::before{
            content:'';
            position:absolute;
            inset:0;
            border-radius: inherit;
            pointer-events:none;
            opacity: 0.78;
            background:
                /* 철제 리벳(4코너) */
                radial-gradient(circle at 10px 10px, var(--slot-rivet) 0 2px, rgba(0,0,0,0) 2.8px),
                radial-gradient(circle at calc(100% - 10px) 10px, var(--slot-rivet) 0 2px, rgba(0,0,0,0) 2.8px),
                radial-gradient(circle at 10px calc(100% - 10px), var(--slot-rivet) 0 2px, rgba(0,0,0,0) 2.8px),
                radial-gradient(circle at calc(100% - 10px) calc(100% - 10px), var(--slot-rivet) 0 2px, rgba(0,0,0,0) 2.8px),

                /* 코너 브라켓 */
                linear-gradient(to right, var(--slot-orn-strong), rgba(0,0,0,0)) left 8px top 8px/28px 2px no-repeat,
                linear-gradient(to bottom, var(--slot-orn-strong), rgba(0,0,0,0)) left 8px top 8px/2px 28px no-repeat,

                linear-gradient(to left, var(--slot-orn-strong), rgba(0,0,0,0)) right 8px top 8px/28px 2px no-repeat,
                linear-gradient(to bottom, var(--slot-orn-strong), rgba(0,0,0,0)) right 8px top 8px/2px 28px no-repeat,

                linear-gradient(to right, var(--slot-orn-strong), rgba(0,0,0,0)) left 8px bottom 8px/28px 2px no-repeat,
                linear-gradient(to top, var(--slot-orn-strong), rgba(0,0,0,0)) left 8px bottom 8px/2px 28px no-repeat,

                linear-gradient(to left, var(--slot-orn-strong), rgba(0,0,0,0)) right 8px bottom 8px/28px 2px no-repeat,
                linear-gradient(to top, var(--slot-orn-strong), rgba(0,0,0,0)) right 8px bottom 8px/2px 28px no-repeat,

                /* 룬 문양(교차) */
                linear-gradient(45deg, transparent 46%, var(--slot-orn) 46% 54%, transparent 54%) left 12px top 12px/14px 14px no-repeat,
                linear-gradient(-45deg, transparent 46%, var(--slot-orn) 46% 54%, transparent 54%) left 12px top 12px/14px 14px no-repeat,

                linear-gradient(45deg, transparent 46%, var(--slot-orn) 46% 54%, transparent 54%) right 12px top 12px/14px 14px no-repeat,
                linear-gradient(-45deg, transparent 46%, var(--slot-orn) 46% 54%, transparent 54%) right 12px top 12px/14px 14px no-repeat,

                linear-gradient(45deg, transparent 46%, var(--slot-orn) 46% 54%, transparent 54%) left 12px bottom 12px/14px 14px no-repeat,
                linear-gradient(-45deg, transparent 46%, var(--slot-orn) 46% 54%, transparent 54%) left 12px bottom 12px/14px 14px no-repeat,

                linear-gradient(45deg, transparent 46%, var(--slot-orn) 46% 54%, transparent 54%) right 12px bottom 12px/14px 14px no-repeat,
                linear-gradient(-45deg, transparent 46%, var(--slot-orn) 46% 54%, transparent 54%) right 12px bottom 12px/14px 14px no-repeat;
        }

        .inv-slot-inner {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .inv-icon {
            width: 92%;
            height: 92%;
            object-fit: contain;
            image-rendering: auto;
            filter: drop-shadow(0 2px 6px rgba(0,0,0,0.65));
        }
        .inv-count {
            position: absolute;
            right: 5px;
            bottom: 4px;
            padding: 1px 5px;
            border-radius: 999px;
            background: rgba(0,0,0,0.55);
            border: 1px solid rgba(255,255,255,0.16);
            color: #fff;
            font-size: 11px;
            font-weight: 700;
            line-height: 1;
            text-shadow: 0 0 4px rgba(0,0,0,0.8);
        }
        .inv-empty-hint {
            opacity: 0.35;
            font-size: 12px;
            color: rgba(255,255,255,0.55);
        }

        /* Responsive inventory: fewer columns on small screens => bigger icons/slots */
        @media (max-width: 1200px) { .inventory-grid { --inv-cols: 7; } }
        @media (max-width: 980px)  { .inventory-grid { --inv-cols: 6; } }
        @media (max-width: 720px)  { .inventory-grid { --inv-cols: 5; } }
        @media (max-width: 520px)  { .inventory-grid { --inv-cols: 4; } }
        @media (max-width: 380px)  { .inventory-grid { --inv-cols: 3; } }


/* Inventory tooltip */
.inv-tooltip {
    position: fixed;
    z-index: 20000;
    max-width: 320px;
    background: rgba(12, 12, 16, 0.96);
    border: 1px solid rgba(255, 255, 255, 0.18);
    border-radius: 14px;
    padding: 10px 12px;
    color: #fff;
    font-family: var(--ui-font-clean);
    font-size: 14px;
    line-height: 1.35;
    box-shadow: 0 12px 34px rgba(0,0,0,0.62), 0 0 18px rgba(255,255,255,0.06) inset;
    pointer-events: none;
    display: none;
    backdrop-filter: blur(6px);
}
.inv-tooltip .tt-name {
    font-weight: 800;
    font-size: 15px;
    margin-bottom: 4px;
    letter-spacing: -0.2px;
}
.inv-tooltip .tt-desc {
    color: rgba(255,255,255,0.82);
    font-size: 13px;
}
.inv-tooltip .tt-meta {
    margin-top: 8px;
    font-size: 12px;
    color: rgba(255,255,255,0.58);
}
.inv-tooltip[data-cat="normal"] { border-color: rgba(46,204,113,0.55); }
.inv-tooltip[data-cat="elite"]  { border-color: rgba(212,175,55,0.55); }
.inv-tooltip[data-cat="royal"]  { border-color: rgba(138,43,226,0.55); }
.inv-tooltip[data-cat="boss"]   { border-color: rgba(220,20,60,0.55); }

        
        

        /* =========================================================
           [NEW] 장비 인벤토리 / 장착 UI
        ========================================================= */
        #equipPanel {
            display: none;
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.80);
            justify-content: center;
            align-items: center;
            z-index: 1200;
            pointer-events: auto;
        }
        #equipPanel .modal-panel.equip-modal { width: min(1320px, 96vw); }

        .equip-layout { display:flex; gap:14px; }
        .equip-left { width: 400px; flex: 0 0 400px; }
        .equip-right { flex:1; min-width: 0; }

        .equip-slots-grid {
            display: grid;
            grid-template-columns: repeat(2, minmax(0, 1fr));
            gap: 10px;
            margin-top: 10px;
        }
        .equip-slot.long-name { grid-column: span 2; }
        .equip-slot {
            border: 1px solid rgba(255,255,255,0.15);
            border-radius: 14px;
            padding: 14px 14px;
            display:flex;
            gap:12px;
            align-items:center;
            cursor:pointer;
            background: rgba(0,0,0,0.25);
            user-select: none;
        
            position: relative;
            padding-right: 38px; /* 우상단 잠금 배지 공간 */
        }
        .equip-slot.selected { outline: 2px solid rgba(255,255,255,0.35); }
        .equip-slot .slot-icon { width: 56px; height: 56px; border-radius: 14px; background: rgba(255,255,255,0.06); display:flex; align-items:center; justify-content:center; overflow:hidden; }
        .equip-slot .slot-icon img { width: 100%; height: 100%; object-fit: contain; }
        .equip-slot .slot-text { line-height: 1.1; min-width: 0; }
        .equip-slot .slot-name { font-weight: 800; font-size: 12px; }
        .equip-slot .item-name {
            font-size: 12px;
            opacity: 0.92;
            white-space: normal;
            overflow: visible;
            text-overflow: clip;
            max-width: none;
            word-break: break-word;
            line-height: 1.15;
        }
        .equip-slot .item-empty {
            font-size: 14px;
            opacity: 0.55;
            white-space: normal;
            overflow: visible;
            text-overflow: clip;
            max-width: none;
            word-break: break-word;
            line-height: 1.2;
        }

        .equip-stats-summary {
            margin-top: 8px;
            padding: 10px;
            border-radius: 12px;
            border: 1px solid rgba(255,255,255,0.12);
            background: rgba(0,0,0,0.22);
            font-size: 14px;
            line-height: 1.5;
            max-height: 300px;
            overflow: auto;
        }

        .gear-inventory-grid { max-height: clamp(360px, 48vh, 680px); }

        .gear-actions { margin-top: 10px; display:flex; align-items:center; gap: 10px; flex-wrap: wrap; }
        .gear-selection { flex: 1; min-width: 220px; font-size: 12px; opacity: 0.95; }
        .gear-actions-buttons { display:flex; gap:8px; }

        .gear-btn {
            padding: 8px 10px;
            border-radius: 12px;
            border: 1px solid rgba(255,255,255,0.18);
            background: rgba(255,255,255,0.06);
            color: #fff;
            font-size: 12px;
            cursor: pointer;
            white-space: nowrap;
        }
        .gear-btn:hover { background: rgba(255,255,255,0.10); }
        .gear-btn:disabled { opacity: 0.35; cursor: not-allowed; }
        .gear-btn.danger { border-color: rgba(255,80,80,0.35); background: rgba(255,80,80,0.08); }
        .gear-btn.danger:hover { background: rgba(255,80,80,0.14); }

        .gear-hint {
            margin-top: 10px;
            font-size: 12px;
            opacity: 0.65;
            line-height: 1.4;
        }

        /* Responsive equip UI: stack panels + larger touch targets on small screens */
        @media (max-width: 980px) {
            .equip-layout { flex-direction: column; }
            .equip-left { width: auto; flex: 1 1 auto; }
            .equip-slot .item-name,
            .equip-slot .item-empty { max-width: none; }
        }
        @media (max-width: 720px) {
            .equip-slots-grid { grid-template-columns: 1fr; gap: 12px; }
            .equip-slot.long-name { grid-column: auto; }
            .equip-slot { padding: 16px 16px; }
            .equip-slot .slot-icon { width: 64px; height: 64px; }
            .equip-slot .slot-name { font-size: 13px; }
            .equip-slot .item-name,
            .equip-slot .item-empty { font-size: 15px; }
        }


        /* 장비 슬롯(인벤토리) - 등급별 테두리 */
        .inv-slot[data-gear-rarity="common"]    { border-color: rgba(176,176,176,0.35); }
        .inv-slot[data-gear-rarity="uncommon"]  { border-color: rgba(76,217,100,0.38); }
        .inv-slot[data-gear-rarity="rare"]      { border-color: rgba(74,144,226,0.45); }
        .inv-slot[data-gear-rarity="epic"]      { border-color: rgba(155,89,182,0.45); }
        .inv-slot[data-gear-rarity="unique"]    { border-color: rgba(241,196,15,0.50); }
        .inv-slot[data-gear-rarity="legendary"] { border-color: rgba(255,140,0,0.55); box-shadow: 0 0 12px rgba(255,140,0,0.12); }
        .inv-slot[data-gear-rarity="demonic"]   { border-color: rgba(255,59,48,0.55); box-shadow: 0 0 12px rgba(255,59,48,0.12); }
        .inv-slot[data-gear-rarity="angelic"]   { border-color: rgba(220,255,255,0.65); box-shadow: 0 0 12px rgba(220,255,255,0.16); }

        .inv-slot[data-gear-equipped="1"] { outline: 2px solid rgba(255,255,255,0.28); }

        /* 장비 툴팁: 등급별 테두리 */
        .inv-tooltip[data-rarity="common"]    { border-color: rgba(176,176,176,0.70); }
        .inv-tooltip[data-rarity="uncommon"]  { border-color: rgba(76,217,100,0.70); }
        .inv-tooltip[data-rarity="rare"]      { border-color: rgba(74,144,226,0.70); }
        .inv-tooltip[data-rarity="epic"]      { border-color: rgba(155,89,182,0.70); }
        .inv-tooltip[data-rarity="unique"]    { border-color: rgba(241,196,15,0.75); }
        .inv-tooltip[data-rarity="legendary"] { border-color: rgba(255,140,0,0.78); }
        .inv-tooltip[data-rarity="demonic"]   { border-color: rgba(255,59,48,0.78); }
        .inv-tooltip[data-rarity="angelic"]   { border-color: rgba(220,255,255,0.85); }


/* =========================================================
   [UI ENHANCE] 장비 등급 텍스트/글로우/네임드 차별화
========================================================= */
.rarity-name {
    font-weight: 900;
    letter-spacing: -0.2px;
    text-shadow: 0 0 10px rgba(0,0,0,0.55);
}
.rarity-common    { color: #d0d0d0; text-shadow: 0 0 10px rgba(176,176,176,0.18), 0 0 12px rgba(0,0,0,0.45); }
.rarity-uncommon  { color: #7CFF92; text-shadow: 0 0 10px rgba(76,217,100,0.22), 0 0 14px rgba(0,0,0,0.45); }
.rarity-rare      { color: #7DB8FF; text-shadow: 0 0 10px rgba(74,144,226,0.25), 0 0 14px rgba(0,0,0,0.45); }
.rarity-epic      { color: #D49BFF; text-shadow: 0 0 10px rgba(155,89,182,0.28), 0 0 14px rgba(0,0,0,0.45); }
.rarity-unique    { color: #FFE066; text-shadow: 0 0 12px rgba(241,196,15,0.28), 0 0 16px rgba(0,0,0,0.45); }
.rarity-legendary {
    background: linear-gradient(90deg, #fff2b3, #ff8c00, #ffe9a6);
    -webkit-background-clip: text;
    background-clip: text;
    color: transparent;
    text-shadow: 0 0 14px rgba(255,140,0,0.35), 0 0 24px rgba(255,215,0,0.18), 0 0 10px rgba(0,0,0,0.55);
}
.rarity-demonic {
    background: linear-gradient(90deg, #ff9aa3, #ff3b30, #b400ff);
    -webkit-background-clip: text;
    background-clip: text;
    color: transparent;
    text-shadow: 0 0 16px rgba(255,59,48,0.35), 0 0 26px rgba(180,0,255,0.18), 0 0 10px rgba(0,0,0,0.55);
}
.rarity-angelic {
    background: linear-gradient(90deg, #ffffff, #bfffff, #ffe9a6);
    -webkit-background-clip: text;
    background-clip: text;
    color: transparent;
    text-shadow: 0 0 16px rgba(220,255,255,0.35), 0 0 28px rgba(255,233,166,0.16), 0 0 10px rgba(0,0,0,0.55);
}

.named-badge {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    padding: 2px 8px;
    border-radius: 999px;
    font-size: 11px;
    font-weight: 800;
    letter-spacing: -0.2px;
    background: rgba(255,255,255,0.08);
    border: 1px solid rgba(255,255,255,0.18);
    color: rgba(255,255,255,0.92);
    margin-left: 8px;
}
.named-badge .dot {
    width: 6px;
    height: 6px;
    border-radius: 999px;
    background: rgba(255,255,255,0.82);
    box-shadow: 0 0 10px rgba(255,255,255,0.28);
}

/* equip panel selection */
#equipPanel .inv-slot.selected {
    outline: 2px solid rgba(120,190,255,0.75);
    box-shadow: 0 0 0 2px rgba(120,190,255,0.18), 0 0 18px rgba(120,190,255,0.10);
}
#equipPanel .inv-slot[data-gear-named="1"]::after {
    content: "✦";
    position: absolute;
    right: 8px;
    top: 6px;
    font-size: 12px;
    font-weight: 900;
    color: rgba(255,255,255,0.92);
    text-shadow: none;
    pointer-events: none;
}

/* gear tag in equip inventory */
#equipPanel #gearInventoryGrid .inv-reserved {
    display: none;
    left: 6px;
    top: auto;
    bottom: 6px;
    background: rgba(255,255,255,0.06);
    border: 1px solid rgba(255,255,255,0.14);
    color: rgba(255,255,255,0.86);

    font-size: 6.5px;
    padding: 1px 3px;
    letter-spacing: 0.2px;
}

/* Icon glow animations (Legendary+) */
@keyframes gearGlowLegendary {
    0%   { filter: drop-shadow(0 0 6px rgba(255,140,0,0.30)) drop-shadow(0 0 0 rgba(255,215,0,0.0)) saturate(1.08) brightness(1.02); transform: translateY(0) scale(1.0); }
    50%  { filter: drop-shadow(0 0 14px rgba(255,140,0,0.70)) drop-shadow(0 0 22px rgba(255,215,0,0.26)) saturate(1.28) brightness(1.10); transform: translateY(-0.8px) scale(1.035); }
    100% { filter: drop-shadow(0 0 6px rgba(255,140,0,0.30)) drop-shadow(0 0 0 rgba(255,215,0,0.0)) saturate(1.08) brightness(1.02); transform: translateY(0) scale(1.0); }
}
@keyframes gearGlowDemonic {
    0%   { filter: drop-shadow(0 0 7px rgba(255,59,48,0.30)) drop-shadow(0 0 0 rgba(180,0,255,0.0)) saturate(1.10) brightness(1.02); transform: translateY(0) scale(1.0) rotate(0deg); }
    50%  { filter: drop-shadow(0 0 16px rgba(255,59,48,0.72)) drop-shadow(0 0 24px rgba(180,0,255,0.28)) saturate(1.35) brightness(1.08) contrast(1.06); transform: translateY(-0.8px) scale(1.04) rotate(-1deg); }
    100% { filter: drop-shadow(0 0 7px rgba(255,59,48,0.30)) drop-shadow(0 0 0 rgba(180,0,255,0.0)) saturate(1.10) brightness(1.02); transform: translateY(0) scale(1.0) rotate(0deg); }
}
@keyframes gearGlowAngelic {
    0%   { filter: drop-shadow(0 0 7px rgba(220,255,255,0.26)) drop-shadow(0 0 0 rgba(255,233,166,0.0)) saturate(1.10) brightness(1.04); transform: translateY(0) scale(1.0); }
    50%  { filter: drop-shadow(0 0 16px rgba(220,255,255,0.70)) drop-shadow(0 0 26px rgba(255,233,166,0.30)) saturate(1.30) brightness(1.12); transform: translateY(-0.9px) scale(1.045); }
    100% { filter: drop-shadow(0 0 7px rgba(220,255,255,0.26)) drop-shadow(0 0 0 rgba(255,233,166,0.0)) saturate(1.10) brightness(1.04); transform: translateY(0) scale(1.0); }
}

#equipPanel .inv-slot[data-gear-rarity="legendary"] .inv-icon { animation: gearGlowLegendary 1.6s ease-in-out infinite; }
#equipPanel .inv-slot[data-gear-rarity="demonic"]   .inv-icon { animation: gearGlowDemonic  1.5s ease-in-out infinite; }
#equipPanel .inv-slot[data-gear-rarity="angelic"]   .inv-icon { animation: gearGlowAngelic  1.7s ease-in-out infinite; }

#equipPanel .equip-slot[data-rarity="legendary"] img { animation: gearGlowLegendary 1.6s ease-in-out infinite; }
#equipPanel .equip-slot[data-rarity="demonic"]   img { animation: gearGlowDemonic  1.5s ease-in-out infinite; }
#equipPanel .equip-slot[data-rarity="angelic"]   img { animation: gearGlowAngelic  1.7s ease-in-out infinite; }
/* Tooltip sections for gear */
.inv-tooltip .tt-section {
    margin-top: 8px;
    padding-top: 8px;
    border-top: 1px solid rgba(255,255,255,0.10);
}
.inv-tooltip .tt-section-title {
    font-size: 12px;
    font-weight: 900;
    opacity: 0.9;
    margin-bottom: 4px;
    letter-spacing: -0.2px;
}
.inv-tooltip .tt-line {
    display: flex;
    justify-content: space-between;
    gap: 10px;
    font-size: 13px;
    line-height: 1.35;
}
.inv-tooltip .tt-line span:last-child {
    font-weight: 800;
    opacity: 0.95;
}

.inv-tooltip .tt-line .tt-v {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    justify-content: flex-end;
    min-width: 110px;
}
.tier-badge {
    font-size: 10px;
    padding: 1px 6px;
    border-radius: 999px;
    border: 1px solid rgba(255,255,255,0.18);
    background: rgba(255,255,255,0.08);
    font-weight: 900;
    letter-spacing: -0.2px;
    line-height: 1.2;
    transform: translateY(-0.5px);
}
.tier-T1 { color: #ffe9a6; border-color: rgba(255,233,166,0.42); box-shadow: 0 0 10px rgba(255,233,166,0.14); }
.tier-T2 { color: #ffd27a; border-color: rgba(255,210,120,0.36); box-shadow: 0 0 8px rgba(255,210,120,0.10); }
.tier-T3 { color: #cbd9ff; border-color: rgba(180,200,255,0.30); box-shadow: 0 0 8px rgba(180,200,255,0.08); }
.tier-T4 { color: #b8ffcc; border-color: rgba(150,255,200,0.26); box-shadow: 0 0 8px rgba(150,255,200,0.06); }
.tier-T5 { color: #e0e0e0; border-color: rgba(255,255,255,0.18); opacity: 0.88; }
.tt-tier-range { opacity: 0.62; font-weight: 700; margin-left: 6px; }


/* Enhance panel */
        .enhance-body {
            display: grid;
            grid-template-columns: 1fr;
            gap: 14px;
        }
        .gear-card {
            background: rgba(255,255,255,0.03);
            border: 1px solid rgba(255,255,255,0.10);
            border-radius: 14px;
            padding: 14px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            overflow: hidden;
        }
        .gear-top {
            display: flex;
            gap: 12px;
            align-items: center;
        }
        .gear-icon {
            width: 120px;
            height: 120px;
            border-radius: 14px;
            background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.10), rgba(0,0,0,0.30));
            border: 1px solid rgba(255,255,255,0.14);
            box-shadow: 0 0 16px rgba(0,0,0,0.45) inset;
            flex: 0 0 auto;
        }
        .gear-name {
            font-family: var(--ui-font-title);
            font-size: 22px;
            color: #fff;
            text-shadow: 0 0 10px rgba(255,255,255,0.14);
        }
        .gear-level {
            margin-top: 4px;
            font-size: 15px;
            color: rgba(255,255,255,0.75);
        }
        .gear-stats {
            margin-top: 8px;
            font-size: 14px;
            color: rgba(255,255,255,0.85);
            line-height: 1.35;
        }
        .gear-req {
            margin-top: 2px;
            padding: 10px 12px;
            border-radius: 12px;
            border: 1px solid rgba(255,255,255,0.10);
            background: rgba(0,0,0,0.25);
            font-size: 14px;
            color: rgba(255,255,255,0.88);
            line-height: 1.4;
        }
        .gear-actions {
            display: flex;
            gap: 10px;
            align-items: center;
            justify-content: flex-end;
        }
        .gear-btn {
            pointer-events: auto;
            padding: 10px 14px;
            border-radius: 12px;
            border: 1px solid rgba(255,255,255,0.18);
            background: linear-gradient(180deg, rgba(255,255,255,0.10), rgba(255,255,255,0.04));
            color: #fff;
            font-family: var(--ui-font-clean);
            font-size: 16px;
            cursor: pointer;
            transition: transform 0.12s ease, box-shadow 0.12s ease;
        }
        .gear-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 0 16px rgba(255,255,255,0.10);
        }
        .gear-btn:disabled {
            opacity: 0.45;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        .gear-mini {
            font-size: 13px;
            color: rgba(255,255,255,0.65);
        }

/* [Font] Enhance UI clean font */
#gearPanel {
    font-family: var(--ui-font-clean);
}
#gearPanel .modal-title {
    font-family: var(--ui-font-clean);
    font-weight: 800;
    letter-spacing: -0.6px;
}
#gearPanel .modal-sub,
#gearPanel .gear-level,
#gearPanel .gear-stats,
#gearPanel .gear-req,
#gearPanel .gear-mini {
    font-family: var(--ui-font-clean);
    letter-spacing: -0.2px;
}
#gearPanel .gear-name {
    font-family: var(--ui-font-clean);
    font-weight: 800;
    letter-spacing: -0.4px;
}
#gearPanel .gear-btn,
#gearPanel .modal-close {
    font-family: var(--ui-font-clean);
    font-weight: 700;
    letter-spacing: -0.2px;
}

        
        @media (max-width: 860px) {
            .enhance-body { grid-template-columns: 1fr; }
            .gear-icon { width: 96px; height: 96px; }
        }


        /* ==============================
           [NEW] Inventory + Enhance Panel
           ============================== */
        .gear-layout {
            display: grid;
            grid-template-columns: 1.15fr 0.85fr;
            gap: 14px;
            height: calc(88vh - 110px);
            min-height: 360px;
        }
        .panel-left, .panel-right {
            min-height: 0;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .panel-left { overflow: hidden; }
        .panel-right { overflow: auto; padding-right: 2px; }

        #gearPanel .inventory-grid {
            max-height: none;
            flex: 1;
        }

        .panel-section-title {
            font-family: var(--ui-font-clean);
            font-weight: 800;
            font-size: 15px;
            color: rgba(255,255,255,0.92);
            letter-spacing: -0.3px;
        }
        .panel-section-sub {
            margin-top: -6px;
            font-size: 12px;
            color: rgba(255,255,255,0.55);
            letter-spacing: -0.1px;
        }

        .panel-hint {
            margin-top: 8px;
            padding: 10px 12px;
            border-radius: 14px;
            border: 1px solid rgba(255,255,255,0.10);
            background: rgba(0,0,0,0.22);
        }
        .panel-hint-title {
            font-weight: 800;
            font-size: 13px;
            color: rgba(255,255,255,0.90);
            letter-spacing: -0.2px;
            margin-bottom: 6px;
        }
        .panel-hint-list {
            margin: 0;
            padding-left: 18px;
            font-size: 12px;
            color: rgba(255,255,255,0.72);
            line-height: 1.5;
        }

        /* Material slots */
        .mat-slots {
            display: grid;
            grid-template-columns: 1fr;
            gap: 10px;
        }
        .mat-slot {
            position: relative;
            border: 1px dashed rgba(255,255,255,0.22);
            border-radius: 14px;
            padding: 10px 12px;
            background: rgba(255,255,255,0.03);
            display: flex;
            flex-direction: column;
            gap: 8px;
            cursor: pointer;
            transition: box-shadow 0.12s ease, border-color 0.12s ease, transform 0.12s ease;
            user-select: none;
        }
        .mat-slot:hover {
            transform: translateY(-1px);
            box-shadow: 0 0 16px rgba(255,255,255,0.06);
        }
        .mat-slot.selected {
            border-color: rgba(255,215,0,0.60);
            box-shadow: 0 0 0 2px rgba(255,215,0,0.18), 0 0 18px rgba(255,215,0,0.08);
        }
        .mat-slot.drag-over {
            border-color: rgba(120,190,255,0.75);
            box-shadow: 0 0 0 2px rgba(120,190,255,0.18), 0 0 18px rgba(120,190,255,0.08);
        }
        .mat-slot-top {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
        }
        .mat-label {
            font-weight: 800;
            letter-spacing: -0.2px;
            color: rgba(255,255,255,0.92);
        }
        .mat-sub {
            font-size: 12px;
            color: rgba(255,255,255,0.55);
        }
        .mat-body {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .mat-icon {
            width: 46px;
            height: 46px;
            border-radius: 12px;
            border: 1px solid rgba(255,255,255,0.14);
            background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.12), rgba(0,0,0,0.25));
            box-shadow: 0 0 14px rgba(0,0,0,0.40) inset;
            flex: 0 0 auto;
            object-fit: cover;
        }
        .mat-count {
            font-size: 13px;
            color: rgba(255,255,255,0.90);
        }
        .mat-hint {
            font-size: 12px;
            color: rgba(255,255,255,0.55);
        }
        .mat-clear {
            pointer-events: auto;
            border: 1px solid rgba(255,255,255,0.16);
            background: rgba(0,0,0,0.18);
            color: rgba(255,255,255,0.92);
            border-radius: 10px;
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: background 0.12s ease, transform 0.12s ease;
        }
        .mat-clear:hover {
            background: rgba(255,255,255,0.06);
            transform: translateY(-1px);
        }

        /* Inventory drag/reserve visuals */
        .inv-slot.has-item { cursor: grab; }
        .inv-slot.dragging { opacity: 0.55; filter: saturate(0.85); }
        .inv-reserved {
            position: absolute;
            left: 6px;
            top: 6px;
            padding: 1px 4px;
            border-radius: 999px;
            background: rgba(255,215,0,0.16);
            border: 1px solid rgba(255,215,0,0.28);
            color: rgba(255,255,255,0.95);
            font-size: 8px;
            line-height: 1;
            text-shadow: 0 0 4px rgba(0,0,0,0.80);
            display: none;
        }
        .inv-slot.inv-fully-reserved .inv-icon { opacity: 0.45; filter: grayscale(0.2); }

        /* Inventory actions (sort / synth) */
        .inv-action-row {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
            margin-top: 4px;
            margin-bottom: 2px;
        }
        .gear-btn.inv-mini-btn {
            padding: 8px 12px;
            font-size: 14px;
            border-radius: 12px;
        }
        .inv-synth-info {
            font-size: 12px;
            color: rgba(255,255,255,0.70);
            line-height: 1.35;
            flex: 1 1 auto;
            min-width: 220px;
        }
        .inv-slot.inv-selected {
            outline: 2px solid rgba(46,204,113,0.65);
            box-shadow: 0 0 0 2px rgba(46,204,113,0.18), 0 0 18px rgba(46,204,113,0.08);
        }
        .inv-slot.drag-over {
            border-color: rgba(120,190,255,0.75);
            box-shadow: 0 0 0 2px rgba(120,190,255,0.18), 0 0 18px rgba(120,190,255,0.08);
        }

        /* [NEW] Synthesis FX overlay (합성 이펙트) */
        .synth-fx {
            position: fixed;
            inset: 0;
            pointer-events: none;
            z-index: 15500;
            display: none;
        }
        .synth-fx.active {
            display: block;
        }
        #synthFxCanvas {
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100%;
            display: block;
            mix-blend-mode: screen;
        }


        @media (max-width: 980px) {
            .gear-layout {
                grid-template-columns: 1fr;
                height: auto;
            }
            .panel-left { overflow: visible; }
            .panel-right { overflow: visible; padding-right: 0; }
            #gearPanel .inventory-grid { max-height: 320px; }
        }


        /* =========================================================
           [FIX + SKIN] GearPanel Scroll + RPG Theme (2026-02)
           - 모바일/데스크탑 스크롤 허용
           - 더 RPG스럽고 고급스러운 스킨
        ========================================================= */
        :root {
            --rpg-gold: #d7b35a;
            --rpg-gold-hi: #f7e7b0;
            --rpg-gold-soft: rgba(215,179,90,0.20);
            --rpg-line: rgba(255,226,160,0.20);
            --rpg-line-2: rgba(255,226,160,0.32);
            --rpg-ink: rgba(0,0,0,0.55);
        }

        /* UI 모드에서만 터치 스크롤 허용(게임 화면은 유지) */
        body.allow-scroll-ui {
            touch-action: auto;
        }

        /* Overlay: 고급스러운 비네트 + 블러 */
        #gearPanel {
            position: fixed;
            inset: 0;
            background:
                radial-gradient(circle at 50% 32%, rgba(215,179,90,0.16), rgba(0,0,0,0.92) 62%),
                linear-gradient(180deg, rgba(0,0,0,0.78), rgba(0,0,0,0.86));
            backdrop-filter: blur(6px);
        }

        /* 패널 프레임(금장) */
        #gearPanel .modal-panel {
            background:
                radial-gradient(circle at 14% 0%, rgba(215,179,90,0.22), transparent 48%),
                radial-gradient(circle at 88% 100%, rgba(80,170,255,0.10), transparent 55%),
                linear-gradient(180deg, rgba(36,24,46,0.98), rgba(12,8,14,0.98));
            border: 1px solid var(--rpg-line);
            border-radius: 18px;
            box-shadow:
                0 36px 140px rgba(0,0,0,0.80),
                0 0 0 1px rgba(0,0,0,0.62) inset,
                0 0 40px rgba(215,179,90,0.10) inset;
            position: relative;
        }

        /* 이너 프레임 */
        #gearPanel .modal-panel::before {
            content: '';
            position: absolute;
            inset: 10px;
            border-radius: 14px;
            border: 1px solid rgba(255,226,160,0.18);
            pointer-events: none;
            box-shadow: 0 0 0 1px rgba(0,0,0,0.40) inset;
        }

        /* 미세 텍스처(부하 적은 패턴) */
        #gearPanel .modal-panel::after {
            content: '';
            position: absolute;
            inset: 0;
            border-radius: 18px;
            pointer-events: none;
            background:
                repeating-linear-gradient(45deg, rgba(255,255,255,0.03) 0 2px, rgba(0,0,0,0.03) 2px 4px);
            opacity: 0.14;
            mix-blend-mode: overlay;
        }

        #gearPanel .modal-header {
            position: relative;
            padding-bottom: 12px;
            border-bottom: 1px solid rgba(255,226,160,0.14);
        }
        #gearPanel .modal-header::after {
            content: '';
            position: absolute;
            left: 0; right: 0;
            bottom: -1px;
            height: 2px;
            background: linear-gradient(90deg, transparent, rgba(215,179,90,0.55), transparent);
            opacity: 0.75;
            pointer-events: none;
        }

        #gearPanel .modal-title {
            font-family: 'Noto Serif KR', 'Gugi', serif;
            font-weight: 800;
            letter-spacing: -0.6px;
            background: linear-gradient(180deg, var(--rpg-gold-hi), var(--rpg-gold));
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            text-shadow: 0 0 18px rgba(215,179,90,0.12);
        }
        #gearPanel .modal-sub {
            color: rgba(255,255,255,0.78);
        }

        /* 좌/우 패널에 가벼운 프레임 */
        #gearPanel .panel-left,
        #gearPanel .panel-right {
            background: linear-gradient(180deg, rgba(255,255,255,0.03), rgba(0,0,0,0.22));
            border: 1px solid rgba(255,226,160,0.10);
            border-radius: 16px;
            padding: 10px;
        }
        #gearPanel .panel-right { padding-right: 10px; }

        #gearPanel .panel-section-title {
            position: relative;
            padding-left: 18px;
            font-size: 14px;
            letter-spacing: -0.2px;
        }
        #gearPanel .panel-section-title::before {
            content: '◆';
            position: absolute;
            left: 0;
            top: 0;
            color: var(--rpg-gold);
            text-shadow: 0 0 12px rgba(215,179,90,0.18);
        }
        #gearPanel .panel-section-sub {
            color: rgba(255,255,255,0.62);
        }

        /* 합성 안내 박스 */
        #gearPanel .inv-synth-info {
            background: rgba(0,0,0,0.18);
            border: 1px solid rgba(255,226,160,0.10);
            padding: 8px 10px;
            border-radius: 12px;
        }
        #gearPanel .inv-synth-info b {
            color: var(--rpg-gold-hi);
        }

        /* 사용법 박스 */
        #gearPanel .panel-hint {
            border: 1px solid rgba(255,226,160,0.10);
            background: rgba(0,0,0,0.18);
        }

        /* 스크롤 영역: 터치/모멘텀 스크롤 + 바운스 방지 */
        #gearPanel .inventory-grid,
        #gearPanel .panel-right,
        #gearPanel .modal-panel {
            overscroll-behavior: contain;
            -webkit-overflow-scrolling: touch;
            touch-action: pan-y;
        }

        /* 스크롤바(웹킷/크로미움) */
        #gearPanel .inventory-grid::-webkit-scrollbar,
        #gearPanel .panel-right::-webkit-scrollbar,
        #gearPanel .modal-panel::-webkit-scrollbar {
            width: 10px;
        }
        #gearPanel .inventory-grid::-webkit-scrollbar-track,
        #gearPanel .panel-right::-webkit-scrollbar-track,
        #gearPanel .modal-panel::-webkit-scrollbar-track {
            background: rgba(0,0,0,0.28);
            border-radius: 999px;
        }
        #gearPanel .inventory-grid::-webkit-scrollbar-thumb,
        #gearPanel .panel-right::-webkit-scrollbar-thumb,
        #gearPanel .modal-panel::-webkit-scrollbar-thumb {
            background: linear-gradient(180deg, rgba(215,179,90,0.62), rgba(215,179,90,0.28));
            border-radius: 999px;
            border: 2px solid rgba(0,0,0,0.28);
        }
        #gearPanel .inventory-grid,
        #gearPanel .panel-right,
        #gearPanel .modal-panel {
            scrollbar-width: thin;
            scrollbar-color: rgba(215,179,90,0.55) rgba(0,0,0,0.25);
        }

        /* 인벤토리 영역: 프레임 + 더 깊은 음영 */
        #gearPanel .inventory-grid {
            background: linear-gradient(180deg, rgba(255,255,255,0.04), rgba(0,0,0,0.16));
            border: 1px solid rgba(255,226,160,0.14);
            box-shadow: 0 0 0 1px rgba(0,0,0,0.45) inset, 0 0 24px rgba(0,0,0,0.25) inset;
            padding: 10px;
            border-radius: 16px;
        }

        /* 슬롯: 금속 프레임 느낌 */
        #gearPanel .inv-slot {
            border-radius: 14px;
            border: 1px solid rgba(255,226,160,0.10);
            box-shadow: 0 14px 28px rgba(0,0,0,0.40) inset, 0 0 0 1px rgba(0,0,0,0.40);
            background:
                radial-gradient(circle at 30% 28%, rgba(255,255,255,0.12), rgba(0,0,0,0.40));
        }
        #gearPanel .inv-slot::after {
            content: '';
            position: absolute;
            inset: 0;
            border-radius: 14px;
            pointer-events: none;
            background: linear-gradient(135deg, rgba(255,255,255,0.14), transparent 45%, rgba(0,0,0,0.18));
            opacity: 0.45;
        }

        /* 버튼: RPG식 금장/각인 */
        #gearPanel .gear-btn,
        #gearPanel .modal-close {
            border: 1px solid rgba(255,226,160,0.22);
            box-shadow: 0 10px 24px rgba(0,0,0,0.38), 0 0 0 1px rgba(0,0,0,0.55) inset;
        }
        #gearPanel .gear-btn {
            background: linear-gradient(180deg, rgba(215,179,90,0.22), rgba(255,255,255,0.06));
        }
        #gearPanel .gear-btn:hover {
            box-shadow: 0 14px 34px rgba(0,0,0,0.46), 0 0 0 1px rgba(0,0,0,0.55) inset, 0 0 18px rgba(215,179,90,0.10);
        }
        #gearPanel .modal-close {
            background: linear-gradient(180deg, rgba(255,255,255,0.10), rgba(255,255,255,0.04));
        }

        /* 장비 카드: 더 묵직한 프레임 */
        #gearPanel .gear-card {
            border: 1px solid rgba(255,226,160,0.14);
            background: linear-gradient(180deg, rgba(255,255,255,0.04), rgba(0,0,0,0.22));
            box-shadow: 0 18px 44px rgba(0,0,0,0.46), 0 0 0 1px rgba(0,0,0,0.55) inset;
        }

        /* 모바일: 단일 컬럼일 때 모달 자체 스크롤 허용 */
        @media (max-width: 980px) {
            #gearPanel .modal-panel {
                overflow-y: auto;
            }
        }


        /* =========================================================
           [NEW] Relic System (O)
           - Unlock with loot, equip for special effects
        ========================================================= */
        #relicPanel {
            position: absolute;
            left: 0; top: 0;
            width: 100%; height: 100%;
            z-index: 15000;
            pointer-events: auto;
            display: none;
            background: rgba(0,0,0,0.65);
            align-items: center;
            justify-content: center;
        }
        #relicPanel .modal-panel.relic-modal { width: min(1200px, 96vw); max-height: 92vh; overflow-y: auto; overflow-x: hidden; }
        #relicPanel .relic-header-row { display:flex; align-items:center; justify-content:space-between; gap:10px; }
        #relicPanel .relic-grid { display:grid; grid-template-columns: repeat(3, minmax(0, 1fr)); gap: 14px; padding: 14px; }
        #relicPanel .relic-card {
            display:flex; align-items:center; gap:12px;
            padding: 12px;
            border-radius: 12px;
            background: rgba(255,255,255,0.06);
            border: 1px solid rgba(255,255,255,0.10);
            cursor: pointer;
            transition: transform .08s ease, background .12s ease, border-color .12s ease;
            user-select:none;
        }
        #relicPanel .relic-card:hover { transform: translateY(-1px); background: rgba(255,255,255,0.09); border-color: rgba(255,255,255,0.18); }
        #relicPanel .relic-card.locked { opacity: 0.92; }
        #relicPanel .relic-card.equipped { border-color: rgba(0, 191, 255, 0.65); box-shadow: 0 0 0 2px rgba(0,191,255,0.15) inset; }
        #relicPanel .relic-thumb {
            width: 64px; height: 64px;
            border-radius: 14px;
            background: rgba(0,0,0,0.35);
            border: 1px solid rgba(255,255,255,0.12);
            overflow:hidden;
            flex: 0 0 64px;
        }
        #relicPanel .relic-thumb img { width:100%; height:100%; object-fit: cover; display:block; }
        #relicPanel .relic-meta { flex: 1; min-width: 0; }
        #relicPanel .relic-name { font-size: 18px; font-weight: 800; letter-spacing: -0.4px; white-space: nowrap; overflow:hidden; text-overflow: ellipsis; }
        #relicPanel .relic-progress { font-size: 14px; opacity: 0.9; margin-top: 2px; }
        #relicPanel .relic-tags { margin-top: 6px; display:flex; gap:6px; flex-wrap: wrap; }
        #relicPanel .relic-tag {
            font-size: 12px;
            padding: 3px 8px;
            border-radius: 999px;
            background: rgba(0,0,0,0.35);
            border: 1px solid rgba(255,255,255,0.10);
            opacity: 0.95;
        }
        #relicPanel .relic-tag.lock { border-color: rgba(255, 80, 80, 0.45); }
        #relicPanel .relic-tag.on  { border-color: rgba(0, 191, 255, 0.45); }

        #relicPanel .relic-equip-bar {
            padding: 10px 14px 0 14px;
            display:flex; align-items:center; justify-content:space-between; gap: 12px;
        }
        #relicPanel .relic-equip-title { font-weight: 800; opacity: 0.95; }
        #relicPanel .relic-equip-slots { display:flex; gap:10px; align-items:center; }
        #relicPanel .relic-equip-slot {
            width: 52px; height: 52px;
            border-radius: 14px;
            background: rgba(0,0,0,0.35);
            border: 1px solid rgba(255,255,255,0.12);
            display:flex; align-items:center; justify-content:center;
            overflow:hidden;
            cursor: pointer;
        }
        #relicPanel .relic-equip-slot img { width: 100%; height: 100%; object-fit: cover; display:block; }
        #relicPanel .relic-equip-slot.empty { cursor: default; opacity: 0.7; }

        /* detail */
        #relicPanel .relic-detail-wrap { padding: 12px 14px 14px 14px; }
        #relicPanel .relic-detail-top {
            display:flex; align-items:center; gap: 10px;
            padding: 10px 14px;
            border-bottom: 1px solid rgba(255,255,255,0.08);
        }
        #relicPanel .relic-detail-title { font-weight: 900; font-size: 18px; letter-spacing: -0.5px; }
        #relicPanel .relic-detail-body { display:flex; gap: 14px; padding: 14px; }
        #relicPanel .relic-board {
            position: relative;
            width: min(560px, 58vw);
            aspect-ratio: 1 / 1;
            border-radius: 16px;
            background: linear-gradient(180deg, rgba(0,0,0,0.55), rgba(0,0,0,0.32));
            border: 1px solid rgba(255,255,255,0.10);
            overflow: hidden;
        }
        #relicPanel .relic-board::before {
            content:'';
            position:absolute; inset:0;
            background-image:
              linear-gradient(rgba(255,255,255,0.06) 1px, transparent 1px),
              linear-gradient(90deg, rgba(255,255,255,0.06) 1px, transparent 1px);
            background-size: 52px 52px;
            opacity: 0.55;
            pointer-events:none;
        }
        #relicPanel .relic-center {
            position:absolute;
            left: 50%; top: 50%;
            transform: translate(-50%, -50%);
            width: 42%;
            aspect-ratio: 1 / 1;
            border-radius: 18px;
            border: 1px solid rgba(255,255,255,0.14);
            background: rgba(0,0,0,0.30);
            display:flex; align-items:center; justify-content:center;
            overflow:hidden;
        }
        #relicPanel .relic-center img { width:100%; height:100%; object-fit: cover; display:block; }
        #relicPanel .relic-slot {
            position:absolute;
            width: 76px; height: 76px;
            border-radius: 18px;
            background: rgba(10,10,10,0.55);
            border: 1px solid rgba(255,255,255,0.12);
            transform: translate(-50%, -50%);
            display:flex; flex-direction:column; align-items:center; justify-content:center;
            gap: 4px;
            cursor: pointer;
            user-select: none;
        }
        #relicPanel .relic-slot.selected { outline: 2px solid rgba(0,191,255,0.8); box-shadow: 0 0 0 2px rgba(0,191,255,0.18) inset; }
        #relicPanel .relic-slot.complete { border-color: rgba(120, 255, 120, 0.55); }
        #relicPanel .relic-slot img { width: 38px; height: 38px; object-fit: contain; }
        #relicPanel .relic-slot .rs-count { font-size: 12px; opacity: 0.95; }
        #relicPanel .relic-side {
            flex: 1;
            min-width: 320px;
            border-radius: 16px;
            background: rgba(0,0,0,0.28);
            border: 1px solid rgba(255,255,255,0.10);
            padding: 12px;
            overflow: auto;
            max-height: calc(92vh - 180px);
        }
        #relicPanel .panel-section-title { font-weight: 900; margin-top: 8px; margin-bottom: 6px; opacity: 0.95; }
        #relicPanel .panel-section-sub { font-size: 12px; opacity: 0.8; margin-bottom: 10px; }
        #relicPanel .relic-effect-desc, #relicPanel .relic-stats-desc { font-size: 14px; line-height: 1.5; opacity: 0.95; }
        #relicPanel .relic-stats-desc .stat-line { display:flex; justify-content:space-between; gap: 10px; padding: 4px 0; border-bottom: 1px dashed rgba(255,255,255,0.10); }
        #relicPanel .relic-stats-desc .stat-line:last-child { border-bottom: none; }

        #relicPanel .relic-inv-wrap { margin-top: 8px; }
        #relicPanel .relic-inv-grid { display:grid; grid-template-columns: repeat(8, 1fr); gap: 8px; }
        #relicPanel .relic-inv-slot {
            position: relative;
            width: 100%;
            aspect-ratio: 1 / 1;
            border-radius: 14px;
            background: rgba(0,0,0,0.35);
            border: 1px solid rgba(255,255,255,0.10);
            display:flex; align-items:center; justify-content:center;
            cursor:pointer;
            user-select:none;
        }
        #relicPanel .relic-inv-slot img { width: 70%; height: 70%; object-fit: contain; pointer-events:none; }
        #relicPanel .relic-inv-slot .inv-count {
            position:absolute; right:6px; bottom:6px;
            font-size: 12px;
            padding: 1px 6px;
            border-radius: 999px;
            background: rgba(0,0,0,0.65);
            border: 1px solid rgba(255,255,255,0.10);
            pointer-events:none;
        }
        #relicPanel .relic-inv-slot.empty { opacity: 0.35; cursor: default; }
        #relicPanel .relic-btn-row { display:flex; gap: 8px; align-items:center; }



/* =========================================================
   [SKIN] EquipPanel RPG Theme + UI Upscale (2026-02)
   - 장착 슬롯 이름 줄임표(...) 제거 (줄바꿈 허용)
   - 인벤토리 부위 태그(좌하단) 더 크게
   - 등급별 아이콘 글로우(전 등급)
   - 전체 스킨을 RPG 프레임 느낌으로
========================================================= */

/* Overlay: 비네트 + 블러 */
#equipPanel{
    position: fixed;
    inset: 0;
    background:
        radial-gradient(circle at 50% 28%, rgba(215,179,90,0.18), rgba(0,0,0,0.92) 64%),
        linear-gradient(180deg, rgba(0,0,0,0.76), rgba(0,0,0,0.86));
    backdrop-filter: blur(6px);
}

/* 패널 프레임(금장 + 텍스처) */
#equipPanel .modal-panel{
    background:
        radial-gradient(circle at 14% 0%, rgba(215,179,90,0.20), transparent 48%),
        radial-gradient(circle at 88% 100%, rgba(80,170,255,0.10), transparent 55%),
        linear-gradient(180deg, rgba(34,24,44,0.98), rgba(10,8,12,0.98));
    border: 1px solid var(--rpg-line);
    border-radius: 18px;
    box-shadow:
        0 36px 140px rgba(0,0,0,0.80),
        0 0 0 1px rgba(0,0,0,0.62) inset,
        0 0 40px rgba(215,179,90,0.10) inset;
    position: relative;
}

/* 이너 프레임 */
#equipPanel .modal-panel::before{
    content:'';
    position:absolute;
    inset: 10px;
    border-radius: 14px;
    border: 1px solid rgba(255,226,160,0.18);
    pointer-events:none;
    box-shadow: 0 0 0 1px rgba(0,0,0,0.40) inset;
}

/* 미세 패턴 */
#equipPanel .modal-panel::after{
    content:'';
    position:absolute;
    inset:0;
    border-radius:18px;
    pointer-events:none;
    background:
        repeating-linear-gradient(45deg, rgba(255,255,255,0.03) 0 2px, rgba(0,0,0,0.03) 2px 4px);
    opacity:0.14;
    mix-blend-mode: overlay;
}

/* 헤더 라인 */
#equipPanel .modal-header{
    position: relative;
    padding-bottom: 12px;
    border-bottom: 1px solid rgba(255,226,160,0.14);
}
#equipPanel .modal-header::after{
    content:'';
    position:absolute;
    left:0; right:0;
    bottom:-1px;
    height:2px;
    background: linear-gradient(90deg, transparent, rgba(215,179,90,0.55), transparent);
    opacity:0.75;
    pointer-events:none;
}

#equipPanel .modal-title{
    font-family: 'Noto Serif KR', 'Gugi', serif;
    font-weight: 800;
    letter-spacing: -0.6px;
    background: linear-gradient(180deg, var(--rpg-gold-hi), var(--rpg-gold));
    -webkit-background-clip: text;
    background-clip: text;
    color: transparent;
    text-shadow: 0 0 18px rgba(215,179,90,0.12);
}
#equipPanel .modal-sub{ color: rgba(255,255,255,0.78); }

/* 좌/우 패널 프레임 */
#equipPanel .equip-left,
#equipPanel .equip-right{
    background: linear-gradient(180deg, rgba(255,255,255,0.03), rgba(0,0,0,0.22));
    border: 1px solid rgba(255,226,160,0.10);
    border-radius: 16px;
    padding: 12px;
}
#equipPanel .equip-layout{ gap: 16px; }
#equipPanel .equip-left{ width: 460px; flex: 0 0 460px; }

/* 섹션 타이틀 장식 */
#equipPanel .panel-section-title{
    position: relative;
    padding-left: 18px;
}
#equipPanel .panel-section-title::before{
    content:'◆';
    position:absolute;
    left:0; top:0;
    color: var(--rpg-gold);
    text-shadow: 0 0 12px rgba(215,179,90,0.18);
}
#equipPanel .panel-section-sub{ color: rgba(255,255,255,0.62); }

/* 장착 슬롯 카드 */
#equipPanel .equip-slot{
    border-radius: 16px;
    border: 1px solid rgba(255,226,160,0.14);
    background: linear-gradient(180deg, rgba(255,255,255,0.04), rgba(0,0,0,0.22));
    box-shadow: 0 18px 44px rgba(0,0,0,0.44), 0 0 0 1px rgba(0,0,0,0.55) inset;
    transition: transform 0.12s ease, box-shadow 0.12s ease, border-color 0.12s ease;
    align-items: flex-start;
}
#equipPanel .equip-slot:hover{
    transform: translateY(-1px);
    box-shadow: 0 22px 54px rgba(0,0,0,0.52), 0 0 0 1px rgba(0,0,0,0.55) inset, 0 0 18px rgba(215,179,90,0.08);
}
#equipPanel .equip-slot.selected{
    outline: 2px solid rgba(215,179,90,0.55);
    box-shadow: 0 0 0 2px rgba(215,179,90,0.14), 0 22px 54px rgba(0,0,0,0.52), 0 0 18px rgba(215,179,90,0.10);
}
#equipPanel .equip-slot .slot-icon{
    width: 66px;
    height: 66px;
    border-radius: 16px;
    border: 1px solid rgba(255,226,160,0.14);
    background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.14), rgba(0,0,0,0.40));
    box-shadow: 0 18px 38px rgba(0,0,0,0.45) inset, 0 0 0 1px rgba(0,0,0,0.45);
    flex: 0 0 auto;
    overflow: hidden;
}
#equipPanel .equip-slot .slot-text{
    line-height: 1.15;
    min-width: 0;
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    gap: 4px;
}

/* [조정] 장착 장비 이름: 글자 크기↓ + 최대 2줄까지만 표시(겹침/지저분함 완화) */
#equipPanel .equip-slot .item-empty,
#equipPanel .equip-slot .item-name{
    /* 장착 슬롯 이름: 2줄 안에 전부 보이도록 JS에서 자동 축소 */
    font-size: 12px;
    line-height: 1.15;
    max-width: none !important;

    display: block !important;
    white-space: normal !important;
    overflow: hidden !important;
    text-overflow: clip !important;

    /* 긴 단어도 깨서 카드 밖으로 안 튀게 */
    word-break: break-word;
    overflow-wrap: anywhere;
}

/* 장착 슬롯 장비 이름 배경: 텍스트 뒤만 얇게(라인별로 클론) */
#equipPanel .equip-slot .item-empty{
    background: none;
    border: none;
    padding: 0;
    box-shadow: none;
}

/* 이름 텍스트 뒤 배경(검정 박스): 너무 크지 않게/겹쳐 보이지 않게 얇게 */
#equipPanel .equip-slot[data-rarity]:not([data-rarity=""]) .item-empty .equip-name-pill{
    display: inline;
    /* 세로 패딩을 줄여서(또는 제거) 줄 간격에서 박스가 겹쳐보이는 느낌 완화 */
    padding: 0 4px;
    border-radius: 8px;

    /* 색/선: 티 나지 않게 아주 은은하게 */
    background: linear-gradient(180deg, rgba(0,0,0,0.22), rgba(0,0,0,0.08));
    border: 1px solid rgba(255,226,160,0.06);
    box-shadow: none;

    /* 여러 줄일 때 줄마다 자연스럽게 분리 */
    -webkit-box-decoration-break: clone;
    box-decoration-break: clone;

    /* 배경만 살짝 부드럽게 */
    -webkit-backdrop-filter: blur(2px);
    backdrop-filter: blur(2px);
}

/* 네임드 별(✦) */
#equipPanel .equip-slot .item-empty .named-star{
    margin-left: 4px;
    font-weight: 900;
    opacity: 0.92;
    text-shadow: none;
}

#equipPanel .equip-slot .item-empty .equip-lock-badge{
    display: inline-flex;
    align-items: center;
    justify-content: center;
    padding: 0 5px;
    border-radius: 999px;
    border: 1px solid rgba(255,255,255,0.25);
    background: rgba(0,0,0,0.35);
    font-size: 10px;
    line-height: 1.4;

    /* 장착 슬롯 카드 우상단에 고정 */
    position: absolute;
    right: 10px;
    top: 10px;
    margin-left: 0;
}




/* 장착 슬롯 이름: '글씨 자체'가 아니라 외곽에만 살짝(아웃라인 느낌) */
#equipPanel .equip-slot .item-empty .rarity-name{
    text-shadow: none !important;
}
#equipPanel .equip-slot .item-empty .rarity-name.rarity-common    { text-shadow: none !important; }
#equipPanel .equip-slot .item-empty .rarity-name.rarity-uncommon  { text-shadow: none !important; }
#equipPanel .equip-slot .item-empty .rarity-name.rarity-rare      { text-shadow: none !important; }
#equipPanel .equip-slot .item-empty .rarity-name.rarity-epic      { text-shadow: none !important; }
#equipPanel .equip-slot .item-empty .rarity-name.rarity-unique    { text-shadow: none !important; }
#equipPanel .equip-slot .item-empty .rarity-name.rarity-legendary { text-shadow: none !important; }
#equipPanel .equip-slot .item-empty .rarity-name.rarity-demonic   { text-shadow: none !important; }
#equipPanel .equip-slot .item-empty .rarity-name.rarity-angelic   { text-shadow: none !important; }

/* 빈 슬롯(비어 있음)은 배경 제거 */
#equipPanel .equip-slot[data-rarity=""] .item-empty{
    background: none;
    border: none;
    padding: 0;
}
#equipPanel .equip-slot[data-rarity=""] .item-empty .rarity-name{
    text-shadow: none;
}

/* 요약 박스: 너무 길어도 칸 밖으로 새지 않게(스크롤/줄바꿈 강화) */
#equipPanel .equip-stats-summary{
    background: rgba(0,0,0,0.18);
    border: 1px solid rgba(255,226,160,0.10);
    box-shadow: 0 0 0 1px rgba(0,0,0,0.45) inset;

    /* 글씨/행간을 살짝 줄여서 '요약' 느낌 유지 */
    font-size: 13px;
    line-height: 1.35;

    /* 패널 높이에 따라 적당히만 차지 */
    max-height: clamp(180px, 22vh, 260px);
    overflow-y: auto;
    overflow-x: hidden;

    /* 긴 텍스트도 박스 밖으로 튀지 않게 */
    white-space: normal;
    word-break: keep-all;
    overflow-wrap: anywhere;
}

/* 인벤토리 그리드: 슬롯 크게(열 수↓) */
#equipPanel .inventory-grid{
    --inv-cols: 7;
    --inv-gap: 12px;
    padding: 12px;
    background: linear-gradient(180deg, rgba(255,255,255,0.04), rgba(0,0,0,0.16));
    border: 1px solid rgba(255,226,160,0.14);
    border-radius: 16px;
    box-shadow: 0 0 0 1px rgba(0,0,0,0.45) inset, 0 0 24px rgba(0,0,0,0.25) inset;
}

#equipPanel .inv-slot{
    --inv-glow: rgba(0,0,0,0);
    /* 코너 장식(룬/리벳): 골드 톤 */
    --slot-orn: rgba(255,226,160,0.14);
    --slot-orn-strong: rgba(255,226,160,0.28);
    --slot-rivet: rgba(255,226,160,0.20);
    border-radius: 14px;
    border: 1px solid rgba(255,226,160,0.10);
    box-shadow:
        0 14px 28px rgba(0,0,0,0.45) inset,
        0 0 0 1px rgba(0,0,0,0.45),
        0 0 18px var(--inv-glow);
    background: radial-gradient(circle at 30% 28%, rgba(255,255,255,0.12), rgba(0,0,0,0.44));
}
/* 아이콘 사이즈 업 */
#equipPanel .inv-icon{
    width: 94%;
    height: 94%;
}

/* 부위 태그(좌하단): 더 크게 */
#equipPanel #gearInventoryGrid .inv-reserved{
    left: 6px;
    top: auto;
    bottom: 6px;
    display: none;
    padding: 2px 7px;
    border-radius: 999px;
    background: rgba(0,0,0,0.45);
    border: 1px solid rgba(255,226,160,0.25);
    color: rgba(255,255,255,0.92);
    font-size: 10px;
    font-weight: 800;
    letter-spacing: -0.1px;
    text-shadow: 0 0 6px rgba(0,0,0,0.85), 0 0 12px rgba(215,179,90,0.10);
}

/* 버튼: RPG식 */
#equipPanel .gear-btn,
#equipPanel .modal-close{
    border: 1px solid rgba(255,226,160,0.22);
    box-shadow: 0 10px 24px rgba(0,0,0,0.38), 0 0 0 1px rgba(0,0,0,0.55) inset;
}
#equipPanel .gear-btn{
    background: linear-gradient(180deg, rgba(215,179,90,0.22), rgba(255,255,255,0.06));
}
#equipPanel .gear-btn:hover{
    box-shadow: 0 14px 34px rgba(0,0,0,0.46), 0 0 0 1px rgba(0,0,0,0.55) inset, 0 0 18px rgba(215,179,90,0.10);
}
#equipPanel .modal-close{
    background: linear-gradient(180deg, rgba(255,255,255,0.10), rgba(255,255,255,0.04));
}

/* 힌트 박스 */
#equipPanel .gear-hint{
    border: 1px solid rgba(255,226,160,0.10);
    background: rgba(0,0,0,0.18);
    border-radius: 14px;
    padding: 10px 12px;
}
#equipPanel .gear-selection{ font-size: 13px; }

/* =========================================================
   등급별 글로우(전 등급)
========================================================= */
@keyframes gearGlowUnique {
    0%   { filter: drop-shadow(0 0 7px rgba(241,196,15,0.35)) drop-shadow(0 0 0 rgba(255,255,255,0.0)) saturate(1.10) brightness(1.03); transform: translateY(0) scale(1.0); }
    50%  { filter: drop-shadow(0 0 16px rgba(241,196,15,0.78)) drop-shadow(0 0 22px rgba(255,255,255,0.14)) saturate(1.25) brightness(1.10); transform: translateY(-0.6px) scale(1.03); }
    100% { filter: drop-shadow(0 0 7px rgba(241,196,15,0.35)) drop-shadow(0 0 0 rgba(255,255,255,0.0)) saturate(1.10) brightness(1.03); transform: translateY(0) scale(1.0); }
}

/* 슬롯 외곽 은은한 발광 */
#equipPanel .inv-slot[data-gear-rarity="common"]    { --inv-glow: rgba(176,176,176,0.10); }
#equipPanel .inv-slot[data-gear-rarity="uncommon"]  { --inv-glow: rgba(76,217,100,0.12); }
#equipPanel .inv-slot[data-gear-rarity="rare"]      { --inv-glow: rgba(74,144,226,0.14); }
#equipPanel .inv-slot[data-gear-rarity="epic"]      { --inv-glow: rgba(155,89,182,0.16); }
#equipPanel .inv-slot[data-gear-rarity="unique"]    { --inv-glow: rgba(241,196,15,0.18); }
#equipPanel .inv-slot[data-gear-rarity="legendary"] { --inv-glow: rgba(255,140,0,0.20); }
#equipPanel .inv-slot[data-gear-rarity="demonic"]   { --inv-glow: rgba(255,59,48,0.22); }
#equipPanel .inv-slot[data-gear-rarity="angelic"]   { --inv-glow: rgba(220,255,255,0.22); }

/* 아이콘 드롭섀도우 글로우(전 등급) */
#equipPanel .inv-slot[data-gear-rarity="common"]   .inv-icon { filter: drop-shadow(0 0 8px rgba(176,176,176,0.32)) drop-shadow(0 2px 6px rgba(0,0,0,0.65)); }
#equipPanel .inv-slot[data-gear-rarity="uncommon"] .inv-icon { filter: drop-shadow(0 0 10px rgba(76,217,100,0.40)) drop-shadow(0 2px 6px rgba(0,0,0,0.65)); }
#equipPanel .inv-slot[data-gear-rarity="rare"]     .inv-icon { filter: drop-shadow(0 0 10px rgba(74,144,226,0.42)) drop-shadow(0 2px 6px rgba(0,0,0,0.65)); }
#equipPanel .inv-slot[data-gear-rarity="epic"]     .inv-icon { filter: drop-shadow(0 0 11px rgba(155,89,182,0.46)) drop-shadow(0 2px 6px rgba(0,0,0,0.65)); }
#equipPanel .inv-slot[data-gear-rarity="unique"]   .inv-icon { animation: gearGlowUnique 2.0s ease-in-out infinite; }
#equipPanel .inv-slot[data-gear-rarity="legendary"] .inv-icon { animation: gearGlowLegendary 1.6s ease-in-out infinite; }
#equipPanel .inv-slot[data-gear-rarity="demonic"]   .inv-icon { animation: gearGlowDemonic  1.5s ease-in-out infinite; }
#equipPanel .inv-slot[data-gear-rarity="angelic"]   .inv-icon { animation: gearGlowAngelic  1.7s ease-in-out infinite; }


#equipPanel .equip-slot{ --slot-glow: rgba(0,0,0,0); }
/* 장착 슬롯 아이콘도 등급 글로우 적용 */
#equipPanel .equip-slot .slot-icon{
    box-shadow:
        0 18px 38px rgba(0,0,0,0.45) inset,
        0 0 0 1px rgba(0,0,0,0.45),
        0 0 18px var(--slot-glow);
}
#equipPanel .equip-slot[data-rarity="common"]   { --slot-glow: rgba(176,176,176,0.10); }
#equipPanel .equip-slot[data-rarity="uncommon"] { --slot-glow: rgba(76,217,100,0.12); }
#equipPanel .equip-slot[data-rarity="rare"]     { --slot-glow: rgba(74,144,226,0.14); }
#equipPanel .equip-slot[data-rarity="epic"]     { --slot-glow: rgba(155,89,182,0.16); }
#equipPanel .equip-slot[data-rarity="unique"]   { --slot-glow: rgba(241,196,15,0.18); }

/* 이미지 자체 글로우 */
#equipPanel .equip-slot[data-rarity="common"]   img { filter: drop-shadow(0 0 8px rgba(176,176,176,0.32)); }
#equipPanel .equip-slot[data-rarity="uncommon"] img { filter: drop-shadow(0 0 10px rgba(76,217,100,0.40)); }
#equipPanel .equip-slot[data-rarity="rare"]     img { filter: drop-shadow(0 0 10px rgba(74,144,226,0.42)); }
#equipPanel .equip-slot[data-rarity="epic"]     img { filter: drop-shadow(0 0 11px rgba(155,89,182,0.46)); }
#equipPanel .equip-slot[data-rarity="unique"]   img { animation: gearGlowUnique 2.0s ease-in-out infinite; }

/* 기존 애니메이션(레전/데모/엔젤) 유지 */
#equipPanel .equip-slot[data-rarity="legendary"] img { animation: gearGlowLegendary 1.6s ease-in-out infinite; }
#equipPanel .equip-slot[data-rarity="demonic"]   img { animation: gearGlowDemonic  1.5s ease-in-out infinite; }
#equipPanel .equip-slot[data-rarity="angelic"]   img { animation: gearGlowAngelic  1.7s ease-in-out infinite; }

/* 반응형: 화면이 좁아지면 열 수를 더 줄여 아이콘 유지 */

#equipPanel .equip-slot[data-rarity]:not([data-rarity=""]) .item-empty .equip-name-pill{ background:none; border:none; padding:0; -webkit-backdrop-filter:none; backdrop-filter:none; }
#equipPanel .inv-slot .inv-icon, #equipPanel .equip-slot img { animation:none !important; filter:none !important; }

@media (max-width: 1200px){
    #equipPanel .inventory-grid{ --inv-cols: 6; }
}
@media (max-width: 980px){
    /* 모바일/좁은 화면: 모달 자체 스크롤 허용(요약/슬롯이 길어도 안전) */
    #equipPanel .modal-panel{ overflow-y: auto; overflow-x: hidden; }

    #equipPanel .equip-left{ width: auto; flex: 1 1 auto; }
    #equipPanel .inventory-grid{ --inv-cols: 5; }
}
@media (max-width: 720px){
    #equipPanel .inventory-grid{ --inv-cols: 4; }
    #equipPanel .equip-slot .slot-icon{ width: 72px; height: 72px; }
}


/* =========================================================
   [PATCH] 장착 장비 이름(글씨) 효과 완전 제거
========================================================= */
#equipPanel .equip-slot .item-empty,
#equipPanel .equip-slot .item-empty *{
    text-shadow: none !important;
    filter: none !important;
    animation: none !important;
    -webkit-text-stroke: 0 !important;
}

#equipPanel .equip-slot .item-empty .equip-name-flat{
    color: var(--equip-name-color, #ffffff) !important;
    text-shadow: none !important;
    filter: none !important;
    animation: none !important;
    -webkit-text-stroke: 0 !important;
    background: none !important;
    -webkit-background-clip: border-box !important;
    background-clip: border-box !important;
    -webkit-text-fill-color: currentColor !important;
}

#equipPanel .equip-slot .item-empty .rarity-name,
#equipPanel .equip-slot .item-empty .rarity-common,
#equipPanel .equip-slot .item-empty .rarity-uncommon,
#equipPanel .equip-slot .item-empty .rarity-rare,
#equipPanel .equip-slot .item-empty .rarity-epic,
#equipPanel .equip-slot .item-empty .rarity-unique,
#equipPanel .equip-slot .item-empty .rarity-legendary,
#equipPanel .equip-slot .item-empty .rarity-demonic,
#equipPanel .equip-slot .item-empty .rarity-angelic{
    background: none !important;
    -webkit-background-clip: border-box !important;
    background-clip: border-box !important;
    -webkit-text-fill-color: currentColor !important;
}

/* 등급별 기본 색만 유지(효과 X) */
#equipPanel .equip-slot .item-empty .rarity-common    { color:#d0d0d0 !important; }
#equipPanel .equip-slot .item-empty .rarity-uncommon  { color:#7CFF92 !important; }
#equipPanel .equip-slot .item-empty .rarity-rare      { color:#7DB8FF !important; }
#equipPanel .equip-slot .item-empty .rarity-epic      { color:#D49BFF !important; }
#equipPanel .equip-slot .item-empty .rarity-unique    { color:#FFE066 !important; }
#equipPanel .equip-slot .item-empty .rarity-legendary { color:#FFE066 !important; }
#equipPanel .equip-slot .item-empty .rarity-demonic   { color:#ff6a61 !important; }
#equipPanel .equip-slot .item-empty .rarity-angelic   { color:#bfffff !important; }

/* 장착 이름 끝 ✦ 제거 */
#equipPanel .equip-slot .item-empty .named-star{
    display:none !important;
}
</style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<div class="damage-overlay" id="damageOverlay"></div>
<div id="poopOverlay"></div>
<div id="mindOverlay"></div>
<div id="confusionOverlay"></div>
<div id="darknessOverlay"></div>
<div id="sacredFaithOverlay"></div>
<div id="bloodOverlay"></div> <!-- [신규] 블러드 오버레이 추가 -->
<div id="visionOverlay"></div>
<div id="skillSealOverlay">
<div id="skillSealText">스킬 봉인!</div>
</div>
<div id="ui-layer">
<div class="hud-top">
<div class="status-container-left">
<!-- HP 바와 스킬 아이콘을 가로로 배치 -->
<div class="hp-skill-row">
<div class="health-container">
<div class="health-bar" id="healthBar"></div>
<div class="health-text" id="healthText">HP</div>
</div>
<!-- 여신의 가호 스킬 아이콘 -->
<div class="skill-icon-box" id="goddessSkillIcon">
<img alt="여신의 가호" class="skill-img" id="goddessSkillImg" src=""/>
<div class="cooldown-overlay" id="goddessCooldownOverlay"></div>
<div class="seal-overlay" id="goddessSealOverlay">X</div>
<span class="key-hint">Q</span>
<span class="cooldown-text" id="goddessCooldownText">35</span>
</div>
<!-- 성스러운 믿음 스킬 아이콘 -->
<div class="skill-icon-box" id="sacredFaithSkillIcon" style="margin-left: 5px;">
<img alt="성스러운 믿음" class="skill-img" id="sacredFaithSkillImg" src=""/>
<div class="cooldown-overlay" id="sacredFaithCooldownOverlay"></div>
<div class="seal-overlay" id="sacredFaithSealOverlay">X</div>
<span class="key-hint">W</span>
<span class="cooldown-text" id="sacredFaithCooldownText">45</span>
</div>
<!-- 한계 집중 스킬 아이콘 -->
<div class="skill-icon-box" id="limitFocusIcon" style="margin-left: 5px;">
<img alt="한계 집중" class="skill-img" id="limitFocusImg" src=""/>
<div class="cooldown-overlay" id="limitFocusCooldownOverlay"></div>
<div class="seal-overlay" id="limitFocusSealOverlay">X</div>
<span class="key-hint">E</span> <span class="cooldown-text" id="limitFocusCooldownText">45</span>
</div>
<!-- 천상의 도약 스킬 아이콘 -->
<div class="skill-icon-box" id="divineDashSkillIcon" style="margin-left: 5px;">
<img alt="천상의 도약" class="skill-img" id="divineDashSkillImg" src=""/>
<div class="cooldown-overlay" id="divineDashCooldownOverlay"></div>
<div class="seal-overlay" id="divineDashSealOverlay">X</div>
<span class="key-hint">Space</span>
<span class="cooldown-text" id="divineDashCooldownText">15</span>
</div>
<!-- 회개의 외침 스킬 아이콘 -->
<div class="skill-icon-box" id="novaSkillIcon" style="margin-left: 5px;">
<img alt="회개의 외침" class="skill-img" id="novaSkillImg" src=""/>
<div class="cooldown-overlay" id="novaCooldownOverlay"></div>
<div class="seal-overlay" id="novaSealOverlay">X</div>
<span class="key-hint">A</span>
<span class="cooldown-text" id="novaCooldownText">20</span>
</div>
</div>
<div class="status-icon-box berserk-border" id="berserkStatus" style="display: none;">
<img alt="베르세르크" class="status-img" id="berserkIcon" src=""/>
<span class="status-text" style="color:#FF0000;"><span id="berserkName">베르세르크!</span></span>
</div>
<div class="status-icon-box shield-border" id="shieldStatus" style="display: none;">
<img alt="보호" class="status-img" id="shieldIcon" src=""/>
<span class="status-text" style="color:#00BFFF;"><span id="shieldName">보호막</span> x <span id="shieldStacks">0</span></span>
</div>
<div class="status-icon-box justice-border" id="justiceStatus" style="display: none;">
<img alt="정의" class="status-img" id="justiceIcon" src=""/>
<span class="status-text" style="color:#FFD700;"><span id="justiceName">정의의 가호</span> x <span id="justiceStacks">0</span></span>
</div>
<div class="status-icon-box blind-border" id="blindStatus" style="display: none;">
<img alt="실명" class="status-img" id="blindIcon" src=""/>
<span class="status-text" style="color:#808080;"><span id="blindName">실명(명중↓)</span> x <span id="blindStacks">0</span></span>
</div>
<div class="status-icon-box paralysis-border" id="paralysisStatus" style="display: none;">
<img alt="마비" class="status-img" id="paralysisIcon" src=""/>
<span class="status-text" style="color:#9370DB;"><span id="paralysisName">마비(이동↓)</span> x <span id="paralysisStacks">0</span></span>
</div>
<div class="status-icon-box poison-border" id="poisonStatus" style="display: none;">
<img alt="가스중독" class="status-img" id="poisonDebuffIcon" src=""/>
<span class="status-text" style="color:#00ff00;"><span id="poisonName">가스</span> x <span id="poisonStacks">0</span></span>
</div>

<div class="status-icon-box fishy-border" id="fishyStatus" style="display: none;">
<img alt="비린내" class="status-img" id="fishyIcon" src=""/>
<span class="status-text" style="color:#7FFFD4;"><span id="fishyName">비린내 붓카게</span> x <span id="fishyStacks">0</span></span>
</div>
<div class="status-icon-box poop-border" id="poopStatus" style="display: none;">
<img alt="똥독" class="status-img" id="poopDebuffIcon" src=""/>
<span class="status-text" style="color:#D2691E;"><span id="poopName">똥독</span> x <span id="poopStacks">0</span></span>
</div>
<div class="status-icon-box bleeding-border" id="bleedingStatus" style="display: none;">
<img alt="출혈" class="status-img" id="bleedingIcon" src=""/>
<span class="status-text" style="color:#DC143C;">출혈 <span id="bleedingVal"></span></span>
</div>
<div class="status-icon-box darkness-border" id="darknessStatus" style="display: none;">
<img alt="암흑" class="status-img dark-icon" id="darknessIcon" src=""/>
<span class="status-text" style="color:#555;">암흑</span>
</div>
<div class="status-icon-box malice-border" id="maliceStatus" style="display: none;">
<img alt="악의의 바이러스" class="status-img" id="maliceIcon" src=""/>
<span class="status-text" style="color:#8A2BE2;"><span id="maliceName">악의의 바이러스</span> x <span id="maliceStacks">0</span></span>
</div>
<!-- -------------------------------------------- -->
<div class="status-icon-box kiss-border" id="kissStatus" style="display: none;">
<img alt="속박키스" class="status-img" id="kissDebuffIcon" src=""/>
<span class="status-text" style="color:#FF1493;"><span id="kissName">키스</span> x <span id="kissStacks">0</span></span>
</div>
<div class="status-icon-box semen-border" id="semenStatus" style="display: none;">
<img alt="질내사정" class="status-img" id="semenDebuffIcon" src=""/>
<span class="status-text" style="color:#FFFFFF; text-shadow: 1px 1px 0 #888;"><span id="semenName">점액</span> x <span id="semenStacks">0</span></span>
</div>
<div class="status-icon-box oral-border" id="oralStatus" style="display: none;">
<img alt="구내사정" class="status-img" id="oralDebuffIcon" src=""/>
<span class="status-text" style="color:#FFFDD0; text-shadow: 1px 1px 0 #888;"><span id="oralName">구내사정</span> x <span id="oralStacks">0</span></span>
</div>
<div class="status-icon-box byururut-border" id="byururutStatus" style="display: none;">
<img alt="뷰루룻" class="status-img" id="byururutDebuffIcon" src=""/>
<span class="status-text" style="color:#FFFDD0; text-shadow: 1px 1px 0 #888;"><span id="byururutName">뷰루룻</span> x <span id="byururutStacks">0</span></span>
</div>
<div class="status-icon-box evil-mind-border" id="evilMindStatus" style="display: none;">
<img alt="사악한 마음" class="status-img" id="evilMindDebuffIcon" src=""/>
<span class="status-text" style="color:#800080;"><span id="evilMindName">사악한 마음</span> x <span id="evilMindStacks">0</span></span>
</div>
</div>
<div class="score-box">생존: <span id="scoreVal">0</span> | 킬: <span id="killVal">0</span></div>
<div class="status-container-right">
<div class="status-icon-box pheromone-overload-border" id="pheromoneOverloadStatus" style="display: none;">
<img alt="페로몬 오버로드" class="status-img" id="pheromoneOverloadIcon" src=""/>
<div class="flex flex-col" style="line-height: 1.1;">
<span class="status-text" style="color:#FF0000;">페로몬 오버로드</span>
<span id="pheromoneOverloadInfo" style="font-size: 14px; color: #FFB3B3; text-shadow: 1px 1px 0 #000; font-weight: bold;">남은 0.0s | 크리 0/3</span>
</div>
</div>
<div class="status-icon-box darkness-overwhelm-border" id="darknessOverwhelmStatus" style="display: none;">
<img alt="다크니스 오버휠름" class="status-img" id="darknessOverwhelmIcon" src=""/>
<span class="status-text" style="color:#483d8b;">다크니스 오버휠름 (속도)</span>
</div>
<div class="status-icon-box hyper-border" id="hypersensitivityStatus" style="display: none;">
<img alt="과민 반응" class="status-img" id="hyperIcon" src=""/>
<span class="status-text" style="color:#FFFF00;"><span id="hyperName">과민 반응 (기절주의!)</span></span>
</div>
<div class="status-icon-box corrupted-oath-border" id="corruptedOathStatus" style="display: none;">
<img alt="타락한 맹세" class="status-img" id="corruptedOathIcon" src=""/>
<span class="status-text" style="color:#8B0000;"><span id="corruptedOathName">타락한 맹세</span> x <span id="corruptedOathStacks">0</span></span>
</div>
<div class="status-icon-box dangerous-judgment-border" id="dangerousJudgmentStatus" style="display: none;">
<img alt="위험한 판단" class="status-img" id="dangerousJudgmentIcon" src=""/>
<span class="status-text" style="color:#FFA500;"><span id="dangerousJudgmentName">위험한 판단</span> x <span id="dangerousJudgmentStacks">0</span></span>
</div>
<div class="status-icon-box deep-darkness-border" id="deepDarknessStatus" style="display: none;">
<img alt="짙은 어둠" class="status-img" id="deepDarknessIcon" src=""/>
<span class="status-text" style="color:#222;"><span id="deepDarknessName">짙은 어둠</span> x <span id="deepDarknessStacks">0</span></span>
</div>
<div class="status-icon-box corrupted-justice-border" id="corruptedJusticeStatus" style="display: none;">
<img alt="타락한 정의" class="status-img" id="corruptedJusticeIcon" src=""/>
<span class="status-text" style="color:#555;"><span id="corruptedJusticeName">타락한 정의</span> x <span id="corruptedJusticeStacks">0</span></span>
</div>
<div class="status-icon-box serum-contamination-border" id="serumContaminationStatus" style="display: none;">
<img alt="혈청 오염" class="status-img" id="serumContaminationIcon" src=""/>
<span class="status-text" style="color:#FF6347;">혈청 오염 (회복 불가)</span>
</div>
<!-- 아서 신규 디버프 UI -->
<div class="status-icon-box majesty-border" id="majestyStatus" style="display: none;">
<img alt="군주의 위엄" class="status-img" id="majestyIcon" src=""/>
<span class="status-text" style="color:#DAA520;">군주의 위엄 (쿨감↓, 회복↓)</span>
</div>
<div class="status-icon-box true-ancestor-border" id="trueAncestorKissStatus" style="display: none;">
<img alt="진조의 키스" class="status-img" id="trueAncestorKissIcon" src=""/>
<span class="status-text" style="color:#DC143C;">진조의 키스 x <span id="trueAncestorKissStacks">0</span></span>
</div>
<div class="status-icon-box fatal-scar-border" id="fatalScarStatus" style="display: none;">
<img alt="페이탈 스칼" class="status-img" id="fatalScarIcon" src=""/>
<span class="status-text" style="color:#8B0000;">페이탈 스칼 x <span id="fatalScarStacks">0</span></span>
</div>
<div class="status-icon-box corrupted-blood-border" id="corruptedBloodStatus" style="display: none;">
<img alt="더럽혀진 피" class="status-img" id="corruptedBloodIcon" src=""/>
<span class="status-text" style="color:#800000;">더럽혀진 피 x <span id="corruptedBloodStacks">0</span></span>
</div>
<div class="status-icon-box geoptal-border" id="geoptalStatus" style="display: none;">
<img alt="겁탈" class="status-img" id="geoptalIcon" src=""/>
<span class="status-text" style="color:#ff0055;"><span id="geoptalName">겁탈(방어↓)</span> x <span id="geoptalStacks">0</span></span>
</div>
<div class="status-icon-box death-brand-border" id="deathBrandStatus" style="display: none;">
<img alt="죽음의 낙인" class="status-img" id="deathBrandIcon" src=""/>
<span class="status-text" style="color:#696969; text-shadow: 1px 1px 0 #000;">죽음의 낙인 (회피/치명타 저항 확률 50%↓)</span>
</div>
<div class="status-icon-box curse-border" id="curseStatus" style="display: none;">
<img alt="저주" class="status-img" id="curseIcon" src=""/>
<span class="status-text" style="color:#4B0082;"><span id="curseName">저주</span> x <span id="curseStacks">0</span></span>
</div>
<div class="status-icon-box fracture-border" id="fractureStatus" style="display: none;">
<img alt="골절" class="status-img" id="fractureIcon" src=""/>
<span class="status-text" style="color:#A9A9A9;">골절 (치명타 저항 확률 -5) x <span id="fractureStacks">0</span></span>
</div>
<div class="status-icon-box gnawing-life-border" id="gnawingLifeStatus" style="display: none;">
<img alt="좀먹는 생명" class="status-img" id="gnawingLifeIcon" src=""/>
<span class="status-text" style="color:#6B8E23;"><span id="gnawingLifeName">좀먹는 생명</span> x <span id="gnawingLifeStacks">0</span></span>
</div>
<div class="status-icon-box dark-scent-border" id="darkScentStatus" style="display: none;">
<img alt="카인의 향기" class="status-img dark-icon" id="darkScentIcon" src=""/>
<span class="status-text" style="color:#2F4F4F;"><span id="darkScentName">카인의 향기</span> x <span id="darkScentStacks">0</span></span>
</div>
<div class="status-icon-box dark-smell-border" id="darkSmellStatus" style="display: none;">
<img alt="카인의 똥내" class="status-img dark-icon" id="darkSmellIcon" src=""/>
<span class="status-text" style="color:#3e2723;"><span id="darkSmellName">카인의 똥내</span> x <span id="darkSmellStacks">0</span></span>
</div>
<div class="status-icon-box dark-seed-border" id="darkSeedStatus" style="display: none;">
<img alt="카인의 씨앗" class="status-img dark-icon" id="darkSeedIcon" src=""/>
<span class="status-text" style="color:#4a4a4a;"><span id="darkSeedName">카인의 씨앗</span> x <span id="darkSeedStacks">0</span></span>
</div>
<div class="status-icon-box dark-kiss-border" id="darkKissStatus" style="display: none;">
<img alt="카인의 키스" class="status-img dark-icon" id="darkKissIcon" src=""/>
<span class="status-text" style="color:#880e4f;"><span id="darkKissName">카인의 키스</span> x <span id="darkKissStacks">0</span></span>
</div>
<div class="status-icon-box dark-receiver-border" id="darkReceiverStatus" style="display: none;">
<img alt="카인의 좆집" class="status-img dark-icon" id="darkReceiverIcon" src=""/>
<span class="status-text" style="color:#1a237e;"><span id="darkReceiverName">카인의 좆집</span> x <span id="darkReceiverStacks">0</span></span>
</div>
<div class="status-icon-box evil-light-border" id="evilLightStatus" style="display: none;">
<img alt="사악한 빛" class="status-img dark-icon" id="evilLightIcon" src=""/>
<span class="status-text" style="color:#3d004d;"><span id="evilLightName">사악한 빛</span></span>
</div>
<div class="status-icon-box" id="blasphemyStatus" style="display: none; border: 2px solid #000000; box-shadow: 0 0 10px #FF0000;">
<img alt="신성 모독" class="status-img" id="blasphemyIcon" src=""/>
<span class="status-text" style="color:#FF0000;">신성 모독</span>
</div>
<div class="status-icon-box confusion-border" id="confusionStatus" style="display: none;">
<img alt="정신착란" class="status-img" id="confusionIcon" src=""/>
<span class="status-text" style="color:#FF4500;">정신착란</span>
</div>
<div class="status-icon-box shading-border" id="shadingStatus" style="display: none;">
<img alt="차광" class="status-img" id="shadingIcon" src=""/>
<span class="status-text" style="color:#4B0082;">차광 (치명타 저항 감소)</span>
</div>
<div class="status-icon-box dark-ecstasy-border" id="darkEcstasyStatus" style="display: none;">
<img alt="어둠의 환희" class="status-img" id="darkEcstasyIcon" src=""/>
<span class="status-text" style="color:#9932CC;"><span id="darkEcstasyName">어둠의 환희</span> x <span id="darkEcstasyStacks">0</span></span>
</div>
<div class="status-icon-box despair-border" id="despairStatus" style="display: none;">
<img alt="절망" class="status-img" id="despairIcon" src=""/>
<span class="status-text" style="color:#708090;">절망 (스킬 실패)</span>
</div>
<div class="status-icon-box baptism-border" id="baptismStatus" style="display: none;">
<img alt="세례" class="status-img" id="baptismIcon" src=""/>
<span class="status-text" style="color:#4169E1;">세례 (공격력↓) x <span id="baptismStacks">0</span></span>
</div>
<div id="xp-bar-container">
<div id="xp-bar"></div>
</div>
<div id="level-text">Lv.1</div>
</div>
<div class="mobile-hint">화면을 드래그하여 이동하세요</div>
<div id="levelUpModal">
<div id="levelUpTitle">LEVEL UP!</div>
<div class="card-container" id="cardContainer">
</div>
<button id="showStatsBtn">내 스탯 확인</button>
</div> <div id="statsInfoBox">
<h2 style="text-align:center; color:#fff; margin-top:0; margin-bottom:15px;">현재 스탯</h2>
<div id="statsContent">
</div>
<button id="closeStatsBtn">닫기</button>
</div>
</div>

<!-- ========================================================= -->
<!-- [신규] 전리품 인벤토리 + 장비 강화 패널 (P) -->
<!-- ========================================================= -->
<div id="gearPanel">
  <div class="modal-panel">
    <div class="modal-header">
      <div>
        <div class="modal-title">인벤토리 · 장비 강화</div>
        <div class="modal-sub">P / ESC로 닫기 · 인벤토리 아이템을 드래그&드롭 또는 클릭하여 재료 슬롯에 투입하세요</div>
      </div>
      <button id="closeGearPanelBtn" class="modal-close">닫기</button>
    </div>

    <div class="gear-layout">
      <div class="panel-left">
        <div class="panel-section-title">인벤토리</div>
        <div class="panel-section-sub">64칸 · 전리품 자동 저장 · 화면 폭에 따라 자동 배치 · 슬롯 드래그로 위치 이동</div>

        <div class="inv-action-row">
          <button id="invSortBtn" class="gear-btn inv-mini-btn">자동 정렬</button>
          <button id="invSynthesisBtn" class="gear-btn inv-mini-btn">합성</button>
          <button id="invSynthClearBtn" class="gear-btn inv-mini-btn">선택 초기화</button>
          <div id="invSynthesisInfo" class="inv-synth-info">
            일반 합성: 일반 빌런 <b>일반</b> 전리품 총합 <b>10개(혼합 가능)</b> → 엘리트 빌런 <b>일반</b> 전리품 랜덤 1개<br/>
            레어 합성: 일반 빌런 <b>레어</b> 전리품 총합 <b>5개(혼합 가능)</b> → 엘리트 빌런 <b>레어</b> 전리품 랜덤 1개<br/>
            상위 일반 합성: 엘리트 빌런 <b>일반</b> 전리품 총합 <b>10개(혼합 가능)</b> → 로열 빌런 <b>일반</b> 전리품 랜덤 1개<br/>
            상위 레어 합성: 엘리트 빌런 <b>레어</b> 전리품 총합 <b>5개(혼합 가능)</b> → 로열 빌런 <b>레어</b> 전리품 랜덤 1개<br/>
            최상위 일반 합성: 로열 빌런 <b>일반</b> 전리품 총합 <b>10개(혼합 가능)</b> → 보스 빌런 <b>일반</b> 전리품 랜덤 1개<br/>
            최상위 레어 합성: 로열 빌런 <b>레어</b> 전리품 총합 <b>5개(혼합 가능)</b> → 보스 빌런 <b>레어</b> 전리품 랜덤 1개
          </div>
        </div>

        <div id="inventoryGrid" class="inventory-grid"></div>
      </div>

      <div class="panel-right">
        <div class="panel-section-title">장비 강화</div>
        <div class="panel-section-sub">강화 패널이 열려있을 때 시간은 일시정지됩니다</div>

        <div class="enhance-body">
          <div class="gear-card" id="weaponCard">
            <div class="gear-top">
              <img id="weaponIcon" class="gear-icon" alt="성검 그록스" />
              <div style="flex:1;">
                <div class="gear-name" id="weaponName">성검 그록스</div>
                <div class="gear-level" id="weaponLevelText">Lv.1</div>
                <div class="gear-stats" id="weaponStatsText"></div>
              </div>
            </div>
            <div class="gear-req" id="weaponReqText"></div>
            <div class="mat-slots" id="weaponMatSlots"></div>
            <div class="gear-actions">
              <div class="gear-mini" id="weaponHaveText"></div>
              <button class="gear-btn" id="weaponUpgradeBtn">강화</button>
            </div>
          </div>

          <div class="gear-card" id="armorCard">
            <div class="gear-top">
              <img id="armorIcon" class="gear-icon" alt="성갑 토렌스" />
              <div style="flex:1;">
                <div class="gear-name" id="armorName">성갑 토렌스</div>
                <div class="gear-level" id="armorLevelText">Lv.1</div>
                <div class="gear-stats" id="armorStatsText"></div>
              </div>
            </div>
            <div class="gear-req" id="armorReqText"></div>
            <div class="mat-slots" id="armorMatSlots"></div>
            <div class="gear-actions">
              <div class="gear-mini" id="armorHaveText"></div>
              <button class="gear-btn" id="armorUpgradeBtn">강화</button>
            </div>
          </div>
        </div>

        <div class="panel-hint">
          <div class="panel-hint-title">사용법</div>
          <ul class="panel-hint-list">
            <li><b>재료 슬롯</b>을 클릭해 선택한 뒤, <b>인벤토리 아이템</b>을 클릭하면 자동 투입됩니다.</li>
            <li>인벤토리 아이템을 <b>재료 슬롯 위로 드래그&드롭</b>해도 투입됩니다.</li>
            <li>인벤토리 슬롯을 <b>서로 드래그</b>하면 위치를 바꿀 수 있습니다. <b>자동 정렬</b> 버튼도 지원합니다.</li>
            <li>재료 슬롯 우측의 <b>✕</b> 버튼으로 투입한 재료를 되돌릴 수 있습니다.</li>
          </ul>
        </div>
      </div>
    </div>
  </div>
</div>



<!-- =========================================================
     [NEW] 장비 인벤토리 + 장착 패널 (I)
========================================================= -->
<div id="equipPanel">
  <div class="modal-panel equip-modal">
    <div class="modal-header">
      <div>
        <div class="modal-title">장비 인벤토리 · 장착</div>
        <div class="modal-sub">I / ESC로 닫기 · 장비를 클릭/더블클릭해서 장착, 분해, 버리기가 가능합니다.</div>
      </div>
      <button id="closeEquipPanelBtn" class="modal-close">닫기</button>
    </div>

    <div class="equip-layout">
      <div class="equip-left">
        <div class="panel-section-title">장착 슬롯</div>
        <div class="panel-section-sub">투구 · 검 · 갑옷 · 장갑 · 신발 · 반지 · 목걸이</div>
        <div id="equipSlotsUI" class="equip-slots-grid"></div>

        <div class="panel-section-title" style="margin-top:14px;">장비 요약</div>
        <div id="equipStatsSummary" class="equip-stats-summary"></div>
      </div>

      <div class="equip-right">
        <div class="panel-section-title">장비 인벤토리</div>
        <div class="panel-section-sub">128칸 · 적 처치 시 자동 획득 · 인벤토리가 가득 차면 보관 대기 · 슬롯 드래그로 위치 이동</div>

        <div class="inv-action-row">
          <button id="gearSortBtn" class="gear-btn inv-mini-btn">자동 정렬</button>
          <select id="gearBulkRaritySelect" class="gear-btn inv-mini-btn" style="pointer-events:auto; max-width:180px;">
            <option value="epic">에픽 이하 일괄 분해</option>
            <option value="rare">레어 이하 일괄 분해</option>
            <option value="uncommon">언커먼 이하 일괄 분해</option>
            <option value="common">커먼만 일괄 분해</option>
          </select>
          <button id="gearBulkDisassembleBtn" class="gear-btn danger inv-mini-btn">일괄 분해</button>
          <div id="pendingGearInfo" class="inv-synth-info" style="margin-left:auto;"></div>
        </div>

        <div id="gearInventoryGrid" class="inventory-grid gear-inventory-grid"></div>

        <div class="gear-actions">
          <div id="gearSelectionInfo" class="gear-selection"></div>
          <div class="gear-actions-buttons">
            <button id="gearEquipBtn" class="gear-btn">장착</button>
            <button id="gearUnequipBtn" class="gear-btn">해제</button>
            <button id="gearDisassembleBtn" class="gear-btn danger">분해</button>
            <button id="gearDropBtn" class="gear-btn danger">버리기</button>
          </div>
        </div>

        <div class="gear-hint">
          <div>• 장비에 마우스를 올리면 설명/옵션이 표시됩니다. (우클릭으로 잠금/해제)</div>
          <div>• 유니크 이상은 효과음이 재생되며, 레전더리/데모닉/엔젤릭 순으로 더 화려해집니다.</div>
        </div>
      </div>
    </div>
  </div>
</div>


<!-- [NEW] 유물 시스템 패널 (O) -->
<div id="relicPanel">
  <div class="modal-panel relic-modal">
    <div class="modal-header">
      <div>
        <div class="modal-title">유물</div>
        <div class="modal-sub">전리품을 투입해 유물을 해금하세요 · 능력치는 항상 적용 · 특수 효과는 ‘장착’한 유물만 적용</div>
      </div>
      <button id="closeRelicPanelBtn" class="modal-close">닫기</button>
    </div>

    <!-- Collection View -->
    <div id="relicCollectionView">
      <div class="relic-equip-bar">
        <div class="relic-equip-title">장착한 유물 (특수 효과 활성)</div>
        <div class="relic-equip-slots" id="relicEquipSlots"></div>
      </div>
      <div class="relic-grid" id="relicGrid"></div>
    </div>

    <!-- Detail View -->
    <div id="relicDetailView" style="display:none;">
      <div class="relic-detail-top">
        <button id="relicBackBtn" class="gear-btn inv-mini-btn">← 목록</button>
        <div class="relic-detail-title" id="relicDetailTitle">유물</div>
        <div style="flex:1;"></div>
        <div class="relic-btn-row">
          <button id="relicInvToggleBtn" class="gear-btn inv-mini-btn">인벤토리</button>
          <button id="relicEquipBtn" class="gear-btn">장착</button>
        </div>
      </div>

      <div class="relic-detail-body">
        <div class="relic-board" id="relicBoard"></div>

        <div class="relic-side">
          <div class="panel-section-title">전리품 투입</div>
          <div class="panel-section-sub">슬롯을 선택한 뒤 인벤토리 아이템을 클릭하면 투입됩니다. (좌클릭 1개 / Shift·우클릭 최대)</div>
          <div class="relic-inv-wrap" id="relicInventoryWrap" style="display:none;">
            <div class="relic-inv-grid" id="relicInventoryGrid"></div>
          </div>

          <div class="panel-section-title" style="margin-top:14px;">특수 효과 (장착 시)</div>
          <div id="relicEffectDesc" class="relic-effect-desc"></div>

          <div class="panel-section-title" style="margin-top:14px;">능력치 (장착 없이도 적용)</div>
          <div id="relicStatsDesc" class="relic-stats-desc"></div>
        </div>
      </div>
    </div>
  </div>
</div>

<div id="invTooltip" class="inv-tooltip"></div>

<div id="synthFx" class="synth-fx" aria-hidden="true"><canvas id="synthFxCanvas"></canvas></div>

<div id="screen-overlay">
<h1 class="title">가죽바지 빌런<br/>서바이벌</h1>
<p class="subtitle">
            캐릭터가 <span style="color:#ffcc00">자동으로 공격</span>합니다.<br/>
<span style="color:#00BFFF">보호의 하트</span>와 <span style="color:#FFD700">Q스킬(여신의 가호)</span>로 상태이상을 방어하세요!<br/>
<span style="color:#ffd700">W스킬(성스러운 믿음)</span>으로 치명타 확률을 줄이세요!<br/>
<span style="color:#00ffff">A스킬(회개의 외침)</span>으로 위기를 탈출하세요!<br/>
<span style="color:#FF0000; font-weight:bold;">어둠의 도래</span>
</p>
<button class="btn" id="startBtn">게임 시작</button>
<button class="btn" id="gameOverStatsBtn" style="display:none; margin-top:15px; background-color: #333; border: 2px solid #aaa; font-size: 20px;">사망 스탯 확인</button>
</div>
<script>
        // ==================================================================================
        // [이미지 커스터마이징 영역]
        // ==================================================================================
        const novaSkillIconSrc = "https://i.ifh.cc/8wVPWP.jpg"; 
        const sacredFaithSkillImgSrc = "https://i.ifh.cc/zcCSL8.jpg"; 
        const limitFocusIconSrc = "https://i.ifh.cc/dR0TkQ.jpg";
        const goddessSkillImgSrc = "https://i.ifh.cc/t1V1v5.jpg"; 
        const hiroImgSrc = "https://i.ifh.cc/3YwsSM.jpg"; 
        // [신규] 아키 '이블 애로우' 발사체 이미지 (첨부 PNG를 배경 제거 후 내장)
        const akiEvilArrowDevilImg = new Image();
        akiEvilArrowDevilImg.src = "./evil_arrow_devil_transparent.png";
        // base64가 보기 싫으면, 이미지를 파일로 분리해서 같은 폴더에 두는 방식이 가장 깔끔합니다.
        akiEvilArrowDevilImg.onerror = () => console.warn("evil_arrow_devil_transparent.png를 HTML과 같은 폴더에 넣어주세요.");

        // [신규] 아키 '포이즈너스 샷' 발사체 이미지 (투명 PNG 파일을 같은 폴더에 두세요)
        const akiPoisonousShotImg = new Image();
        akiPoisonousShotImg.src = "./aki_poisonous_shot.png";
        akiPoisonousShotImg.onerror = () => console.warn("aki_poisonous_shot.png를 HTML과 같은 폴더에 넣어주세요.");

        
        // [신규] 검은 민족 테토라 및 스킬 이미지
        const tetoraImgSrc = "https://i.ifh.cc/OoPjFM.jpg"; // ★ 테토라 이미지 (커스텀 필요)
        const tetoraImg = new Image(); 
        tetoraImg.src = tetoraImgSrc;

        // [신규] 퀘스타 이미지 및 아이콘
        const questaImgSrc = "https://i.ifh.cc/HfdXXh.jpg"; // ★ 퀘스타 이미지 주소 입력 (커스터마이즈)
        const fractureIconSrc = "https://i.ifh.cc/4Kcfo8.jpg"; // ★ 골절 아이콘 주소 입력 (커스터마이즈)
        
        const questaImg = new Image(); 
        questaImg.src = questaImgSrc;

        // [신규] 검은 민족 카이토 및 관련 이미지
        const kaitoImgSrc = "https://i.ifh.cc/MbWl3j.jpg"; //
        const kaitoImg = new Image(); kaitoImg.src = kaitoImgSrc;

        const despairIconSrc = "https://i.ifh.cc/8W1Qbf.jpg";
        const baptismIconSrc = "https://i.ifh.cc/kKnoKF.jpg";

        // [신규] 검은 민족 마사쿠니 이미지 (커스터마이즈 가능)
        const masakuniImgSrc = "https://i.ifh.cc/l7Knjn.jpg";
        const masakuniImg = new Image(); 
        masakuniImg.src = masakuniImgSrc;

        const kaiImgSrc = "https://i.ifh.cc/lDSMxF.jpg";
        const kaiImg = new Image(); kaiImg.src = kaiImgSrc;

        const jacquesImgSrc = "https://i.ifh.cc/caP80b.jpg";
        const jacquesImg = new Image(); jacquesImg.src = jacquesImgSrc;
        const blasphemyIconSrc = "https://i.ifh.cc/4j7Alv.jpg";
        const deathBrandIconSrc = "https://i.ifh.cc/OGcch6.jpg"; // 원하는 이미지 주소로 변경하세요 ★죽음의 낙인 아이콘 주소 입력★
        const bleedingIconSrc = "https://i.ifh.cc/faQZ8Z.jpg"; // 출혈 아이콘 주소
        const shadingIconSrc = "https://i.ifh.cc/16CqwH.jpg"; // 차광 아이콘 주소
        const darknessIconSrc = "https://i.ifh.cc/Z94Wa8.jpg"; // 암흑 아이콘
        const confusionIconSrc = "https://i.ifh.cc/5hbTZ0.jpg"; // 정신착란 아이콘

        // [신규] 보스 기믹 아이콘 이미지 (원하는 주소로 변경 가능)
        const pheromoneOverloadIconSrc = "https://i.ifh.cc/Rs2bWR.jpg"; 
        const darknessOverwhelmIconSrc = "https://i.ifh.cc/soyV4f.jpg"; 


        // ================================================================
        // [보조] 페로몬 오버로드: UI 갱신 / 해제 공통 처리
        //  - 해제 조건: (1) 10초 경과, (2) 크리티컬 3회 피격, (3) 카인 사망
        // ================================================================
        function updatePheromoneOverloadUI() {
            const infoEl = document.getElementById('pheromoneOverloadInfo');
            if (!infoEl) return;
            if (player.pheromoneOverloadTimer > 0) {
                const sec = (player.pheromoneOverloadTimer / 60).toFixed(1);
                const cnt = (player.pheromoneOverloadCritCount || 0);
                infoEl.textContent = `남은 ${sec}s | 크리 ${cnt}/3`;
            }
        }

        function endPheromoneOverload() {
            player.pheromoneOverloadTimer = 0;
            player.pheromoneOverloadCritCount = 0;

            // UI 즉시 반영
            const phStatus = document.getElementById('pheromoneOverloadStatus');
            if (phStatus) phStatus.style.display = 'none';

            // bloodOverlay는 다른 효과(군주의 위엄/더럽혀진 피)가 없을 때만 끄기
            const bloodOverlay = document.getElementById('bloodOverlay');
            if (bloodOverlay && !player.majestyActive && player.corruptedBloodTimers.length === 0) {
                bloodOverlay.style.opacity = 0;
            }
        }

        // [신규] 혈청 오염 아이콘 (커스터마이징 가능)
        const serumContaminationIconSrc = "https://i.ifh.cc/zGNVfg.jpg";

        const arthurImgSrc = "https://i.ifh.cc/lMCXBQ.jpg"; // 아서 이미지
        const majestyIconSrc = "https://i.ifh.cc/l8KVCB.jpg"; // 군주의 위엄 (아서 아이콘 재활용)
        const trueAncestorKissIconSrc = "https://i.ifh.cc/FZRpzQ.jpg"; // 진조의 키스 (키스 아이콘 재활용)
        const fatalScarIconSrc = "https://i.ifh.cc/zYKx2c.jpg"; // 페이탈 스칼
        const corruptedBloodIconSrc = "https://i.ifh.cc/T8FJOn.jpg"; // 더럽혀진 피

        // [신규] 천상의 도약 스킬 아이콘 (커스터마이징 가능)
        const divineDashIconSrc = "https://i.ifh.cc/nTqFDL.jpg"; // 원하는 이미지 주소로 변경하세요

        // [신규] 아서 등장 BGM
        const arthurSpawnBgmSrc = "https://adverse-chocolate-xu548n9xf6-uxib5ngrdl.edgeone.dev/KakaoTalk_20251228_162954993.mp4"; //
        // ==================================================================================

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // =========================
        // [최적화] 다크 똥(유도 포함) 스프라이트 캐시
        // - 기존: 매 프레임마다 createRadialGradient/ellipse/shadowBlur 등을 똥 개수만큼 수행 → 프레임 드랍
        // - 변경: radius별로 1회만 오프스크린 캔버스에 그려두고, 매 프레임엔 drawImage만 수행
        // =========================
        const _darkBigPoopSpriteCache = new Map();

        function _makeDarkBigPoopSprite(radius) {
            const r = Math.max(1, radius);
            const pad = Math.ceil(r * 1.6);  // 오라/그림자 여백
            const size = Math.ceil(r * 4.2) + pad * 2;
            const c = document.createElement('canvas');
            c.width = size; c.height = size;
            const g = c.getContext('2d');

            const cx = size / 2, cy = size / 2;

            // 색상 팔레트 (검정, 다크 그레이, 보라빛)
            const baseColor = '#1a1a1a';
            const midColor  = '#333333';
            const darkColor = '#000000';
            const glowColor = '#4B0082';

            g.save();
            g.translate(cx, cy);

            // 오라(스프라이트 내부에서만 1회 계산)
            g.shadowColor = glowColor;
            g.shadowBlur = Math.max(8, Math.floor(r * 0.35));

            const drawDarkLump = (yOffset, width, height) => {
                g.beginPath();
                const grad = g.createRadialGradient(-width*0.2, yOffset-height*0.2, width*0.1, 0, yOffset, width);
                grad.addColorStop(0, midColor);
                grad.addColorStop(0.3, baseColor);
                grad.addColorStop(0.8, darkColor);
                grad.addColorStop(1, '#100010');
                g.fillStyle = grad;
                g.ellipse(0, yOffset, width, height, 0, 0, Math.PI * 2);
                g.fill();

                // 균열(정적)
                g.shadowBlur = 0;
                g.strokeStyle = 'rgba(75, 0, 130, 0.45)';
                g.lineWidth = 1;
                g.beginPath();
                g.moveTo(-width*0.5, yOffset);
                g.quadraticCurveTo(0, yOffset - height*0.5, width*0.5, yOffset + height*0.3);
                g.stroke();

                // 오라 재적용(다음 덩어리용)
                g.shadowColor = glowColor;
                g.shadowBlur = Math.max(8, Math.floor(r * 0.35));
            };

            // 바닥, 중간, 끝 (기존과 동일한 비율)
            drawDarkLump(r * 0.4,  r,       r * 0.6);
            drawDarkLump(-r * 0.2, r * 0.8, r * 0.55);
            drawDarkLump(-r * 0.8, r * 0.5, r * 0.5);

            // 간단한 "냄새" 라인(정적) — 기존의 Date.now 기반 웨이브는 런타임 비용이 커서 정적으로 축소
            g.shadowBlur = Math.max(4, Math.floor(r * 0.12));
            g.shadowColor = '#8A2BE2';
            g.strokeStyle = 'rgba(50, 0, 50, 0.7)';
            g.lineWidth = Math.max(2, Math.floor(r * 0.06));
            g.beginPath();
            for (let k = 0; k < 3; k++) {
                const startX = (k - 1) * r * 0.35;
                g.moveTo(startX, -r * 0.9);
                g.lineTo(startX + (k === 1 ? 8 : -6), -r * 3.2);
            }
            g.stroke();

            g.restore();

            // 메타(그리기에서 편하게 쓰기)
            c.__half = size / 2;
            return c;
        }

        function getDarkBigPoopSprite(radius) {
            // radius가 부동소수로 바뀌어도 캐시가 과도하게 쌓이지 않도록 0.5단위로 스냅
            const key = Math.max(1, Math.round(radius * 2) / 2);
            let sprite = _darkBigPoopSpriteCache.get(key);
            if (!sprite) {
                sprite = _makeDarkBigPoopSprite(key);
                _darkBigPoopSpriteCache.set(key, sprite);
            }
            return sprite;
        }

// [Polyfill] ctx.roundRect for older browsers
if (ctx && !ctx.roundRect) {
  CanvasRenderingContext2D.prototype.roundRect = function(x, y, w, h, r) {
    const rr = Array.isArray(r) ? r[0] : r;
    const radius = Math.max(0, Math.min(rr || 0, Math.min(w, h) / 2));
    this.beginPath();
    this.moveTo(x + radius, y);
    this.lineTo(x + w - radius, y);
    this.quadraticCurveTo(x + w, y, x + w, y + radius);
    this.lineTo(x + w, y + h - radius);
    this.quadraticCurveTo(x + w, y + h, x + w - radius, y + h);
    this.lineTo(x + radius, y + h);
    this.quadraticCurveTo(x, y + h, x, y + h - radius);
    this.lineTo(x, y + radius);
    this.quadraticCurveTo(x, y, x + radius, y);
    this.closePath();
    return this;
  };
}

// === [Aki] Projectile Draw Cache (Evil Arrow / Drag Shot) ===
let _akiProjectileUid = 1;
const _akiDrawCache = {
  hookPath: null,
  devilBodyPath: null,
};

function _initAkiProjectilePaths() {
  if (_akiDrawCache.hookPath && _akiDrawCache.devilBodyPath) return;

  // Long hook (local space: forward = +x)
  const hook = new Path2D();
  // Shaft + hook curve
  hook.moveTo(-80, -10);
  hook.lineTo(20, -10);
  hook.quadraticCurveTo(45, -10, 45, -32);
  hook.quadraticCurveTo(45, -60, 10, -60);
  hook.lineTo(2, -46);
  hook.quadraticCurveTo(22, -46, 22, -32);
  hook.quadraticCurveTo(22, -22, 5, -22);
  hook.lineTo(-80, -22);
  hook.closePath();

  // Spikes / barbs (multiple) — cached Path2D (no per-frame random)
  // Main big barb (top)
  hook.moveTo(-10, -22);
  hook.lineTo(-28, -44);
  hook.lineTo(-6, -34);
  hook.closePath();

  // Additional barbs along the shaft (alternate top/bottom)
  // Barb 1 (top)
  hook.moveTo(-58, -10);
  hook.lineTo(-74, -26);
  hook.lineTo(-52, -18);
  hook.closePath();

  // Barb 2 (bottom)
  hook.moveTo(-48, -22);
  hook.lineTo(-66, -8);
  hook.lineTo(-44, -12);
  hook.closePath();

  // Barb 3 (top)
  hook.moveTo(-34, -10);
  hook.lineTo(-50, -28);
  hook.lineTo(-30, -18);
  hook.closePath();

  // Barb 4 (bottom)
  hook.moveTo(-24, -22);
  hook.lineTo(-42, -6);
  hook.lineTo(-20, -12);
  hook.closePath();

  // Barb 5 (top near curve)
  hook.moveTo(-8, -10);
  hook.lineTo(-24, -26);
  hook.lineTo(-4, -18);
  hook.closePath();

  _akiDrawCache.hookPath = hook;

  // Devil body silhouette (local space: forward = +x)
  // Rebuilt to be grotesque / unsettling (less round, more torn + asymmetrical)
  const devil = new Path2D();

  // Twisted torso
  devil.moveTo(-26, 0);
  devil.bezierCurveTo(-30, -22, -6, -32, 10, -24);
  devil.bezierCurveTo(30, -16, 44, -8, 46, 0);
  devil.bezierCurveTo(44, 16, 24, 30, 6, 26);
  devil.bezierCurveTo(-12, 22, -24, 12, -26, 0);
  devil.closePath();

  // Snout extension (longer, sharper)
  devil.moveTo(18, -4);
  devil.quadraticCurveTo(42, -16, 48, 0);
  devil.quadraticCurveTo(40, 16, 18, 5);
  devil.closePath();

  // Split jaw / fang
  devil.moveTo(12, 8);
  devil.lineTo(28, 22);
  devil.lineTo(8, 26);
  devil.closePath();

  // Torn back membrane (top)
  devil.moveTo(-10, -6);
  devil.lineTo(-46, -34);
  devil.lineTo(-30, -2);
  devil.closePath();

  // Torn back membrane (bottom)
  devil.moveTo(-12, 8);
  devil.lineTo(-42, 32);
  devil.lineTo(-24, 24);
  devil.closePath();

  // Ragged spine spikes
  devil.moveTo(-6, -14);
  devil.lineTo(-22, -30);
  devil.lineTo(-4, -24);
  devil.closePath();

  devil.moveTo(2, -16);
  devil.lineTo(-6, -38);
  devil.lineTo(12, -22);
  devil.closePath();

  devil.moveTo(10, -14);
  devil.lineTo(4, -36);
  devil.lineTo(22, -18);
  devil.closePath();

  // Asymmetric horns (one longer, one jagged)
  devil.moveTo(2, -18);
  devil.lineTo(-12, -48);
  devil.lineTo(16, -26);
  devil.closePath();

  devil.moveTo(18, -16);
  devil.lineTo(44, -44);
  devil.lineTo(24, -22);
  devil.closePath();

  // Forehead spike (adds "wrong" silhouette)
  devil.moveTo(8, -18);
  devil.lineTo(14, -36);
  devil.lineTo(20, -18);
  devil.closePath();

  _akiDrawCache.devilBodyPath = devil;
}

function _drawAkiPurpleElectric(ctx, frame, seed, backLen, spread, lineWidth = 2) {
  // Deterministic "sparks" (no Math.random in render loop)
  const phase = frame * 0.22 + seed * 0.001;

  ctx.save();
  ctx.globalCompositeOperation = 'lighter';
  ctx.lineWidth = lineWidth;
  ctx.lineCap = 'round';

  for (let s = 0; s < 2; s++) {
    const sign = s === 0 ? 1 : -1;

    ctx.beginPath();
    ctx.strokeStyle = 'rgba(75, 0, 130, 0.75)'; // Indigo
    ctx.moveTo(10, 0);
    for (let j = 1; j <= 3; j++) {
      const xx = -j * (backLen / 3);
      const yy = sign * (Math.sin(phase + j * 1.6 + s * 2.2) * spread) + (j === 3 ? 0 : sign * 4);
      ctx.lineTo(xx, yy);
    }
    ctx.stroke();

    ctx.beginPath();
    ctx.strokeStyle = 'rgba(138, 43, 226, 0.55)'; // BlueViolet glow
    ctx.moveTo(6, 0);
    for (let j = 1; j <= 3; j++) {
      const xx = -j * (backLen / 3);
      const yy = sign * (Math.sin(phase + j * 1.9 + 1.3 + s) * (spread * 0.8));
      ctx.lineTo(xx, yy);
    }
    ctx.stroke();
  }

  ctx.restore();
}

function drawAkiDragShot(ctx, shot, frame) {
    // 요청한 신규 드래그 샷 발사체 렌더링: 검정 전류 + 갈고리
    // (기존 Path2D 캐시/가스/보라 전류 연출은 사용하지 않음)
    // NOTE: Math.random()을 사용하므로 프레임마다 모양이 흔들리며 '찌릿' 느낌이 납니다.

    // [1] 검정색 전류 이펙트 (찌릿거리는 효과)
    ctx.save();
    ctx.strokeStyle = 'black';
    ctx.lineWidth = 2;
    ctx.beginPath();

    // 전류 줄기 3개를 랜덤하게 생성
    for (let k = 0; k < 3; k++) {
        let lx = shot.x;
        let ly = shot.y;
        ctx.moveTo(lx, ly);

        // 전류의 길이와 굴절
        for (let j = 0; j < 3; j++) {
            // 진행 방향 반대로 약간 퍼지며 찌릿거림
            lx += (Math.random() - 0.5) * 30 - (Math.cos(shot.angle) * 10);
            ly += (Math.random() - 0.5) * 30 - (Math.sin(shot.angle) * 10);
            ctx.lineTo(lx, ly);
        }
    }
    ctx.stroke();
    ctx.restore();

    // [2] 갈고리 모양 그리기
    ctx.save();
    ctx.translate(shot.x, shot.y);
    ctx.rotate(shot.angle); // 발사 각도에 맞춰 회전

    ctx.fillStyle = '#1a1a1a'; // 아주 진한 회색 (Aki 테마)
    ctx.strokeStyle = '#4B0082'; // 보라색 테두리
    ctx.lineWidth = 3;

    ctx.beginPath();
    // 갈고리 형상 그리기 (좌표는 크기에 맞춰 조절 가능)
    // 중심에서 시작하여 굽은 칼날 모양 형성
    ctx.moveTo(10, 0);
    ctx.bezierCurveTo(20, -15, 40, -30, 10, -40); // 윗 날 곡선
    ctx.lineTo(-10, -10);
    ctx.lineTo(-20, 0);
    ctx.lineTo(-10, 10);
    ctx.lineTo(10, 40); // 아랫 날 끝
    ctx.bezierCurveTo(40, 30, 20, 15, 10, 0); // 아랫 날 곡선

    ctx.fill();
    ctx.stroke();

    ctx.restore();
}

function drawAkiEvilArrow(ctx, arrow, frame) {
    // 첨부 이미지의 악마 발사체를 그대로 렌더링 (배경 제거된 PNG 내장)
    const r = (arrow.radius || 60);

    // 원본 이미지 비율(512x347)을 유지하면서, 날개가 잘 보이게 판정보다 조금 크게 표시
    const w = r * 3.0;
    const h = w * (347 / 512);

    ctx.save();
    ctx.translate(arrow.x, arrow.y);

    // 정면 실루엣이라 회전은 하지 않음 (원하면 아래 주석 해제)
    // ctx.rotate(arrow.angle);

    if (typeof akiEvilArrowDevilImg !== "undefined" &&
        akiEvilArrowDevilImg.complete &&
        akiEvilArrowDevilImg.naturalWidth > 0) {
        ctx.drawImage(akiEvilArrowDevilImg, -w / 2, -h / 2, w, h);
    } else {
        // 로딩 실패/지연 대비 임시 대체
        ctx.fillStyle = "rgba(180, 0, 0, 0.9)";
        ctx.beginPath();
        ctx.arc(0, 0, r, 0, Math.PI * 2);
        ctx.fill();
    }

    ctx.restore();
}


function drawAkiPoisonousShot(ctx, shot, frame) {
    // 첨부 이미지(빌런+가스+응가)를 그대로 렌더링 (투명 PNG)
    const r = (shot.radius || 60);

    // Evil Arrow와 같은 체급(크기 체감)을 맞추기 위해 동일 스케일 사용
    const w = r * 3.0;

    ctx.save();
    ctx.translate(shot.x, shot.y);

    // 이미지가 정면형이라 회전은 하지 않음 (원하면 아래 주석 해제)
    // ctx.rotate(shot.angle);

    if (typeof akiPoisonousShotImg !== "undefined" &&
        akiPoisonousShotImg.complete &&
        akiPoisonousShotImg.naturalWidth > 0) {

        const iw = akiPoisonousShotImg.naturalWidth || 1;
        const ih = akiPoisonousShotImg.naturalHeight || 1;
        const h = w * (ih / iw);

        ctx.drawImage(akiPoisonousShotImg, -w / 2, -h / 2, w, h);
    } else {
        // 로딩 실패/지연 대비 임시 대체
        ctx.fillStyle = "rgba(20, 120, 20, 0.85)";
        ctx.beginPath();
        ctx.arc(0, 0, r, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = "rgba(120, 80, 20, 0.9)";
        ctx.beginPath();
        ctx.arc(0, r * 0.45, r * 0.55, 0, Math.PI * 2);
        ctx.fill();
    }

    ctx.restore();
}

// === [/Aki] Projectile Draw Cache ===


        // === [Firm Darkness] Dome 캐시 ===
        const _firmDarknessCache = {
          dome: null, // { key: string, canvas: HTMLCanvasElement }
        };

        function getFirmDarknessDomeCanvas(radius) {
          // 캐시 키: 반지름이 조금만 달라도 새로 만들지 않게 반올림/정수화
          const r = Math.max(1, Math.round(radius));
          const key = `r:${r}`;

          if (_firmDarknessCache.dome && _firmDarknessCache.dome.key === key) {
            return _firmDarknessCache.dome.canvas;
          }

          // 오프스크린 캔버스(이미지) 생성
          const c = document.createElement("canvas");
          c.width = c.height = r * 2;

          const g = c.getContext("2d");
          const cx = r, cy = r;

          // 기존과 동일한 그라데이션 (원본 돔 효과와 동일)
          const domeGrad = g.createRadialGradient(cx, cy, r * 0.2, cx, cy, r);
          domeGrad.addColorStop(0, 'rgba(0, 0, 0, 0.2)');
          domeGrad.addColorStop(0.7, 'rgba(20, 0, 30, 0.5)');
          domeGrad.addColorStop(0.95,'rgba(0, 0, 0, 0.9)');
          domeGrad.addColorStop(1, 'rgba(75, 0, 130, 0.6)');

          g.fillStyle = domeGrad;
          g.beginPath();
          g.arc(cx, cy, r, 0, Math.PI * 2);
          g.fill();

          _firmDarknessCache.dome = { key, canvas: c };
          return c;
        }
        const startBtn = document.getElementById('startBtn');
        const overlay = document.getElementById('screen-overlay');
        const gameOverStatsBtn = document.getElementById('gameOverStatsBtn');
        const healthBar = document.getElementById('healthBar');
        const scoreVal = document.getElementById('scoreVal');
        const killVal = document.getElementById('killVal');
        const damageOverlay = document.getElementById('damageOverlay');
        const mindOverlay = document.getElementById('mindOverlay');
        const darknessOverlay = document.getElementById('darknessOverlay'); 
        const sacredFaithOverlay = document.getElementById('sacredFaithOverlay'); 
        const bloodOverlay = document.getElementById('bloodOverlay');
        const confusionOverlay = document.getElementById('confusionOverlay');
        const visionOverlay = document.getElementById('visionOverlay');
        const skillSealOverlay = document.getElementById('skillSealOverlay');
        // [최적화] 데미지 오버레이 플래시 상태 (히트마다 setTimeout을 쌓지 않고, 애니메이션 루프에서 감쇠)
        let damageFlashOpacity = 0;
        let damageFlashColor = '101, 67, 33';
        let damageFlashAlpha = 0.6; // rgba 알파
        let damageFlashDirty = false;
        const DAMAGE_FLASH_DECAY = 0.85; // 0.0~1.0 (낮을수록 더 빨리 사라짐)
        const GAWAIN_SANCTUARY_STRIDE = 6; // 성역 범위 체크 간격(프레임)

        const uiLayer = document.getElementById('ui-layer');
        const UI_LAYER_DEFAULT_Z = parseInt(getComputedStyle(uiLayer).zIndex, 10) || 20;
        const UI_LAYER_LEVELUP_Z = 20000;
        const poopOverlay = document.getElementById('poopOverlay');
        
        // UI Elements
        const poisonStatus = document.getElementById('poisonStatus');
        const poisonDebuffIcon = document.getElementById('poisonDebuffIcon');
        const poisonStacksText = document.getElementById('poisonStacks');
        const poopStatus = document.getElementById('poopStatus');
        const poopStacksText = document.getElementById('poopStacks');
        const poopDebuffIcon = document.getElementById('poopDebuffIcon');
        
        const maliceStatus = document.getElementById('maliceStatus');
        const maliceStacksText = document.getElementById('maliceStacks');
        const maliceIcon = document.getElementById('maliceIcon');

        const kissStatus = document.getElementById('kissStatus');
        const kissStacksText = document.getElementById('kissStacks');
        const kissDebuffIcon = document.getElementById('kissDebuffIcon');
        const semenStatus = document.getElementById('semenStatus');
        const semenStacksText = document.getElementById('semenStacks');
        const semenDebuffIcon = document.getElementById('semenDebuffIcon');
        const oralStatus = document.getElementById('oralStatus');
        const oralStacksText = document.getElementById('oralStacks');
        const oralDebuffIcon = document.getElementById('oralDebuffIcon');
        
        const byururutStatus = document.getElementById('byururutStatus');
        const byururutStacksText = document.getElementById('byururutStacks');
        const byururutDebuffIcon = document.getElementById('byururutDebuffIcon');

        const geoptalStatus = document.getElementById('geoptalStatus');
        const geoptalStacksText = document.getElementById('geoptalStacks');
        const geoptalIcon = document.getElementById('geoptalIcon');

        const fishyStatus = document.getElementById('fishyStatus');
        const fishyStacksText = document.getElementById('fishyStacks');
        const fishyIcon = document.getElementById('fishyIcon');

        const shieldStatus = document.getElementById('shieldStatus');
        const shieldStacksText = document.getElementById('shieldStacks');
        const shieldIcon = document.getElementById('shieldIcon');

        const justiceStatus = document.getElementById('justiceStatus');
        const justiceStacksText = document.getElementById('justiceStacks');
        const justiceIcon = document.getElementById('justiceIcon');
        
        const blindStatus = document.getElementById('blindStatus');
        const blindStacksText = document.getElementById('blindStacks');
        const blindIcon = document.getElementById('blindIcon');
        
        const paralysisStatus = document.getElementById('paralysisStatus');
        const paralysisStacksText = document.getElementById('paralysisStacks');
        const paralysisIcon = document.getElementById('paralysisIcon');

        const berserkStatus = document.getElementById('berserkStatus');
        const berserkIcon = document.getElementById('berserkIcon'); 
        
        const hypersensitivityStatus = document.getElementById('hypersensitivityStatus');
        const hyperIcon = document.getElementById('hyperIcon');

        const evilMindStatus = document.getElementById('evilMindStatus');
        const evilMindStacksText = document.getElementById('evilMindStacks');
        const evilMindDebuffIcon = document.getElementById('evilMindDebuffIcon');
        
        const curseStatus = document.getElementById('curseStatus');
        const curseStacksText = document.getElementById('curseStacks');
        const curseIcon = document.getElementById('curseIcon');

        const gnawingLifeStatus = document.getElementById('gnawingLifeStatus');
        const gnawingLifeStacksText = document.getElementById('gnawingLifeStacks');
        const gnawingLifeIcon = document.getElementById('gnawingLifeIcon');

        const darkScentStatus = document.getElementById('darkScentStatus');
        const darkScentStacksText = document.getElementById('darkScentStacks');
        const darkScentIcon = document.getElementById('darkScentIcon');
        
        const darkSmellStatus = document.getElementById('darkSmellStatus');
        const darkSmellStacksText = document.getElementById('darkSmellStacks');
        const darkSmellIcon = document.getElementById('darkSmellIcon');
        
        const darkSeedStatus = document.getElementById('darkSeedStatus');
        const darkSeedStacksText = document.getElementById('darkSeedStacks');
        const darkSeedIcon = document.getElementById('darkSeedIcon');

        const darkKissStatus = document.getElementById('darkKissStatus');
        const darkKissStacksText = document.getElementById('darkKissStacks');
        const darkKissIcon = document.getElementById('darkKissIcon');

        const darkReceiverStatus = document.getElementById('darkReceiverStatus');
        const darkReceiverStacksText = document.getElementById('darkReceiverStacks');
        const darkReceiverIcon = document.getElementById('darkReceiverIcon');

        const evilLightStatus = document.getElementById('evilLightStatus');
        const evilLightIcon = document.getElementById('evilLightIcon');

        const darkEcstasyStatus = document.getElementById('darkEcstasyStatus');
        const darkEcstasyStacksText = document.getElementById('darkEcstasyStacks');
        const darkEcstasyIcon = document.getElementById('darkEcstasyIcon');

        const corruptedOathStatus = document.getElementById('corruptedOathStatus');
        const corruptedOathStacksText = document.getElementById('corruptedOathStacks');
        const corruptedOathIcon = document.getElementById('corruptedOathIcon');

        const dangerousJudgmentStatus = document.getElementById('dangerousJudgmentStatus');
        const dangerousJudgmentStacksText = document.getElementById('dangerousJudgmentStacks');
        const dangerousJudgmentIcon = document.getElementById('dangerousJudgmentIcon');

        const deepDarknessStatus = document.getElementById('deepDarknessStatus');
        const deepDarknessStacksText = document.getElementById('deepDarknessStacks');
        const deepDarknessIcon = document.getElementById('deepDarknessIcon');

        const corruptedJusticeStatus = document.getElementById('corruptedJusticeStatus');
        const corruptedJusticeStacksText = document.getElementById('corruptedJusticeStacks');
        const corruptedJusticeIcon = document.getElementById('corruptedJusticeIcon');

        const darknessStatusEl = document.getElementById('darknessStatus'); 
        const darknessIcon = document.getElementById('darknessIcon');
        const confusionStatusEl = document.getElementById('confusionStatus');
        const confusionIcon = document.getElementById('confusionIcon');

        const serumContaminationStatus = document.getElementById('serumContaminationStatus');
        const serumContaminationIcon = document.getElementById('serumContaminationIcon');
        if(serumContaminationIcon) serumContaminationIcon.src = serumContaminationIconSrc;
        
        // [신규] 출혈/차광 UI 연결
        const bleedingStatus = document.getElementById('bleedingStatus');
        const bleedingIcon = document.getElementById('bleedingIcon');
        const shadingStatus = document.getElementById('shadingStatus');
        const shadingIcon = document.getElementById('shadingIcon');
        
        if(bleedingIcon) bleedingIcon.src = bleedingIconSrc;
        if(shadingIcon) shadingIcon.src = shadingIconSrc;

        // [신규] 죽음의 낙인 UI 연결
        const deathBrandStatus = document.getElementById('deathBrandStatus');
        const deathBrandIcon = document.getElementById('deathBrandIcon');
        if(deathBrandIcon) deathBrandIcon.src = deathBrandIconSrc;

        if(darknessIcon) darknessIcon.src = darknessIconSrc;
        if(confusionIcon) confusionIcon.src = confusionIconSrc;

        const blasphemyIconEl = document.getElementById('blasphemyIcon');
        if (blasphemyIconEl) {
        blasphemyIconEl.src = blasphemyIconSrc;
       }
        const majestyStatus = document.getElementById('majestyStatus');
        const majestyIcon = document.getElementById('majestyIcon');
        
        const trueAncestorKissStatus = document.getElementById('trueAncestorKissStatus');
        const trueAncestorKissStacksText = document.getElementById('trueAncestorKissStacks');
        const trueAncestorKissIcon = document.getElementById('trueAncestorKissIcon');

        const fatalScarStatus = document.getElementById('fatalScarStatus');
        const fatalScarStacksText = document.getElementById('fatalScarStacks');
        const fatalScarIcon = document.getElementById('fatalScarIcon');

        const corruptedBloodStatus = document.getElementById('corruptedBloodStatus');
        const corruptedBloodStacksText = document.getElementById('corruptedBloodStacks');
        const corruptedBloodIcon = document.getElementById('corruptedBloodIcon');
       
        // [신규] 카이토 상태이상 UI 연결
        const despairStatus = document.getElementById('despairStatus');
        const despairIcon = document.getElementById('despairIcon');
        if(despairIcon) despairIcon.src = despairIconSrc;

        const baptismStatus = document.getElementById('baptismStatus');
        const baptismStacksText = document.getElementById('baptismStacks');
        const baptismIcon = document.getElementById('baptismIcon');
        if(baptismIcon) baptismIcon.src = baptismIconSrc;

        // 여신의 가호 UI 요소
        const goddessSkillImg = document.getElementById('goddessSkillImg');
        const goddessCooldownOverlay = document.getElementById('goddessCooldownOverlay');
        const goddessCooldownText = document.getElementById('goddessCooldownText');
        const goddessSealOverlay = document.getElementById('goddessSealOverlay');

        // 성스러운 믿음 UI 요소
        const sacredFaithSkillImg = document.getElementById('sacredFaithSkillImg');
        const sacredFaithCooldownOverlay = document.getElementById('sacredFaithCooldownOverlay');
        const sacredFaithCooldownText = document.getElementById('sacredFaithCooldownText');
        const sacredFaithSealOverlay = document.getElementById('sacredFaithSealOverlay');

        // [신규] 한계 집중 UI 요소
        const limitFocusImg = document.getElementById('limitFocusImg');
        const limitFocusCooldownOverlay = document.getElementById('limitFocusCooldownOverlay');
        const limitFocusCooldownText = document.getElementById('limitFocusCooldownText');
        const limitFocusSealOverlay = document.getElementById('limitFocusSealOverlay');

        // 회개의 외침 UI 요소
        const novaSkillImg = document.getElementById('novaSkillImg');
        const novaCooldownOverlay = document.getElementById('novaCooldownOverlay');
        const novaCooldownText = document.getElementById('novaCooldownText');
        const novaSealOverlay = document.getElementById('novaSealOverlay');
        
        // [신규] 천상의 도약 UI 요소 연결
        const divineDashSkillImg = document.getElementById('divineDashSkillImg');
        const divineDashCooldownOverlay = document.getElementById('divineDashCooldownOverlay');
        const divineDashCooldownText = document.getElementById('divineDashCooldownText');
        const divineDashSealOverlay = document.getElementById('divineDashSealOverlay');

        // ==================================================================================
        // [텍스트 커스터마이징] 
        // ==================================================================================
        
        const berserkText = "베르세르크!";
        const shieldText = "보호막";
        const justiceText = "정의의 가호";
        const poisonText = "가스중독";
        const poopText = "똥독";
        const maliceText = "악의의 바이러스"; 
        const kissText = "속박키스(지속↑)";
        const semenText = "질내사정(회피)";
        const oralText = "구내사정(리치)";
        const byururutText = "뷰루룻♡";
        const evilMindText = "사악한 마음";
        const geoptalText = "겁탈"; 
        const fishyText = "비린내 붓카게"; 
        const hyperText = "과민 반응 (기절주의!)";
        const blindText = "실명 (명중↓)";
        const paralysisText = "마비 (이동↓)";

        const curseText = "저주(종료시 피해)"; 
        const gnawingLifeText = "좀먹는 생명(회복↓)";
        const darkScentText = "카인의 향기";
        const darkSmellText = "카인의 똥내";
        const darkSeedText = "카인의 씨앗(공격)";
        const darkKissText = "카인의 키스(공속)";
        const darkReceiverText = "카인의 좆집(방증 2%)";
        const evilLightText = "사악한 빛";
        const darkEcstasyText = "어둠의 환희(적 이속)";

        const corruptedOathText = "타락한 맹세(치명타 확률↑)";
        const dangerousJudgmentText = "위험한 판단(치명타 저항 확률↓)";
        const deepDarknessText = "짙은 어둠(명중↓)";
        const corruptedJusticeText = "타락한 정의(쿨타임)";

        document.getElementById('berserkName').innerText = berserkText;
        document.getElementById('shieldName').innerText = shieldText;
        document.getElementById('justiceName').innerText = justiceText;
        document.getElementById('poisonName').innerText = poisonText;
        document.getElementById('poopName').innerText = poopText;
        document.getElementById('maliceName').innerText = maliceText; 
        document.getElementById('kissName').innerText = kissText;
        document.getElementById('semenName').innerText = semenText;
        document.getElementById('oralName').innerText = oralText;
        document.getElementById('byururutName').innerText = byururutText;
        document.getElementById('evilMindName').innerText = evilMindText;
        document.getElementById('geoptalName').innerText = geoptalText;
        document.getElementById('fishyName').innerText = fishyText; 
        document.getElementById('hyperName').innerText = hyperText;
        document.getElementById('blindName').innerText = blindText;
        document.getElementById('paralysisName').innerText = paralysisText;

        document.getElementById('curseName').innerText = curseText;
        document.getElementById('gnawingLifeName').innerText = gnawingLifeText;
        document.getElementById('darkScentName').innerText = darkScentText;
        document.getElementById('darkSmellName').innerText = darkSmellText;
        document.getElementById('darkSeedName').innerText = darkSeedText;
        document.getElementById('darkKissName').innerText = darkKissText;
        document.getElementById('darkReceiverName').innerText = darkReceiverText;
        document.getElementById('evilLightName').innerText = evilLightText;
        document.getElementById('darkEcstasyName').innerText = darkEcstasyText;

        document.getElementById('corruptedOathName').innerText = corruptedOathText;
        document.getElementById('dangerousJudgmentName').innerText = dangerousJudgmentText;
        document.getElementById('deepDarknessName').innerText = deepDarknessText;
        document.getElementById('corruptedJusticeName').innerText = corruptedJusticeText;
        

        const cainSpawnBgmSrc = "https://steady-crimson-4nscd46j2b-jy3x40xm74.edgeone.dev/KakaoTalk_20251228_165908350.mp4"; 
        const touyaSpawnBgmSrc = "https://steady-crimson-4nscd46j2b-jy3x40xm74.edgeone.dev/KakaoTalk_20251228_182024105.mp4"; 
        const pandemoniumBgmSrc = "https://steady-crimson-4nscd46j2b-jy3x40xm74.edgeone.dev/KakaoTalk_20251228_182026246.mp4"; 
        
        const impregnateAudioSrc = "https://steady-crimson-4nscd46j2b-jy3x40xm74.edgeone.dev/KakaoTalk_20251228_182023409.mp4"; 
        const impregnateAudio = new Audio(impregnateAudioSrc);
        impregnateAudio.volume = 0.8;

        const rapistAttachAudioSrc = "https://scrawny-purple-jefbabss6q-qdbf8o789a.edgeone.dev/KakaoTalk_20251218_222054381.mp4"; 
        const rapistAttachAudio = new Audio(rapistAttachAudioSrc);
        rapistAttachAudio.volume = 1.0;

        const darkDenizenSummonAudioSrc = "https://unfortunate-tan-h3am4473op-es3zafqeoh.edgeone.dev/KakaoTalk_20251219_232117812.mp4"; 
        const darkDenizenSummonAudio = new Audio(darkDenizenSummonAudioSrc);
        darkDenizenSummonAudio.volume = 0.5;

        const raiAttachAudioSrc = "https://scrawny-purple-jefbabss6q-qdbf8o789a.edgeone.dev/KakaoTalk_20251218_222054381.mp4"; 
        const raiAttachAudio = new Audio(raiAttachAudioSrc);
        raiAttachAudio.volume = 1.0;

        const cainAudio = new Audio(cainSpawnBgmSrc);
        cainAudio.volume = 1.0; 
        
        // [신규] 아서 BGM
        const arthurAudio = new Audio(arthurSpawnBgmSrc);
        arthurAudio.volume = 1.0;

        const touyaAudio = new Audio(touyaSpawnBgmSrc);
        touyaAudio.volume = 1.0; 

        const pandemoniumAudio = new Audio(pandemoniumBgmSrc); 
        pandemoniumAudio.volume = 1.0; 

        // [커스터마이즈] 아키 '포이즈너스 샷' 사용 시 재생할 사운드 (mp3/ogg 등)
        // 같은 폴더에 mp3를 두면: "./aki_poisonous_shot.mp3"
        const akiPoisonousShotSfxSrc = "./aki_poisonous_shot.mp3";
        const AKI_POISONOUS_SHOT_SFX_VOLUME = 0.4;

        // 짧은 시간에 연속 발사해도 끊기지 않도록 오디오 풀(4개) 사용
        const akiPoisonousShotSfxPool = Array.from({ length: 4 }, () => {
            const a = new Audio(akiPoisonousShotSfxSrc);
            a.preload = "auto";
            a.volume = AKI_POISONOUS_SHOT_SFX_VOLUME;
            return a;
        });
        let _akiPoisonousShotSfxIdx = 0;
        function playAkiPoisonousShotSfx() {
            // src가 비어있거나, 브라우저 정책상 막힐 수 있으니 try/catch
            if (!akiPoisonousShotSfxSrc) return;
            const a = akiPoisonousShotSfxPool[_akiPoisonousShotSfxIdx++ % akiPoisonousShotSfxPool.length];
            try {
                a.currentTime = 0;
                a.play().catch(()=>{});
            } catch(e) {}
        }


        
        // [커스터마이즈] 아키 '이블 애로우' 사용 시 재생할 사운드 (mp3/ogg 등)
        // 같은 폴더에 mp3를 두면: "./aki_evil_arrow.mp3"
        const akiEvilArrowSfxSrc = "./aki_evil_arrow.mp3";
        const AKI_EVIL_ARROW_SFX_VOLUME = 1.0;

        // 짧은 시간에 연속 발사해도 끊기지 않도록 오디오 풀(4개) 사용
        const akiEvilArrowSfxPool = Array.from({ length: 4 }, () => {
            const a = new Audio(akiEvilArrowSfxSrc);
            a.preload = "auto";
            a.volume = AKI_EVIL_ARROW_SFX_VOLUME;
            return a;
        });
        let _akiEvilArrowSfxIdx = 0;
        function playAkiEvilArrowSfx() {
            if (!akiEvilArrowSfxSrc) return;
            const a = akiEvilArrowSfxPool[_akiEvilArrowSfxIdx++ % akiEvilArrowSfxPool.length];
            try {
                a.currentTime = 0;
                a.play().catch(()=>{});
            } catch(e) {}
        }

        // [커스터마이즈] 오즈마 '방구 스모그' 발사 시 재생할 사운드 (mp3/ogg 등)
        // 같은 폴더에 mp3를 두면: "./ozma_fart_smog_shoot.mp3"
        const ozmaFartSmogSfxSrc = "./ozma_fart_smog_shoot.mp3";
        const OZMA_FART_SMOG_SFX_VOLUME = 0.85;

        // 짧은 시간에 연속 발사해도 끊기지 않도록 오디오 풀(4개) 사용
        const ozmaFartSmogSfxPool = Array.from({ length: 4 }, () => {
            const a = new Audio(ozmaFartSmogSfxSrc);
            a.preload = "auto";
            a.volume = OZMA_FART_SMOG_SFX_VOLUME;
            // 파일이 없으면 콘솔에만 경고 (게임은 계속 진행)
            a.onerror = () => console.warn("ozma_fart_smog_shoot.mp3를 HTML과 같은 폴더에 넣어주세요.");
            return a;
        });
        let _ozmaFartSmogSfxIdx = 0;
        function playOzmaFartSmogSfx() {
            if (!ozmaFartSmogSfxSrc) return;
            const a = ozmaFartSmogSfxPool[_ozmaFartSmogSfxIdx++ % ozmaFartSmogSfxPool.length];
            try {
                a.currentTime = 0;
                a.play().catch(()=>{});
            } catch(e) {}
        }


const berserkUiIconSrc = "https://i.ifh.cc/2zdKr7.jpg"; 
        const shieldUiIconSrc = "https://i.ifh.cc/y69OcC.jpg";  
        const justiceUiIconSrc = "https://i.ifh.cc/bP1nVV.jpg"; 
        const blindIconSrc = "https://i.ifh.cc/dqwQpz.jpg"; 
        const magnetItemSrc = "https://i.ifh.cc/LzpmBZ.jpg"; 
        const paralysisIconSrc = "https://i.ifh.cc/SfR4f5.jpg"; // 마비 아이콘 (임시)
        
        const berserkItemImg = new Image(); berserkItemImg.src = berserkUiIconSrc;
        const shieldItemImg = new Image(); shieldItemImg.src = shieldUiIconSrc;
        const justiceItemImg = new Image(); justiceItemImg.src = justiceUiIconSrc;
        const magnetItemImg = new Image(); magnetItemImg.src = magnetItemSrc;
        
        const evilLightIconSrc = "https://i.ifh.cc/YkQoPQ.jpg";
        
        const geoptalIconSrc = "https://i.ifh.cc/9Jp26f.jpg"; 
        geoptalIcon.src = geoptalIconSrc;

        const fishyIconSrc = "https://i.ifh.cc/V14G9O.jpg"; 
        fishyIcon.src = fishyIconSrc;

        const maliceIconSrc = "https://i.ifh.cc/acHt9B.jpg"; 
        maliceIcon.src = maliceIconSrc;
        
        const hyperIconSrc = "https://i.ifh.cc/TbX5ak.jpg"; 
        hyperIcon.src = hyperIconSrc;

        const corruptedOathIconSrc = "https://i.ifh.cc/3fpSq8.jpg"; 
        const dangerousJudgmentIconSrc = "https://i.ifh.cc/OYCwhZ.jpg";
        const deepDarknessIconSrc = "https://i.ifh.cc/vSjmlo.jpg";
        const corruptedJusticeIconSrc = "https://i.ifh.cc/1myqLR.jpg";

        corruptedOathIcon.src = corruptedOathIconSrc;
        dangerousJudgmentIcon.src = dangerousJudgmentIconSrc;
        deepDarknessIcon.src = deepDarknessIconSrc;
        corruptedJusticeIcon.src = corruptedJusticeIconSrc;
        
        // [신규] 기믹 UI 연결
        const pheromoneOverloadStatus = document.getElementById('pheromoneOverloadStatus');
        const pheromoneOverloadIcon = document.getElementById('pheromoneOverloadIcon');
        pheromoneOverloadIcon.src = pheromoneOverloadIconSrc;

        const darknessOverwhelmStatus = document.getElementById('darknessOverwhelmStatus');
        const darknessOverwhelmIcon = document.getElementById('darknessOverwhelmIcon');
        darknessOverwhelmIcon.src = darknessOverwhelmIconSrc;

        const fractureStatus = document.getElementById('fractureStatus');
        const fractureStacksText = document.getElementById('fractureStacks');
        const fractureIcon = document.getElementById('fractureIcon');
        if(fractureIcon) fractureIcon.src = fractureIconSrc;

        // [신규] 아서 디버프 아이콘 설정
        majestyIcon.src = majestyIconSrc;
        trueAncestorKissIcon.src = trueAncestorKissIconSrc;
        fatalScarIcon.src = fatalScarIconSrc;
        corruptedBloodIcon.src = corruptedBloodIconSrc;

        const projectileImg = new Image(); projectileImg.src = "https://i.ifh.cc/dgWMPY.jpg"; 
        poisonDebuffIcon.src = "https://i.ifh.cc/70Db1a.jpg"; 
        poopDebuffIcon.src = "https://i.ifh.cc/pA83O9.jpg";
        kissDebuffIcon.src = "https://i.ifh.cc/W7sZSA.jpg"; 
        blindIcon.src = blindIconSrc;
        paralysisIcon.src = paralysisIconSrc;
        
        const darkScentIconSrc = "https://i.ifh.cc/frk6ah.jpg"; 
        const darkSmellIconSrc = "https://i.ifh.cc/KWly6J.jpg";
        const darkSeedIconSrc = "https://i.ifh.cc/v16XGA.jpg";
        const darkKissIconSrc = "https://i.ifh.cc/BJxVzf.jpg";
        const darkReceiverIconSrc = "https://i.ifh.cc/zXk13D.jpg";

        const summonerVillainImgSrc = "https://i.ifh.cc/LlvP0q.jpg"; 
        const rapistVillainImgSrc = "https://i.ifh.cc/X6QpjD.jpg";   
        const zakoVillainImgSrc = "https://i.ifh.cc/FWJgpP.jpg";     
        
        const zakoTerroristImgSrc = "https://i.ifh.cc/jCmRky.jpg"; 
        const zakoTerroristImg = new Image();
        zakoTerroristImg.src = zakoTerroristImgSrc;

        const zakoPlagueImgSrc = "https://i.ifh.cc/mmZddv.jpg"; 
        const zakoPlagueImg = new Image();
        zakoPlagueImg.src = zakoPlagueImgSrc;

        const agentCurseImgSrc = "https://i.ifh.cc/YOtrJ1.jpg"; 
        const agentPainImgSrc = "https://i.ifh.cc/328BaC.jpg";
        const agentBlindImgSrc = "https://i.ifh.cc/zsh8Hz.jpg";

        const agentCurseImg = new Image(); agentCurseImg.src = agentCurseImgSrc;
        const agentPainImg = new Image(); agentPainImg.src = agentPainImgSrc;
        const agentBlindImg = new Image(); agentBlindImg.src = agentBlindImgSrc;
        
        const akiImgSrc = "https://i.ifh.cc/bH4RAo.jpg"; 
        const akiImg = new Image(); akiImg.src = akiImgSrc;

        const hiroImg = new Image();
        hiroImg.src = hiroImgSrc;
        
        // [신규] 아서 이미지
        const arthurImg = new Image();
        arthurImg.src = arthurImgSrc;

        goddessSkillImg.src = goddessSkillImgSrc;
        sacredFaithSkillImg.src = sacredFaithSkillImgSrc;
        limitFocusImg.src = limitFocusIconSrc;
        novaSkillImg.src = novaSkillIconSrc;
        divineDashSkillImg.src = divineDashIconSrc;

        const summonerVillainImg = new Image(); summonerVillainImg.src = summonerVillainImgSrc;
        const rapistVillainImg = new Image(); rapistVillainImg.src = rapistVillainImgSrc;
        const zakoVillainImg = new Image(); zakoVillainImg.src = zakoVillainImgSrc;

        const eliteVillainImg = new Image(); eliteVillainImg.src = "https://i.ifh.cc/MJcqhD.jpg";
        
        const corruptedHeroImgSrc = "https://i.ifh.cc/7Cy4KY.jpg"; 
        const corruptedHeroImg = new Image(); corruptedHeroImg.src = corruptedHeroImgSrc;

        const corruptedSniperImgSrc = "https://i.ifh.cc/vyGsG5.jpg";
        const corruptedSniperImg = new Image(); corruptedSniperImg.src = corruptedSniperImgSrc;

        const ozmaImgSrc = "https://i.ifh.cc/CfXbx2.jpg"; 
        const ozmaImg = new Image(); ozmaImg.src = ozmaImgSrc;

        // [신규] 오즈마 스킬 '방구 스모그' 발사체 이미지 (투명 PNG 파일을 같은 폴더에 두세요)
        const fartSmogImg = new Image();
        fartSmogImg.src = "./fart_smog.png";
        fartSmogImg.onerror = () => console.warn("fart_smog.png를 HTML(또는 txt)과 같은 폴더에 넣어주세요.");

        // [방구 스모그] 크기 배율 (시각 크기 + 히트박스가 함께 커짐)
        // 1.0 = 기본, 1.3 = 30% 크게
        const FART_SMOG_SIZE_MULT = 1.9;


const taroImgSrc = "https://i.ifh.cc/ZqPPQc.jpg"; 
        const taroImg = new Image(); taroImg.src = taroImgSrc;

        const gawainImgSrc = "https://i.ifh.cc/lKzqBQ.jpg"; 
        const gawainImg = new Image(); gawainImg.src = gawainImgSrc;

        const playerImgSrc = "https://i.ifh.cc/g6CNM9.jpg"; 
        const playerImg = new Image();
        playerImg.src = playerImgSrc;

        const bossVillainImg = new Image(); 
        bossVillainImg.src = "https://i.ifh.cc/kMhZx6.jpg";

        const akitoImg = new Image();
        akitoImg.src = "https://i.ifh.cc/PvD0DF.jpg"; 
        
        const touyaImg = new Image();
        touyaImg.src = "https://i.ifh.cc/hWy9sB.jpg"; 

        const louieImgSrc = "https://i.ifh.cc/H7CKDf.jpg"; 
        const louieImg = new Image(); louieImg.src = louieImgSrc;

        const raiImgSrc = "https://i.ifh.cc/2HKg2q.jpg"; 
        const raiImg = new Image(); raiImg.src = raiImgSrc;

        const kissEffectImgSrc = "https://i.ifh.cc/W7sZSA.jpg"; 
        semenDebuffIcon.src = "https://i.ifh.cc/yTks6A.jpg"; 
        oralDebuffIcon.src = "https://i.ifh.cc/oqTaNK.jpg";
        const byururutDebuffIconSrc = "https://i.ifh.cc/HB6Kqs.jpg"; 
        byururutDebuffIcon.src = byururutDebuffIconSrc;
        
        const gnawingLifeIconSrc = "https://i.ifh.cc/cfASLW.jpg"; 
        gnawingLifeIcon.src = gnawingLifeIconSrc;

        berserkIcon.src = berserkUiIconSrc;
        shieldIcon.src = shieldUiIconSrc; 
        justiceIcon.src = justiceUiIconSrc; 

        darkScentIcon.src = darkScentIconSrc;
        darkSmellIcon.src = darkSmellIconSrc;
        darkSeedIcon.src = darkSeedIconSrc;
        darkKissIcon.src = darkKissIconSrc;
        darkReceiverIcon.src = darkReceiverIconSrc;
        
        evilLightIcon.src = evilLightIconSrc;
        
        darkEcstasyIcon.src = "https://i.ifh.cc/5JWG2Z.jpg";

        const evilMindIconSrc = "https://i.ifh.cc/ZzxJms.jpg"; 
        evilMindDebuffIcon.src = evilMindIconSrc;
     
        curseIcon.src = "https://i.ifh.cc/cfASLW.jpg"; 

        const bgmSrc = "https://miserable-jade-dmyozf8ndo.edgeone.dev/0-ntr5.mp3";
        const bgmAudio = new Audio(bgmSrc);
        bgmAudio.loop = true;
        bgmAudio.volume = 0.3;

        let isGameRunning = false;
        let score = 0;
        let enemyTimer = 0;
        let lastTime = 0;
        let frameDt = 1000 / 60;
        let frameDtScale = 1;

        let lastScoreTime = 0;
        let killCount = 0;
        let startTime = 0;
        let animationId;
        let itemSpawnTimeout;
        let nextBossSpawnFrame = 0;
        let nextEliteSpawnFrame = 0;
        let xp = 0;
        let maxXp = 10;
        let level = 1;
        let isLevelUpPaused = false;
        let luck = 0;
        let rerollCount = 0;
        let frameCount = 0;
        let selectedCardIndex = 0;

        // =========================================================
        // [밸런스] 만렙 확장 + 레벨업 경험치 완화
        // =========================================================
        const MAX_LEVEL = 500;              // 만렙 (기존 200)

// [밸런스] 레벨업 필요 XP: 초반은 '적당히 빠르게', 중반부터는 '조금씩 느려지게' (완만한 구간 스케일)
//  Lv   1~ 60 : 1.018  (초반: 빠른 성장 유지)
//  Lv  61~180 : 1.022  (중반 진입: 서서히 둔화)
//  Lv 181~300 : 1.024  (중반: 점진적 둔화)
//  Lv 301~500 : 1.026  (후반: 완만하지만 확실한 둔화)
const XP_GROWTH_SEG1_MULT   = 1.018;
const XP_GROWTH_SEG2_MULT   = 1.022;
const XP_GROWTH_SEG3_MULT   = 1.024;
const XP_GROWTH_SEG4_MULT   = 1.026;

const XP_GROWTH_SEG1_END_LV = 60;
const XP_GROWTH_SEG2_END_LV = 180;
const XP_GROWTH_SEG3_END_LV = 300;
const XP_GROWTH_SEG4_END_LV = 500;
let shockwaves = []; 
        let groundCracks = [];
        let dragShots = []; 
        let evilArrows = []; 
        let poisonousShots = [];
        let jammingWaves = [];
        let neuroNeedles = [];
        let bloodBats = [];
        let bloodPuddles = [];
        let excaliburSlashes = [];
        let slashTrails = [];
        let chaosOrbs = [];
        let pinkGases = [];
        let sadismBrownGases = [];
        let darkNotes = [];
        let blinkMines = [];
        let blackHolyBloods = [];
        let antiPassingTentacles = [];
        let pianissimoSnipes = [];
        let soulHarvestSlashes = [];
        let cursedCatastrophes = [];
        let prismSweeps = [];
        let occlusionSpools = [];
        let darkMatters = [];
        let confessionalTotems = [];
        let shadowGrips = [];
        let maliceBallistics = [];
        let maliceGasParticles = [];
        let phantomGasParticles = [];
        let phantomSparkParticles = [];
        let cruelChargeAuras = [];
        let justiceChargeAuras = [];
        let floatingTexts = [];
        let activeAkiCount = 0;
        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resize);
        resize();

        // [Anti Passing] cached render assets for performance (telegraph silhouette + gas sprite)
        let _apTeleTex = null;
        let _apSmokeTex = null;
        function _ensureAntiPassingAssets() {
            if (_apTeleTex && _apSmokeTex) return;

            // Telegraph texture (tapered silhouette, drawn once then scaled/rotated)
            _apTeleTex = document.createElement('canvas');
            _apTeleTex.width = 256;
            _apTeleTex.height = 64;
            {
                const c = _apTeleTex.getContext('2d');
                c.clearRect(0, 0, _apTeleTex.width, _apTeleTex.height);
                const w = _apTeleTex.width, h = _apTeleTex.height;

                const grad = c.createLinearGradient(0, 0, w, 0);
                grad.addColorStop(0, 'rgba(0,0,0,1)');
                grad.addColorStop(0.55, 'rgba(0,0,0,0.85)');
                grad.addColorStop(1, 'rgba(0,0,0,0)');

                c.fillStyle = grad;
                c.beginPath();
                c.moveTo(0, h * 0.5);
                c.quadraticCurveTo(w * 0.35, h * 0.08, w * 0.82, h * 0.34);
                c.quadraticCurveTo(w, h * 0.5, w * 0.82, h * 0.66);
                c.quadraticCurveTo(w * 0.35, h * 0.92, 0, h * 0.5);
                c.closePath();
                c.fill();

                // Outline hint (visibility)
                c.strokeStyle = 'rgba(0,0,0,0.95)';
                c.lineWidth = 3;
                c.stroke();
            }

            // Gas/smoke texture (radial blob)
            _apSmokeTex = document.createElement('canvas');
            _apSmokeTex.width = 64;
            _apSmokeTex.height = 64;
            {
                const g = _apSmokeTex.getContext('2d');
                g.clearRect(0, 0, _apSmokeTex.width, _apSmokeTex.height);
                const cx = 32, cy = 32, r = 28;
                const rg = g.createRadialGradient(cx, cy, 0, cx, cy, r);
                rg.addColorStop(0, 'rgba(151, 171, 86, 0.85)');
                rg.addColorStop(0.55, 'rgba(98, 86, 43, 0.55)');
                rg.addColorStop(1, 'rgba(53, 45, 22, 0)');
                g.fillStyle = rg;
                g.beginPath();
                g.arc(cx, cy, r, 0, Math.PI * 2);
                g.fill();
            }
        }

        const player = {
            x: canvas.width / 2,
            y: canvas.height / 2,
            radius: 30,
            baseSpeed: 5.125, 
            speed: 5.125,
            vx: 0, 
            vy: 1,
            baseMaxHealth: 400, 
            maxHealth: 400,
            health: 400,
            
            baseCritChance: 25, 
            critChance: 25,
            baseCritResist: 15,   
            critResist: 15,
            baseCritDamageMultiplier: 1.5,
            critDamageMultiplier: 1.5,
            baseRegen: 1,
            regen: 1,
            bonusSkillCooldownReduction: 0,
            
            permanentSkillCooldownReduction: 0,
            corruptedOathStacks: 0, 
            dangerousJudgmentStacks: 0,
            deepDarknessStacks: 0,
            corruptedJusticeStacks: 0,

            poisonTimers: [],
            poopPoisonTimers: [],
            maliceTimers: [], 
            kissTimers: [],
            semenTimers: [],
            oralTimers: [],
            byururutTimers: [],
            evilMindTimers: [],
            curseTimers: [],
            gnawingLifeTimers: [], 
            fishyTimers: [], 
            darkScentTimers: [],
            darkSmellTimers: [],
            darkSeedTimers: [],
            darkKissTimers: [],
            darkReceiverTimers: [],
            blindTimers: [], 
            paralysisTimers: [],
            deathBrandTimers: [],
            evilLightTimers: [],
            bleedingTimers: [], // 출혈 타이머
            shadingTimers: [],  // 차광 타이머
            darkEcstasyTimers: [], 
            serumContaminationTimers: [],
            fractureTimers: [],

            // [신규] 아서 디버프 관련
            majestyActive: false, // 군주의 위엄 활성 여부
            trueAncestorKissTimers: [], // 진조의 키스 (스택형, 타이머)
            fatalScarTimers: [], // 페이탈 스칼
            corruptedBloodTimers: [], // 더럽혀진 피
            
            geoptalCount: 0, 
            hasHypersensitivity: false,

            // paralysisStacks: 0, // [삭제] 기존 단순 스택 변수 삭제 (Timers로 대체)
            rootTimer: 0,
            skillSealTimer: 0,
            pheromoneOverloadTimer: 0, // 카인 기믹 타이머
            darknessOverwhelmActive: false, // 아키토 기믹 활성화 여부
            stunTimer: 0,
            evilMindGasTimer: 0,
            despairTimer: 0,
            baptismStacks: 0,
            netherGrabbedBy: null, // 네더 그랩에 잡혔는지 확인 (카이토 객체 참조)
            netherGrabTimer: 0, // 네더 그랩 데미지 틱
            semenCooldown: 0,
            oralCooldown: 0,
            darkReceiverCooldown: 0,

            byururutCooldown: 0,
            bodyHitCooldown: 0,
            shieldStacks: 0, 
            justiceShield: 0, 
            novaBarrierValue: 0,
            novaBarrierTimer: 0,
            slowedByCloud: false,
            slowedByStickyCream: false,
            invincibleTimer: 0, 
            berserkTimer: 0, 
            
            defense: 0, 
            defenseBroken: false,

            goddessSkill: {
                cooldown: 0, 
                maxCooldown: 2100
            },
            
            sacredFaithSkill: {
                cooldown: 0,
                maxCooldown: 2700, 
                duration: 600, 
                activeTimer: 0
            },
            
            novaSkill: {
                cooldown: 0,
                maxCooldown: 1200, 
                range: 280,       
                pushPower: 300    
            },

            limitFocusSkill: {
                cooldown: 0,
                maxCooldown: 2700,
                duration: 600,
                activeTimer: 0
            },

            divineDashSkill: {
                cooldown: 0,
                maxCooldown: 900, // 쿨타임 15초
                duration: 15,     // 돌진 지속 시간 (0.25초)
                speed: 18         // 돌진 속도
            },
            dashTimer: 0,         // 현재 돌진 중인지 체크하는 타이머
            dashVx: 0,            // 돌진 X 벡터
            dashVy: 0,            // 돌진 Y 벡터

            weapon: {
                length: 280, 
                baseLength: 280, 
                width: 10,  
                color: 'black', 
                angle: 0, 
                baseAngle: 0, 
                isAttacking: false,
                attackTimer: 0,
                cooldown: 0,
                baseDamage: 22, 
                damage: 22, 
                autoAttackInterval: 27.5, 
                baseAutoAttackInterval: 27.5,
                originalAutoAttackInterval: 28,
                autoTimer: 0,
                buffTimer: 0 
            },
                bonusAttackSpeed: 0
         };
        const keys = { ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false, Space: false, KeyQ: false, KeyW: false, KeyE: false, KeyA: false };
        let touchStart = { x: 0, y: 0 };
        let touchCurrent = { x: 0, y: 0 };
        let isTouching = false;

        let enemies = [];
        let gases = []; 
        let darkGases = []; 
        let darkGreenGases = []; 
        let poops = []; 
        let bigPoops = []; 
        let darkBigPoops = []; 
        let darkSemens = []; 
        let homingSemens = []; 
        let poopStains = []; 
        let whiteshots = []; 
        let fartSmogs = []; // [신규] 오즈마: 방구 스모그
        let ghosts = []; 
        let deathClouds = []; 
        let items = [];
        let mindSkulls = [];
        let stickyCreamPuddles = []; 
        let pandemoniums = []; 
        let hollowNight = [];
        let darkHearts = []; 
        let darkWaves = []; 
        let pheromoneMarkers = []; 
        let pleasureZones = [];
        let movingGases = [];
        let explosions = [];
        let shiningInfernoEffects = [];
        let holyCrossEffects = [];
        let phantomSwords = [];
        let blackMoons = [];
        let deathMetalNotes = [];      // 데스메탈 크레센도 투사체 배열
        let darknessSpotlights = [];   // 다크니스 스포트라이트 장판 배열
        let tetoraRequiemActive = false; // 진혼곡 활성화 상태 (전역)
        let tetoraRhapsodyActive = false; // 광시곡 활성화 상태 (전역)
        let royalSpawnTimer = 0;

        // ==================================================================================
        // [신규] 인벤토리/장비 시스템 (단축키 변경)
        //  - 특정 적 처치 시 고유 전리품(강화/합성 재료)이 확률적으로 드랍되며 전리품 인벤토리에 자동 저장됩니다.
        //  - P: 전리품 인벤토리 + 장비 강화 패널 열기/닫기 (열려있는 동안 시간 일시정지)
        //  - I: 장비 인벤토리(128칸) + 장착 패널 열기/닫기 (열려있는 동안 시간 일시정지)
        // ==================================================================================

        const INVENTORY_COLS = 8;
        const INVENTORY_ROWS = 8;
        const INVENTORY_SIZE = INVENTORY_COLS * INVENTORY_ROWS;

        // [NEW] 장비(Equipment) 인벤토리 : 128칸(8x16)
        const GEAR_INV_COLS = 8;
        const GEAR_INV_ROWS = 16;
        const GEAR_INV_SIZE = GEAR_INV_COLS * GEAR_INV_ROWS;

        // [NEW] 장비 등급(희귀도) 8단계 (커먼 → 엔젤릭)
        const EQUIP_RARITIES = ['common','uncommon','rare','epic','unique','legendary','demonic','angelic'];
        const EQUIP_RARITY_KO = {
            common: '커먼',
            uncommon: '언커먼',
            rare: '레어',
            epic: '에픽',
            unique: '유니크',
            legendary: '레전더리',
            demonic: '데모닉',
            angelic: '엔젤릭'
        };
        const EQUIP_RARITY_ORDER = {
            common: 0,
            uncommon: 1,
            rare: 2,
            epic: 3,
            unique: 4,
            legendary: 5,
            demonic: 6,
            angelic: 7
        };
        const EQUIP_RARITY_OPTION_MULT = {
            common: 1.30,
            uncommon: 1.50,
            rare: 1.80,
            epic: 2.15,
            unique: 2.50,
            legendary: 3.00,
            demonic: 3.60,
            angelic: 4.50
        };
        const EQUIP_RARITY_COLORS = {
            common: '#b0b0b0',
            uncommon: '#4cd964',
            rare: '#4a90e2',
            epic: '#9b59b6',
            unique: '#f1c40f',
            legendary: '#ff8c00',
            demonic: '#ff3b30',
            angelic: '#e6ffff'
        };

        const EQUIP_SLOT_TYPES = ['Helmet','Sword','Armor','Gloves','Boots','Ring','Necklace'];
        const EQUIP_SLOT_KO = {
            Helmet: '투구',
            Sword: '검',
            Armor: '갑옷',
            Gloves: '장갑',
            Boots: '신발',
            Ring: '반지',
            Necklace: '목걸이'
        };


        const LOOT_CATEGORY = {
            NORMAL: 'normal', // 일반 빌런
            ELITE: 'elite',
            ROYAL: 'royal',
            BOSS: 'boss'
        };

        const LOOT_DEFS = {
    // =============================
    // [일반 전리품] (강화 재료)
    // =============================

    // --- 일반 빌런 (기본 드랍: 일반 1% / 레어 0.75%) ---
    curse_vial:          { name: '저주의 시약병',      rarity: 'normal', category: LOOT_CATEGORY.NORMAL, dropFrom: '공작원(저주/실명/고통)', desc: '저주가 농축된 작은 시약병. 마개를 열지 않아도 피부가 따끔거린다.' },
    dark_cloak_fragment: { name: '어둠의 망토 조각',   rarity: 'normal', category: LOOT_CATEGORY.NORMAL, dropFrom: '소환사(역병/덮치기범/테러범)', desc: '빛을 삼키는 섬유로 짜인 망토의 파편. 손끝에서 차가운 그림자가 번진다.' },
    used_condom:         { name: '사용한 콘돔',        rarity: 'normal', category: LOOT_CATEGORY.NORMAL, dropFrom: '강간범(일반/은신/매복)', desc: '추악한 범죄의 흔적이 남은 증거물. 봉인해도 불쾌한 열기가 남아 있다.' },

    // --- 일반 빌런 레어 ---
    poisoned_hilt:       { name: '독이 발린 칼자루',   rarity: 'rare',   category: LOOT_CATEGORY.NORMAL, dropFrom: '공작원(저주/실명/고통)', desc: '잡는 순간 손목이 저릿해지는 칼자루. 미세한 독기가 틈새에서 새어 나온다.' },
    ebony_powder:        { name: '칠흑의 가루',        rarity: 'rare',   category: LOOT_CATEGORY.NORMAL, dropFrom: '소환사(역병/덮치기범/테러범)', desc: '불빛을 잠깐 죽여버리는 검은 가루. 흩날리는 순간 주변 소리가 멀어진다.' },
    aphrodisiac_perfume: { name: '미약의 향수',        rarity: 'rare',   category: LOOT_CATEGORY.NORMAL, dropFrom: '강간범(일반/은신/매복)', desc: '달콤한 향 뒤에 불길한 잔향이 따라붙는다. 맡으면 판단이 흐릿해지는 기분이 든다.' },

    // --- 엘리트 (기본 드랍 20%) ---
    ryuon_emblem:  { name: '피로 물든 용사의 엠블렘', rarity: 'normal', category: LOOT_CATEGORY.ELITE, dropFrom: '타락한 용사 류온', desc: '타락한 용사의 피와 맹세가 엉겨 붙은 엠블렘. 손끝에 닿으면 아직도 뜨거운 결의가 맥동한다.' },
    luca_diary:    { name: '빛바랜 일기장',         rarity: 'normal', category: LOOT_CATEGORY.ELITE, dropFrom: '타락한 스나이퍼 루카', desc: '낡은 종이에 남겨진 마지막 기록. 페이지를 넘길 때마다 차가운 조준감이 스며든다.' },
    ozma_orb:      { name: '힘을 잃은 수정구슬',     rarity: 'normal', category: LOOT_CATEGORY.ELITE, dropFrom: '타락한 마법사 오즈마', desc: '마력이 빠져나가 잔향만 남은 수정구슬. 귓가에 희미한 주문이 메아리친다.' },
    taro_chain:    { name: '부서진 쇠사슬 조각',     rarity: 'normal', category: LOOT_CATEGORY.ELITE, dropFrom: '타락한 암살자 타로', desc: '끊어진 사슬의 파편. 달그락거리는 금속음이 어둠을 끌어당기는 듯하다.' },
    gawain_flag:   { name: '찢어진 맹세의 깃발 조각', rarity: 'normal', category: LOOT_CATEGORY.ELITE, dropFrom: '타락한 성기사 가웨인', desc: '찢긴 깃발 조각에 남은 성스러운 잔향. 잃어버린 맹세가 바람처럼 스쳐간다.' },
    aki_potion:    { name: '어둠의 독약병',         rarity: 'normal', category: LOOT_CATEGORY.ELITE, dropFrom: '타락한 사냥꾼 아키', desc: '검은 기운이 농축된 독약병. 마개를 열지 않아도 살갗이 서늘해진다.' },
    hiro_radio:    { name: '망가진 무전기',         rarity: 'normal', category: LOOT_CATEGORY.ELITE, dropFrom: '타락한 첩보원 히로', desc: '잡음만 남은 무전기. 끊어진 호출 속에 누군가의 절박함이 남아 있다.' },
    kai_grimoire:  { name: '토막난 고서 조각',       rarity: 'normal', category: LOOT_CATEGORY.ELITE, dropFrom: '흑마법사 카이', desc: '찢겨 나간 고서의 한 장. 금지된 문장이 어둠 속에서 스스로 이어지려 한다.' },
    jacques_note:  { name: '어둠의 음표 파편',       rarity: 'normal', category: LOOT_CATEGORY.ELITE, dropFrom: '타락한 바드 자크', desc: '깨진 음표의 파편. 손에 쥐면 저주받은 선율이 심장박동과 겹친다.' },
    cassias_badge: { name: '엘리트 빌런의 뱃지',     rarity: 'normal', category: LOOT_CATEGORY.ELITE, dropFrom: '카시아스', desc: '엘리트 빌런의 위계를 증명하는 뱃지. 묵직한 권위와 오만이 서려 있다.' },

    // --- 로열 (기본 드랍 15%) ---
    masakuni_mask: { name: '어둠의 사무라이 가면',   rarity: 'normal', category: LOOT_CATEGORY.ROYAL, dropFrom: '검은 민족 마사쿠니', desc: '검은 민족의 사무라이 가면. 시야 끝에 잔혹한 결의가 아른거린다.' },
    kaito_orb:     { name: '감염된 유리구슬',       rarity: 'normal', category: LOOT_CATEGORY.ROYAL, dropFrom: '검은 민족 카이토', desc: '유리 속 흑빛이 끓어오르는 구슬. 가까이 하면 불길한 맥동이 전해진다.' },
    questa_bottle: { name: '독가스가 응축된 병',     rarity: 'normal', category: LOOT_CATEGORY.ROYAL, dropFrom: '검은 민족 퀘스타', desc: '독가스가 고요히 응축된 병. 실금 사이로 매캐한 기운이 새어 나온다.' },
    tetora_note:   { name: '깊은 어둠의 음표 파편', rarity: 'normal', category: LOOT_CATEGORY.ROYAL, dropFrom: '검은 민족 테토라', desc: '심연처럼 깊은 음의 파편. 숨을 들이킬 때마다 절규 같은 화음이 스민다.' },

    // --- 보스 (기본 드랍 10%) ---
    dark_virus:    { name: '다크 바이러스',         rarity: 'normal', category: LOOT_CATEGORY.BOSS, dropFrom: '방구킹 카인', desc: '보스의 어둠이 실체화된 바이러스. 가까이 하면 시야가 잠깐 흔들린다.' },
    blood_hilt:    { name: '피로 물든 칼자루',       rarity: 'normal', category: LOOT_CATEGORY.BOSS, dropFrom: '타락한 로드 아서', desc: '핏자국이 마르지 않은 칼자루. 잡는 순간 누군가의 검격이 손바닥을 타고 흐른다.' },

    // =============================
    // [레어 전리품] (등급 업그레이드 재료)
    //  - 엘리트: 1%
    //  - 로열: 0.75%
    //  - 보스: 0.5%
    // =============================

    // --- 엘리트 레어 ---
    oath_blooddrop:     { name: '맹세의 핏방울',           rarity: 'rare', category: LOOT_CATEGORY.ELITE, dropFrom: '타락한 용사 류온', desc: '엠블렘에 스며든 피가 굳지 못하고, 아직도 약속을 속삭인다.' },
    broken_aim_lens:    { name: '깨진 조준 렌즈',           rarity: 'rare', category: LOOT_CATEGORY.ELITE, dropFrom: '타락한 스나이퍼 루카', desc: '균열 너머로 보이는 건 적이 아니라… 죽음의 장면이다.' },
    arcane_echo_dust:   { name: '마력 잔향의 결정가루',     rarity: 'rare', category: LOOT_CATEGORY.ELITE, dropFrom: '타락한 마법사 오즈마', desc: '힘을 잃은 수정구슬이 마지막으로 토해낸, 희미한 주문의 가루.' },
    torn_letter:        { name: '찢어진 편지',             rarity: 'rare', category: LOOT_CATEGORY.ELITE, dropFrom: '타락한 암살자 타로', desc: '소중히 간직했던것 같은 편지. 하지만 찢어져 알아볼수 없다.' },
    oath_wind_shard:    { name: '맹세의 바람조각',           rarity: 'rare', category: LOOT_CATEGORY.ELITE, dropFrom: '타락한 성기사 가웨인', desc: '깃발이 찢긴 자리에서, 맹세의 온도만 바람처럼 남았다.' },
    dark_sediment:      { name: '어둠의 침전물',             rarity: 'rare', category: LOOT_CATEGORY.ELITE, dropFrom: '타락한 사냥꾼 아키', desc: '병 바닥에 가라앉은 검은 침전물. 병을 만지는 것만으로도 어둠이 흡수될것만 같다.' },
    call_sign_noise:    { name: '잡음 속의 호출부호',         rarity: 'rare', category: LOOT_CATEGORY.ELITE, dropFrom: '타락한 첩보원 히로', desc: '망가진 무전기에서 딱 한 번, 고통스러운 목소리가 분명히 새어 나왔다.' },
    greed_ink_trace:    { name: '탐욕의 잉크흔',             rarity: 'rare', category: LOOT_CATEGORY.ELITE, dropFrom: '흑마법사 카이', desc: '찢긴 고서 가장자리에 번진 잉크. 글자가 아니라 욕망이 기록돼 있다.' },
    dissonance_meter:   { name: '불협의 박자표',             rarity: 'rare', category: LOOT_CATEGORY.ELITE, dropFrom: '타락한 바드 자크', desc: '심장박동과 맞지 않는 박자. 보는 것만으로도 정신 착란에 걸릴 것만 같다.' },
    rank_seal_wax:      { name: '계급의 봉랍인',             rarity: 'rare', category: LOOT_CATEGORY.ELITE, dropFrom: '카시아스', desc: '뱃지에 찍힌 봉랍. 녹여도 ‘서열’만큼은 지워지지 않는다.' },

    // --- 로열 레어 ---
    abyss_orb:          { name: '심연의 구슬',               rarity: 'rare', category: LOOT_CATEGORY.ROYAL, dropFrom: '검은 민족 마사쿠니', desc: '칠흑같은 어둠의 구슬. 계속 쳐다보면 심연이 집어 삼킨다고 한다.' },
    black_confession_thread:{ name: '고해의 검은 실',         rarity: 'rare', category: LOOT_CATEGORY.ROYAL, dropFrom: '검은 민족 카이토', desc: '기도도, 변명도 아닌… 죄를 꿰매던 실의 잔재.' },
    black_veil_strand:  { name: '칠흑 장막의 올',           rarity: 'rare', category: LOOT_CATEGORY.ROYAL, dropFrom: '검은 민족 퀘스타', desc: '장막의 한 올을 잡는 순간, 손끝의 색이 잠깐 사라진다.' },
    abyss_phrase:       { name: '심연의 한 소절',           rarity: 'rare', category: LOOT_CATEGORY.ROYAL, dropFrom: '검은 민족 테토라', desc: '노래가 끝났는데도, 마지막 소절이 공기 중에서 계속 울린다.' },

    // --- 보스 레어 ---
    abyss_residual_spore:{ name: '심연의 잔류 포자',          rarity: 'rare', category: LOOT_CATEGORY.BOSS, dropFrom: '방구킹 카인', desc: '바이러스가 지나간 자리엔, ‘다음’ 재앙을 위한 씨앗만 남는다.' },
    true_ancestor_mark: { name: '진조의 낙인',               rarity: 'rare', category: LOOT_CATEGORY.BOSS, dropFrom: '타락한 로드 아서', desc: '진조의 피로 만들어진 낙인. 낙인의 상징은 그의 \'짝\'이 되는것.' },

    // --- 장비 분해 재료(전리품 인벤토리 저장) ---
    common_hardener: { name: '커먼 경화제', rarity: 'normal', category: LOOT_CATEGORY.NORMAL, dropFrom: '장비 분해', desc: '커먼 등급의 무기를 분해해 얻은 경화제. (장비 분해)' },
    common_cloth: { name: '커먼 헝겊 조각', rarity: 'normal', category: LOOT_CATEGORY.NORMAL, dropFrom: '장비 분해', desc: '커먼 등급의 방어구를 분해해 얻은 헝겊 조각. (장비 분해)' },
    common_metal: { name: '커먼 금속 조각', rarity: 'normal', category: LOOT_CATEGORY.NORMAL, dropFrom: '장비 분해', desc: '커먼 등급의 악세사리를 분해해 얻은 금속 조각. (장비 분해)' },
    uncommon_hardener: { name: '언커먼 경화제', rarity: 'normal', category: LOOT_CATEGORY.NORMAL, dropFrom: '장비 분해', desc: '언커먼 등급의 무기를 분해해 얻은 경화제. (장비 분해)' },
    uncommon_cloth: { name: '언커먼 헝겊 조각', rarity: 'normal', category: LOOT_CATEGORY.NORMAL, dropFrom: '장비 분해', desc: '언커먼 등급의 방어구를 분해해 얻은 헝겊 조각. (장비 분해)' },
    uncommon_metal: { name: '언커먼 금속 조각', rarity: 'normal', category: LOOT_CATEGORY.NORMAL, dropFrom: '장비 분해', desc: '언커먼 등급의 악세사리를 분해해 얻은 금속 조각. (장비 분해)' },
    rare_hardener: { name: '레어 경화제', rarity: 'normal', category: LOOT_CATEGORY.NORMAL, dropFrom: '장비 분해', desc: '레어 등급의 무기를 분해해 얻은 경화제. (장비 분해)' },
    rare_cloth: { name: '레어 헝겊 조각', rarity: 'normal', category: LOOT_CATEGORY.NORMAL, dropFrom: '장비 분해', desc: '레어 등급의 방어구를 분해해 얻은 헝겊 조각. (장비 분해)' },
    rare_metal: { name: '레어 금속 조각', rarity: 'normal', category: LOOT_CATEGORY.NORMAL, dropFrom: '장비 분해', desc: '레어 등급의 악세사리를 분해해 얻은 금속 조각. (장비 분해)' },
    epic_hardener: { name: '에픽 경화제', rarity: 'normal', category: LOOT_CATEGORY.NORMAL, dropFrom: '장비 분해', desc: '에픽 등급의 무기를 분해해 얻은 경화제. (장비 분해)' },
    epic_cloth: { name: '에픽 헝겊 조각', rarity: 'normal', category: LOOT_CATEGORY.NORMAL, dropFrom: '장비 분해', desc: '에픽 등급의 방어구를 분해해 얻은 헝겊 조각. (장비 분해)' },
    epic_metal: { name: '에픽 금속 조각', rarity: 'normal', category: LOOT_CATEGORY.NORMAL, dropFrom: '장비 분해', desc: '에픽 등급의 악세사리를 분해해 얻은 금속 조각. (장비 분해)' },
    unique_hardener: { name: '유니크 경화제', rarity: 'rare', category: LOOT_CATEGORY.NORMAL, dropFrom: '장비 분해', desc: '유니크 등급의 무기를 분해해 얻은 경화제. (장비 분해)' },
    unique_cloth: { name: '유니크 헝겊 조각', rarity: 'rare', category: LOOT_CATEGORY.NORMAL, dropFrom: '장비 분해', desc: '유니크 등급의 방어구를 분해해 얻은 헝겊 조각. (장비 분해)' },
    unique_metal: { name: '유니크 금속 조각', rarity: 'rare', category: LOOT_CATEGORY.NORMAL, dropFrom: '장비 분해', desc: '유니크 등급의 악세사리를 분해해 얻은 금속 조각. (장비 분해)' },
    legendary_hardener: { name: '레전더리 경화제', rarity: 'rare', category: LOOT_CATEGORY.NORMAL, dropFrom: '장비 분해', desc: '레전더리 등급의 무기를 분해해 얻은 경화제. (장비 분해)' },
    legendary_cloth: { name: '레전더리 헝겊 조각', rarity: 'rare', category: LOOT_CATEGORY.NORMAL, dropFrom: '장비 분해', desc: '레전더리 등급의 방어구를 분해해 얻은 헝겊 조각. (장비 분해)' },
    legendary_metal: { name: '레전더리 금속 조각', rarity: 'rare', category: LOOT_CATEGORY.NORMAL, dropFrom: '장비 분해', desc: '레전더리 등급의 악세사리를 분해해 얻은 금속 조각. (장비 분해)' },
    demonic_hardener: { name: '데모닉 경화제', rarity: 'rare', category: LOOT_CATEGORY.NORMAL, dropFrom: '장비 분해', desc: '데모닉 등급의 무기를 분해해 얻은 경화제. (장비 분해)' },
    demonic_cloth: { name: '데모닉 헝겊 조각', rarity: 'rare', category: LOOT_CATEGORY.NORMAL, dropFrom: '장비 분해', desc: '데모닉 등급의 방어구를 분해해 얻은 헝겊 조각. (장비 분해)' },
    demonic_metal: { name: '데모닉 금속 조각', rarity: 'rare', category: LOOT_CATEGORY.NORMAL, dropFrom: '장비 분해', desc: '데모닉 등급의 악세사리를 분해해 얻은 금속 조각. (장비 분해)' },
    angelic_hardener: { name: '엔젤릭 경화제', rarity: 'rare', category: LOOT_CATEGORY.NORMAL, dropFrom: '장비 분해', desc: '엔젤릭 등급의 무기를 분해해 얻은 경화제. (장비 분해)' },
    angelic_cloth: { name: '엔젤릭 헝겊 조각', rarity: 'rare', category: LOOT_CATEGORY.NORMAL, dropFrom: '장비 분해', desc: '엔젤릭 등급의 방어구를 분해해 얻은 헝겊 조각. (장비 분해)' },
    angelic_metal: { name: '엔젤릭 금속 조각', rarity: 'rare', category: LOOT_CATEGORY.NORMAL, dropFrom: '장비 분해', desc: '엔젤릭 등급의 악세사리를 분해해 얻은 금속 조각. (장비 분해)' },
};

        const WEAPON_NAME = '성검 그록스';
        const ARMOR_NAME  = '성갑 토렌스';
        const MAX_ENHANCE_LEVEL = 30;

        // 인벤토리: 64칸(스택형)
                let inventorySlots = new Array(INVENTORY_SIZE).fill(null);


        // [저장] 인벤토리만 사망/재시작 후에도 유지 (localStorage)
        const INVENTORY_STORAGE_KEY = 'gbvs_inventory_v1';

        function loadInventoryFromStorage() {
            try {
                const raw = localStorage.getItem(INVENTORY_STORAGE_KEY);
                if (!raw) return;
                const parsed = JSON.parse(raw);
                if (!Array.isArray(parsed)) return;

                const next = new Array(INVENTORY_SIZE).fill(null);
                for (let i = 0; i < INVENTORY_SIZE; i++) {
                    const s = parsed[i];
                    if (!s || typeof s !== 'object') continue;
                    if (typeof s.id !== 'string') continue;
                    if (!LOOT_DEFS[s.id]) continue;
                    const qty = Math.max(1, Math.floor(Number(s.qty || 1)));
                    next[i] = { id: s.id, qty };
                }
                inventorySlots = next;
            } catch (e) {
                console.warn('Failed to load inventory from localStorage:', e);
            }
        }

        function saveInventoryToStorage() {
            try {
                localStorage.setItem(INVENTORY_STORAGE_KEY, JSON.stringify(inventorySlots));
            } catch (e) {
                console.warn('Failed to save inventory to localStorage:', e);
            }
        }

        // 페이지 로드 시 1회 복원
        loadInventoryFromStorage();


        // 장비 강화 레벨(1~30) + 장비 등급(커먼~엔젤릭)
        //  - 레벨은 등급마다 1~30, Lv.30 달성 시 등급 업그레이드 가능
        //  - 등급 업그레이드 시 Lv.1로 리셋되지만, 직전 등급 Lv.30의 능력치는 보장
        const GEAR_GRADES = ['커먼','언커먼','레어','유니크','히로익','아티팩트','미스틱','레전더리','기간틱','데모닉','엔젤릭'];
        const MAX_GEAR_GRADE_INDEX = GEAR_GRADES.length - 1;

        let weaponGradeIndex = 0; // 0=커먼
        let armorGradeIndex  = 0; // 0=커먼

        let weaponEnhanceLevel = 1;
        let armorEnhanceLevel  = 1;

        // [저장] 무기/방어구 레벨/등급도 사망/재시작 후 유지 (localStorage)
        const ENHANCE_STORAGE_KEY = 'gbvs_enhance_v1';

        function loadEnhanceFromStorage() {
            try {
                const raw = localStorage.getItem(ENHANCE_STORAGE_KEY);
                if (!raw) return;
                const parsed = JSON.parse(raw);
                if (!parsed || typeof parsed !== 'object') return;

                const w = Number(parsed.weaponLv);
                const a = Number(parsed.armorLv);
                const wg = Number(parsed.weaponGrade);
                const ag = Number(parsed.armorGrade);

                if (Number.isFinite(w) && w >= 1 && w <= MAX_ENHANCE_LEVEL) weaponEnhanceLevel = Math.floor(w);
                if (Number.isFinite(a) && a >= 1 && a <= MAX_ENHANCE_LEVEL) armorEnhanceLevel = Math.floor(a);

                if (Number.isFinite(wg) && wg >= 0 && wg <= MAX_GEAR_GRADE_INDEX) weaponGradeIndex = Math.floor(wg);
                if (Number.isFinite(ag) && ag >= 0 && ag <= MAX_GEAR_GRADE_INDEX) armorGradeIndex = Math.floor(ag);
            } catch (e) {
                console.warn('Failed to load enhance from localStorage:', e);
            }
        }

        function saveEnhanceToStorage() {
            try {
                const payload = {
                    weaponLv: weaponEnhanceLevel,
                    armorLv: armorEnhanceLevel,
                    weaponGrade: weaponGradeIndex,
                    armorGrade: armorGradeIndex
                };
                localStorage.setItem(ENHANCE_STORAGE_KEY, JSON.stringify(payload));
            } catch (e) {
                console.warn('Failed to save enhance to localStorage:', e);
            }
        }

        // 페이지 로드 시 1회 복원
        loadEnhanceFromStorage();

        // UI Open flags (열려있는 동안 animate()가 멈추며, 닫을 때 다시 requestAnimationFrame)
        let isGearPanelOpen = false;

        // [NEW] 인벤토리 선택(합성/정렬 UI)
        let selectedSynthInvIndex = null;

        // [NEW] 합성(멀티 선택/합산) 상태
        //  - 일반 합성: 일반 빌런 '일반' 전리품 총합 10개(혼합 가능) → 엘리트 빌런 '일반' 전리품 랜덤 1개
        //  - 레어 합성: 일반 빌런 '레어' 전리품 총합 5개(혼합 가능) → 엘리트 빌런 '레어' 전리품 랜덤 1개
        const SYNTH_MIX_NEED = 10;
        const SYNTH_RARE_NEED = 5;
        const SYNTH_EQUIP_NEED = 100; // [NEW] 장비 합성(경화제/헝겊/금속 조각)

        const synthState = {
            // mode: null | 'normal' | 'rare' | 'equip'
            mode: null,
            // invIndex -> 선택(예약) 수량 (현재 mode에 해당하는 재료만 담김)
            reservedByInvIndex: new Array(INVENTORY_SIZE).fill(0)
        };


        // 아이콘(DataURL) 캐시
        const LOOT_ICON = {};
        let WEAPON_ICON_URL = '';
        let ARMOR_ICON_URL = '';
        const WEAPON_ICON_FILE = './weapon_grox.png';
        const ARMOR_ICON_FILE = './armor_torens.png';


        // UI 요소(런타임 초기화)
        let gearPanelEl, inventoryGridEl, closeGearPanelBtnEl, invTooltipEl;
        let invSortBtnEl, invSynthesisBtnEl, invSynthClearBtnEl, invSynthesisInfoEl;
        let weaponIconEl, armorIconEl;
        let weaponMatSlotsEl, armorMatSlotsEl;
        let weaponLevelTextEl, armorLevelTextEl;
        let weaponStatsTextEl, armorStatsTextEl;
        let weaponReqTextEl, armorReqTextEl;
        let weaponHaveTextEl, armorHaveTextEl;
        let weaponUpgradeBtnEl, armorUpgradeBtnEl;

        // [NEW] 강화 패널(재료 슬롯) 세션 상태
        const enhancePanelState = {
            focusGear: 'weapon',      // 'weapon' | 'armor'
            activeTarget: null,       // { gear: 'weapon'|'armor', index: number }
            reservedByInvIndex: new Array(INVENTORY_SIZE).fill(0),
            weapon: { reqSig: '', slots: [] },
            armor:  { reqSig: '', slots: [] }
        };

        // ---------------------------
        // [유틸] 인벤토리 조작
        // ---------------------------
        function resetInventoryAndEnhance({ clearInventory = false } = {}) {
            if (clearInventory) {
                inventorySlots = new Array(INVENTORY_SIZE).fill(null);
                saveInventoryToStorage();
            }
            weaponEnhanceLevel = 1;
            armorEnhanceLevel  = 1;
            weaponGradeIndex   = 0;
            armorGradeIndex    = 0;
            saveEnhanceToStorage();
            updateInventoryUI();
            updateEnhanceUI();
        }

        
function addLootToInventory(id, qty = 1) {
    if (!LOOT_DEFS[id]) return false;
    qty = Math.max(1, Math.floor(qty));

    // 1) 같은 아이템이 이미 있으면 스택
    for (let i = 0; i < inventorySlots.length; i++) {
        const s = inventorySlots[i];
        if (s && s.id === id) {
            s.qty += qty;
            saveInventoryToStorage();
            return true;
        }
    }
    // 2) 빈 칸에 새로 추가
    for (let i = 0; i < inventorySlots.length; i++) {
        if (!inventorySlots[i]) {
            inventorySlots[i] = { id, qty };
            saveInventoryToStorage();
            return true;
        }
    }
    return false; // 가득 참
}

        function getLootCount(id) {
            let total = 0;
            for (const s of inventorySlots) {
                if (s && s.id === id) total += s.qty;
            }
            return total;
        }

        
function consumeLoot(id, qty) {
    qty = Math.max(0, Math.floor(qty));
    if (qty <= 0) return true;
    if (getLootCount(id) < qty) return false;

    for (let i = 0; i < inventorySlots.length; i++) {
        const s = inventorySlots[i];
        if (!s || s.id !== id) continue;
        const take = Math.min(qty, s.qty);
        s.qty -= take;
        qty -= take;
        if (s.qty <= 0) inventorySlots[i] = null;
        if (qty <= 0) break;
    }
    saveInventoryToStorage();
    return true;
}


function getLootCountByCategory(category) {
    let total = 0;
    for (const s of inventorySlots) {
        if (!s) continue;
        const def = LOOT_DEFS[s.id];
        if (def && def.category === category && (def.rarity !== 'rare')) total += s.qty;
    }
    return total;
}

function getLootCountByCategoryAndRarity(category, rarity) {
    let total = 0;
    for (const s of inventorySlots) {
        if (!s) continue;
        const def = LOOT_DEFS[s.id];
        if (def && def.category === category && def.rarity === rarity) total += s.qty;
    }
    return total;
}

function consumeLootByCategory(category, qty) {
    qty = Math.max(0, Math.floor(qty));
    if (qty <= 0) return true;
    if (getLootCountByCategory(category) < qty) return false;

    for (let i = 0; i < inventorySlots.length; i++) {
        const s = inventorySlots[i];
        if (!s) continue;
        const def = LOOT_DEFS[s.id];
        if (!def || def.category !== category || def.rarity === 'rare') continue;

        const take = Math.min(qty, s.qty);
        s.qty -= take;
        qty -= take;
        if (s.qty <= 0) inventorySlots[i] = null;
        if (qty <= 0) break;
    }
    saveInventoryToStorage();
    return true;
}



        // =====================================================================
        // [NEW] 장비 시스템 (드랍/인벤토리/장착/분해)
        //  - I : 장비 인벤토리(128칸) + 장착
        //  - P : 전리품 인벤토리 + 장비 강화 (기존 Gear Panel)
        //  - 장비 등급: 커먼 → 언커먼 → 레어 → 에픽 → 유니크 → 레전더리 → 데모닉 → 엔젤릭
        // =====================================================================

        const GEAR_INV_STORAGE_KEY = 'gbvs_equipInventory_v1';
        const EQUIPPED_GEAR_STORAGE_KEY = 'gbvs_equippedGear_v1';
        const PENDING_GEAR_STORAGE_KEY = 'gbvs_pendingGear_v1';
        const GEAR_LOCK_STORAGE_KEY = 'gbvs_gearLockMap_v1';

        // 128칸 장비 인벤토리
        let gearInventorySlots = new Array(GEAR_INV_SIZE).fill(null);

        // 장착 슬롯(7)
        let equippedGear = (() => {
            const obj = {};
            for (const s of EQUIP_SLOT_TYPES) obj[s] = null;
            return obj;
        })();

        // 인벤토리 가득 찼을 때 보관 대기 큐
        let pendingGearDrops = [];
        let gearLockMap = {};
        let gearBulkDisassembleRarity = 'epic';

        // 장비 패널 UI 상태
        let isEquipPanelOpen = false;
        let equipPanelEl = null;
        let closeEquipPanelBtnEl = null;
        let gearInventoryGridEl = null;
        let equipSlotsUIEl = null;
        let gearSortBtnEl = null;
        let gearBulkDisassembleBtnEl = null;
        let gearBulkRaritySelectEl = null;
        let gearEquipBtnEl = null;
        let gearUnequipBtnEl = null;
        let gearDisassembleBtnEl = null;
        let gearDropBtnEl = null;
        let gearSelectionInfoEl = null;
        let pendingGearInfoEl = null;
        let equipStatsSummaryEl = null;

        let gearInventorySlotEls = [];
        let equipSlotEls = {};

        let selectedGearInvIndex = null;
        let selectedEquipSlotKey = null;

        // [NEW] 장비 인벤토리 드래그 이동(슬롯 교환)
        let gearInvDragSourceIndex = null;

        // ---------------------------------------------------------
        // 장비 데이터 (장비패치.txt 기반)
        // ---------------------------------------------------------
        const EQUIP_BASE_ITEMS = {"Helmet": [{"name": "낡은 철투구", "desc": "수많은 전투를 거치며 수없이 찌그러지고 다시 펴진 흔적이 역력합니다. 이름 없는 병사들의 머리를 지켜주던 이 투구는, 이제 전장의 비정함과 허무함을 묵묵히 전하고 있습니다."}, {"name": "가죽 두건", "desc": "누군가 오랫동안 사용한 듯 낡고 해진 두건입니다. 질긴 가죽 특유의 비린내와 땀 냄새가 섞여 있지만, 머리를 보호하기에는 충분해 보입니다."}, {"name": "찌그러진 철모", "desc": "주인을 잃고 땅바닥을 굴러다니던 낡은 철모입니다. 깊게 팬 자국은 치열했던 전투의 흔적이며, 누군가의 생명을 마지막 순간까지 지켜내려 노력했던 고귀한 패배의 훈장입니다."}, {"name": "검댕 묻은 두건", "desc": "무언가 거대한 것이 타버린 잿더미 속에서 건져낸 천 조각입니다. 아무리 세탁해도 씻겨나가지 않는 검은 그을음은 그날의 참혹했던 화마를 증언합니다."}, {"name": "뼈 장식 투구", "desc": "거대한 짐승의 두개골을 깎아 만든 투박한 투구입니다. 원시적인 힘이 깃들어 있어, 착용자로 하여금 야생의 본능을 깨우고 신체적 한계를 돌파하게 만드는 기묘한 흥분을 줍니다."}, {"name": "얇은 사슬 후드", "desc": "작은 금속 고리들을 촘촘하게 엮어 만든 방어구입니다. 가볍고 유연하여 활동성이 뛰어나지만, 강력한 타격이나 관통 공격에는 최소한의 보호막 역할밖에 하지 못합니다."}, {"name": "깨진 바이저 투구", "desc": "한때는 찬란했을 기사의 투구였으나, 이제는 바이저 한쪽이 처참하게 깨져나갔습니다. 금이 간 틈새로 들어오는 시야는 불안정하지만, 그 너머로 비치는 눈동자에는 여전히 투지가 서려 있습니다."}, {"name": "방진 마스크", "desc": "거친 먼지가 날리는 광산이나 공방에서 흔히 볼 수 있는 마스크입니다. 생존에 직결된 특별한 능력은 없지만, 호흡기를 보호하는 가장 기초적인 수단입니다."}, {"name": "낡은 전령 모자", "desc": "대륙의 끝에서 끝까지 소식을 전하던 이의 모자입니다. 비바람에 깎인 가죽의 질감에는 수많은 국경을 넘나들었던 고독과 책임감이 켜켜이 쌓여 있습니다."}, {"name": "철사로 꿰맨 면갑", "desc": "부서진 조각들을 녹슨 철사로 거칠게 엮어 만든 급조품입니다. 보기에는 흉측하고 착용감도 엉망이지만, 어떻게든 살아남겠다는 착용자의 처절한 생존 의지가 돋보입니다."}, {"name": "교단의 검은 후드", "desc": "하급 사제들이 얼굴을 가리고 고행을 수행할 때 사용하던 천입니다. 거친 질감은 세속의 안락함을 잊게 만들지만, 어둠 속에서 번뜩이는 그들의 눈빛은 신앙보다는 광기에 가깝습니다."}, {"name": "무대용 반가면", "desc": "얼굴의 절반만을 가리는 단순하고 우아한 가면입니다. 정체를 완전히 숨기기보다는 자신의 신비로움을 돋보이게 하려는 귀족들의 연회용 소품에 가깝습니다."}, {"name": "헌병의 철모", "desc": "옛 질서가 유지되던 시절, 치안과 규율을 담당하던 이들의 장비입니다. 이제는 권위도 힘도 잃었지만, 법이 존재했던 시대의 마지막 유산으로서 묵직한 무게감을 지니고 있습니다."}, {"name": "젖은 천 두건", "desc": "불길 속을 통과하거나 열기를 견디기 위해 급히 물에 적신 천입니다. 축축하고 무겁지만, 타오르는 전장의 열기로부터 잠시나마 이성을 지켜줄 유일한 위안입니다."}, {"name": "은빛 머리띠", "desc": "가느다란 은실로 정교하게 세공된 머리띠입니다. 방어력은 미미하지만, 은 특유의 정화 작용 덕분에 미세한 마력 교란으로부터 정신을 맑게 유지해 줍니다."}], "Sword": [{"name": "무딘 단검", "desc": "날이 너무 많이 무뎌져서 찌르기보다는 둔기로 쓰는 것이 나을 정도입니다. 하지만 급한 대로 가죽을 찢거나 방어구가 없는 적을 위협하기엔 유용합니다."}, {"name": "녹슨 장검", "desc": "오랫동안 습한 곳에 방치되어 붉은 녹이 슬었습니다. 베인 상처에 파상풍을 유발할 것 같은 비주얼이지만, 기본 공격력 자체는 낮습니다."}, {"name": "군용 대검", "desc": "제식으로 보급되는 표준형 대검입니다. 내구성이 뛰어나고 균형이 잘 잡혀 있어 어떤 상황에서도 신뢰할 수 있는 병사의 동반자입니다."}, {"name": "부러진 레이피어", "desc": "결투 중 끝부분이 부러져 나갔습니다. 사거리는 짧아졌지만 가벼워진 무게 덕분에 더욱 빠른 속도로 적의 틈을 파고들 수 있습니다."}, {"name": "흑철 검", "desc": "탄소 함량이 높은 흑철을 제련하여 만든 튼튼한 장검입니다. 화려한 마법은 없지만 기본에 충실하며, 어떤 적의 방패와 부딪혀도 결코 꺾이지 않는 강도를 자랑합니다."}, {"name": "톱니 커터", "desc": "공업용 날을 여러 겹 겹친 형태입니다. 날이 무뎌지면 한 칸씩 꺾어 새 날을 쓸 수 있어, 장기전에서도 내구도 소모 걱정이 적습니다."}, {"name": "야전도", "desc": "거친 환경에서 생존하기 위해 만들어진 실용적인 칼입니다. 덤불을 헤치거나 나무를 베는 데도 사용되며, 근접전에서도 준수한 성능을 보입니다."}, {"name": "주방칼", "desc": "주방에서 고기를 썰 때 쓰던 칼입니다. 전장에서는 우스꽝스러워 보이지만, 익숙한 손놀림으로 휘두르면 예상외로 날카로운 공격이 가능합니다."}, {"name": "낡은 세이버", "desc": "녹이 슬고 손잡이가 헐거운 기병도입니다. 전성기는 지났지만, 여전히 날카로운 끝부분은 방심한 적의 목술기를 노리기에 충분합니다."}, {"name": "각목검", "desc": "단단한 나무를 깎아 만든 연습용 검입니다. 날은 없지만 묵직한 타격감을 자랑하며, 초보자가 기본 검술을 익히는 데 가장 적합합니다."}, {"name": "캔따개 단도", "desc": "앞부분이 고리 모양으로 휜 작은 칼입니다. 주로 보급품을 뜯는 데 쓰이지만, 갑옷의 틈새를 걸어 당기는 변칙적인 전투가 가능합니다."}, {"name": "뼈날 단검", "desc": "거대한 괴수의 뼛조각을 갈아 만들었습니다. 금속과는 다른 거친 질감이 적의 살점을 파고들어 더 큰 고통을 줍니다."}, {"name": "가시 쇼텔", "desc": "낫처럼 휘어진 칼날 뒤편에 날카로운 가시들이 돋아 있습니다. 화려하진 않지만, 방패를 우회하여 적의 빈틈을 찌르는 데 특화된 실전적인 무기입니다."}, {"name": "쇳조각 스틸레토", "desc": "길가에 굴러다니던 쇳조각을 날카롭게 갈아 손잡이를 달았습니다. 조잡하지만 갑옷의 이음새를 찌르기에는 충분히 치명적입니다."}, {"name": "허름한 대검 ‘뒷골목’", "desc": "뒷골목의 불량배들이 조잡하게 두드려 만든 대검입니다. 무겁고 투박하지만, 그만큼 한 번 맞으면 뼈가 으스러지는 충격을 줍니다."}], "Armor": [{"name": "헤진 흉갑", "desc": "수많은 세월과 전투를 거치며 표면이 마모되고 얇아진 흉갑입니다. 전성기의 방어력은 기대할 수 없지만, 오랜 시간 주인을 지켜온 장비의 헌신적인 기운이 미세하게 남아 있습니다."}, {"name": "쇠사슬 갑옷", "desc": "작은 고리들을 연결하여 베기 공격에 대한 면역을 높인 갑옷입니다. 유연성이 좋아 신체 움직임이 자유롭지만, 무거운 둔기나 송곳 같은 관통 공격에는 취약할 수 있으니 주의가 필요합니다."}, {"name": "강철 판금", "desc": "단순하지만 견고한 강철판을 가슴에 덧댄 갑옷입니다. 투박한 외형만큼이나 정직한 방어력을 보여주며, 전선의 병사들이 가장 신뢰하는 방패 역할을 합니다."}, {"name": "누더기 로브", "desc": "수십 개의 천 조각을 이어 붙인 초라한 로브입니다. 하지만 그 조잡함 뒤에는 세상의 눈을 피해 몸을 숨기려는 현자의 지혜가 숨겨져 있을지도 모릅니다."}, {"name": "검은 외투", "desc": "평범한 검은 천으로 만든 외투입니다. 밤의 그림자에 숨어들기 좋으며, 가벼운 무게 덕분에 오랜 시간 이동해도 지치지 않는 실용적인 의복입니다."}, {"name": "가죽 조끼", "desc": "가볍고 질긴 가죽으로 만든 기본적인 방어구입니다. 신속한 움직임을 방해하지 않으면서도 예리한 칼날로부터 치명상을 피하게 해주는, 초보 모험가들의 든든한 동료입니다."}, {"name": "보급형 방탄조끼", "desc": "치안 유지 부대원들에게 보급되는 표준형 조끼입니다. 가볍고 신속한 착용이 가능하며, 소구경 탄환이나 날카로운 흉기로부터 상체를 보호하는 데 최적화되어 있습니다."}, {"name": "수선된 경갑", "desc": "파손된 부위를 다른 장비의 부품으로 덧대어 수리한 가벼운 갑옷입니다. 조잡해 보일 수 있으나, 수많은 사선을 넘나들며 얻은 실전적인 보강 덕분에 의외의 방어 성능을 보여줍니다."}, {"name": "방진 코트", "desc": "거친 먼지와 모래바람이 부는 황야의 생존자들이 즐겨 입는 코트입니다. 호흡기를 보호하는 깃과 모래가 잘 달라붙지 않는 특수 원단으로 제작되어 쾌적한 활동을 보장합니다."}, {"name": "철사 흉갑", "desc": "부서진 갑옷 조각들을 녹슨 철사로 엮어 만든 급조품입니다. 보기에는 흉측하고 방어력도 낮지만, 전장에서 한 번이라도 더 칼날을 튕겨내겠다는 착용자의 간절한 생존 의지가 담겨 있습니다."}, {"name": "쿠션 천갑", "desc": "천 사이에 부드러운 솜과 가죽을 넣어 충격을 완화한 갑옷입니다. 날카로운 공격에는 약하지만, 둔기에 의한 타격이나 추락 충격을 흡수하는 데 탁월한 효과를 발휘합니다."}, {"name": "찢어진 도복", "desc": "혹독한 수행의 흔적이 고스란히 남은 찢어진 도복입니다. 비록 너덜너덜하지만, 그 틈새로 보이는 단단한 근육과 도복에 밴 불굴의 정신력은 그 어떤 갑옷보다도 위협적으로 보입니다."}, {"name": "기름때 외투", "desc": "기계 장치를 수리하는 공방에서 사용하던 낡은 외투입니다. 겹겹이 쌓인 기름때는 의외로 가벼운 도탄 공격이나 산성 물질로부터 몸을 보호하는 막이 되어줍니다."}, {"name": "교단의 회색 로브", "desc": "중급 사제들이 고행의 길을 걸을 때 입던 로브입니다. 거친 질감은 육체적인 안락함을 멀리하게 하며, 정신을 오직 신앙의 목소리에 집중하도록 돕습니다."}, {"name": "냉기 도는 판금", "desc": "차가운 만년설 아래 잠겨있던 금속으로 제련된 판금입니다. 착용자의 체온을 일정하게 유지시켜 화염 마법에 대한 내성을 주지만, 장시간 착용 시 뼈마디가 시려오는 고통을 감수해야 합니다."}], "Gloves": [{"name": "천 장갑", "desc": "흔히 볼 수 있는 면 소재의 장갑입니다. 방어력은 거의 없으나 청결을 유지하거나 추위로부터 손을 보호하는 데 사용되며, 가벼운 활동성만큼은 최고입니다."}, {"name": "사냥꾼 장갑", "desc": "화살 깃의 감촉을 느끼고 활시위를 당길 때의 마찰로부터 손가락을 보호하는 궁수용 장갑입니다. 오랜 사냥의 경험이 밴 낡은 가죽 냄새가 납니다."}, {"name": "전투 장갑", "desc": "전선의 보병들에게 지급되는 표준형 가죽-철재 혼합 장갑입니다. 활동성과 방어력의 균형이 잘 잡혀 있어 어떤 상황에서도 신뢰할 수 있는 기본적인 장비입니다."}, {"name": "조준 장갑", "desc": "손등에 보조 조준선이 그려진 사수용 장갑입니다. 단순한 보조 장치지만 원거리 무기를 사용할 때 안정적인 지지대 역할을 해주어 명중률 향상에 도움을 줍니다."}, {"name": "흑가죽 장갑", "desc": "검게 무두질된 소가죽으로 만든 장식 없는 장갑입니다. 튼튼하고 눈에 띄지 않아 어둠 속에서 활동하는 이들이나 험한 일을 하는 이들에게 오랫동안 사랑받아온 장비입니다."}, {"name": "가시 장갑", "desc": "손등과 마디에 날카로운 금속 가시를 박아 넣었습니다. 단순한 가죽 장갑처럼 보이지만, 주먹을 휘두르는 순간 적의 살점을 찢어발기는 치명적인 무기로 변합니다."}, {"name": "방열 장갑", "desc": "달궈진 금속이나 화염을 다루기 위해 단열재를 겹겹이 덧대었습니다. 뜨거운 무기를 쥐어도 손이 데지 않으며, 화염 속에서도 물건을 집어 올릴 수 있는 인내심을 제공합니다."}, {"name": "실험용 고무장갑", "desc": "알 수 없는 액체가 튀거나 전기가 흐르는 실험실에서 사용되던 장갑입니다. 투박하지만 절연 성능이 뛰어나 전기 계열 공격으로부터 손을 안전하게 지켜줍니다."}, {"name": "도둑 장갑", "desc": "손끝이 얇게 가공되어 미세한 감각을 그대로 느낄 수 있습니다. 자물쇠를 따거나 주머니를 뒤질 때 최적의 성능을 발휘하며, 마찰을 최소화하여 소리 없이 움직이게 돕습니다."}, {"name": "철망 장갑", "desc": "미세한 철망을 덧대어 베기 공격으로부터 손을 보호합니다. 고기나 가공품을 다루던 이들이 사용하던 것으로, 투박하지만 확실한 실용성을 보여줍니다."}, {"name": "손목 보호대", "desc": "장갑이라기보다 손목의 인대와 근육을 지지하는 보조 기구입니다. 무거운 무기를 휘두를 때 발생하는 반동을 억제하여 손목의 부상을 예방합니다."}, {"name": "무두질 장갑", "desc": "질긴 가죽을 다루던 장인의 장갑입니다. 거친 환경에서도 손을 완벽하게 보호하며, 의외로 끈질긴 마찰력 덕분에 무기를 놓치는 일이 거의 없습니다."}, {"name": "사슬 장갑", "desc": "작은 금속 고리들을 엮어 가죽 위에 덧씌웠습니다. 칼날에 손가락이 잘려 나가는 비극을 방지해주며, 주먹 싸움에서도 묵직한 타격감을 더해줍니다."}, {"name": "제식 장갑", "desc": "의장대나 사열식에서 사용하던 깔끔한 면 장갑입니다. 방어력은 미미하지만, 품위를 유지하고 무기를 정중하게 다루는 자의 마음가짐을 투영하여 정신력을 고양시킵니다."}, {"name": "봉합 장갑", "desc": "상처를 꿰매는 의사나 자객들이 사용하던 정교한 장갑입니다. 손가락 끝의 감각이 극도로 예민하게 설계되어, 아주 얇은 실이나 바늘도 자유자재로 다룰 수 있습니다."}], "Boots": [{"name": "닳은 부츠", "desc": "수천 킬로미터를 걸어온 듯 밑창이 얇아진 부츠입니다. 비록 낡았지만 착용자의 발 모양에 완벽하게 길들어 있어, 새 신발보다 훨씬 편안한 착용감을 제공합니다."}, {"name": "전령의 장화", "desc": "소식을 전달하기 위해 밤낮없이 달리는 전령들을 위해 무게를 극단적으로 줄였습니다. 깃털처럼 가벼워 발에 무리를 주지 않으며 순수하게 달리기만을 위해 최적화되었습니다."}, {"name": "잠행 장화", "desc": "발목 위까지 부드럽게 감싸는 가죽 신발로, 움직임이 유연하고 소음이 적습니다. 은밀하게 움직여야 하는 정찰병들에게 가장 대중적인 선택입니다."}, {"name": "무쇠 부츠", "desc": "발 전체를 무거운 강철로 감쌌습니다. 매우 무겁지만 웬만한 칼날이나 화살은 발등에서 튕겨 나가며, 강력한 발차기 한 번으로 문을 부술 수 있는 위력을 가집니다."}, {"name": "진흙투성이 장화", "desc": "이미 진흙이 잔뜩 묻어있어 더러워지는 것을 두려워할 필요가 없습니다. 험지에서의 실전적인 경험이 묻어있으며, 미끄러운 바닥에서도 의외로 접지력이 좋습니다."}, {"name": "고무 장화", "desc": "물이 고인 늪지나 비 오는 날의 진흙탕에서 발을 쾌적하게 유지해 줍니다. 전도성이 낮아 전기 함정이 가득한 구역에서도 의외의 생존력을 발휘합니다."}, {"name": "삐걱대는 군화", "desc": "오래되어 걸을 때마다 기분 나쁜 소리가 나는 군화입니다. 방어력은 준수하지만 은밀함과는 거리가 멀며, 오히려 자신의 존재감을 과시하고 싶어 하는 전사들에게 어울립니다."}, {"name": "스파이크 부츠", "desc": "바닥에 날카로운 금속 징이 박혀 있어 빙판이나 가파른 절벽에서도 미끄러지지 않습니다. 험준한 산악 지형을 돌파할 때 없어서는 안 될 도구입니다."}, {"name": "마차꾼 부츠", "desc": "마차를 몰 때 페달을 밟기 편하도록 뒷굽이 튼튼하게 설계되었습니다. 진흙이 잘 묻지 않는 특수 처리가 되어 있어 험한 길에서도 청결을 유지하기 쉽습니다."}, {"name": "헌 운동화", "desc": "한때는 누군가의 일상을 함께했을 낡은 운동화입니다. 방어력은 없지만 매우 가볍고 친숙하며, 험난한 모험 속에서도 인간성을 잃지 않으려는 작은 위안이 됩니다."}, {"name": "사막용 부츠", "desc": "모래에 발이 빠지지 않도록 밑창이 넓고 통기성이 뛰어납니다. 뜨거운 태양 아래의 모래 언덕을 지치지 않고 넘을 수 있게 설계된 생존형 부츠입니다."}, {"name": "방수 부츠", "desc": "특수 오일로 코팅되어 물이 스며들지 않습니다. 장시간 물속에 발을 담그고 있어도 피부가 불지 않으며, 쾌적한 컨디션을 유지하게 돕습니다."}, {"name": "누더기 샌들", "desc": "다 떨어진 천과 밧줄로 겨우 형태만 유지하고 있습니다. 발을 제대로 보호해주지는 못하지만, 아무것도 가진 게 없는 자의 처절한 생존 본능을 상징합니다."}, {"name": "가죽 각반", "desc": "거친 수풀이나 돌부리로부터 정강이를 보호하기 위해 가죽을 덧대었습니다. 장거리 행군에 필수적이며, 투박하지만 신뢰할 수 있는 모험가의 기본 소양입니다."}, {"name": "철제 굽 장화", "desc": "뒷굽에 단단한 철판을 박아 넣어 걸을 때마다 묵직한 소리가 납니다. 이 소리는 착용자의 권위를 나타내기도 하며, 위급 시 강력한 뒷발차기로 적의 턱을 날려버릴 수 있습니다."}], "Ring": [{"name": "구리 반지", "desc": "가장 흔하게 구할 수 있는 금속 반지입니다. 마력 전도율은 낮지만 가벼운 행운을 불러온다는 속설이 있어 모험가들이 부적처럼 끼고 다닙니다."}, {"name": "은빛 반지", "desc": "깔끔하게 세공된 은반지입니다. 은 특유의 정화 성질 덕분에 약한 독을 감지하면 색이 변하며, 착용자의 기품을 유지해 줍니다. "}, {"name": "검은 인장반지", "desc": "아무런 문양도 새겨지지 않은 투박한 검은 금속 반지입니다. 단순하지만 견고하며, 장식보다는 실용성을 중시하는 이들이 도장 대용으로 사용하곤 합니다."}, {"name": "깨진 보석반지", "desc": "알이 빠지거나 깨진 낡은 반지입니다. 한때는 화려했을지 모르나 지금은 그저 추억만이 담겨 있습니다. 의외로 깨진 단면이 날카로워 비상시 도구로 쓸 수 있습니다."}, {"name": "봉랍 씰링", "desc": "편지를 봉인할 때 쓰는 붉은 왁스로 만든 반지입니다. 단단하지 않아 금방 부서지지만, 비밀스러운 정보를 담은 인장을 숨기기에 적합합니다."}, {"name": "쇠사슬 반지", "desc": "작은 사슬 고리를 연결해 만들었습니다. 거칠지만 튼튼하며, 밧줄이나 쇠사슬을 다룰 때 미끄러지지 않도록 도와주는 실용적인 반지입니다."}, {"name": "유리구슬 반지", "desc": "아이들이 가지고 놀 법한 투명한 유리구슬을 박았습니다. 가치는 없지만 빛을 굴절시켜 조그만 신호를 보내거나 어두운 곳에서 반사광을 이용하는 데 쓰입니다."}, {"name": "철사 반지", "desc": "철사를 꼬아서 만든 가장 원시적인 형태의 반지입니다. 비상시 풀어서 자물쇠를 따거나 낚싯바늘로 만드는 등 다목적 도구로 활용도가 높습니다."}, {"name": "물결 문양 반지", "desc": "표면에 부드러운 물결무늬가 새겨져 있습니다. 마음을 진정시키는 효과가 있어, 긴박한 전투 상황에서도 당황하지 않고 마법 영창을 이어가도록 돕습니다."}, {"name": "작은 기어 반지", "desc": "정밀 기계의 톱니바퀴를 반지로 개조했습니다. 기계류 아이템을 다룰 때 조작감이 향상되며, 공학적인 직감을 약간 높여줍니다."}, {"name": "동전 반지", "desc": "동전 가운데에 구멍을 뚫어 만든 반지입니다. 가난한 여행자들이 비상금을 몸에 지니기 위해 만들었으며, 행운의 여신이 깃들기를 바라는 마음이 담겨 있습니다."}, {"name": "뼈반지", "desc": "동물의 손가락뼈를 깎아 만들었습니다. 장식적인 가치는 낮으나 원시적인 주술적 힘이 깃들어 있어, 짐승들을 길들이거나 야생에서의 감각을 높여줍니다."}, {"name": "나사 반지", "desc": "기계 부품인 나사를 구부려 만든 조잡한 반지입니다. 별다른 마력은 없지만, 기계 장치를 수리할 때 급한 부품 대용으로 사용할 수 있는 실용적인 면모가 있습니다."}, {"name": "열쇠고리 링", "desc": "여러 개의 열쇠를 묶어두던 링을 손가락에 끼웠습니다. 별다른 힘은 없지만, 잡다한 도구들을 걸어두어 손을 자유롭게 쓰는 데 유용합니다."}, {"name": "검은 코팅 반지", "desc": "평범한 구리 반지에 검은 칠을 덧입혔습니다. 빛을 반사하지 않아 밤에 움직일 때 눈에 띄지 않으며, 아주 미미한 물리 방어력을 제공합니다."}], "Necklace": [{"name": "낡은 목걸이", "desc": "오랜 세월을 버틴 평범한 구슬 목걸이입니다. 마력은 거의 없지만, 착용자의 목을 따뜻하게 보호하여 감기 예방에 아주 미미한 도움을 줍니다."}, {"name": "작은 부적", "desc": "마을 무당이 써준 소박한 종이 부적입니다. 귀신이나 하급 언데드들이 착용자를 보고 기분 나빠하며 접근하지 않게 하는 소소한 효과가 있습니다."}, {"name": "피 묻은 펜던트", "desc": "주인을 알 수 없는 피가 말라붙어 있습니다. 기분 나쁜 기운을 풍기지만, 착용자의 투쟁심을 자극하여 근력을 약간 향상시킵니다."}, {"name": "검은 실 목걸이", "desc": "질긴 검은 실에 작은 쇳조각을 매달았습니다. 장식적 가치는 없지만, 끊어지지 않는 끈질긴 생명력을 상징하는 초보 모험가들의 흔한 장신구입니다."}, {"name": "수정 파편 목걸이", "desc": "빛을 받으면 영롱하게 빛나는 작은 수정 조각입니다. 동굴이나 어두운 곳에서 미미한 빛을 내어 시야 확보를 돕는 초보 정찰병의 장비입니다."}, {"name": "동전 목걸이", "desc": "가운데 구멍이 뚫린 고대의 동전을 꿰었습니다. 행운을 불러온다는 속설 덕분에 상점에서 물건을 살 때 아주 약간의 할인을 받을 수도 있습니다."}, {"name": "탄피 목걸이", "desc": "자신을 죽일 뻔했던 총알의 탄피를 기념으로 걸었습니다. 행운의 부적 역할을 하며, 투사체에 의한 피해를 아주 미미하게 줄여줍니다."}, {"name": "열쇠 펜던트", "desc": "어디에 쓰는지 모를 평범한 무쇠 열쇠입니다. 하지만 던전 곳곳에 숨겨진 '하급 보급 상자'를 여는 데 사용될 수 있어 뜻밖의 횡재를 가져다주기도 합니다."}, {"name": "부러진 나침반 목걸이", "desc": "바늘이 멋대로 돌아가는 고장 난 나침반입니다. 방향을 찾는 데는 쓸모없지만, 마력이 폭주하는 구역에 들어가면 바늘이 격렬하게 반응하여 위험을 경고합니다."}, {"name": "말린 꽃 부적", "desc": "소중한 사람이 전해준 꽃을 정성껏 말려 넣었습니다. 심리적인 안정감을 주며, 자연 계열 몬스터들이 착용자를 선제 공격할 확률을 조금 낮춰줍니다."}, {"name": "쇠사슬 펜던트", "desc": "단단한 쇠사슬 고리 하나를 매달았습니다. 단순하지만 무거운 무게감이 착용자에게 평정심을 유지하게 하며, 아주 약간의 물리 방어력을 더해줍니다."}, {"name": "병뚜껑 목걸이", "desc": "버려진 음료 병뚜껑을 펴서 만든 조잡한 장신구입니다. 가치는 없지만 빛을 반사해 신호를 보내거나, 심심할 때 만지작거리며 지루함을 달래기에 좋습니다."}, {"name": "깃털 장식 목걸이", "desc": "야생 조류의 깃털을 엮어 만들었습니다. 몸을 가볍게 해주는 미미한 바람의 가호가 깃들어 있어, 이동 중 스태미나 소모를 약간 줄여줍니다."}, {"name": "유리병 병목 펜던트", "desc": "깨진 술병의 목 부분을 갈아 목걸이로 만들었습니다. 날카로운 단면을 이용해 비상시 밧줄을 끊거나 근접전에서 허점을 찌르는 용도로 사용됩니다."}, {"name": "낡은 표찰", "desc": "글자가 지워져 알아볼 수 없는 금속 판입니다. 누군가의 이름이었을 이 표찰은 정체 모를 용기를 주며, 초반부의 낮은 물리 방어력을 보강해 줍니다."}]};

        // 에픽/유니크/레전더리/데모닉/엔젤릭 네임드 풀(전역)
        const WORLD_NAMED_ITEMS = {"epic": [{"name": "잿빛 방진면", "slot": "Helmet", "desc": "영원히 재가 내리는 잿빛 대륙의 생존자들이 사용하던 장비입니다. 필터에는 허무의 정수가 응축되어 있어, 착용자의 감정을 지우고 오직 생존만을 위한 차가운 기계적 판단을 돕습니다."}, {"name": "찢어진 서약의 투구", "slot": "Helmet", "desc": "한때는 형제애의 상징이었으나 이제는 날카롭게 찢겨나간 투구입니다. 투구 조각마다 서린 서글픈 마력은 착용자가 공격받을 때마다 과거의 기억을 환영으로 보여주며 투지를 꺾어버립니다."}, {"name": "황혼의 야전도", "slot": "Sword", "desc": "해 질 녘의 기운이 깃든 야전도입니다. 낮과 밤이 교차하는 시간에 가장 강력한 위력을 발휘하며, 적의 시야를 어둡게 만드는 황혼의 장막을 형성합니다."}, {"name": "균형의 세이버", "slot": "Sword", "desc": "공격과 방어의 완벽한 조화를 추구하는 검입니다. 이 검을 든 자는 적의 공격을 튕겨냄과 동시에 즉각적인 반격을 가할 수 있는 마법적인 가속도를 얻게 됩니다."}, {"name": "꿰맨 방탄 외투", "slot": "Armor", "desc": "수많은 총탄 자국을 특수 합금 실로 기워 만든 외투입니다. '살아남은 자'의 상징과도 같으며, 덧댄 조각마다 죽음을 비껴간 강인한 운명의 마력이 깃들어 있습니다."}, {"name": "조용한 쇠사슬 갑옷", "slot": "Armor", "desc": "고리 하나하나를 소음을 흡수하는 가죽으로 감싼 쇠사슬 갑옷입니다. 금속 특유의 챙그랑거리는 소리가 전혀 발생하지 않아, 중무장을 하고서도 도둑처럼 은밀하게 움직일 수 있습니다."}, {"name": "집중의 손싸개", "slot": "Gloves", "desc": "오로지 주먹 하나에 모든 인생을 건 격투가의 낡은 손싸개입니다. 불필요한 장식을 배제하고 오직 타격의 집중력을 높이는 데만 집중되어 있어, 일격에 모든 마력을 쏟아붓게 합니다."}, {"name": "연마된 장갑 ‘정밀’", "slot": "Gloves", "desc": "표면을 특수 연마하여 마찰계수를 제로에 가깝게 만들었습니다. 무기를 휘두르는 공기 저항마저 최소화하여, 착용자의 공격 속도를 극한까지 끌어올리는 효과가 있습니다."}, {"name": "흔적 없는 부츠", "slot": "Boots", "desc": "물리적 흔적뿐만 아니라 마력의 잔재, 심지어는 공기의 떨림까지도 억제합니다. 당신이 지나간 자리는 마치 아무도 없었던 것처럼 완벽하게 정적만이 감돌게 됩니다."}, {"name": "하프스텝 장화", "slot": "Boots", "desc": "현실의 공간을 반 걸음(Half-step) 정도 건너뛰어 이동합니다. 적의 눈에는 당신이 끊기듯 움직이는 것처럼 보여 공격 타이밍을 잡기 매우 까다롭게 만듭니다."}, {"name": "봉인 흉터 반지", "slot": "Ring", "desc": "과거에 걸렸던 강력한 저주가 정화된 후 남은 흉터를 반지의 형태로 고정했습니다. 유사한 저주가 들어왔을 때 이미 있는 흉터가 그 저주를 흡수하여 무효화해 줍니다."}, {"name": "주사위 눈 반지", "slot": "Ring", "desc": "반지 표면에 1부터 6까지의 눈이 새겨져 있습니다. 착용자의 행운 수치를 고정하여 불운한 상황에서도 평균 이상의 결과를 얻게 해주는 확률 보정용 반지입니다."}, {"name": "전언자의 펜던트", "slot": "Necklace", "desc": "먼 거리에 있는 아군과 텔레파시로 대화할 수 있게 합니다. 전장의 상황을 실시간으로 공유하여 파티원들 간의 연계 공격 성공률을 비약적으로 높여줍니다."}, {"name": "등짐꾼의 부적", "slot": "Necklace", "desc": "무거운 짐을 지고 산맥을 넘던 이들의 기도가 담겨 있습니다. 착용자가 소지할 수 있는 아이템의 무게 한도를 크게 늘려주며, 무게로 인한 속도 저하를 완화합니다."}], "unique": [{"name": "균열의 단두검", "slot": "Sword", "desc": "공간의 틈새를 베어 넘기는 기괴한 대검입니다. 휘두를 때마다 아주 작은 차원의 균열을 발생시켜 적의 방어력을 무시하고 영혼에 직접적인 상처를 남깁니다."}, {"name": "모서리 없는 약속검", "slot": "Sword", "desc": "날이 서 있지 않은 뭉툭한 검이지만, 착용자의 '약속'의 힘에 의해 타격 지점에 폭발적인 물리 압력을 가합니다. 살생을 피하면서도 적을 완벽히 제압할 수 있습니다."}, {"name": "길잃은 레이피어", "slot": "Sword", "desc": "주인을 잃고 전장을 떠돌던 검의 원념이 서려 있습니다. 공격 방향을 예측하기 힘들게 만드는 환영 잔상을 남기며, 적의 감각을 교란하여 명중률을 높입니다."}, {"name": "이단의 면갑", "slot": "Helmet", "desc": "성소에서 쫓겨난 자들이 자신들의 신념을 지키기 위해 금속으로 얼굴을 봉인한 형태입니다. 면갑에 새겨진 이단의 문양은 정통 신성 마법에 대한 강력한 저항력을 지닙니다."}, {"name": "잔혹한 흉터 투구", "slot": "Helmet", "desc": "착용자의 얼굴에 지워지지 않는 흉터를 남기며 장착되는 저주받은 장비입니다. 고통은 곧 힘이 되고, 착용자가 흘리는 피는 투구의 마력을 증폭시켜 전장을 피로 물들이게 합니다."}, {"name": "검은 숨의 후드", "slot": "Helmet", "desc": "그림자의 정수를 실로 뽑아 직조한 후드입니다. 착용자의 얼굴은 물리적인 빛을 거부하는 심연의 구멍처럼 변하며, 그 안에서는 오직 안광만이 서늘하게 번뜩입니다."}, {"name": "무쇠의 흉갑", "slot": "Armor", "desc": "순수한 무쇠만을 수만 번 두드려 만든 극도의 견고함을 자랑합니다. 마법적인 기능은 없으나, 오로지 물리적인 힘만으로 세상의 모든 파괴적인 충격을 정면에서 받아내도록 설계되었습니다."}, {"name": "떠돌이의 판금", "slot": "Armor", "desc": "대륙 곳곳을 방랑하던 용사의 흉갑입니다. 각 지역에서 덧붙여진 보강판들은 저마다 다른 마법 저항력을 지니고 있어, 다양한 환경의 위협으로부터 착용자를 보호합니다."}, {"name": "교단 파손 코트", "slot": "Armor", "desc": "교단의 엄격한 규율을 상징하던 코트였으나, 모종의 사건으로 처참하게 찢겨나갔습니다. 찢어진 틈새로 새어 나오는 마력은 과거의 영광과 현재의 타락을 동시에 증명합니다."}, {"name": "목표 분쇄자의 장갑", "slot": "Gloves", "desc": "한 번 포착한 목표물이 완전히 파괴될 때까지 장갑의 마력 엔진이 멈추지 않습니다. 압도적인 악력으로 적의 무기를 부러뜨리거나 뼈를 으스러뜨리는 데 특화되어 있습니다."}, {"name": "집요한 포착 장갑", "slot": "Gloves", "desc": "한 번이라도 만졌던 물체나 생명체의 잔류 기운을 끝까지 추적합니다. 아무리 멀리 도망쳐도 손끝이 느끼는 가느다란 운명의 실을 따라 적의 위치를 찾아낼 수 있습니다."}, {"name": "손끝의 나침반", "slot": "Gloves", "desc": "손가락 끝에 미세한 자기장 감지 장치가 내장되어 있습니다. 어둠 속이나 길을 잃은 미로에서도 방향을 잃지 않게 해주며, 보이지 않는 적의 위치를 감각적으로 잡아냅니다."}, {"name": "도주자의 장화", "slot": "Boots", "desc": "절체절명의 위기 상황에서 착용자의 아드레날린에 반응합니다. 도망쳐야 할 방향으로 발을 강제로 이끌며, 추격자와의 거리가 멀어질수록 이동 속도가 비약적으로 상승합니다."}, {"name": "비밀통로 장화", "slot": "Boots", "desc": "벽이나 막다른 길에 발을 대면 숨겨진 통로나 기믹을 감지하여 진동합니다. 던전 탐색 시 보물 창고나 탈출구를 찾는 데 결정적인 단서를 제공합니다."}, {"name": "후퇴의 신발", "slot": "Boots", "desc": "뒷걸음질 칠 때의 속도가 앞으로 달릴 때보다 빨라지는 기묘한 장화입니다. 적을 정면으로 주시하면서도 안전하게 거리를 벌려야 하는 원거리 딜러들에게 최고의 생존 도구입니다."}, {"name": "봉인된 인장반지", "slot": "Ring", "desc": "두꺼운 마력 사슬이 반지를 감싸고 있어 진정한 힘이 가려져 있습니다. 특정 조건을 만족하여 봉인을 해제할 때마다 감춰진 속성 마법이 하나씩 깨어납니다."}, {"name": "거짓맹세의 반지", "slot": "Ring", "desc": "겉으로는 화려하게 빛나지만 속은 비어있는 기만의 반지입니다. 타인과의 계약이나 맹세를 파기했을 때 돌아오는 대가를 무효화해주며, 착용자의 거짓말을 진실처럼 들리게 만드는 마력이 깃들어 있습니다."}, {"name": "진홍의 루비 반지", "slot": "Ring", "desc": "타오르는 불꽃의 마력을 간직한 루비가 박혀 있습니다. 화염 마법의 위력을 강화하며, 추운 지형에서도 착용자의 체온을 따뜻하게 유지해 주는 가호가 있습니다."}, {"name": "천칭의 목걸이", "slot": "Necklace", "desc": "절대적인 중립과 균형을 수호합니다. 적과의 능력치 차이가 클수록 그 간극을 메우는 보정치를 제공하며, 모든 확률형 공격을 평균값으로 수렴시키는 공정함을 강제합니다."}, {"name": "부러진 저울추 펜던트", "slot": "Necklace", "desc": "균형을 잃은 정의를 상징합니다. 자신보다 강한 적을 상대할 때 부족한 만큼의 능력치를 보정해 주는 역전의 기능을 가지고 있습니다."}, {"name": "기억의 실 목걸이", "slot": "Necklace", "desc": "잊고 싶지 않은 소중한 기억을 마법적인 실로 꼬아 만들었습니다. 정신 혼란이나 기억 상실 계열의 상태 이상에 완전한 면역을 제공하며, 착용자의 집중력을 최고조로 유지합니다."}], "legendary": [{"name": "단결의 파쇄검", "slot": "Sword", "desc": "혼자보다 여럿이 함께할 때 진가를 발휘합니다. 주변 아군의 수에 비례하여 검의 파괴력이 기하급수적으로 상승하며, 진형을 무너뜨리는 강력한 충격파를 발산합니다."}, {"name": "단죄의 대검", "slot": "Sword", "desc": "죄가 무거운 자일수록 이 검의 무게는 가벼워지고 위력은 강해집니다. 악한 의지를 가진 적을 단죄할 때 신적인 심판의 낙인을 찍어 소멸시킵니다."}, {"name": "진실 절단검", "slot": "Sword", "desc": "모든 거짓과 위선을 베어내어 본질을 드러냅니다. 은신한 적을 강제로 노출시키며, 적의 허상을 무시하고 본체에만 모든 피해를 집중시킵니다."}, {"name": "침묵의 가면", "slot": "Helmet", "desc": "이 가면을 쓰는 순간, 세상의 모든 소리는 사라지고 완벽한 무음의 세계가 펼쳐집니다. 소음이라는 방해 요소가 사라진 상태에서 착용자의 감각은 극도로 예민해져, 공기의 미세한 흐름조차 감지합니다."}, {"name": "불굴의 투구", "slot": "Helmet", "desc": "산맥의 심장에서 캐낸 강철로 제련된 이 투구는 어떤 충격에도 찌그러지지 않습니다. 투구에 깃든 영혼은 착용자가 치명적인 상처를 입어도 마지막 순간까지 의식을 붙들 수 있도록 강제합니다."}, {"name": "재단사의 방진면", "slot": "Helmet", "desc": "차원의 틈새를 기워 누더기 세계를 만드는 '재단사'의 도구입니다. 현실 세계의 물리 법칙이 통하지 않는 미세한 차원 먼지를 차단하며, 착용자의 존재를 인과율의 궤도 밖으로 격리합니다."}, {"name": "철벽의 갑주", "slot": "Armor", "desc": "결코 무너지지 않았던 난공불락의 요새, 그 심장부의 주춧돌을 깎아 만들었습니다. 이 갑주를 입은 자는 대지에 뿌리를 내린 산맥과 같아져, 어떤 거대한 충격에도 뒤로 밀려나지 않는 부동의 자세를 유지합니다."}, {"name": "전장의 장막 갑주", "slot": "Armor", "desc": "수많은 병사가 흘린 피와 눈물이 만들어낸 전장의 안개를 형상화했습니다. 갑주 주변에는 쓰러져간 영혼들의 사념이 장막이 되어 흐르며, 착용자를 향한 적의 살의를 대신 받아냅니다."}, {"name": "무너진 성채 코트", "slot": "Armor", "desc": "함락당한 왕국의 성문을 녹여 만든 코트입니다. 한 국가를 지키려 했던 거대한 의지가 깃들어 있어, 착용자가 쓰러지려 할 때마다 성벽과 같은 견고한 힘으로 몸을 지탱해 줍니다."}, {"name": "완벽주의자의 장갑", "slot": "Gloves", "desc": "한 치의 틈이나 흠집조차 허용하지 않는 완벽한 이들이 만든 걸작입니다. 장갑 자체가 하나의 지능을 가진 듯 착용자의 가장 효율적인 동작을 유도하여, 전장에서 낭비되는 움직임을 완전히 없앱니다."}, {"name": "절대조준 건틀릿", "slot": "Gloves", "desc": "인과율을 계산하여 공격이 반드시 명중하는 미래를 보여줍니다. 이 장갑을 낀 채 던지는 단검이나 쏘는 화살은 바람의 방해조차 무시하고 적의 숨통으로 빨려 들어갑니다."}, {"name": "무결의 장갑", "slot": "Gloves", "desc": "단 한 점의 오염도 허용하지 않는 무결한 백색의 장갑입니다. 착용자의 행동에 도덕적 결함이 없을 때 가장 빛을 발하며, 악한 기운을 만지는 것만으로도 정화의 화염을 일으킵니다."}, {"name": "그림자 밟는 장화", "slot": "Boots", "desc": "자신의 그림자를 딛고 허공을 도약할 수 있는 신비로운 기능을 갖췄습니다. 물리적인 지형지물을 무시하고 그림자가 닿는 곳이라면 어디든 순식간에 이동할 수 있는 암살자의 필수품입니다."}, {"name": "망각의 행보", "slot": "Boots", "desc": "이 장화를 신고 걸으면 세상이 당신의 발자국을 기억하지 못합니다. 소리도, 흔적도, 심지어 당신이 그곳을 지나갔다는 사실조차 사람들의 기억 속에서 지워버리는 은밀함의 정점입니다."}, {"name": "역행의 장화", "slot": "Boots", "desc": "시간의 흐름을 거스르는 기묘한 마력이 깃들어 있습니다. 착용자가 밟은 위치를 기억했다가, 위기의 순간 몇 초 전의 위치로 신체를 강제로 되돌리는 기적을 일으킵니다."}, {"name": "기만의 반지", "slot": "Ring", "desc": "보는 사람마다 반지의 형태가 다르게 보이는 환각을 일으킵니다. 착용자의 존재 자체를 주변 풍경에 녹여내어 완벽한 은신을 돕고, 적의 감각을 교란하여 헛것을 공격하게 만듭니다."}, {"name": "확률도둑의 반지", "slot": "Ring", "desc": "상대방에게 올 행운을 강제로 빼앗아 자신에게 가져옵니다. 적의 공격은 계속해서 빗나가고, 당신의 모든 행동은 기막힌 우연이 겹쳐 성공하게 만드는 인과율 조작 장치입니다."}, {"name": "틈새의 성환", "slot": "Ring", "desc": "차원과 차원 사이의 틈새를 움켜쥐고 있습니다. 공격을 받을 때 짧은 순간 차원을 이동하여 무적 상태가 되거나, 적의 뒤편 공간으로 전이하여 기습하는 공간 마법에 특화되어 있습니다."}, {"name": "기도문의 목걸이", "slot": "Necklace", "desc": "성자가 평생을 바쳐 읊조린 기도문이 금속판에 미세하게 새겨져 있습니다. 착용자가 위기에 처할 때마다 자동으로 보호막을 생성하며, 신의 가호가 항상 함께하고 있음을 느끼게 합니다."}, {"name": "서약의 묵주", "slot": "Necklace", "desc": "결코 깨뜨릴 수 없는 서약의 힘이 알 하나하나에 깃들어 있습니다. 한 번 지정한 목표를 쓰러뜨릴 때까지 모든 능력치가 점진적으로 상승하며, 서약을 지켰을 때 신적인 보상을 내립니다."}, {"name": "마지막 숨 펜던트", "slot": "Necklace", "desc": "생의 마지막 순간에 내뱉은 숨결을 유리 병에 담았습니다. 착용자의 생명력이 바닥났을 때, 담겨있던 숨결이 몸 안으로 스며들어 잠시 동안 무적 상태로 전투를 지속하게 합니다."}], "demonic": [{"name": "심연의 고리", "slot": "Ring", "desc": "끝을 알 수 없는 심연의 구멍이 손가락에 매달려 있는 듯합니다. 주변의 모든 마나와 에너지를 무차별적으로 빨아들이며, 응축된 에너지를 한꺼번에 방출하여 모든 것을 파멸시킵니다."}, {"name": "배신의 주사위 반지", "slot": "Ring", "desc": "도박의 악마가 깃든 반지입니다. 매 공격마다 주사위가 굴려지며, 대박이 터지면 적을 즉사시키지만 실패하면 착용자에게 치명적인 역류 피해를 입힙니다."}, {"name": "악몽의 결정 단검", "slot": "Sword", "desc": "공포의 기억을 결정화하여 만들었습니다. 이 단검에 베인 적은 일시적으로 자신이 가장 두려워하는 환각을 보게 되어 전투 불능 상태에 빠집니다."}, {"name": "심연의 독니검", "slot": "Sword", "desc": "심연에 서식하는 괴수의 독을 주입했습니다. 이 독은 신체뿐만 아니라 정신까지 오염시켜, 베인 적이 아군과 적군을 구별하지 못하고 날뛰게 만듭니다."}, {"name": "혈흔의 흉갑", "slot": "Armor", "desc": "단 한 번도 씻겨나가지 않은 신선한 선혈이 덮여 있는 흉갑입니다. 이 피는 착용자의 분노에 반응하여 뜨겁게 달아오르며, 주변의 적들에게 화상을 입히고 광기를 전염시키는 피의 장막을 형성합니다."}, {"name": "붕괴한 성배 갑주", "slot": "Armor", "desc": "성스러운 유물이 오염되어 파괴될 때의 파편들을 모아 만든 갑옷입니다. 신성력을 역전시켜 주변의 모든 생기를 빨아들이는 암흑의 소용돌이를 형성하며, 착용자를 파멸적인 투귀로 변모시킵니다."}, {"name": "속삭이는 데몬 후드", "slot": "Helmet", "desc": "후드의 가느다란 실 하나하나가 악마의 머리카락으로 엮여 있습니다. 밤마다 들려오는 수만 마리 악마들의 속삭임은 착용자에게 금지된 마법을 알려주지만, 그 대가로 정신을 갉아먹습니다."}, {"name": "절규의 건틀릿", "slot": "Gloves", "desc": "장갑 마디마다 박힌 보석들이 전장에서 죽어간 이들의 비명소리를 내뱉습니다. 주먹을 쥘 때마다 증폭되는 소음은 적의 고막을 찢고 정신을 마비시키며, 착용자를 광기 어린 전투의 화신으로 만듭니다."}, {"name": "타락한 추락자의 장화", "slot": "Boots", "desc": "천상에서 추락한 자가 지상에 닿는 순간의 충격과 분노가 서려 있습니다. 도약 후 착지할 때 지면에 강력한 충격파를 발생시켜 주변의 모든 것을 파괴합니다."}, {"name": "폐허의 목걸이", "slot": "Necklace", "desc": "멸망한 왕국의 잔해에서 발견되었습니다. 건물이나 구조물에 가하는 피해를 수십 배로 증폭시키며, 착용자가 지나가는 곳마다 지형을 붕괴시키는 파괴의 권능을 가집니다."}, {"name": "현실 도피의 인장", "slot": "Ring", "desc": "고통스러운 현실을 잊게 하는 환각의 세계로 착용자를 안내합니다. 육체는 전장에 있지만 정신은 평온한 꿈속에 있게 하여 공포와 고통을 전혀 느끼지 못하게 합니다."}, {"name": "어둠의 질주의 주술 장화", "slot": "Boots", "desc": "악마의 가죽을 주술로 엮어 만들었습니다. 질주 시 발 뒤편으로 검은 화염이 치솟으며, 그 화염에 닿는 모든 것을 태우고 착용자의 속도를 한계치 이상으로 가속시킵니다."}, {"name": "회피의 손끝", "slot": "Gloves", "desc": "공격이 닿기 직전 공간을 미세하게 비틉니다. 적의 무기가 손을 관통하는 것처럼 보이지만 실제로는 차원의 틈새로 흘려보내며, 닿을 수 없는 신기루와 같은 존재감을 부여합니다."}, {"name": "심야의 흉터가면", "slot": "Helmet", "desc": "가면의 표면에는 깊게 팬 흉터들이 살아있는 것처럼 꿈틀거립니다. 이 흉터들은 착용자가 입은 피해를 기억하고 증폭시켜 적에게 되돌려주는 저주받은 보복의 기운을 담고 있습니다."}, {"name": "추격 불가의 코트", "slot": "Armor", "desc": "지옥의 사냥개들조차 냄새를 맡지 못한다는 저주받은 코트입니다. 인과율의 실타래에서 착용자의 자취를 지워버리며, 당신을 쫓는 자들은 결국 방향 감각을 잃고 영원한 미로 속을 헤매게 됩니다."}, {"name": "어둠의 서약 목걸이", "slot": "Necklace", "desc": "영혼의 일부를 어둠에 내주고 그림자를 다루는 능력을 얻습니다. 자신의 그림자를 실체화하여 함께 싸우게 하거나, 그림자 속에 숨어 적의 공격을 회피할 수 있습니다."}, {"name": "야행의 서약 펜던트", "slot": "Necklace", "desc": "어둠 속에서만 진정한 힘을 발휘하겠다는 악마와의 약속입니다. 햇빛 아래서는 아무런 힘이 없지만, 밤이 되거나 그림자 속으로 들어가면 모든 속도가 비약적으로 상승합니다."}], "angelic": [{"name": "세인트 홀릭 성환", "slot": "Ring", "desc": "성스러움에 중독될 정도의 강력한 신성력을 방출합니다. 착용자를 경건한 광휘로 감싸며, 주변 아군들의 모든 능력치를 대폭 상승시키고 도덕적 공포를 완전히 제거합니다."}, {"name": "가브리엘의 영원한 자애의 반지", "slot": "Ring", "desc": "천상의 사랑을 형상화한 듯한 눈부신 광채의 반지입니다. 이 반지를 낀 손이 만지는 모든 생명체는 고통에서 해방되며, 죽음의 문턱에 선 영혼조차 자애로운 빛으로 다시 불러세웁니다."}, {"name": "찬가의 목걸이", "slot": "Necklace", "desc": "천사들의 합창 소리가 상시 울려 퍼지는 신비로운 목걸이입니다. 착용자 주변의 공기 자체가 성역(Holy Ground)으로 판정되어, 악한 존재는 발을 들이는 것만으로도 타 죽게 됩니다."}, {"name": "평온의 펜던트", "slot": "Necklace", "desc": "그 어떤 폭풍 속에서도 흔들리지 않는 마음을 줍니다. 모든 정신 지배, 공포, 도발 상태 이상에 완전 면역이 되며, 착용자의 마력 회복 속도를 평화롭게 안정시킵니다."}, {"name": "창천의 푸르름", "slot": "Helmet", "desc": "가장 높은 하늘의 색을 그대로 담아낸 투구입니다. 이를 쓰면 지상의 중력으로부터 해방된 듯 신체가 가벼워지며, 착용자의 마음속에 서린 모든 불안과 증오를 맑은 공기처럼 씻어내 줍니다."}, {"name": "기적의 가브리엘 면갑", "slot": "Helmet", "desc": "천상의 대장간에서 신성한 불꽃으로 벼려진 면갑입니다. 정면을 응시하는 것만으로도 사악한 자들은 자신의 죄악이 불타는 환상에 빠지며, 의로운 자들에게는 결코 무너지지 않는 성벽과 같은 안도감을 선사합니다."}, {"name": "가브리엘의 성스러운 순백의 외투", "slot": "Armor", "desc": "천상의 구름을 자아 만든 듯한 순백의 외투입니다. 이 옷을 걸치는 자는 지상의 오염으로부터 완벽히 보호받으며, 그 존재만으로도 주변의 어둠을 몰아내는 성스러운 등불이 됩니다."}, {"name": "인도자의 새크리파이스 장갑", "slot": "Gloves", "desc": "타인을 위해 자신을 희생할 준비가 된 자만이 그 진정한 힘을 이끌어낼 수 있습니다. 착용자의 생명력을 대가로 아군에게는 무적에 가까운 가호를, 적에게는 거룩한 심판의 낙인을 찍습니다."}, {"name": "헤르메스의 크리스탈 제이드빛 부츠", "slot": "Boots", "desc": "전령의 신 헤르메스의 가호가 깃든 비취색 부츠입니다. 공기를 계단처럼 밟고 하늘로 솟구칠 수 있으며, 세상에서 가장 빠른 존재보다도 한 발짝 더 앞서 나가는 신성을 부여합니다."}, {"name": "가브리엘의 눈부신 맹세의 성검", "slot": "Sword", "desc": "대천사 가브리엘이 직접 하사했다고 전해지는 신성한 검입니다. 검신에서 뿜어져 나오는 성스러운 빛은 어둠을 몰아내며, 사악한 존재를 베를 때마다 신성한 폭발을 일으킵니다."}]};

        
        // ---------------------------------------------
        // 전용 네임드(특정 적 전용 드랍) 풀 (장비패치.txt 9)
        // ---------------------------------------------
        const EXCLUSIVE_NAMED_LABELS = {
          "ryuon": "타락한 용사 류온",
          "luca": "타락한 스나이퍼 루카",
          "ozma": "타락한 마법사 오즈마",
          "taro": "타락한 암살자 타로",
          "gawain": "타락한 성기사 가웨인",
          "aki": "타락한 사냥꾼 아키",
          "hiro": "타락한 첩보원 히로",
          "kai": "흑마법사 카이",
          "jacques": "타락한 바드 자크",
          "cassias": "똥방구 카시아스",
          "masakuni": "검은 민족 마사쿠니",
          "kaito": "검은 민족 카이토",
          "questa": "검은 민족 퀘스타",
          "tetora": "검은 민족 테토라",
          "cain": "방구킹 카인",
          "arthur": "타락한 로드 아서",
          "akito": "대악마 아키토",
          "touya": "대악마 토우야"
        };

        const EXCLUSIVE_NAMED_ITEMS = {
  "ryuon": [
    {
      "name": "피맹세의 결의검",
      "slot": "Sword",
      "minRarity": "unique",
      "maxRarity": "unique",
      "desc": "동료와의 굳은 결의가 담겨 있습니다. 파티원이 위험에 처할수록 검이 붉게 달아오르며, 위기에 빠진 아군을 지키기 위한 수호 마력이 방출됩니다."
    },
    {
      "name": "피맹세 파쇄대검",
      "slot": "Sword",
      "minRarity": "legendary",
      "maxRarity": "legendary",
      "desc": "자신의 피를 대가로 파괴적인 힘을 얻습니다. 현재 체력을 일정량 소모하여 광범위한 지역을 초토화하는 혈액 폭발을 일으키는 무시무시한 대검입니다."
    },
    {
      "name": "배신한 용사의 흉갑",
      "slot": "Armor",
      "minRarity": "epic",
      "maxRarity": "epic",
      "desc": "동료를 버리고 도망친 용사가 입었던 장비입니다. 흉갑 표면에는 지워지지 않는 치욕의 문양이 새겨져 있으며, 착용자에게는 아군의 희생을 대가로 강력한 보호막을 얻는 저주받은 권능을 부여합니다."
    },
    {
      "name": "붉은 서약의 판금",
      "slot": "Armor",
      "minRarity": "legendary",
      "maxRarity": "legendary",
      "desc": "피의 맹세를 나눈 전우들의 갑옷을 녹여 하나로 합쳤습니다. 갑옷에서 배어 나오는 붉은 기운은 착용자의 생명력이 낮아질수록 더욱 단단해지며, 맹세한 바를 이룰 때까지 죽음을 유예시킵니다."
    },
    {
      "name": "맹세의 파편 투구",
      "slot": "Helmet",
      "minRarity": "epic",
      "maxRarity": "epic",
      "desc": "깨진 맹세의 조각들을 억지로 이어 붙인 듯한 형상을 하고 있습니다. 날카로운 금속 모서리가 착용자의 피부를 긁어대지만, 그 자극은 망각해서는 안 될 증오를 상기시킵니다."
    },
    {
      "name": "배반의 면투구",
      "slot": "Helmet",
      "minRarity": "unique",
      "maxRarity": "unique",
      "desc": "전우의 등을 찌른 자가 죽음 직전까지 썼다는 전설이 있습니다. 시야가 좁게 고정되어 앞만을 보게 만들며, 끊임없이 뒤쪽에서 누군가 자신을 노린다는 강박적인 공포를 착용자에게 심어줍니다."
    },
    {
      "name": "결의의 강철장갑",
      "slot": "Gloves",
      "minRarity": "epic",
      "maxRarity": "epic",
      "desc": "수천 번의 망치질로 단련된 강철 장갑입니다. 장갑에 깃든 견고한 결의는 착용자의 손 뼈가 부서지는 한이 있더라도 적의 목을 놓치지 않게 만듭니다."
    },
    {
      "name": "맹세 찢는 손",
      "slot": "Gloves",
      "minRarity": "unique",
      "maxRarity": "unique",
      "desc": "가장 신성한 서약을 배신한 자의 손을 미라화하여 장갑의 소재로 사용했습니다. 장갑에 닿는 모든 성스러운 가호와 맹세의 보호막을 찢어버리는 부정적인 에너지를 내뿜습니다."
    },
    {
      "name": "맹세파기자의 장화",
      "slot": "Boots",
      "minRarity": "rare",
      "maxRarity": "rare",
      "desc": "신뢰를 저버리고 도망친 배신자의 낙인이 찍혀 있습니다. 정의로운 자들의 추격을 피하기 위해 제작되었으며, 정면 승부보다는 비겁한 퇴로를 찾는 데 탁월한 속도를 부여합니다."
    },
    {
      "name": "처형자의 행보",
      "slot": "Boots",
      "minRarity": "epic",
      "maxRarity": "epic",
      "desc": "사형대로 향하는 죄수의 뒤를 따르던 처형자의 신발입니다. 이 발소리를 듣는 타겟은 피할 수 없는 죽음이 다가오고 있음을 직감하며 심한 압박감과 공포를 느끼게 됩니다."
    },
    {
      "name": "피로 물든 서약반지",
      "slot": "Ring",
      "minRarity": "unique",
      "maxRarity": "unique",
      "desc": "피로 맺은 동맹의 증표입니다. 함께 반지를 낀 동료가 근처에 있을 때 서로의 생명력을 공유하거나 능력치를 보완해 주는 유대감의 마력이 깃들어 있습니다."
    },
    {
      "name": "핏빛 계약 성환",
      "slot": "Ring",
      "minRarity": "legendary",
      "maxRarity": "legendary",
      "desc": "자신의 영혼을 담보로 강력한 힘을 빌려옵니다. 계약이 유지되는 동안에는 죽음을 초월한 무력을 발휘하지만, 계약의 대가를 지불하지 못할 경우 영혼이 반지에 귀속됩니다."
    },
    {
      "name": "피의 서약 펜던트",
      "slot": "Necklace",
      "minRarity": "unique",
      "maxRarity": "unique",
      "desc": "자신의 피를 바쳐 강력한 마력을 얻는 서약을 맺습니다. 현재 생명력이 낮을수록 마법 공격력이 기하급수적으로 상승하는 광기의 마력을 선사합니다."
    }
  ],
  "luca": [
    {
      "name": "냉정한 조준 장갑",
      "slot": "Gloves",
      "minRarity": "unique",
      "maxRarity": "unique",
      "desc": "착용자의 맥박을 강제로 늦추고 감각을 차갑게 식힙니다. 극한의 긴장 속에서도 얼음 같은 냉정함을 유지하게 하여, 가장 혼란스러운 순간에도 적의 심장을 정확히 꿰뚫게 합니다."
    },
    {
      "name": "‘무오차’ 건틀릿",
      "slot": "Gloves",
      "minRarity": "legendary",
      "maxRarity": "legendary",
      "desc": "초정밀 자이로스코프와 마력 센서가 내장되어 착용자의 손떨림을 0.001%까지 보정합니다. 이 건틀릿을 낀 손은 운명마저도 한 치의 오차 없이 조준하여 쏘아 맞힐 수 있습니다."
    },
    {
      "name": "저격수의 고글투구",
      "slot": "Helmet",
      "minRarity": "epic",
      "maxRarity": "epic",
      "desc": "초점을 수만 번 조정할 수 있는 다층 렌즈 시스템이 구축되어 있습니다. 수 킬로미터 밖의 심장 박동에 따른 미세한 어깨 떨림까지 포착하여, 단 한 발의 오차도 허용하지 않습니다."
    },
    {
      "name": "한 점 응시의 바이저",
      "slot": "Helmet",
      "minRarity": "unique",
      "maxRarity": "unique",
      "desc": "오직 정면의 목표물만을 위해 모든 신경을 집중시키도록 시야를 극단적으로 제한합니다. 바이저 너머의 대상은 착용자의 세계에서 유일한 실존이 되며, 그 존재가 소멸하기 전까지 추적은 멈추지 않습니다."
    },
    {
      "name": "저격수의 방탄코트",
      "slot": "Armor",
      "minRarity": "unique",
      "maxRarity": "unique",
      "desc": "장거리 사격 시의 미세한 근육 떨림을 잡아주는 보조 장치가 내장되어 있습니다. 가볍고 튼튼한 방탄 섬유는 기동성을 유지하면서도, 예기치 못한 근접전에서의 기습을 훌륭하게 방어해 줍니다."
    },
    {
      "name": "정밀 단검 ‘한 발’",
      "slot": "Sword",
      "minRarity": "epic",
      "maxRarity": "epic",
      "desc": "단 한 번의 완벽한 찌르기를 위해 설계되었습니다. 공격 속도는 느리지만, 적의 방어력을 100% 관통하여 심장을 꿰뚫는 일격필살의 위력을 자랑합니다."
    },
    {
      "name": "결정탄 레이피어 ‘두 번째’",
      "slot": "Sword",
      "minRarity": "unique",
      "maxRarity": "unique",
      "desc": "검신이 마법적인 결정체로 이루어져 있습니다. 찌르기 공격 시 결정 조각이 적의 체내에 박혀 '두 번째' 연쇄 폭발을 일으켜 치명적인 내부 피해를 입힙니다."
    },
    {
      "name": "탄피 꿰맨 목걸이",
      "slot": "Necklace",
      "minRarity": "epic",
      "maxRarity": "epic",
      "desc": "전쟁터에서 수거한 수많은 탄피를 가죽 끈에 꿰었습니다. 사격 시 반동을 억제하는 실전적인 가호가 깃들어 있으며, 총기류 무기의 연사 속도를 상승시킵니다."
    },
    {
      "name": "마지막 탄창 펜던트",
      "slot": "Necklace",
      "minRarity": "unique",
      "maxRarity": "unique",
      "desc": "마지막 한 발이 남은 권총 탄창 모양의 펜던트입니다. 원거리 무기 사용 시 마지막 공격의 위력을 수십 배로 증폭시키며, 탄환을 모두 소모했을 때 즉시 재장전되는 기믹을 가집니다."
    },
    {
      "name": "조준수의 인장",
      "slot": "Ring",
      "minRarity": "epic",
      "maxRarity": "epic",
      "desc": "손끝의 미세한 흔들림을 잡아주는 반전 중력 장치가 들어있습니다. 투척 무기나 활을 사용할 때 사거리를 늘려주며, 조준점이 흐트러지지 않게 고정해 줍니다."
    },
    {
      "name": "감염 해독의 성환",
      "slot": "Ring",
      "minRarity": "legendary",
      "maxRarity": "legendary",
      "desc": "세상의 모든 역병을 빨아들여 정화하는 성스러운 고리입니다. 착용자는 어떤 독이나 질병에도 면역이 되며, 주변에 퍼진 감염의 근원지를 찾아내어 무력화하는 권능을 가집니다."
    },
    {
      "name": "사선(射線)의 장화",
      "slot": "Boots",
      "minRarity": "rare",
      "maxRarity": "rare",
      "desc": "원거리 공격의 궤적을 감지하여 발에 신호를 보냅니다. 화살이나 총탄이 날아오는 방향을 본능적으로 피해 딛게 하여, 빗발치는 포화 속에서도 살아남을 확률을 높여줍니다."
    },
    {
      "name": "무음 이동 장화",
      "slot": "Boots",
      "minRarity": "epic",
      "maxRarity": "epic",
      "desc": "소리를 먹는 마법의 펠트천을 겹겹이 덧대었습니다. 금속 바닥이나 자갈길을 뛰어도 깃털이 떨어지는 소리조차 나지 않아, 은밀한 잠입 작전의 신뢰도를 높여줍니다."
    }
  ],
  "ozma": [
    {
      "name": "힘을 잃은 수정구슬 반지",
      "slot": "Ring",
      "minRarity": "unique",
      "maxRarity": "unique",
      "desc": "한때는 미래를 보여주던 수정구슬이었으나 지금은 마력이 거의 소진되었습니다. 하지만 여전히 위험을 감지하면 희미한 빛을 내어 착용자에게 경고를 보냅니다."
    },
    {
      "name": "허수의 원환",
      "slot": "Ring",
      "minRarity": "legendary",
      "maxRarity": "legendary",
      "desc": "존재하지만 존재하지 않는 '허수'의 마력을 다룹니다. 물리적인 법칙을 무시하는 공격을 가능케 하며, 적의 방어막이나 갑옷을 마치 유령처럼 통과하여 본체에 타격을 입힙니다."
    },
    {
      "name": "잔향의 주문목걸이",
      "slot": "Necklace",
      "minRarity": "unique",
      "maxRarity": "unique",
      "desc": "이미 시전된 마법의 잔향을 붙잡아둡니다. 마법 사용 후 일정 확률로 동일한 마법이 마나 소모 없이 한 번 더 발동되는 '메아리' 현상을 일으킵니다."
    },
    {
      "name": "금지된 주문의 열쇠목걸이",
      "slot": "Necklace",
      "minRarity": "legendary",
      "maxRarity": "legendary",
      "desc": "세상을 멸망시킬 수도 있는 금단의 마도서를 여는 유일한 열쇠입니다. 열쇠 자체에 흐르는 고대 마력은 착용자가 사용하는 모든 주문의 소모 마나를 없애고 위력을 한계까지 끌어올립니다."
    },
    {
      "name": "감염된 후드",
      "slot": "Helmet",
      "minRarity": "epic",
      "maxRarity": "epic",
      "desc": "이 후드를 짜낸 실은 살아있는 생물의 힘줄인 것 같습니다. 후드를 쓰면 정체불명의 심장 박동이 관자놀이에서 느껴지며, 억눌린 비명 같은 환청이 끊임없이 고막을 긁어댑니다."
    },
    {
      "name": "해독 불가의 가면",
      "slot": "Helmet",
      "minRarity": "unique",
      "maxRarity": "unique",
      "desc": "표면의 기하학적 문양들이 초당 수천 번씩 위치를 바꾸며 보는 이의 시각 정보를 교란합니다. 누구도 이 가면 뒤의 인물을 정의하거나 기억할 수 없으며, 당신은 오직 '해석되지 않는 존재'로 남습니다."
    },
    {
      "name": "연금술 방진 로브",
      "slot": "Armor",
      "minRarity": "epic",
      "maxRarity": "epic",
      "desc": "위험한 시약을 다루는 연금술사들이 입는 코트입니다. 특수 코팅된 원단은 화학적 부식과 마법 폭발로부터 착용자를 보호하며, 주머니 속의 마법 재료들이 안정적으로 유지되도록 돕습니다."
    },
    {
      "name": "주문자의 장갑",
      "slot": "Gloves",
      "minRarity": "rare",
      "maxRarity": "rare",
      "desc": "마력을 전도하는 특수 금속 실로 짜여 있습니다. 착용자의 마나를 무기로 흘려보내는 효율을 높여주어, 속성 공격의 위력을 증폭시키는 데 특화되어 있습니다."
    },
    {
      "name": "증폭의 장갑",
      "slot": "Gloves",
      "minRarity": "unique",
      "maxRarity": "unique",
      "desc": "손바닥 중앙에 설치된 마력 증폭기가 착용자의 신체 에너지를 수십 배로 튀깁니다. 평범한 펀치조차 거대한 폭발처럼 느껴지게 하는 파괴적인 충격파를 발생시킵니다."
    },
    {
      "name": "연금술사의 부츠",
      "slot": "Boots",
      "minRarity": "rare",
      "maxRarity": "rare",
      "desc": "다양한 약품이 쏟아져도 부식되지 않는 특수 소재입니다. 부츠 옆면에 작은 시약병을 수납할 수 있는 공간이 있어, 전투 중에도 빠르게 물약을 꺼내 사용할 수 있습니다."
    },
    {
      "name": "파열의 레이피어",
      "slot": "Sword",
      "minRarity": "epic",
      "maxRarity": "epic",
      "desc": "찌른 부위를 중심으로 마력의 파동을 일으켜 내부를 파열시킵니다. 갑옷 겉면은 멀쩡해도 내부 장기에 치명적인 충격을 주는 잔인한 무기입니다."
    },
    {
      "name": "기호(符號) 절단검",
      "slot": "Sword",
      "minRarity": "unique",
      "maxRarity": "unique",
      "desc": "추상적인 개념조차 베어낼 수 있다고 전해집니다. 적에게 걸린 마법적인 버프나 '강화 기호'를 물리적으로 잘라내어 무력화시키는 특수한 능력을 지녔습니다."
    }
  ],
  "taro": [
    {
      "name": "백스텝 장화",
      "slot": "Boots",
      "minRarity": "unique",
      "maxRarity": "unique",
      "desc": "후퇴 시 순간적으로 공간을 압축하여 평소보다 몇 배는 긴 거리를 뒤로 도약하게 합니다. 적의 기습적인 사거리에서 순식간에 벗어나 반격을 준비할 시간을 벌어줍니다."
    },
    {
      "name": "사라짐의 행보",
      "slot": "Boots",
      "minRarity": "legendary",
      "maxRarity": "legendary",
      "desc": "일정 속도 이상으로 달리면 착용자의 모습이 빛의 산란과 함께 투명해집니다. 눈앞에서 적이 사라지는 마술 같은 광경을 선사하며, 추격 불가능한 속도의 영역으로 당신을 인도합니다."
    },
    {
      "name": "그림자꿰매기 단검",
      "slot": "Sword",
      "minRarity": "unique",
      "maxRarity": "unique",
      "desc": "암살자들이 애용하는 검게 그을린 단검입니다. 어둠 속에서 휘두를 때 궤적이 보이지 않으며, 적의 급소를 찌를 경우 그림자가 촉수처럼 튀어나와 적을 압박합니다."
    },
    {
      "name": "그림자 봉합검",
      "slot": "Sword",
      "minRarity": "legendary",
      "maxRarity": "legendary",
      "desc": "적의 그림자를 바닥에 꿰매어 움직임을 봉쇄하는 전설적인 검입니다. 일단 한 번 베이면 육체뿐만 아니라 그림자까지 구속되어 적은 결코 도망칠 수 없게 됩니다."
    },
    {
      "name": "뒷골목 장갑",
      "slot": "Gloves",
      "minRarity": "epic",
      "maxRarity": "epic",
      "desc": "진창 같은 삶 속에서 살아남은 싸움꾼의 지혜가 담겨 있습니다. 손바닥에 납 조각을 덧대어 타격력을 높였으며, 비겁하지만 확실하게 적을 쓰러뜨리는 실전적인 기술이 깃들어 있습니다."
    },
    {
      "name": "무흔의 손",
      "slot": "Gloves",
      "minRarity": "unique",
      "maxRarity": "unique",
      "desc": "착용자의 지문과 흔적을 물리적, 마법적으로 완벽히 지워버립니다. 무엇을 만져도 자취가 남지 않으며, 적에게 가한 상처조차 마치 자연적으로 발생한 것처럼 보이게 만듭니다."
    },
    {
      "name": "검은 두건 ‘침묵’",
      "slot": "Helmet",
      "minRarity": "rare",
      "maxRarity": "rare",
      "desc": "소리를 완벽하게 흡수하는 검은 암영의 천으로 제작되었습니다. 이 두건을 쓰면 주변의 소음이 마치 물속에 잠긴 듯 멀어지며, 오직 자신의 거친 숨소리만이 고요를 가르게 됩니다."
    },
    {
      "name": "무표정의 가면",
      "slot": "Helmet",
      "minRarity": "unique",
      "maxRarity": "unique",
      "desc": "어떤 감정도 읽어낼 수 없는 차가운 무표정의 가면입니다. 착용자의 두려움, 고통, 환희조차도 이 가면 뒤에서는 죽은 듯이 가라앉으며, 오직 효율적인 살육을 위한 냉정함만이 남습니다."
    },
    {
      "name": "흑연 외투",
      "slot": "Armor",
      "minRarity": "epic",
      "maxRarity": "epic",
      "desc": "탄소의 정수를 응축하여 만든 초경량 고강도 외투입니다. 깃털처럼 가볍지만 그 강도는 다이아몬드에 필적하며, 현대 기술과 마법이 결합된 방어구의 정점을 보여줍니다."
    },
    {
      "name": "암살자의 표식반지",
      "slot": "Ring",
      "minRarity": "epic",
      "maxRarity": "epic",
      "desc": "적에게 보이지 않는 마킹을 남깁니다. 표식이 남은 대상은 벽 너머에서도 위치가 파악되며, 다음 공격 시 치명타가 터질 확률이 압도적으로 상승합니다."
    },
    {
      "name": "최후의 암호반지",
      "slot": "Ring",
      "minRarity": "legendary",
      "maxRarity": "legendary",
      "desc": "세상의 종말을 막기 위한 마지막 암호가 새겨져 있습니다. 이 반지를 낀 자는 고대어와 신들의 언어를 이해할 수 있게 되며, 봉인된 신전의 문을 여는 유일한 열쇠가 됩니다."
    },
    {
      "name": "끊어진 쇠사슬 펜던트",
      "slot": "Necklace",
      "minRarity": "epic",
      "maxRarity": "epic",
      "desc": "구속구에서 풀려난 해방의 상징입니다. 착용자를 구속하는 모든 마법적 힘에 대한 저항력을 부여하며, 속박 상태에 빠졌을 때 즉시 탈출할 수 있는 힘을 줍니다."
    },
    {
      "name": "도주로의 지도 펜던트",
      "slot": "Necklace",
      "minRarity": "unique",
      "maxRarity": "unique",
      "desc": "펜던트 내부에 마법적으로 축소된 지도가 들어있습니다. 미궁이나 복잡한 던전에서 출구 방향을 화살표로 알려주며, 퇴로를 확보하는 데 최적화되어 있습니다."
    }
  ],
  "gawain": [
    {
      "name": "성역 파괴자의 판금",
      "slot": "Armor",
      "minRarity": "unique",
      "maxRarity": "unique",
      "desc": "신성한 장소를 짓밟았던 자들의 전리품입니다. 성소의 결계를 무력화하는 부정한 마력이 깃들어 있으며, 신성 계열의 공격을 받을 때 오히려 그 에너지를 흡수하여 자신의 힘으로 치환합니다."
    },
    {
      "name": "속죄 불가의 갑주",
      "slot": "Armor",
      "minRarity": "legendary",
      "maxRarity": "legendary",
      "desc": "평생을 죄악 속에 살았던 자가 죽기 직전까지 입었던 회한의 갑옷입니다. 갑옷의 무게는 착용자가 지은 죄의 무게만큼 무거워지지만, 그 고통을 견디는 자에게는 어떤 공격에도 굴하지 않는 강철의 육체를 선사합니다."
    },
    {
      "name": "찢어진 맹세의 면갑",
      "slot": "Helmet",
      "minRarity": "epic",
      "maxRarity": "epic",
      "desc": "지켜지지 못한 약속이 물리적인 균열이 되어 면갑을 찢어놓았습니다. 그 틈새로 새어 나오는 검은 안개는 배신당한 자의 사무친 원한이며, 적들의 생명력을 갉아먹는 독이 됩니다."
    },
    {
      "name": "순례자의 투구 ‘폐허’",
      "slot": "Helmet",
      "minRarity": "unique",
      "maxRarity": "unique",
      "desc": "멸망한 성지의 잔해로 만들어진 투구입니다. 투구의 틈새로 새어 나오는 빛은 과거의 영광에 대한 애도이며, 착용자에게는 고통 속에서도 꺾이지 않는 고결한 인내심을 부여합니다."
    },
    {
      "name": "성기사의 부러진 성검",
      "slot": "Sword",
      "minRarity": "unique",
      "maxRarity": "unique",
      "desc": "명예로운 전투 중 부러졌지만, 그 숭고한 의지는 사라지지 않았습니다. 부러진 단면 위로 빛의 칼날이 형성되어 원래의 길이보다 더 긴 사거리를 가집니다."
    },
    {
      "name": "성역 절단검",
      "slot": "Sword",
      "minRarity": "legendary",
      "maxRarity": "legendary",
      "desc": "그 어떤 결계나 성역도 무의미하게 만듭니다. 신이 내린 보호구역조차 종잇장처럼 찢어버리며 침입할 수 있는, 신성 모독적인 파괴력을 지닌 검입니다."
    },
    {
      "name": "서약의 장갑",
      "slot": "Gloves",
      "minRarity": "rare",
      "maxRarity": "rare",
      "desc": "전우와 피의 맹세를 나눌 때 착용하던 장갑입니다. 손바닥의 붉은 문양은 위기의 순간 착용자의 악력을 강화하며, 무기를 결코 포기하지 않게 만드는 투지를 부여합니다."
    },
    {
      "name": "심문관의 건틀릿",
      "slot": "Gloves",
      "minRarity": "unique",
      "maxRarity": "unique",
      "desc": "죄인의 침묵을 깨기 위해 고안된 고문 기구와 같은 건틀릿입니다. 손마디마다 돌출된 금속 돌기는 타격 시 신경계에 극심한 고통을 전달하며, 공포를 형상화한 마력을 내뿜습니다."
    },
    {
      "name": "순례자의 장화",
      "slot": "Boots",
      "minRarity": "rare",
      "maxRarity": "rare",
      "desc": "성지를 향해 고난의 길을 걷는 순례자들을 위한 신발입니다. 육체의 피로를 마력으로 치환하여 장거리 여행에도 발의 통증을 느끼지 않게 해주는 축복이 깃들어 있습니다."
    },
    {
      "name": "무너진 성역의 발걸음",
      "slot": "Boots",
      "minRarity": "unique",
      "maxRarity": "unique",
      "desc": "파괴된 신전의 대리석 파편을 밑창에 박아 넣었습니다. 신성함이 타락한 자리에 남은 공허한 힘이 깃들어 있어, 신성 계열의 결계를 깨뜨리고 침입하는 데 특화되어 있습니다."
    },
    {
      "name": "부서진 성인의 인장",
      "slot": "Ring",
      "minRarity": "epic",
      "maxRarity": "epic",
      "desc": "성인이 사용하던 인장이 불경한 힘에 의해 부서졌습니다. 성스러운 빛은 희미해졌지만, 부서진 틈새로 나오는 날카로운 성력이 부정적인 존재들에게는 치명적인 독이 됩니다."
    },
    {
      "name": "잃어버린 성배 부적",
      "slot": "Necklace",
      "minRarity": "epic",
      "maxRarity": "epic",
      "desc": "성배의 파편을 담은 작은 주머니입니다. 매일 아침 깨끗한 물 한 잔을 성스러운 치유약으로 변환시켜 주며, 착용자의 성스러운 마력을 상시 회복시킵니다."
    },
    {
      "name": "파편 성배 펜던트",
      "slot": "Necklace",
      "minRarity": "legendary",
      "maxRarity": "legendary",
      "desc": "부서진 성배의 가장 큰 조각입니다. 착용자의 생명력이 0이 되는 순간, 성배에 담겼던 생명의 물이 쏟아져 나와 착용자를 완벽한 상태로 부활시키고 주위를 정화합니다."
    }
  ],
  "aki": [
    {
      "name": "추적자의 손끝",
      "slot": "Gloves",
      "minRarity": "unique",
      "maxRarity": "unique",
      "desc": "대기의 흐름과 미세한 진동을 감지하는 센서가 손가락 끝에 집중되어 있습니다. 보이지 않는 적이 휘두르는 칼날의 바람조차 읽어내어 완벽한 회피와 반격을 가능케 합니다."
    },
    {
      "name": "‘표적 고정’ 장갑",
      "slot": "Gloves",
      "minRarity": "unique",
      "maxRarity": "unique",
      "desc": "손바닥에 특수 마력 점착 레이저가 장착되어 있습니다. 한 번 무기를 쥐면 절대로 놓치지 않으며, 시야에 들어온 적의 약점을 본능적으로 가리키도록 설계되었습니다."
    },
    {
      "name": "사냥꾼의 독니검",
      "slot": "Sword",
      "minRarity": "epic",
      "maxRarity": "epic",
      "desc": "맹독을 품은 사냥개의 이빨을 검신에 이식했습니다. 베인 적은 즉시 신경이 마비되어 이동 속도가 느려지며, 중독 상태가 중첩될수록 마비 시간이 길어집니다."
    },
    {
      "name": "흉터내는 톱니검",
      "slot": "Sword",
      "minRarity": "unique",
      "maxRarity": "unique",
      "desc": "베인 상처가 결코 아물지 않도록 설계된 거친 톱니날입니다. 치유 마법조차 무시하는 깊은 흉터를 남겨 적의 최대 체력을 지속적으로 감소시킵니다."
    },
    {
      "name": "덫지기의 부츠",
      "slot": "Boots",
      "minRarity": "epic",
      "maxRarity": "epic",
      "desc": "야생의 덫을 감지하는 미세한 진동 센서가 바닥에 내장되어 있습니다. 발을 내딛기 직전 지면의 위협을 미리 알려주며, 함정을 밟더라도 그 충격을 분산시켜 피해를 최소화합니다."
    },
    {
      "name": "발자국 지우는 부츠",
      "slot": "Boots",
      "minRarity": "unique",
      "maxRarity": "unique",
      "desc": "지나간 자리에 남는 물리적인 흔적을 마력이 즉시 지워버립니다. 젖은 땅이나 눈 위를 걸어도 추적자들은 당신의 행방을 찾지 못하고 제자리를 맴돌게 됩니다."
    },
    {
      "name": "사냥 두건",
      "slot": "Helmet",
      "minRarity": "rare",
      "maxRarity": "rare",
      "desc": "자연스러운 나뭇잎 문양과 흙먼지 색이 뒤섞인 은신용 두건입니다. 숲속에서 정지해 있는 착용자를 발견하는 것은 숙련된 사냥꾼에게도 쉽지 않은 일입니다."
    },
    {
      "name": "야시 바이저 ‘추적’",
      "slot": "Helmet",
      "minRarity": "unique",
      "maxRarity": "unique",
      "desc": "특수한 마력 렌즈가 생명체의 생체 에너지를 붉은 안광으로 치환하여 보여줍니다. 아무리 짙은 어둠이나 벽 뒤에 숨어있어도, 당신의 시선으로부터 자유로울 수 있는 생명체는 없습니다."
    },
    {
      "name": "짐승가죽 흉갑",
      "slot": "Armor",
      "minRarity": "epic",
      "maxRarity": "epic",
      "desc": "전설적인 맹수의 가죽을 가공하여 만든 흉갑입니다. 가죽에 남은 짐승의 투쟁 본능은 착용자의 신체 능력을 폭발적으로 끌어올리며, 상처를 입을수록 더욱 흉포한 힘을 내뿜게 합니다."
    },
    {
      "name": "어둠의 독약인장",
      "slot": "Ring",
      "minRarity": "epic",
      "maxRarity": "epic",
      "desc": "반지 내부에 고농축 독약이 들어있으며, 바늘처럼 튀어나와 적에게 주입합니다. 중독된 적은 서서히 감각이 마비되며 어둠 속에서 고통스럽게 죽어갑니다."
    },
    {
      "name": "사냥꾼의 확률표",
      "slot": "Ring",
      "minRarity": "unique",
      "maxRarity": "unique",
      "desc": "적의 약점을 명중시킬 확률을 계산하여 손가락에 진동으로 전달합니다. 사냥감이 도망갈 수 없는 완벽한 사선에 들어왔을 때 반지의 보석이 붉게 점멸합니다."
    },
    {
      "name": "병바닥 침전물 펜던트",
      "slot": "Necklace",
      "minRarity": "unique",
      "maxRarity": "unique",
      "desc": "연금술사의 실험 실패로 만들어진 기묘한 침전물을 가두었습니다. 착용자가 공격받을 때마다 무작위 원소 폭발을 일으켜 주변 적들에게 예상치 못한 피해를 입힙니다. "
    },
    {
      "name": "해골 부적 ‘표적’",
      "slot": "Necklace",
      "minRarity": "legendary",
      "maxRarity": "legendary",
      "desc": "죽음의 신이 찍은 표적입니다. 이 부적이 가리키는 대상은 세상 그 어디에 숨어도 반드시 찾아내게 되며, 표적에게 가하는 첫 번째 공격은 반드시 치명타로 적중합니다."
    }
  ],
  "hiro": [
    {
      "name": "암호화된 인장반지",
      "slot": "Ring",
      "minRarity": "unique",
      "maxRarity": "unique",
      "desc": "표면의 문양이 계속해서 변하며 정보를 암호화합니다. 도청이나 정신 지배 계열의 마법으로부터 착용자의 사고를 보호하며, 비밀 메시지를 안전하게 전달하는 용도로 쓰입니다."
    },
    {
      "name": "저주 해독의 성환",
      "slot": "Ring",
      "minRarity": "legendary",
      "maxRarity": "legendary",
      "desc": "이미 몸에 박힌 고대의 저주조차 뽑아내어 정화하는 기적의 고리입니다. 반지가 저주를 대신 짊어지며 금이 가지만, 착용자의 영혼만큼은 언제나 순결하게 보존합니다."
    },
    {
      "name": "잠입 장화 ‘노이즈’",
      "slot": "Boots",
      "minRarity": "epic",
      "maxRarity": "epic",
      "desc": "특수한 소음 발생 장치가 내장되어 있어, 실제 위치와 다른 방향에서 발소리가 들리도록 적의 청각을 기만합니다. 혼란에 빠진 적들의 등 뒤를 노리기에 최적입니다."
    },
    {
      "name": "탈출 코드 장화",
      "slot": "Boots",
      "minRarity": "unique",
      "maxRarity": "unique",
      "desc": "감옥이나 봉인 구역의 문을 여는 마법 코트가 밑창에 새겨져 있습니다. 굳게 닫힌 문도 이 신발로 걷어차는 것만으로도 보안을 해제하고 탈출할 수 있게 돕습니다."
    },
    {
      "name": "교란 장갑",
      "slot": "Gloves",
      "minRarity": "epic",
      "maxRarity": "epic",
      "desc": "손을 움직일 때마다 빛의 굴절을 조작하여 잔상을 남깁니다. 적은 당신이 뻗은 손의 실제 위치를 파악하지 못해 허공을 휘두르게 되며, 당신은 그 틈을 타 치명적인 일격을 날립니다."
    },
    {
      "name": "무음 타이핑 장갑",
      "slot": "Gloves",
      "minRarity": "unique",
      "maxRarity": "unique",
      "desc": "정보전의 귀재들이 사용하던 특수 장갑입니다. 어떤 소리도 내지 않고 기계 장치를 조작할 수 있으며, 손끝의 마력 신호를 통해 복잡한 시스템을 눈 깜짝할 새에 해킹합니다."
    },
    {
      "name": "무전 헤드셋 투구",
      "slot": "Helmet",
      "minRarity": "rare",
      "maxRarity": "rare",
      "desc": "먼 곳의 소리를 잡아내는 마력 증폭 장치가 내장되어 있습니다. 치직거리는 잡음 사이로 가끔 들려오는 과거의 교신 기록은, 이 장비가 얼마나 많은 전장을 전전해 왔는지를 보여줍니다."
    },
    {
      "name": "전자전 헬멧 ‘재밍’",
      "slot": "Helmet",
      "minRarity": "unique",
      "maxRarity": "unique",
      "desc": "끊임없이 변화하는 복잡한 수열과 신호가 헬멧 표면을 흐르고 있습니다. 기계 지능의 연산을 방해하고 탐지 레이더상에서 착용자를 노이즈로 처리하여, 금속의 눈으로부터 자유로워집니다."
    },
    {
      "name": "잡음 속 호출부호 목걸이",
      "slot": "Necklace",
      "minRarity": "unique",
      "maxRarity": "unique",
      "desc": "끊임없는 노이즈 속에서 아군의 신호를 찾아냅니다. 은신하거나 변장한 적의 위장 신호를 간파하여 본래의 위치를 드러내게 만드는 탐지 전용 목걸이입니다."
    },
    {
      "name": "암호키 펜던트",
      "slot": "Necklace",
      "minRarity": "legendary",
      "maxRarity": "legendary",
      "desc": "세상의 모든 기계와 통신망을 해킹할 수 있는 마스터 코드입니다. 기계 몬스터를 조종하거나 고대의 병기를 기동시키는 등, 기술과 마법이 접목된 구역에서 신적인 권능을 발휘합니다."
    },
    {
      "name": "방탄 외투 ‘불완전’",
      "slot": "Armor",
      "minRarity": "epic",
      "maxRarity": "epic",
      "desc": "최첨단 방탄 소재를 사용하려 했으나 제작 과정에서 예기치 못한 사고로 마력이 뒤섞인 외투입니다. 방어력은 불안정하지만, 때때로 물리 법칙을 무시하고 모든 공격을 무효화하는 기적을 보여줍니다."
    },
    {
      "name": "위장 코트 ‘스위치’",
      "slot": "Armor",
      "minRarity": "unique",
      "maxRarity": "unique",
      "desc": "주변 환경의 색상과 질감을 실시간으로 복제하여 투사하는 광학 미채 코트입니다. 스위치를 켜는 순간 당신은 풍경의 일부가 되며, 적들은 당신이 바로 앞에 있음을 인지하지 못한 채 죽음을 맞이합니다."
    },
    {
      "name": "은닉 칼날 ‘폴딩’",
      "slot": "Sword",
      "minRarity": "unique",
      "maxRarity": "unique",
      "desc": "평상시에는 작은 금속 막대 같지만, 버튼을 누르는 순간 날카로운 칼날이 튀어나옵니다. 기습 공격 시 첫 타격의 위력이 엄청나게 증폭되는 암기형 무기입니다."
    }
  ],
  "kai": [
    {
      "name": "탐욕의 흑서 펜던트",
      "slot": "Necklace",
      "minRarity": "unique",
      "maxRarity": "unique",
      "desc": "재물에 대한 끝없는 탐욕이 담긴 작은 책 모양 펜던트입니다. 몬스터 처치 시 드랍되는 금화의 양을 늘려주며, 가끔씩 주변의 숨겨진 보물 상자의 위치를 속삭여줍니다."
    },
    {
      "name": "봉인 해제의 열쇠목걸이",
      "slot": "Necklace",
      "minRarity": "legendary",
      "maxRarity": "legendary",
      "desc": "그 어떤 마법적, 물리적 자물쇠도 단 한 번의 터치로 열 수 있습니다. 잠긴 보물 상자뿐만 아니라 적의 방어 태세조차 강제로 해제해 버리는 절대적인 '개방'의 힘입니다."
    },
    {
      "name": "욕망의 인장",
      "slot": "Ring",
      "minRarity": "epic",
      "maxRarity": "epic",
      "desc": "적의 가장 간절한 욕망을 환영으로 보여주어 빈틈을 만듭니다. 전투 중에 적이 망설이게 하거나 유혹에 빠지게 하여 치명적인 실수를 유도합니다."
    },
    {
      "name": "탐욕의 기만링",
      "slot": "Ring",
      "minRarity": "legendary",
      "maxRarity": "legendary",
      "desc": "보물 상자나 귀한 아이템으로 위장하는 능력이 있습니다. 적을 유인하여 덫에 빠뜨리기에 최적이며, 착용자가 얻는 모든 재화의 양을 부정한 방법으로 늘려줍니다."
    },
    {
      "name": "금지된 서고의 후드",
      "slot": "Helmet",
      "minRarity": "epic",
      "maxRarity": "epic",
      "desc": "진실을 마주할 자격이 없는 자들을 처단하기 위해 설계되었습니다. 후드에 깃든 살의는 착용자의 감정을 메마르게 하고, 오직 침입자를 향한 차가운 증오만을 남깁니다."
    },
    {
      "name": "검은 서고의 투구",
      "slot": "Helmet",
      "minRarity": "unique",
      "maxRarity": "unique",
      "desc": "금지된 지식을 수호하던 서고지기들의 투구입니다. 투구 안쪽에는 미세한 바늘 같은 마력이 흐르고 있어, 착용자의 뇌에 잊힌 고대사의 파편들을 강제로 주입합니다."
    },
    {
      "name": "검은 잉크 로브",
      "slot": "Armor",
      "minRarity": "epic",
      "maxRarity": "epic",
      "desc": "마치 살아있는 잉크가 천 위를 흐르는 듯한 기묘한 로브입니다. 물리적인 타격을 받으면 잉크가 그 부위로 집중되어 충격을 흡수하며, 착용자의 존재감을 희미한 얼룩처럼 만듭니다."
    },
    {
      "name": "금지서 코트",
      "slot": "Armor",
      "minRarity": "unique",
      "maxRarity": "unique",
      "desc": "봉인된 마법서의 표지를 뜯어 만든 코트입니다. 코트 안감에는 수천 개의 금지된 주문들이 속삭이고 있으며, 착용자가 위기에 처할 때마다 제멋대로 방어 주술을 영창합니다."
    },
    {
      "name": "탐욕의 장갑",
      "slot": "Gloves",
      "minRarity": "rare",
      "maxRarity": "rare",
      "desc": "황금을 탐하던 자의 욕망이 장갑에 스며들었습니다. 무엇이든 움켜쥐면 놓지 않으려 하며, 적을 쓰러뜨릴 때마다 그들의 귀중품을 감별하고 훔치는 데 비정상적인 직감을 발휘합니다."
    },
    {
      "name": "주문 새기는 장갑",
      "slot": "Gloves",
      "minRarity": "unique",
      "maxRarity": "unique",
      "desc": "손바닥에 고대의 룬 문자가 영구적으로 각인되어 있습니다. 허공에 마법 문자를 그리는 것만으로도 영창 시간 없이 강력한 주문을 발동시킬 수 있게 돕는 마법사의 무구입니다."
    },
    {
      "name": "글자 밟는 장화",
      "slot": "Boots",
      "minRarity": "rare",
      "maxRarity": "rare",
      "desc": "고대 마법 문자가 바닥에 새겨져 있습니다. 특정 마법진 위를 걸을 때 그 마력을 증폭시키거나, 복잡한 함정의 메커니즘을 밟아서 무력화하는 기묘한 힘이 있습니다."
    },
    {
      "name": "잉크 번짐 부츠",
      "slot": "Boots",
      "minRarity": "epic",
      "maxRarity": "epic",
      "desc": "그림자 속에 숨을 때 마치 물에 잉크가 퍼지듯 자연스럽게 동화되도록 돕습니다. 어둠과의 경계를 허물어 착용자를 풍경의 일부로 만드는 암살용 장비입니다."
    },
    {
      "name": "잉크 절단검",
      "slot": "Sword",
      "minRarity": "unique",
      "maxRarity": "unique",
      "desc": "그려진 것들을 실체화하거나, 실체를 잉크로 돌려버립니다. 적의 마법 소환수나 환영을 베면 즉시 검은 잉크가 되어 흩어지게 만듭니다."
    }
  ],
  "jacques": [
    {
      "name": "불협의 스텝",
      "slot": "Boots",
      "minRarity": "unique",
      "maxRarity": "unique",
      "desc": "착용자의 발소리를 기괴한 박자로 변형시킵니다. 적들은 당신의 움직임을 예측하지 못해 박자를 놓치게 되며, 전투의 흐름을 당신의 불규칙한 리듬으로 끌어들입니다."
    },
    {
      "name": "저주의 행보",
      "slot": "Boots",
      "minRarity": "legendary",
      "maxRarity": "legendary",
      "desc": "당신이 밟고 지나간 땅에는 100년 동안 풀 한 포기 자라지 않는 저주가 내립니다. 적들은 당신의 발자국 근처에만 가도 생명력을 빼앗기며 서서히 시들어갑니다."
    },
    {
      "name": "저주받은 음표 목걸이",
      "slot": "Necklace",
      "minRarity": "unique",
      "maxRarity": "unique",
      "desc": "연주되는 순간 재앙을 불러오는 불길한 음표가 새겨져 있습니다. 착용자가 공격할 때마다 기괴한 불협화음이 발생하여 적의 청각을 마비시키고 정신 착란을 유도합니다."
    },
    {
      "name": "진혼의 악보 펜던트",
      "slot": "Necklace",
      "minRarity": "legendary",
      "maxRarity": "legendary",
      "desc": "죽은 자들을 영원한 안식으로 인도하는 마지막 악보입니다. 주변의 모든 언데드를 성불시키거나 자신의 부하로 부릴 수 있으며, 죽음의 기운을 다루는 자들에게 절대적인 우위를 점하게 합니다."
    },
    {
      "name": "박자표 인장반지",
      "slot": "Ring",
      "minRarity": "epic",
      "maxRarity": "epic",
      "desc": "메트로놈처럼 일정한 마력 박자를 방출합니다. 연타 공격이나 마법 난사 시 최적의 타이밍을 시각적 신호로 알려주어 전투 효율을 극대화합니다."
    },
    {
      "name": "불협화음의 성환",
      "slot": "Ring",
      "minRarity": "unique",
      "maxRarity": "unique",
      "desc": "주변의 마력 흐름을 강제로 비틀어 불협화음을 만듭니다. 상대방의 마법 영창을 방해하고 집중력을 흐트러뜨려, 적이 제 실력을 발휘하지 못하게 만드는 심리전용 반지입니다."
    },
    {
      "name": "연주자의 장갑",
      "slot": "Gloves",
      "minRarity": "epic",
      "maxRarity": "epic",
      "desc": "악기의 현을 타듯 섬세하게 무기를 다루는 자를 위한 장갑입니다. 이 장갑을 끼면 칼날이 허공을 가르는 소리마저 아름다운 선율이 되며, 적들의 주의력을 흐트러뜨립니다."
    },
    {
      "name": "현(絃) 조율 장갑",
      "slot": "Gloves",
      "minRarity": "unique",
      "maxRarity": "unique",
      "desc": "악기의 줄을 정밀하게 다루던 장인의 감각이 이식되었습니다. 보이지 않는 마력의 실을 자아내어 전장을 거미줄처럼 통제하거나, 적의 신경계를 현처럼 튕겨 마비시킬 수 있습니다."
    },
    {
      "name": "무대용 가면",
      "slot": "Helmet",
      "minRarity": "rare",
      "maxRarity": "rare",
      "desc": "슬픔의 광대가 썼던 가면으로, 눈가에 흐르는 눈물 자국은 마르지 않는 마력의 흔적입니다. 이를 쓰는 자는 타인의 비탄을 자신의 힘으로 변환하는 기이한 공감 능력을 얻습니다."
    },
    {
      "name": "막 없는 가면",
      "slot": "Helmet",
      "minRarity": "unique",
      "maxRarity": "unique",
      "desc": "눈과 입의 구멍이 전혀 없는 매끄러운 자기 가면입니다. 시각에 의존하지 않는 초월적인 감각을 일깨우며, 착용자는 세상의 소음 뒤에 숨겨진 만물의 진동을 '보게' 됩니다."
    },
    {
      "name": "검은 커튼 로브",
      "slot": "Armor",
      "minRarity": "epic",
      "maxRarity": "epic",
      "desc": "무대의 막을 내리는 커튼으로 제작된 로브입니다. 이 로브를 입은 자가 움직이는 궤적은 마치 한 편의 비극이 끝난 것처럼 주변을 무거운 정적과 어둠으로 뒤덮습니다."
    },
    {
      "name": "선율 절단검",
      "slot": "Sword",
      "minRarity": "epic",
      "maxRarity": "epic",
      "desc": "공기 중의 진동을 베어 소리를 없앱니다. 이 검을 든 자의 움직임은 완벽한 무음 상태가 되며, 적이 비명을 지르기 전에 목을 벨 수 있는 암살용 무기입니다."
    },
    {
      "name": "박자 파쇄검",
      "slot": "Sword",
      "minRarity": "legendary",
      "maxRarity": "legendary",
      "desc": "세상의 모든 흐름과 박자를 뒤틀어버립니다. 적이 공격해오는 타이밍을 강제로 지연시키거나 자신의 공격 속도를 비정상적으로 가속하여 전투의 주도권을 완벽히 장악합니다."
    }
  ],
  "cassias": [
    {
      "name": "서열의 관",
      "slot": "Helmet",
      "minRarity": "unique",
      "maxRarity": "unique",
      "desc": "지배를 위해 태어난 자들의 상징입니다. 이 관의 마력은 주변의 미천한 영혼들을 위압하며, 착용자가 내뱉는 모든 언어에 보이지 않는 강제력을 부여하여 복종을 이끌어냅니다."
    },
    {
      "name": "절대권위의 관",
      "slot": "Helmet",
      "minRarity": "legendary",
      "maxRarity": "legendary",
      "desc": "이 관을 머리에 올리는 순간, 착용자는 개인이 아닌 '국가' 그 자체가 됩니다. 관에 깃든 역대 군주들의 영혼이 착용자에게 결단력을 강요하며, 주변의 아군들에게는 광적인 충성심을 불러일으킵니다."
    },
    {
      "name": "계급의 봉랍 반지",
      "slot": "Ring",
      "minRarity": "unique",
      "maxRarity": "unique",
      "desc": "몰락한 귀족 가문의 인장입니다. 반지에 남아있는 과거의 권위는 낮은 등급의 몬스터들을 위압하며, 인간 사회에서 신분을 증명하거나 협상을 유리하게 이끄는 데 도움을 줍니다."
    },
    {
      "name": "승인 도장 성환",
      "slot": "Ring",
      "minRarity": "legendary",
      "maxRarity": "legendary",
      "desc": "이 반지를 낀 손으로 적을 타격하는 것은 곧 '죽음의 승인'을 의미합니다. 인장이 찍힌 대상은 모든 방어력이 무시되며, 인과율에 의해 반드시 소멸하는 운명에 처해집니다."
    },
    {
      "name": "권위의 흉갑",
      "slot": "Armor",
      "minRarity": "epic",
      "maxRarity": "epic",
      "desc": "보는 것만으로도 위압감을 주는 화려한 문양이 새겨진 흉갑입니다. 착용자의 신분을 드높여 주며, 적들의 투지를 꺾고 아군에게는 굴하지 않는 용기를 불어넣는 지도자의 장비입니다."
    },
    {
      "name": "규정의 판금",
      "slot": "Armor",
      "minRarity": "unique",
      "maxRarity": "unique",
      "desc": "한 치의 오차도 허용하지 않는 엄격한 법집행관들의 판금입니다. 착용자의 흐트러진 자세를 강제로 교정하며, 어떤 혼란스러운 전장에서도 평정심을 잃지 않도록 정신을 압박합니다."
    },
    {
      "name": "지시자의 장갑",
      "slot": "Gloves",
      "minRarity": "rare",
      "maxRarity": "rare",
      "desc": "지휘봉을 쥐는 손을 위해 화려하게 장식되었습니다. 손가락을 가리키는 것만으로도 아군들에게 명확한 의사를 전달하며, 지휘 계통의 마력적 결속력을 강화합니다."
    },
    {
      "name": "결재자의 장갑",
      "slot": "Gloves",
      "minRarity": "unique",
      "maxRarity": "unique",
      "desc": "생사를 결정짓는 서류에 도장을 찍던 고위 관료의 장갑입니다. 이 장갑을 낀 손이 휘두르는 명령은 절대적이며, 장갑에 닿는 모든 계약을 강제로 이행시키는 권능이 서려 있습니다."
    },
    {
      "name": "행정관의 장화",
      "slot": "Boots",
      "minRarity": "rare",
      "maxRarity": "rare",
      "desc": "도시의 치안을 담당하는 행정관들의 구두입니다. 포장된 도로에서 최고의 이동 효율을 보여주며, 시민들에게는 신뢰를, 범죄자들에게는 엄중한 법의 발소리로 들립니다."
    },
    {
      "name": "점검의 행보",
      "slot": "Boots",
      "minRarity": "epic",
      "maxRarity": "epic",
      "desc": "기계 장치 위를 걸을 때 그 내부 구조와 고장 유무를 발바닥의 감각으로 읽어냅니다. 복잡한 기계 던전이나 함정 구역을 안전하게 통과하는 데 큰 도움이 됩니다."
    },
    {
      "name": "명령서 펜던트",
      "slot": "Necklace",
      "minRarity": "epic",
      "maxRarity": "epic",
      "desc": "상급 지휘관의 명령이 담긴 통신 펜던트입니다. 주변 아군들의 공격 속도와 이동 속도를 조절하는 지휘 능력을 부여하며, 소규모 분대 전투에서 탁월한 효율을 발휘합니다."
    },
    {
      "name": "봉인된 명령서 목걸이",
      "slot": "Necklace",
      "minRarity": "unique",
      "maxRarity": "unique",
      "desc": "아직 개봉되지 않은 일급 비밀 명령서입니다. 특정 임무를 완수하기 전까지는 능력치가 잠겨있으나, 목표를 달성하는 순간 착용자에게 필요한 최적의 능력치로 개방됩니다."
    },
    {
      "name": "서류칼 ‘결재’",
      "slot": "Sword",
      "minRarity": "unique",
      "maxRarity": "unique",
      "desc": "작고 날카로운 사무용 칼처럼 생겼지만, 마법적인 인장이 새겨져 있습니다. 적의 운명에 '종결'의 도장을 찍듯, 낮은 확률로 체력이 낮은 적을 즉사시킵니다."
    }
  ],
  "masakuni": [
    {
      "name": "흑도 ‘무라사메’",
      "slot": "Sword",
      "minRarity": "legendary",
      "maxRarity": "legendary",
      "desc": "비가 내리는 날 그 진가가 드러난다는 전설의 도검입니다. 검신에 묻은 피를 스스로 씻어내는 물줄기가 흐르며, 흐르는 물처럼 끊임없는 연격으로 적을 압도합니다."
    },
    {
      "name": "흑도 ‘무라사메・심연’",
      "slot": "Sword",
      "minRarity": "demonic",
      "maxRarity": "demonic",
      "desc": "무라사메가 심연의 마력에 오염되어 타락했습니다. 맑은 물 대신 검은 저주가 흘러나오며, 베인 적의 영혼을 심연으로 끌고 가 영원한 고통 속에 가둡니다."
    },
    {
      "name": "어둠의 사무라이 가면",
      "slot": "Helmet",
      "minRarity": "unique",
      "maxRarity": "unique",
      "desc": "동방의 검귀들이 사용했다는 귀면입니다. 가면 안쪽에는 착용자의 혈액을 흡수하는 침이 돋아나 있으며, 피를 마신 가면은 착용자의 검속을 인간의 경지 너머로 가속시킵니다."
    },
    {
      "name": "월식의 투구",
      "slot": "Helmet",
      "minRarity": "legendary",
      "maxRarity": "legendary",
      "desc": "태양의 빛이 가려지는 찰나의 순간을 영원히 고정시킨 투구입니다. 빛과 어둠이 공존하는 기묘한 기운은 착용자의 존재를 현실에서 살짝 비껴나게 만들어, 적의 공격을 허상처럼 통과시킵니다."
    },
    {
      "name": "그림자 도복",
      "slot": "Armor",
      "minRarity": "unique",
      "maxRarity": "unique",
      "desc": "실체가 없는 그림자를 실로 뽑아 직조한 도복입니다. 착용자의 신체 근육을 최적으로 보조하며, 움직일 때마다 검은 잔상을 남겨 적의 공격 궤도를 교란합니다."
    },
    {
      "name": "월식 도복 ‘무사도’",
      "slot": "Armor",
      "minRarity": "legendary",
      "maxRarity": "legendary",
      "desc": "태양과 달이 하나가 되는 월식의 찰나에 제련된 도복입니다. 삶과 죽음의 경계에 서 있는 무사의 투지가 깃들어 있으며, 일격필살의 검기를 견뎌낼 수 있는 신비로운 탄성을 지니고 있습니다."
    },
    {
      "name": "환영검 장갑",
      "slot": "Gloves",
      "minRarity": "epic",
      "maxRarity": "epic",
      "desc": "무기를 쥐지 않아도 환영의 칼날이 손의 움직임을 따라 생성됩니다. 맨손 전투 중에도 적에게 예리한 자상을 입힐 수 있으며, 실제 무기를 쥐었을 때는 공격 궤도를 예측 불가능하게 만듭니다."
    },
    {
      "name": "칼자국 장갑",
      "slot": "Gloves",
      "minRarity": "unique",
      "maxRarity": "unique",
      "desc": "수천 번의 칼날을 손으로 막아낸 흔적이 훈장처럼 남은 장갑입니다. 갑옷을 뚫고 들어오는 칼날을 직접 움켜쥐어도 손이 잘리지 않는 신비로운 방어 주술이 깃들어 있습니다."
    },
    {
      "name": "무사의 게타",
      "slot": "Boots",
      "minRarity": "epic",
      "maxRarity": "epic",
      "desc": "전통적인 나무 신발의 형태를 하고 있지만, 강철보다 단단한 영목으로 제작되었습니다. 딱딱거리는 소리는 적에게 위압감을 주며, 지면과의 마찰을 이용해 강력한 반동 공격을 가할 수 있게 합니다."
    },
    {
      "name": "무사도의 발걸음",
      "slot": "Boots",
      "minRarity": "legendary",
      "maxRarity": "legendary",
      "desc": "한 치의 흐트러짐 없는 무사의 기개가 발끝까지 이어집니다. 어떤 험난한 지형에서도 균형 감각을 잃지 않으며, 적의 공격을 종이 한 장 차이로 흘려보내는 정교한 스텝을 보조합니다."
    },
    {
      "name": "검혼의 인장반지",
      "slot": "Ring",
      "minRarity": "unique",
      "maxRarity": "unique",
      "desc": "검의 형상이 정교하게 새겨진 반지입니다. 검기를 형상화하는 효율을 높여주며, 검과 착용자의 마력이 하나로 공명하게 하여 무기의 내구도와 절삭력을 강화합니다."
    },
    {
      "name": "검혼의 성환",
      "slot": "Ring",
      "minRarity": "legendary",
      "maxRarity": "legendary",
      "desc": "전설적인 검객들의 투혼이 깃든 인장입니다. 무기를 쥐었을 때 손가락에서부터 검의 영혼이 흘러들어와, 착용자의 검술 실력을 수십 년 연마한 달인의 경지로 끌어올립니다."
    },
    {
      "name": "명예의 매듭 목걸이",
      "slot": "Necklace",
      "minRarity": "unique",
      "maxRarity": "unique",
      "desc": "수많은 승전 기록을 상징하는 매듭으로 이루어져 있습니다. 명성치가 높을수록 추가 능력치를 제공하며, 적들에게 정면 승부를 강제하는 명예로운 오라를 방출합니다."
    }
  ],
  "kaito": [
    {
      "name": "감염된 유리구슬 반지",
      "slot": "Ring",
      "minRarity": "unique",
      "maxRarity": "unique",
      "desc": "뿌연 유리구슬 안에 정체 모를 보라색 균사가 꿈틀거리고 있습니다. 착용자의 상처를 강제로 오염시켜 고통을 마비시키고, 비정상적인 회복력을 부여하는 위험한 물건입니다."
    },
    {
      "name": "다크 돌연변이 인장",
      "slot": "Ring",
      "minRarity": "demonic",
      "maxRarity": "demonic",
      "desc": "착용자의 신체를 무작위로 변이시키는 저주받은 인장입니다. 이성이 깎여 나가는 대신 인간을 초월한 완력을 얻게 되며, 피부가 단단한 껍질로 덮여 물리 피해를 무시하게 됩니다."
    },
    {
      "name": "검은 고해의 실 목걸이",
      "slot": "Necklace",
      "minRarity": "unique",
      "maxRarity": "unique",
      "desc": "죄를 고백할 때마다 한 매듭씩 묶은 검은 실 뭉치입니다. 착용자의 죄책감을 양분 삼아 정신 마법에 대한 강력한 내성을 제공하며, 적의 심리를 위축시키는 오라를 내뿜습니다."
    },
    {
      "name": "격리구역 표찰(도그태그)",
      "slot": "Necklace",
      "minRarity": "legendary",
      "maxRarity": "legendary",
      "desc": "사상 최악의 오염 구역에 끝까지 남았던 자의 군인 인식표입니다. 죽음의 문턱을 넘나든 자의 기운이 서려 있어, 치명적인 타격을 입었을 때 한 번만 운명을 비틀어 생존하게 합니다."
    },
    {
      "name": "감염된 방독면",
      "slot": "Helmet",
      "minRarity": "epic",
      "maxRarity": "epic",
      "desc": "필터 내부에서 정체 모를 균사가 꿈틀거리고 있습니다. 정화 기능은 이미 상실되었으며, 오히려 외부의 공기를 더 기괴한 독소로 변환하여 착용자의 폐부 깊숙이 밀어 넣습니다."
    },
    {
      "name": "격리자의 투구",
      "slot": "Helmet",
      "minRarity": "unique",
      "maxRarity": "unique",
      "desc": "치명적인 오염 구역에서 마지막까지 살아남으려 했던 자의 유물입니다. 완벽한 밀폐 구조 덕분에 안전할지 모르나, 안에서 들리는 것은 자신의 미쳐가는 목소리뿐입니다."
    },
    {
      "name": "검은 밀봉 코트",
      "slot": "Armor",
      "minRarity": "epic",
      "maxRarity": "epic",
      "desc": "외부와의 접촉을 거부하듯 단추 하나하나에 봉인 주술이 걸린 코트입니다. 착용자의 기운이 밖으로 새어 나가는 것을 막아주어, 적의 탐지로부터 자신을 숨기기에 최적화되어 있습니다."
    },
    {
      "name": "오염 저지 판금",
      "slot": "Armor",
      "minRarity": "unique",
      "maxRarity": "unique",
      "desc": "치명적인 역병 지대를 돌파하기 위해 제작된 특수 판금입니다. 판금 표면의 정화 룬은 외부의 독소와 감염원을 즉각 분해하며, 착용자에게는 오염된 대지조차 가장 안전한 성소로 느껴지게 합니다."
    },
    {
      "name": "오염 차단 장갑",
      "slot": "Gloves",
      "minRarity": "epic",
      "maxRarity": "epic",
      "desc": "어떠한 생화학적 오염 물질도 통과할 수 없는 나노 섬유로 제작되었습니다. 더러운 환경에서도 착용자의 손은 항상 청결한 상태를 유지하며, 세균이나 독소의 침투를 99% 차단합니다."
    },
    {
      "name": "부패 차단 장갑",
      "slot": "Gloves",
      "minRarity": "unique",
      "maxRarity": "unique",
      "desc": "죽음의 기운이 감도는 언데드나 부패한 시체를 만져도 오염되지 않도록 신성한 은색 실로 자수를 놓았습니다. 생명의 기운을 보존하는 결계가 착용자의 손을 감싸고 있습니다."
    },
    {
      "name": "검은 잔재 부츠",
      "slot": "Boots",
      "minRarity": "epic",
      "maxRarity": "epic",
      "desc": "불타버린 전장의 재를 모아 마법으로 응고시켰습니다. 이동할 때마다 검은 먼지가 아스라이 흩날리며, 착용자가 지나간 자리에 남은 잔재는 추격자들의 시야를 흐릿하게 만듭니다."
    },
    {
      "name": "소독 구역 장화",
      "slot": "Boots",
      "minRarity": "epic",
      "maxRarity": "epic",
      "desc": "병원이나 실험실의 청결 구역을 유지하기 위해 제작되었습니다. 장화 바닥에서 상시 정화 마력이 방출되어, 착용자가 밟는 곳의 오염과 독소를 즉각 정화합니다."
    },
    {
      "name": "살균 톱니검",
      "slot": "Sword",
      "minRarity": "unique",
      "maxRarity": "unique",
      "desc": "의료용 메스를 연상시키는 정교한 톱니날이 달려 있습니다. 언데드나 부패한 생명체를 베어낼 때 신성한 약품 성분이 방출되어 추가적인 정화 피해를 입힙니다."
    }
  ],
  "questa": [
    {
      "name": "응축 독가스 부적",
      "slot": "Necklace",
      "minRarity": "legendary",
      "maxRarity": "legendary",
      "desc": "대륙 하나를 사멸시킬 수 있는 양의 독가스를 나노 단위로 응축했습니다. 착용자가 사망할 경우 부적이 깨지며 주변 모든 생태계를 즉시 파괴하는 '최후의 복수' 기믹을 가집니다."
    },
    {
      "name": "독가스 심장부적",
      "slot": "Necklace",
      "minRarity": "demonic",
      "maxRarity": "demonic",
      "desc": "심장 부근에 독가스를 가두어 둔 위험한 부적입니다. 착용자의 생명력을 조금씩 갉아먹는 대신, 주변 적들에게 상시 맹독 피해를 입히는 역병의 근원이 됩니다."
    },
    {
      "name": "방독 장갑 ‘밀폐’",
      "slot": "Gloves",
      "minRarity": "unique",
      "maxRarity": "unique",
      "desc": "유독 가스가 만연한 폐허를 탐사하기 위해 제작되었습니다. 손끝부터 팔꿈치까지 완벽하게 밀폐되어 있으며, 피부를 통해 침투하는 독소조차 마력 필터로 걸러냅니다."
    },
    {
      "name": "밀폐 건틀릿 ‘진공’",
      "slot": "Gloves",
      "minRarity": "legendary",
      "maxRarity": "legendary",
      "desc": "내부를 완벽한 진공 상태로 유지하는 최첨단 건틀릿입니다. 외부의 기압이나 온도 변화에 전혀 영향을 받지 않으며, 펀치를 내지를 때 주변 공기를 빨아들여 충격파를 증폭시킵니다."
    },
    {
      "name": "맹세의 방독 마스크",
      "slot": "Helmet",
      "minRarity": "epic",
      "maxRarity": "epic",
      "desc": "결코 전우를 버리지 않겠다는 피의 맹세가 새겨진 마스크입니다. 필터에 깃든 마력은 치명적인 독구름 속에서도 착용자가 맑은 정신을 유지하며 전진할 수 있게 돕습니다."
    },
    {
      "name": "무연의 흡입기",
      "slot": "Helmet",
      "minRarity": "legendary",
      "maxRarity": "legendary",
      "desc": "초고대 문명의 유산으로 추정되는 이 장치는 공기 중의 마력 찌꺼기와 대기 오염을 완벽하게 분해합니다. 기계적인 구동음이 규칙적으로 들려오며, 착용자에게는 마치 진공 상태와 같은 순수한 정적을 제공합니다."
    },
    {
      "name": "장막 로브",
      "slot": "Armor",
      "minRarity": "epic",
      "maxRarity": "epic",
      "desc": "현실과 허상의 경계에 존재하는 안개를 실로 뽑아 짰습니다. 이 로브를 입은 자는 물리적인 타격으로부터 살짝 비껴난 차원에 존재하는 듯한 효과를 얻어, 치명적인 공격을 허상처럼 흘려보냅니다."
    },
    {
      "name": "차단막 판금",
      "slot": "Armor",
      "minRarity": "unique",
      "maxRarity": "unique",
      "desc": "모든 종류의 에너지 흐름을 차단하는 마법 절연체로 제작되었습니다. 화염, 냉기, 전격 등 원소 마법의 영향을 거의 받지 않으며, 착용자를 마법적인 재앙으로부터 완벽하게 격리합니다."
    },
    {
      "name": "무연(無煙) 장화",
      "slot": "Boots",
      "minRarity": "epic",
      "maxRarity": "epic",
      "desc": "불길 속을 걸어도 연기가 나지 않으며 발이 타지 않습니다. 화염 마법이 난무하는 전장에서 유유히 걸어 나올 수 있게 해주며, 고열의 지형을 탐사할 때 필수적인 장비입니다."
    },
    {
      "name": "진공 스텝",
      "slot": "Boots",
      "minRarity": "unique",
      "maxRarity": "unique",
      "desc": "발바닥에 순간적인 진공 상태를 만들어 벽이나 천장에도 달라붙어 이동할 수 있게 합니다. 지면이라는 제약을 벗어나 3차원적인 움직임을 가능케 하는 혁신적인 장화입니다."
    },
    {
      "name": "가스 씰링",
      "slot": "Ring",
      "minRarity": "epic",
      "maxRarity": "epic",
      "desc": "산업 시대의 가스 밸브를 축소해 놓은 듯한 디자인의 반지입니다. 착용자의 체내 마력 누출을 완벽히 차단하여 마나 효율을 극대화하며, 외부의 유독 성분이 침투하는 것을 방어합니다."
    },
    {
      "name": "가스 캡슐 성환",
      "slot": "Ring",
      "minRarity": "unique",
      "maxRarity": "unique",
      "desc": "투명한 보석 안에 치명적인 신경 가스가 응축되어 있습니다. 위기의 순간 보석을 깨트리면 반경 수 미터를 즉시 초토화시키며, 평소에는 가스 계열 마법의 위력을 크게 증폭시킵니다."
    },
    {
      "name": "누출 봉쇄검",
      "slot": "Sword",
      "minRarity": "unique",
      "maxRarity": "unique",
      "desc": "마력이나 생명력이 새어나가는 곳을 강제로 닫아버리는 검입니다. 적의 회복 능력을 억제하고, 상처가 아물지 않게 하여 지속적인 출혈 상태를 유지시킵니다."
    }
  ],
  "tetora": [
    {
      "name": "심연의 한 소절",
      "slot": "Necklace",
      "minRarity": "legendary",
      "maxRarity": "legendary",
      "desc": "듣는 것만으로도 이성을 마비시키는 심연의 노래가 결정화되었습니다. 이 소리를 들은 적들은 영혼이 찢겨나가는 고통을 느끼며 방어 의지를 상실한 채 제자리에 굳어버립니다."
    },
    {
      "name": "검은 합창의 성흔",
      "slot": "Necklace",
      "minRarity": "demonic",
      "maxRarity": "demonic",
      "desc": "수많은 원혼의 비명이 하나의 화음으로 응축된 기괴한 목걸이입니다. 전투 중 주변의 시체가 많아질수록 착용자의 마력을 폭발적으로 증폭시키지만, 환청을 유발하는 부작용이 있습니다."
    },
    {
      "name": "진혼곡 장화",
      "slot": "Boots",
      "minRarity": "unique",
      "maxRarity": "unique",
      "desc": "전장에서 쓰러진 자들의 넋을 기리며 걷습니다. 발소리가 마치 엄숙한 진혼곡처럼 울려 퍼지며, 주변 언데드들을 성불시키거나 아군의 공포를 잠재우는 성질을 가집니다."
    },
    {
      "name": "피날레 행보",
      "slot": "Boots",
      "minRarity": "legendary",
      "maxRarity": "legendary",
      "desc": "전투의 마지막 순간, 마무리를 짓기 위해 제작되었습니다. 적의 체력이 낮을수록 이동 속도와 공격력이 폭발적으로 증가하여, 확실한 죽음을 선사하는 마지막 일격을 보조합니다."
    },
    {
      "name": "공명 인장반지",
      "slot": "Ring",
      "minRarity": "unique",
      "maxRarity": "unique",
      "desc": "주변의 마력 파동에 반응하여 미세하게 진동합니다. 보이지 않는 마법 함정이나 은신한 적의 존재를 진동으로 알려주며, 특정 마법 장치와 공명하여 문을 여는 열쇠 역할을 하기도 합니다."
    },
    {
      "name": "박자 훔치는 성환",
      "slot": "Ring",
      "minRarity": "legendary",
      "maxRarity": "legendary",
      "desc": "전장의 모든 흐름과 박자를 자신의 것으로 가져옵니다. 적의 공격 템포를 억지로 늦추고 자신의 속도를 가속시켜, 마치 시간이 멈춘 듯한 공간 속에서 일방적인 공격을 퍼붓게 합니다."
    },
    {
      "name": "박자 제어 장갑",
      "slot": "Gloves",
      "minRarity": "epic",
      "maxRarity": "epic",
      "desc": "전장의 소음을 리듬으로 치환하여 느낍니다. 적의 공격 템포를 읽어내어 완벽한 타이밍에 받아치게 하며, 착용자의 움직임을 춤추듯 우아하고 치명적으로 바꿉니다."
    },
    {
      "name": "공명 조율 장갑",
      "slot": "Gloves",
      "minRarity": "unique",
      "maxRarity": "unique",
      "desc": "특정 주파수의 마력을 진동으로 변환합니다. 무기를 쥐었을 때 그 진동을 조율하여 적의 방어구와 공명하게 함으로써, 보이지 않는 내부 타격을 가하는 것이 가능합니다."
    },
    {
      "name": "무대 조명 가면",
      "slot": "Helmet",
      "minRarity": "epic",
      "maxRarity": "epic",
      "desc": "가면 표면의 보석들이 주변의 아주 작은 빛이라도 끌어모아 눈부시게 산란시킵니다. 전장의 한복판에서도 마치 무대 위의 주인공처럼 돋보이게 만들며, 적들의 시선을 강제로 고정시킵니다."
    },
    {
      "name": "장막의 가면 ‘무대 뒤’",
      "slot": "Helmet",
      "minRarity": "unique",
      "maxRarity": "unique",
      "desc": "진실을 조작하는 광대들의 비기입니다. 이 가면을 쓰면 착용자의 목소리, 체격, 기운조차 타인이 원하는 환상으로 뒤바뀌어, 완벽한 기만전술을 펼칠 수 있게 됩니다."
    },
    {
      "name": "어둠의 코러스 로브",
      "slot": "Armor",
      "minRarity": "epic",
      "maxRarity": "epic",
      "desc": "수많은 원혼의 비명소리를 노래로 승화시켜 옷감에 가두었습니다. 로브가 바람에 휘날릴 때마다 기괴한 화음이 들려오며, 이는 적들의 정신을 붕괴시키고 환청에 시달리게 만듭니다."
    },
    {
      "name": "무대장막 판금",
      "slot": "Armor",
      "minRarity": "unique",
      "maxRarity": "unique",
      "desc": "연극의 시작과 끝을 알리는 무대 장막을 금속판에 씌운 형태입니다. 착용자의 행동 하나하나를 극적인 연출처럼 보이게 하며, 적들을 관객으로 만들어 행동을 제약하는 기묘한 마력을 내뿜습니다."
    },
    {
      "name": "선율 파쇄검",
      "slot": "Sword",
      "minRarity": "legendary",
      "maxRarity": "legendary",
      "desc": "전장의 소음을 에너지로 흡수합니다. 주변의 함성과 칼질 소리가 커질수록 검신이 진동하며, 거대한 음파 병기처럼 모든 것을 파괴하는 소음 폭풍을 내뿜습니다."
    }
  ],
  "cain": [
    {
      "name": "블랙 미스트 왕관",
      "slot": "Helmet",
      "minRarity": "legendary",
      "maxRarity": "legendary",
      "desc": "물질적인 금속이 아닌, 응축된 어둠의 안개가 왕관의 형상을 유지하고 있습니다. 이 왕관을 쓰는 자는 그림자를 부리는 권능을 얻지만, 매 순간 자신의 생명력을 어둠에 제물로 바쳐야 합니다."
    },
    {
      "name": "수호천사의 신성한 방진면",
      "slot": "Helmet",
      "minRarity": "angelic",
      "maxRarity": "angelic",
      "desc": "하늘의 사자들이 지상의 혼탁한 공기로부터 성체를 보존하기 위해 하사한 유물입니다. 방진면을 통과한 공기는 순수한 신성력으로 정화되어, 착용자의 상처를 치유하고 영혼을 맑게 합니다."
    },
    {
      "name": "미스트브레이커 왕검",
      "slot": "Sword",
      "minRarity": "legendary",
      "maxRarity": "legendary",
      "desc": "안개 낀 대륙을 통치하던 왕의 검입니다. 전장을 뒤덮는 어떤 환상이나 안개도 단 한 번의 휘두름으로 걷어내며, 진실만을 꿰뚫는 일격을 가합니다."
    },
    {
      "name": "가스 분사 장갑",
      "slot": "Gloves",
      "minRarity": "unique",
      "maxRarity": "unique",
      "desc": "손목 부분에 소형 가스 탱크가 매립되어 있습니다. 근접전 시 손가락 사이로 치명적인 마비 가스를 분사하여, 적이 눈치채기도 전에 숨통을 조일 수 있습니다."
    },
    {
      "name": "그림자 누설 장화",
      "slot": "Boots",
      "minRarity": "unique",
      "maxRarity": "unique",
      "desc": "그림자의 세계로부터 어둠이 조금씩 새어 나오는 장화입니다. 착용자의 발치가 항상 어둑하게 가라앉아 있어, 밝은 곳에서도 발소리와 형체를 숨기기에 용이합니다."
    },
    {
      "name": "누설 제트부츠",
      "slot": "Boots",
      "minRarity": "legendary",
      "maxRarity": "legendary",
      "desc": "불안정한 마력 엔진이 외부에 노출된 형태의 최첨단 부츠입니다. 제어하기는 극도로 어렵지만, 순간적으로 폭발적인 추진력을 내뿜어 중력을 거스르는 초고속 이동을 가능케 합니다."
    },
    {
      "name": "테러블 흉갑",
      "slot": "Armor",
      "minRarity": "unique",
      "maxRarity": "unique",
      "desc": "보는 이로 하여금 본능적인 공포를 유발하는 기괴한 디자인의 흉갑입니다. 흉갑 표면에서는 끊임없이 공포의 파동이 흘러나와, 적들의 손을 떨리게 하고 판단력을 흐리게 만듭니다."
    },
    {
      "name": "어둠 정화자의 눈부신 판금",
      "slot": "Armor",
      "minRarity": "angelic",
      "maxRarity": "angelic",
      "desc": "타락한 대지를 정화하기 위해 강림한 천상의 사자를 위한 갑주입니다. 판금에서 뿜어져 나오는 성광은 사악한 저주를 즉시 해독하며, 주변의 동료들에게 무결한 가호의 영역을 제공합니다."
    },
    {
      "name": "다크 바이러스 반지",
      "slot": "Ring",
      "minRarity": "unique",
      "maxRarity": "unique",
      "desc": "착용자의 마나를 바이러스처럼 증식시켜 폭발적인 위력을 내게 합니다. 하지만 마나를 소모할 때마다 사용자의 생명력도 조금씩 갉아먹는 양날의 검입니다."
    },
    {
      "name": "역병의 왕 인장",
      "slot": "Ring",
      "minRarity": "demonic",
      "maxRarity": "demonic",
      "desc": "장갑 위에 끼워진 이 인장은 공기 중으로 미세한 균사를 퍼뜨립니다. 착용자는 멀리서 지켜보기만 해도 적들이 병들어 쓰러지는 광경을 목격하게 될 것입니다."
    },
    {
      "name": "타락 성흔의 사슬",
      "slot": "Necklace",
      "minRarity": "demonic",
      "maxRarity": "demonic",
      "desc": "성스러운 사슬이 타락하여 붉은 녹이 슬었습니다. 닿는 모든 성스러운 축복을 저주로 반전시키며, 성직자 계열의 적에게 치명적인 악의의 타격을 입힙니다."
    },
    {
      "name": "검은 계약 펜던트",
      "slot": "Necklace",
      "minRarity": "demonic",
      "maxRarity": "demonic",
      "desc": "악마와 맺은 계약의 내용이 깨진 거울 조각에 새겨져 있습니다. 착용자가 고통을 느낄수록 펜던트가 검게 타오르며, 그 고통을 파괴적인 마력으로 치환하여 방출합니다."
    },
    {
      "name": "심연의 청구서",
      "slot": "Necklace",
      "minRarity": "demonic",
      "maxRarity": "demonic",
      "desc": "심연의 존재에게 힘을 빌린 대가를 기록한 양피지입니다. 착용자에게 압도적인 마력을 제공하지만, 전투 종료 시 소모한 마력의 일부를 생명력으로 '청구'해 가는 잔혹한 목걸이입니다."
    },
    {
      "name": "서늘한 악마의 가면",
      "slot": "Helmet",
      "minRarity": "demonic",
      "maxRarity": "demonic",
      "desc": "심연의 가장 깊고 차가운 곳에서 생성된 얼음 결정으로 깎아 만들었습니다. 가면에서 뿜어져 나오는 한기는 착용자의 주변 지면을 얼려버리며, 그를 바라보는 이의 심장까지 얼어붙게 만듭니다."
    },
    {
      "name": "악마의 계약을 찢는 손",
      "slot": "Gloves",
      "minRarity": "demonic",
      "maxRarity": "demonic",
      "desc": "지옥의 계약서조차 찢어발길 수 있는 부정의 힘이 깃든 장갑입니다. 이 장갑을 낀 손은 물리적인 형체뿐만 아니라 추상적인 속박과 저주까지 움켜쥐어 파괴할 수 있습니다."
    },
    {
      "name": "파멸의 스텝",
      "slot": "Boots",
      "minRarity": "demonic",
      "maxRarity": "demonic",
      "desc": "한 걸음을 내딛을 때마다 대지가 갈라지고 용암이 치솟습니다. 당신의 행차는 곧 재앙의 시작이며, 지형 자체를 파괴하여 적들이 발붙일 곳을 없애버립니다."
    },
    {
      "name": "호러블 네크로 펜던트",
      "slot": "Necklace",
      "minRarity": "legendary",
      "maxRarity": "legendary",
      "desc": "공포 그 자체가 형상화된 네크로맨서의 정수입니다. 죽은 자들을 끝없이 소환하여 군대를 만들 수 있으며, 착용자 자체가 죽음의 화신이 되어 적들의 영혼을 직접 수확하게 합니다."
    },
    {
      "name": "가스호스 목걸이",
      "slot": "Necklace",
      "minRarity": "unique",
      "maxRarity": "unique",
      "desc": "폐기된 방독면의 호스를 잘라 목걸이로 만들었습니다. 내부의 여과 필터가 소량 남아있어, 목 근처의 공기를 상시 정화하며 호흡기 계열 저항력을 높여줍니다."
    },
    {
      "name": "성스러운 정화의 성환",
      "slot": "Ring",
      "minRarity": "angelic",
      "maxRarity": "angelic",
      "desc": "닿는 모든 부정을 태워버리는 백색 불꽃의 고리입니다. 착용자에게 걸린 모든 상태 이상을 즉시 해제하며, 언데드나 악마형 적들에게는 존재만으로도 극심한 고통을 줍니다."
    },
    {
      "name": "호위무신의 운검", "slot": "Sword", "minRarity": "angelic", "maxRarity": "angelic", "desc": "천계를 수호하는 무신이 사용하던 구름 무늬의 검입니다. 검을 휘두를 때마다 구름과 바람이 착용자를 감싸 보호하며, 적의 공격을 부드럽게 흘려보냅니다."},
    {"name": "원시 태동의 결속 장갑", "slot": "Gloves", "minRarity": "angelic", "maxRarity": "angelic", "desc": "세상이 창조될 때의 생명력을 간직한 고대의 장비입니다. 장갑을 끼는 순간 대지와 연결된 듯한 무한한 에너지가 손끝으로 밀려오며, 닿는 모든 생명을 치유하거나 재구축하는 신성을 보여줍니다."},
    {"name": "약속을 지키는 발걸음", "slot": "Boots", "minRarity": "angelic", "maxRarity": "angelic", "desc": "한 번 가기로 맹세한 목적지에 도달할 때까지 착용자를 절대 쓰러지지 않게 보호합니다. 그 어떤 유혹이나 방해물도 이 성스러운 발걸음을 멈추게 할 수 없습니다."},
    {"name": "구원의 향(香) 목걸이",
      "slot": "Necklace",
      "minRarity": "angelic",
      "maxRarity": "angelic",
      "desc": "천상의 꽃에서 추출한 향료가 담긴 작은 병입니다. 목걸이에서 끊임없이 흘러나오는 은은한 향기는 아군들의 상처를 치유하고 정신을 맑게 정화하는 기적을 행합니다."
    }
  ],
  "arthur": [
    {
      "name": "진조의 결단검",
      "slot": "Sword",
      "minRarity": "legendary",
      "maxRarity": "legendary",
      "desc": "흡혈귀의 시조가 사용했다는 검입니다. 적을 베어 얻은 피로 검신을 강화하며, 착용자가 빈사 상태일 때 소지한 피를 소모해 폭발적인 힘을 줍니다."
    },
    {
      "name": "왕의 선고검",
      "slot": "Sword",
      "minRarity": "legendary",
      "maxRarity": "legendary",
      "desc": "왕의 명령 한마디가 곧 칼날이 됩니다. 착용자가 지목한 적에게는 '사형'의 낙인이 찍히며, 모든 아군이 그 대상을 공격할 때 피해량이 폭발적으로 증가합니다."
    },
    {
      "name": "타락한 로드 아서의 피흉갑",
      "slot": "Armor",
      "minRarity": "legendary",
      "maxRarity": "legendary",
      "desc": "성군이었으나 광기에 물든 로드 아서가 자신의 신하들을 학살할 때 입었던 흉갑입니다. 흉갑에 스며든 피는 여전히 마르지 않고 박동하며, 착용자에게는 절대적인 파괴력과 함께 영혼의 타락을 요구합니다."
    },
    {
      "name": "타락한 왕의 판금",
      "slot": "Armor",
      "minRarity": "demonic",
      "maxRarity": "demonic",
      "desc": "왕관을 버리고 심연에 영혼을 판 군주의 갑옷입니다. 갑옷의 장식들은 고통에 신음하는 백성들의 얼굴 형상을 하고 있으며, 주변의 생기를 강제로 착취하여 착용자의 상처를 실시간으로 치유합니다."
    },
    {
      "name": "붉은 위엄의 면갑",
      "slot": "Helmet",
      "minRarity": "legendary",
      "maxRarity": "legendary",
      "desc": "수많은 승리를 거머쥔 정복자의 장비입니다. 면갑에서 뿜어져 나오는 붉은 기운은 주변의 공기를 무겁게 짓누르며, 적들로 하여금 신체적인 압박감과 함께 거부할 수 없는 복종심을 느끼게 합니다."
    },
    {
      "name": "타락한 로드의 왕관",
      "slot": "Helmet",
      "minRarity": "legendary",
      "maxRarity": "legendary",
      "desc": "백성을 사랑하던 성군이 광기에 물들어 제국을 멸망시킨 뒤 남긴 왕관입니다. 왕관에 맺힌 피눈물 모양의 보석은 착용자에게 지배의 쾌락과 함께 영원히 채워지지 않는 갈증을 부여합니다."
    },
    {
      "name": "혈계 장갑",
      "slot": "Gloves",
      "minRarity": "unique",
      "maxRarity": "unique",
      "desc": "착용자의 혈액을 마력의 촉매로 사용합니다. 손가락 끝에서 혈액으로 형성된 예리한 칼날을 뽑아낼 수 있으며, 자신의 생명력을 태워 적에게 치명적인 혈독을 주입합니다."
    },
    {
      "name": "기사단 붕괴 건틀릿",
      "slot": "Gloves",
      "minRarity": "legendary",
      "maxRarity": "legendary",
      "desc": "왕국을 수호하던 기사단의 마지막 방패를 녹여 만들었습니다. 기사단의 몰락과 함께 깃든 원한은 적의 방패와 갑옷을 종잇장처럼 구기고 파괴하는 극악의 근력을 부여합니다."
    },
    {
      "name": "왕의 행진 장화",
      "slot": "Boots",
      "minRarity": "unique",
      "maxRarity": "unique",
      "desc": "금실로 수놓아진 화려한 장화입니다. 착용자가 걷는 속도에 맞춰 주변 아군들의 사기와 이동 속도를 동기화시키는 통치자의 오라를 내뿜습니다."
    },
    {
      "name": "붉은 행진",
      "slot": "Boots",
      "minRarity": "legendary",
      "maxRarity": "legendary",
      "desc": "수만 명의 적을 쓰러뜨린 정복자의 장화입니다. 적의 피로 물든 붉은 가죽은 승리의 기운을 내뿜으며, 전투가 지속될수록 착용자의 지치지 않는 활력을 보충해 줍니다."
    },
    {
      "name": "왕권의 인장",
      "slot": "Ring",
      "minRarity": "legendary",
      "maxRarity": "legendary",
      "desc": "찬란했던 제국의 황제가 사용하던 인장입니다. 이 반지를 낀 자의 목소리는 곧 법이 되며, 의지가 약한 적들은 무릎을 꿇고 복종하게 만드는 제왕의 위압감을 풍깁니다."
    },
    {
      "name": "타락한 피의 왕 인장",
      "slot": "Ring",
      "minRarity": "demonic",
      "maxRarity": "demonic",
      "desc": "피의 갈증에 미쳐버린 고대 왕의 인장입니다. 전장에 피가 많이 뿌려질수록 착용자의 근력과 속도가 기하급수적으로 상승하며, 죽기 직전까지 광란의 춤을 추게 합니다."
    },
    {
      "name": "혼돈의 정화 반지", "slot": "Ring", "minRarity": "angelic", "maxRarity": "angelic", "desc": "뒤틀린 차원의 혼돈조차 질서의 빛으로 정돈합니다. 미쳐버린 자들을 제정신으로 돌려놓으며, 무질서하게 날뛰는 마력 폭주를 가라앉히는 평온의 반지입니다."},
    {"name": "피로 물든 자비의 인장",
      "slot": "Ring",
      "minRarity": "angelic",
      "maxRarity": "angelic",
      "desc": "자비로운 신의 눈물을 피로 씻어낸 형태입니다. 적에게 가한 고통만큼 아군을 치유하는 독특한 성질을 가지며, 희생을 통해 더 큰 기적을 불러일으킵니다."
    },
    {
      "name": "가득찬 마력의 백색 구두", "slot": "Boots", "minRarity": "angelic", "maxRarity": "angelic", "desc": "순수한 마력 그 자체를 고착화하여 빚어낸 구두입니다. 걷는 곳마다 빛의 꽃이 피어나며, 착용자의 발이 대지에 닿기도 전에 마력의 쿠션이 충격을 흡수하여 구름 위를 걷는 듯한 부유감을 선사합니다."},
    {"name": "찬란한 유산의 실키얀 글로브", "slot": "Gloves", "minRarity": "angelic", "maxRarity": "angelic", "desc": "천계의 누에가 뽑아낸 마력 실로 짰습니다. 솜사탕처럼 가볍지만 그 인장 강도는 어떤 금속보다 질기며, 착용자의 손을 부드러운 빛의 장막으로 감싸 모든 상처를 즉시 치유합니다."},
    {"name": "영명한 천상의 날개", "slot": "Armor", "minRarity": "angelic", "maxRarity": "angelic", "desc": "갑옷이라기보다 빛나는 날개들이 신체를 감싸고 있는 형태에 가깝습니다. 중력을 무시하는 천상의 힘이 깃들어 있어, 착용자를 지상의 물리 법칙으로부터 자유롭게 하며 하늘을 유영하듯 움직이게 합니다."},
    {"name": "샤이닝 인페르노", "slot": "Sword", "minRarity": "angelic", "maxRarity": "angelic", "desc": "천상의 불꽃을 가둔 검입니다. 휘두를 때마다 하얀 불꽃이 일렁이며, 그 불꽃에 닿는 모든 악은 재가 되어 사라질 때까지 멈추지 않고 타오릅니다."},
    {"name": "왕의 성흔 펜던트",
      "slot": "Necklace",
      "minRarity": "angelic",
      "maxRarity": "angelic",
      "desc": "진정한 왕으로 선택받은 자만이 가질 수 있는 성스러운 증표입니다. 주변 모든 생명체에게 복종의 오라를 발산하며, 착용자의 말 한마디가 곧 물리적인 충격파가 되는 왕권의 위엄을 부여합니다."
    },
    {
      "name": "붉은 계약 펜던트",
      "slot": "Necklace",
      "minRarity": "demonic",
      "maxRarity": "demonic",
      "desc": "피로 쓰인 계약서의 파편입니다. 적을 타격하여 흘린 피를 흡수해 착용자의 생명력을 회복시키며, 피 냄새를 맡을수록 착용자를 광기 어린 전투 기계로 만듭니다."
    },
    {
      "name": "구원받은 성흔 펜던트",
      "slot": "Necklace",
      "minRarity": "angelic",
      "maxRarity": "angelic",
      "desc": "타락했던 영혼이 회개하여 얻은 빛의 흔적입니다. 과거의 어둠을 빛으로 정화하여 사용하는 힘이 깃들어 있으며, 악한 성향의 적에게 가하는 모든 공격에 신성 추가 피해를 입힙니다."
    },
    {
      "name": "타락성의 흑요 투구",
      "slot": "Helmet",
      "minRarity": "demonic",
      "maxRarity": "demonic",
      "desc": "하늘에서 떨어진 불길한 흑요석을 악마의 불꽃으로 제련했습니다. 투구 주변의 에너지를 끊임없이 빨아들여 검은 빛을 내뿜으며, 착용자의 이성을 대가로 파괴적인 마력을 선사합니다."
    },
    {
      "name": "암야의 몰락 면갑",
      "slot": "Helmet",
      "minRarity": "demonic",
      "maxRarity": "demonic",
      "desc": "멸망한 세계의 마지막 밤을 가두어 만든 면갑입니다. 이를 착용하면 주변의 모든 빛이 왜곡되어 사라지며, 오직 종말을 앞둔 자만이 느낄 수 있는 절대적인 절망감이 전장을 지배합니다."
    },
    {
      "name": "심연 추적자의 각반",
      "slot": "Boots",
      "minRarity": "demonic",
      "maxRarity": "demonic",
      "desc": "심연 속으로 도망친 배신자들을 쫓기 위해 지옥의 금속으로 제련되었습니다. 어둠이 깊을수록 이동 속도가 빨라지며, 적의 영혼이 남긴 자취를 붉은 안개 형태로 시각화하여 보여줍니다."
    },
    {
      "name": "파멸의 흑풍 장화",
      "slot": "Boots",
      "minRarity": "demonic",
      "maxRarity": "demonic",
      "desc": "검은 폭풍을 타고 달리는 듯한 속도를 제공합니다. 지나간 자리에는 강력한 회오리가 남아 뒤따라오는 적들을 공중으로 날려버리며 전장을 난장판으로 만듭니다."
    },
    {
      "name": "타락한 결속 건틀릿",
      "slot": "Gloves",
      "minRarity": "demonic",
      "maxRarity": "demonic",
      "desc": "결코 풀리지 않는 저주받은 사슬로 손과 무기를 강제로 결속합니다. 무기를 버리는 자유를 대가로 죽을 때까지 지치지 않는 광적인 공격력과 살육의 본능을 얻게 됩니다. "
    },
    {
      "name": "심야 군주의 암반지",
      "slot": "Ring",
      "minRarity": "demonic",
      "maxRarity": "demonic",
      "desc": "밤의 지배자였던 고대 흡혈귀의 유산입니다. 그림자 속에서 착용자의 공격력을 증폭시키며, 적에게 입힌 피해의 일부를 착용자의 생명력으로 전환합니다."
    },
    {
      "name": "어둠 장막의 목걸이",
      "slot": "Necklace",
      "minRarity": "demonic",
      "maxRarity": "demonic",
      "desc": "착용자의 주변에 상시 짙은 어둠의 장막을 형성합니다. 원거리에서 날아오는 화살이나 마법이 장막에 닿으면 궤적이 뒤틀려 착용자를 빗겨나가게 만듭니다."
    }
  ],
  "akito": [
    {
      "name": "악의로 가득찬 니힐리즘 단검",
      "slot": "Sword",
      "minRarity": "demonic",
      "maxRarity": "demonic",
      "desc": "허무와 파멸의 의지가 담겨 있습니다. 적의 모든 희망적인 마법 효과를 무효화하며, 존재 자체를 부정하듯 적의 최대 체력을 영구적으로 깎아냅니다."
    },
    {
      "name": "악의의 단도 ‘환불불가’",
      "slot": "Sword",
      "minRarity": "legendary",
      "maxRarity": "legendary",
      "desc": "한 번이라도 적의 피를 묻히면 그 대가를 반드시 받아냅니다. 공격 성공 시 적의 골드나 아이템을 일정 확률로 강탈하며, 장비 내구도에 직접적인 손상을 가합니다."
    },
    {
      "name": "피의 거래 흉갑",
      "slot": "Armor",
      "minRarity": "demonic",
      "maxRarity": "demonic",
      "desc": "악마와 피의 계약을 맺어 얻어낸 갑옷입니다. 착용자가 적을 벨 때마다 그 피를 흡수하여 더욱 견고해지며, 전투가 길어질수록 무적에 가까운 방어력을 보여주지만 그 끝은 항상 비극적입니다."
    },
    {
      "name": "악의의 인장",
      "slot": "Ring",
      "minRarity": "demonic",
      "maxRarity": "demonic",
      "desc": "착용자가 품은 순수한 악의를 물리적인 힘으로 변환합니다. 증오가 깊을수록 반지의 위력은 강해지며, 공격당한 적에게 낫지 않는 저주받은 상처를 남깁니다."
    },
    {
      "name": "대악마의 봉인",
      "slot": "Ring",
      "minRarity": "demonic",
      "maxRarity": "demonic",
      "desc": "지옥의 군주 중 한 명을 봉인했던 고리의 파편입니다. 반지에 깃든 악마의 기운은 적들의 정신을 붕괴시키며, 착용자에게는 그림자를 조종하는 강력한 암흑 마법을 허용합니다."
    },
    {
      "name": "악마의 후드",
      "slot": "Helmet",
      "minRarity": "legendary",
      "maxRarity": "legendary",
      "desc": "하급 악마의 가죽을 통째로 벗겨 만든 후드입니다. 가죽에 남은 악마의 잔류 사념은 착용자의 신체 능력을 폭발적으로 끌어올리지만, 가끔 주인의 의지를 무시하고 날뛰기도 합니다."
    },
    {
      "name": "파멸의 장갑",
      "slot": "Gloves",
      "minRarity": "legendary",
      "maxRarity": "legendary",
      "desc": "닿는 모든 것을 붕괴시키는 파괴의 입자가 끊임없이 손을 감싸고 있습니다. 이 장갑이 닿는 벽은 무너지고, 적의 무기는 부식되며, 대지는 생명력을 잃고 재가 되어 흩어집니다."
    },
    {
      "name": "불온한 발걸음",
      "slot": "Boots",
      "minRarity": "legendary",
      "maxRarity": "legendary",
      "desc": "불길한 기운이 발끝에서 끊임없이 피어오릅니다. 당신이 걷는 땅은 서서히 부식되며, 주변의 생명체들은 당신의 발소리만 듣고도 본능적인 공포에 질려 도망치게 됩니다."
    }
  ],
  "touya": [
    {
      "name": "그림자 질주",
      "slot": "Boots",
      "minRarity": "legendary",
      "maxRarity": "legendary",
      "desc": "착용자의 육체를 일시적으로 그림자 화(化) 시킵니다. 질주하는 동안에는 모든 물리적 충돌을 무시하고 통과하며, 바람보다 빠른 속도로 전장을 가로지르는 검은 섬광이 됩니다."
    },
    {
      "name": "잔영 건틀릿",
      "slot": "Gloves",
      "minRarity": "demonic",
      "maxRarity": "demonic",
      "desc": "심연의 안개를 고착화하여 만들었습니다. 장갑을 낀 손이 움직일 때마다 수만 개의 검은 손들이 잔상으로 나타나 함께 적을 공격하며, 적의 시야를 어둠으로 가려버립니다."
    },
    {
      "name": "에너지 드레인 인장",
      "slot": "Ring",
      "minRarity": "demonic",
      "maxRarity": "demonic",
      "desc": "접촉하는 모든 대상으로부터 활력을 앗아갑니다. 적뿐만 아니라 주변 식물이나 환경의 생명력까지 빨아들여 착용자의 스태미나를 강제로 유지시킵니다."
    },
    {
      "name": "칠흑의 그림자 가면",
      "slot": "Helmet",
      "minRarity": "legendary",
      "maxRarity": "legendary",
      "desc": "빛이 닿지 않는 심연의 가장 어두운 구석을 도려내어 가면으로 빚었습니다. 착용자는 빛의 세계에서 지워지며, 오직 그림자 속에서만 실체를 가질 수 있는 반투명한 암살자로 변모합니다."
    },
    {
      "name": "심야의 갑주",
      "slot": "Armor",
      "minRarity": "legendary",
      "maxRarity": "legendary",
      "desc": "태양이 영원히 뜨지 않는 영원의 밤에서 가져온 물질로 제작되었습니다. 빛을 거부하는 이 갑옷은 어둠 속에서 착용자의 형상을 완전히 지워버리며, 심연의 공포를 적들의 마음속에 직접 주입합니다."
    },
    {
      "name": "도주자의 절단검",
      "slot": "Sword",
      "minRarity": "demonic",
      "maxRarity": "demonic",
      "desc": "등 뒤를 공격할 때 잔혹한 위력을 발휘합니다. 도망치는 적의 발목을 절단하는 데 특화되어 있으며, 비겁한 수단일수록 검은 마력이 더욱 강하게 요동칩니다."
    }
  ]
};
const EQUIP_DROP_CHANCE = {
            normal: 0.020,
            elite: 0.20,
            royal: 0.25,
            boss: 0.30,
            archdemon: 0.28
        };

        // ---------------------------------------------------------
        // [옵션] 네임드(전용/전역) 고정옵션/시그니처 특수옵션 정책
        //  - 기본값은 장비패치.txt 철학(랜덤성)을 우선: 고정 스탯은 OFF,
        //    전용 네임드만 '특수옵션 1개'를 테마에 맞게 뽑아주는 정도로만 개입합니다.
        // ---------------------------------------------------------
        // 'off' | 'legacy' | 'legacy_exclusive'
        const NAMED_FIXED_MODS_MODE = 'legacy';
        // 'off' | 'signature' | 'legacy'
        const NAMED_SPECIALS_MODE = 'signature';


        // 슬롯 결정 확률 (7-2)
        const EQUIP_SLOT_WEIGHTS = [
            { slot: 'Sword',    weight: 17 },
            { slot: 'Armor',    weight: 17 },
            { slot: 'Helmet',   weight: 16 },
            { slot: 'Gloves',   weight: 17 },
            { slot: 'Boots',    weight: 17 },
            { slot: 'Ring',     weight: 8 },
            { slot: 'Necklace', weight: 8 }
        ];

        // 등급(희귀도) 가중치 W0 → W1 (7-3)
        const EQUIP_RARITY_WEIGHT_W0 = {
            common: 75000,
            uncommon: 20000,
            rare: 4500,
            epic: 900,
            unique: 300,
            legendary: 80,
            demonic: 6,
            angelic: 1.6
        };
        const EQUIP_RARITY_WEIGHT_W1 = {
            common: 60000,
            uncommon: 25000,
            rare: 12000,
            epic: 2500,
            unique: 700,
            legendary: 220,
            demonic: 12,
            angelic: 2.0
        };

        // 티어 확률(4-1)
        const EQUIP_TIER_WEIGHTS = {
            common:    [55, 30, 13,  2,  0], // T5..T1
            uncommon:  [40, 32, 22,  6,  0],
            rare:      [25, 30, 28, 14,  3],
            epic:      [12, 26, 32, 22,  8],
            unique:    [ 5, 20, 35, 28, 12],
            legendary: [ 2, 10, 30, 35, 23],
            demonic:   [ 0,  6, 24, 38, 32],
            angelic:   [ 0,  4, 18, 38, 40]
        };
        const EQUIP_TIER_LABELS = ['T5','T4','T3','T2','T1'];

        // 스탯 범위(2)
        const EQUIP_STAT_RANGES = {
            atk: {
                T5: [0.7,1.0], T4: [1.0,1.3], T3: [1.3,1.6], T2: [1.6,2.0], T1: [2.0,2.5]
            },
            def: {
                T5: [0.9,1.2], T4: [1.2,1.6], T3: [1.6,2.0], T2: [2.0,2.6], T1: [2.6,3.3]
            },
            acc: {
                T5: [0.012,0.020], T4: [0.020,0.028], T3: [0.028,0.036], T2: [0.036,0.045], T1: [0.045,0.055]
            },
            eva: {
                T5: [0.012,0.020], T4: [0.020,0.028], T3: [0.028,0.036], T2: [0.036,0.045], T1: [0.045,0.055]
            },
            critChance: {
                T5: [0.9,1.3], T4: [1.3,1.7], T3: [1.7,2.2], T2: [2.2,3.0], T1: [3.0,4.0]
            },
            critResist: {
                T5: [2.0,3.0], T4: [3.0,4.0], T3: [4.0,5.5], T2: [5.5,7.0], T1: [7.0,8.5]
            },
            magicChance: {
                T5: [0.020,0.030], T4: [0.030,0.050], T3: [0.050,0.070], T2: [0.070,0.090], T1: [0.090,0.120]
            },
            reduceDebuff: {
                T5: [0.10,0.20], T4: [0.20,0.30], T3: [0.30,0.45], T2: [0.45,0.60], T1: [0.60,0.70]
            }
        };

        // 슬롯별 암묵(Implicit) 스탯과 배율(1)
        const EQUIP_IMPLICIT = {
            Helmet:   [{ key:'def', mult:1.00 }, { key:'critResist', mult:1.00 }],
            Sword:    [{ key:'atk', mult:1.60 }, { key:'acc', mult:1.00 }],
            Armor:    [{ key:'def', mult:1.60 }, { key:'eva', mult:1.00 }],
            Gloves:   [{ key:'acc', mult:1.00 }, { key:'critChance', mult:1.00 }],
            Boots:    [{ key:'eva', mult:1.00 }, { key:'critResist', mult:0.70 }],
            Ring:     [{ key:'magicChance', mult:1.00 }, { key:'acc', mult:0.70 }],
            Necklace: [{ key:'magicChance', mult:1.00 }, { key:'def', mult:0.70 }]
        };

        // 접두/접미 (4)
        const PREFIX_NONE_WEIGHT = {
            common: 60, uncommon: 40, rare: 25, epic: 15, unique: 8, legendary: 3, demonic: 2, angelic: 1
        };
        const SUFFIX_NONE_WEIGHT = {
            common: 70, uncommon: 45, rare: 28, epic: 18, unique: 10, legendary: 4, demonic: 3, angelic: 2
        };

        const PREFIX_POOL = [
            // 단일
            { name:'예리한',     mods:[{key:'atk', mult:1.00}], weight: 10 },
            { name:'단단한',     mods:[{key:'def', mult:1.00}], weight: 10 },
            { name:'정밀한',     mods:[{key:'acc', mult:1.00}], weight: 10 },
            { name:'민첩한',     mods:[{key:'eva', mult:1.00}], weight: 10 },
            { name:'날카로운',   mods:[{key:'critChance', mult:1.00}], weight: 10 },
            { name:'굳건한',     mods:[{key:'critResist', mult:1.00}], weight: 10 },
            { name:'마력 깃든',  mods:[{key:'magicChance', mult:1.00}], weight: 9, onlySlots:['Ring','Necklace'] },

            // 2줄 (small = 0.65)
            { name:'기이한',     mods:[{key:'acc', mult:0.65}, {key:'critChance', mult:0.65}], weight: 7 },
            { name:'묵직한',     mods:[{key:'atk', mult:0.65}, {key:'def', mult:0.65}], weight: 7 },
            { name:'경량화된',   mods:[{key:'eva', mult:0.65}, {key:'acc', mult:0.65}], weight: 7 },
            { name:'새겨진',     mods:[{key:'critResist', mult:0.65}, {key:'def', mult:0.65}], weight: 7 }
        ];

        const SUFFIX_POOL = [
            // 2줄 (0.70)
            { suffix:'의 결의',  mods:[{key:'atk', mult:0.70}, {key:'critChance', mult:0.70}], weight: 7 },
            { suffix:'의 수호',  mods:[{key:'def', mult:0.70}, {key:'critResist', mult:0.70}], weight: 7 },
            { suffix:'의 조준',  mods:[{key:'acc', mult:0.70}, {key:'critChance', mult:0.70}], weight: 7 },
            { suffix:'의 도주',  mods:[{key:'eva', mult:0.70}, {key:'acc', mult:0.70}], weight: 7 },

            // 단일
            { suffix:'의 방벽',  mods:[{key:'def', mult:1.00}], weight: 10 },
            { suffix:'의 균열',  mods:[{key:'critResist', mult:1.00}], weight: 10 },
            { suffix:'의 약속',  mods:[{key:'critChance', mult:1.00}], weight: 10 },
            { suffix:'의 집중',  mods:[{key:'acc', mult:1.00}], weight: 10 },
            { suffix:'의 잔영',  mods:[{key:'eva', mult:1.00}], weight: 10 },
            { suffix:'의 축복',  mods:[{key:'magicChance', mult:1.00}], weight: 9, onlySlots:['Ring','Necklace'] }
        ];

        const EQUIP_STAT_LABELS = {
            atk: '공격',
            def: '방어',
            acc: '명중',
            eva: '회피',
            critChance: '치확',
            critResist: '치저',
            magicChance: '매직 찬스',
            atkSpeed: '공속',
            moveSpeed: '이속'
        };

        function clampVal(v, mn, mx) {
            return Math.max(mn, Math.min(mx, v));
        }

        function getRarityOptionMultiplier(rarityKey) {
            return EQUIP_RARITY_OPTION_MULT[rarityKey] ?? 1;
        }
        function scaleGearModsByRarity(mods, rarityKey) {
            if (!mods || !mods.length) return mods || [];
            const rarityMult = getRarityOptionMultiplier(rarityKey);
            if (Math.abs(rarityMult - 1) < 1e-9) return mods;
            return mods.map((m) => {
                if (!m || typeof m.value !== 'number') return m;
                return {
                    ...m,
                    value: roundEquipStatValue(m.key, (m.value || 0) * rarityMult)
                };
            });
        }
        function randInt(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }
        function randFloat(min, max) {
            return Math.random() * (max - min) + min;
        }
        function chooseWeighted(options, weights) {
            let total = 0;
            for (const w of weights) total += w;
            if (total <= 0) return options[0];
            let r = Math.random() * total;
            for (let i = 0; i < options.length; i++) {
                r -= weights[i];
                if (r <= 0) return options[i];
            }
            return options[options.length - 1];
        }


// ---------------------------------------------------------
// [NEW] 네임드(전역) 장비 고정 옵션/전용 특수옵션
//  - 같은 네임드는 항상 비슷한 '고정 옵션'을 갖습니다(결정적 시드)
//  - 네임드 전용 특수옵션은 툴팁에서 별도 섹션으로 강하게 구분됩니다
// ---------------------------------------------------------
function hashStringToSeed(str) {
    // FNV-1a 32bit
    let h = 2166136261 >>> 0;
    const s = String(str ?? '');
    for (let i = 0; i < s.length; i++) {
        h ^= s.charCodeAt(i);
        h = Math.imul(h, 16777619);
    }
    return h >>> 0;
}

function mulberry32(seed) {
    let a = seed >>> 0;
    return function() {
        a |= 0;
        a = (a + 0x6D2B79F5) | 0;
        let t = Math.imul(a ^ (a >>> 15), 1 | a);
        t = (t + Math.imul(t ^ (t >>> 7), 61 | t)) ^ t;
        return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
    };
}

function strIncludesAny(str, keywords) {
    const s = String(str || '');
    for (const k of keywords) {
        if (s.indexOf(k) !== -1) return true;
    }
    return false;
}

function seededRollStatValue(statKey, tierLabel, rng, biasMin = 0.4, biasMax = 0.8) {
    const ranges = (EQUIP_STAT_RANGES[statKey] && EQUIP_STAT_RANGES[statKey][tierLabel]) ? EQUIP_STAT_RANGES[statKey][tierLabel] : [0, 0];
    const t = biasMin + (biasMax - biasMin) * (rng ? rng() : Math.random());
    const v = ranges[0] + (ranges[1] - ranges[0]) * t;
    // 정수/소수 처리
    if (statKey === 'atk' || statKey === 'def') return Math.round(v);
    if (statKey === 'critChance' || statKey === 'critResist') return Math.round(v * 10) / 10;
    return Math.round(v * 10000) / 10000;
}

function pickNamedFocusStat(namedName, slot) {
    const n = String(namedName || '');

    // 확률/주사위/기도 계열 → 매직 찬스
    if (strIncludesAny(n, ['확률','도박','주사위','기만','성환','인장','묵주','기도','찬가','구원','자비','기적','맹세'])) return 'magicChance';
    // 정밀/추적 → 명중
    if (strIncludesAny(n, ['정밀','조준','포착','추적','나침반','명중'])) return 'acc';
    // 그림자/망각/도주 → 회피
    if (strIncludesAny(n, ['그림자','망각','도주','비밀','역행','하프스텝','흔적','후퇴','밟는'])) return 'eva';
    // 철벽/갑주/성채 → 방어
    if (strIncludesAny(n, ['철벽','성채','흉갑','갑주','판금','무쇠','외투','코트','방탄','벽','성배'])) return 'def';
    // 검류 → 공격
    if (slot === 'Sword' && strIncludesAny(n, ['파쇄','절단','대검','단죄','성검','단검','이빨','레이피어','세이버','단두','검'])) return 'atk';
    // 저항/불굴 → 치저
    if (strIncludesAny(n, ['저항','불굴','무결','완벽','방벽'])) return (slot === 'Sword') ? 'critChance' : 'critResist';

    const slotMain = { Helmet:'def', Sword:'atk', Armor:'def', Gloves:'acc', Boots:'eva', Ring:'magicChance', Necklace:'magicChance' };
    return slotMain[slot] || 'def';
}

function pickNamedSecondaryStat(slot, mainStat) {
    const prefs = {
        Helmet:   ['critResist','def','eva','acc'],
        Sword:    ['critChance','acc','atk','eva'],
        Armor:    ['eva','critResist','def','acc'],
        Gloves:   ['critChance','atk','acc','eva'],
        Boots:    ['critResist','acc','eva','def'],
        Ring:     ['acc','critChance','def','magicChance'],
        Necklace: ['def','critResist','acc','magicChance']
    };
    const arr = prefs[slot] || ['def','atk','acc','eva','critChance','critResist','magicChance'];
    for (const k of arr) if (k !== mainStat) return k;
    return arr[0];
}

function buildNamedFixedMods(namedName, rarityKey, slot, meta = {}) {
    // ---------------------------------------------------------
    // 네임드 고정 스탯(옵션)
    //  - 기본값: OFF (장비패치.txt의 '랜덤성' 철학을 우선)
    //  - 필요하면 NAMED_FIXED_MODS_MODE를 'legacy'로 바꾸면
    //    기존 20.txt 스타일(네임드 1~2줄 고정 스탯)을 다시 켤 수 있습니다.
    // ---------------------------------------------------------
    if (!NAMED_FIXED_MODS_MODE || NAMED_FIXED_MODS_MODE === 'off') return [];

    // 전용 네임드에만 적용하고 싶으면(선택): 'legacy_exclusive'
    if (NAMED_FIXED_MODS_MODE === 'legacy_exclusive') {
        if (!meta || meta.namedScope !== 'exclusive') return [];
    }

    // legacy: 원본 20.txt 방식(시드 기반, 드랍할 때마다 같은 네임드는 같은 고정 스탯 경향)
    const idx = EQUIP_RARITY_ORDER[rarityKey] || 0;
    if (idx < EQUIP_RARITY_ORDER.epic) return [];

    const seed = hashStringToSeed(`NM|${namedName}|${rarityKey}|${slot}`);
    const rng = mulberry32(seed);

    const main = pickNamedFocusStat(namedName, slot);
    const sub  = pickNamedSecondaryStat(slot, main);

    const fixedMods = [];
    let modCount = 1;
    if (rarityKey === 'legendary' || rarityKey === 'demonic' || rarityKey === 'angelic') modCount = 2;

    const mainTier =
        rarityKey === 'epic' ? 'T3' :
        rarityKey === 'unique' ? 'T2' :
        rarityKey === 'legendary' ? 'T1' :
        (rarityKey === 'demonic' || rarityKey === 'angelic') ? 'T1' : 'T3';

    const subTier =
        rarityKey === 'legendary' ? 'T2' :
        (rarityKey === 'demonic' || rarityKey === 'angelic') ? 'T1' : 'T3';

    const biasFor = (r, isMain) => {
        if (r === 'epic') return isMain ? [0.55, 0.85] : [0.45, 0.75];
        if (r === 'unique') return isMain ? [0.60, 0.90] : [0.50, 0.80];
        if (r === 'legendary') return isMain ? [0.78, 0.98] : [0.62, 0.88];
        if (r === 'demonic') return isMain ? [0.82, 0.99] : [0.75, 0.95];
        if (r === 'angelic') return isMain ? [0.84, 0.99] : [0.75, 0.95];
        return isMain ? [0.55, 0.85] : [0.45, 0.75];
    };

    const [b0, b1] = biasFor(rarityKey, true);
    fixedMods.push({
        key: main,
        value: seededRollStatValue(main, mainTier, rng, b0, b1),
        tier: mainTier,
        source: 'fixed'
    });

    if (modCount >= 2) {
        const [c0, c1] = biasFor(rarityKey, false);
        fixedMods.push({
            key: sub,
            value: seededRollStatValue(sub, subTier, rng, c0, c1),
            tier: subTier,
            source: 'fixed'
        });
    }

    return fixedMods;
}

function pickReduceKeyForNamed(namedName) {
    const n = String(namedName || '');
    if (strIncludesAny(n, ['혈','피','흉터','혈흔'])) return 'reduceBleedDuration';
    if (strIncludesAny(n, ['방진','면갑','마스크','후드','숨','외투','코트','장막'])) return 'reducePoisonDotDamage';
    if (strIncludesAny(n, ['어둠','심연','악몽','그림자','검은','이단'])) return 'reduceDarknessDuration';
    if (strIncludesAny(n, ['폐허','붕괴','무너진','파손'])) return 'reducePoopPoisonDotDamage';
    if (strIncludesAny(n, ['비린내','어획','바다'])) return 'reduceFishyDotDamage';
    return 'reducePoisonDotDamage';
}

function pickConditionalKeyForNamed(slot, rng) {
    const table = {
        Sword:    ['doubleCritCritChance', 'noHitAttack', 'streakKillAttack'],
        Gloves:   ['noHitAccuracy', 'streakCritAttackSpeed', 'lowHpCritChance'],
        Boots:    ['lowHpEvasion', 'highHpMoveSpeed', 'noHitEvasion'],
        Helmet:   ['highHpDefense', 'recentlyHitDefense', 'debuffedDefense'],
        Armor:    ['highHpDefense', 'bossPresentDefense', 'crowdDefense'],
        Ring:     ['cleanseWindowAccuracy', 'shieldedEvasion', 'debuffedAttackSpeed'],
        Necklace: ['highHpEvasion', 'crowdAttack', 'shieldedAttack']
    };
    const arr = table[slot] || ['highHpDefense', 'noHitAccuracy', 'lowHpEvasion'];
    const r = rng ? rng() : Math.random();
    return arr[Math.floor(r * arr.length)] || arr[0];
}

function buildNamedFixedSpecials(namedName, rarityKey, slot, meta = {}) {
    // ---------------------------------------------------------
    // 전용/네임드 "시그니처 특수옵션"(옵션)
    //  - 장비패치.txt의 룰(Unique 0~1 / Legendary 1 / Demonic 1~2)을 깨지 않도록
    //    레어 옵션(specialMods)과 스페셜 옵션(fixedSpecialMods)은 분리해서 관리합니다.
    //  - SPECIAL_POOL(레어 옵션) 키들은 fixedSpecialMods에 절대 들어가지 않습니다.
    //
    // 모드:
    //  - 'off'      : 사용 안 함
    //  - 'signature': 전용 네임드만, 특수옵션이 생성되는 경우 1개를 테마에 맞게 먼저 배정(권장)
    //  - 'legacy'   : 원본 20.txt 스타일(네임드 고정 특수옵션)
    // ---------------------------------------------------------
    const idx = EQUIP_RARITY_ORDER[rarityKey] || 0;
    if (idx < EQUIP_RARITY_ORDER.unique) return [];

    const budget = (meta && typeof meta.specialBudget === 'number') ? meta.specialBudget : 0;
    if (budget <= 0) return [];

    // 엔젤릭 스페셜 옵션(요청 장비)
    const angelicFixedMap = {
        '샤이닝 인페르노': { key:'angelicShiningInferno', label:'드랍 아이템 획득 시 랜덤 적에게 공격력 1.5배 화염 폭발' },
        '호위무신의 운검': { key:'angelicGuardianRevive', label:'사망 시 최대 HP 10% 회복 + 5초 무적 (게임당 1회)' },
        '창천의 푸르름': { key:'angelicSkyShield', label:'적 공격 회피 시 최대 HP 10% 실드 획득 (10초 쿨타임)' },
        '영명한 천상의 날개': { key:'angelicActiveExtend', label:'액티브 스킬 시전 시 25% 확률 지속시간 2배 (10초 쿨타임)' },
        '찬란한 유산의 실키얀 글로브': { key:'angelicNextHitSure', label:'공격이 회피되면 다음 공격 100% 명중 (3초 쿨타임)' },
        '원시 태동의 결속 장갑': { key:'angelicSupportDouble', label:'상태이상 관련 아이템 획득 시 25% 확률 효과 2배' },
        '약속을 지키는 발걸음': { key:'angelicEliteEvasion', label:'엘리트/로열/보스 적 1명당 회피 +2%' },
        '가득찬 마력의 백색 구두': { key:'angelicCooldownReset', label:'25초마다 랜덤 액티브 스킬 쿨타임 초기화' },
        '혼돈의 정화 반지': { key:'angelicCleansePulse', label:'5초마다 치료 가능한 상태이상 1중첩 정화' },
        '가브리엘의 눈부신 맹세의 성검': { key:'angelicOathSwordNova', label:'6초마다 반경 240 내 최대 4명에게 공격력 60% 성광 폭발 피해' },
        '가브리엘의 성스러운 순백의 외투': { key:'angelicWhiteArmorHeal', label:'어둠 디버프 지속시간 50% 감소' },
        '가브리엘의 영원한 자애의 반지': { key:'angelicMercyRing', label:'체력 35% 이하 시 20초 쿨타임으로 최대 HP 8% 회복' },
        '구원받은 성흔 펜던트': { key:'angelicStigmataCleanse', label:'12초마다 최대 HP의 2% 회복' },
        '구원의 향(香) 목걸이': { key:'angelicAromaEvasion', label:'60초마다 리로드 기회 +1' },
        '기적의 가브리엘 면갑': { key:'angelicMiracleHelmet', label:'12초마다 최대 HP의 5% 실드 획득' },
        '성스러운 정화의 성환': { key:'angelicHolyPurifyRing', label:'사악한 마음 디버프 회피할 확률 25% 추가' },
        '세인트 홀릭 성환': { key:'angelicSaintRing', label:'20초마다 상태이상 보호막 +3' },
        '수호천사의 신성한 방진면': { key:'angelicGuardianMask', label:'가스 중독 디버프를 회피할 확률 50% 추가' },
        '어둠 정화자의 눈부신 판금': { key:'angelicDarknessPurifier', label:'어둠 상태이상 회피할 확률 25%' },
        '왕의 성흔 펜던트': { key:'angelicKingPendant', label:'20초마다 모든 액티브 스킬 쿨타임 1.5초 감소' },
        '인도자의 새크리파이스 장갑': { key:'angelicSacrificeGloves', label:'10초마다 저스티스 실드 1중첩' },
        '찬가의 목걸이': { key:'angelicHymnNecklace', label:'15초마다 5초동안 플레이어의 공격력 5% 상승' },
        '평온의 펜던트': { key:'angelicCalmPendant', label:'엘리트/로열/보스 적 1명당 명중 +2%' },
        '피로 물든 자비의 인장': { key:'angelicBloodMercyRing', label:'엘리트/로열/보스 적 1명당 방어 +1%' },
        '헤르메스의 크리스탈 제이드빛 부츠': { key:'angelicHermesBoots', label:'엘리트/로열/보스 적 1명당 치저 +2%' }
    };
    if (rarityKey === 'angelic' && angelicFixedMap[namedName]) {
        const m = angelicFixedMap[namedName];
        return [{ key:m.key, type:'boolean', label:m.label, tier:'—', value:true, source:'signature' }].slice(0,budget);
    }

    const demonicFixedMap = {
        '심연의 고리': { key:'demonicAbyssLoop', label:'치명타 시 12% 확률로 5초간 치명타 피해 1.2배 (10초 쿨타임)' },
        '배신의 주사위 반지': { key:'demonicBetrayalDice', label:'12초마다 75% 확률로 5초 명중 +8%, 실패 시 5초 명중 -2%' },
        '악몽의 결정 단검': { key:'demonicNightmareDagger', label:'적 타격 시 10% 확률로 적에게 저주 부여' },
        '심연의 독니검': { key:'demonicAbyssFangSword', label:'적 타격 시 3% 확률로 적에게 정화의 독 부여(10초)' },
        '혈흔의 흉갑': { key:'demonicBloodstainArmor', label:'피격 시 5% 확률 최대 HP 2% 회복, 2% 확률 최대 HP 1% 자해' },
        '붕괴한 성배 갑주': { key:'demonicCollapsedGrail', label:'현재 HP 40% 이하일 때 공격력 +5%, 방어력 -5%' },
        '속삭이는 데몬 후드': { key:'demonicWhisperHood', label:'회피 +5%, 명중 -3%' },
        '절규의 건틀릿': { key:'demonicScreamGauntlet', label:'상시 공격력 +5%, 스킬 시전 시 10% 확률 10초 절망' },
        '타락한 추락자의 장화': { key:'demonicFallenBoots', label:'피격 후 2초 이동속도 +5%(10초 쿨), 상시 회피 -3%' },
        '폐허의 목걸이': { key:'demonicRuinNecklace', label:'반경 250 내 적 5명 이상일 때 공격력 +3%, 방어력 -2%' },
        '현실 도피의 인장': { key:'demonicRealityEscapeSigil', label:'디버프 수신 시 3% 무시, 1% 확률 지속시간 +10초' },
        '어둠의 질주의 주술 장화': { key:'demonicDarkSprintBoots', label:'6초마다 1.5초 이속 +7%, 이후 1.5초 이속 -4%' },
        '회피의 손끝': { key:'demonicEvasionFingertip', label:'회피 성공 시 5초간 공격력 +5%, 방어력 -3%' },
        '심야의 흉터가면': { key:'demonicMidnightScarMask', label:'암흑 지속시간 +5초, 상시 공격력 +3%' },
        '추격 불가의 코트': { key:'demonicUntraceableCoat', label:'상시 공격력 +10%, 회피 불가' },
        '어둠의 서약 목걸이': { key:'demonicDarkOathNecklace', label:'카인/아서 존재 시 5초마다 서로 최대 HP 3% 피해' },
        '야행의 서약 펜던트': { key:'demonicNightOathPendant', label:'치명타 확률 -5%, 치명타 피해 +10%' },
        '흑도 ‘무라사메・심연’': { key:'demonicMurasameAbyss', label:'적 타격 시 5% 확률 10초 암흑 부여, 상시 치확 -5%' },
        '다크 돌연변이 인장': { key:'demonicDarkMutationSigil', label:'카인의 향기/똥내 지속시간 25% 증가, 상시 공격력 +4%' },
        '독가스 심장부적': { key:'demonicGasCoreCharm', label:'가스 중독 지속시간 25% 증가, 상시 공격력 +2%' },
        '검은 합창의 성흔': { key:'demonicBlackChorusStigma', label:'5초마다 주변 적 이속 변조(20% -8%, 10% +4%)' },
        '역병의 왕 인장': { key:'demonicPlagueKingSigil', label:'카인의 향기/똥내 지속시간 25% 감소, 상시 공격력 -8%' },
        '타락 성흔의 사슬': { key:'demonicCorruptStigmaChain', label:'로열 빌런 존재 시 공격력 +8%, 방어력 -4%' },
        '검은 계약 펜던트': { key:'demonicBlackContractPendant', label:'해제 불가 디버프 5종 이상 시 치명타 확률 +5%' },
        '심연의 청구서': { key:'demonicAbyssBill', label:'게임 시작 후 60초 명중 +5%, 공격력 +3%, 방어력 -5%' },
        '서늘한 악마의 가면': { key:'demonicCoolDemonMask', label:'이속 감소 상태일 때 치명타 확률 +3%' },
        '악마의 계약을 찢는 손': { key:'demonicTornContractHand', label:'행운 +10, 최종 매직 찬스 -50%' },
        '파멸의 스텝': { key:'demonicDoomStep', label:'회피 성공 시 2초 이속 +4%, 종료 후 1초 이속 -4%' },
        '타락한 왕의 판금': { key:'demonicCorruptKingPlate', label:'카인/아서 피해 -25%, 엘리트/로열 피해 +15%' },
        '타락한 피의 왕 인장': { key:'demonicCorruptBloodKingSigil', label:'출혈 지속시간 50% 증가, 상시 치확 +3%' },
        '붉은 계약 펜던트': { key:'demonicRedContractPendant', label:'치명타 시 최대 HP 1% 회복, 상시 방어 -3% 회피 -4%' },
        '타락성의 흑요 투구': { key:'demonicCorruptObsidianHelm', label:'암흑 지속시간 5초 감소, 상시 공격력 -3%' },
        '암야의 몰락 면갑': { key:'demonicNightfallMask', label:'HP회복 아이템 회복량 -10%, 드랍률 +1%' },
        '심연 추적자의 각반': { key:'demonicAbyssTrackerLeggings', label:'사악한 마음 보유 시 이속 +10%, 미보유 시 -5%' },
        '파멸의 흑풍 장화': { key:'demonicBlackWindBoots', label:'저스티스 실드 보유 시 이속 +5%, 미보유 시 -3%' },
        '타락한 결속 건틀릿': { key:'demonicCorruptBondGauntlet', label:'금서/비석 존재 시 공격력 +10%, 없으면 치확 -2%' },
        '심야 군주의 암반지': { key:'demonicMidnightLordRing', label:'20초마다 2초 은신(무적), 상시 회피 -5%' },
        '어둠 장막의 목걸이': { key:'demonicDarkVeilNecklace', label:'10초마다 1초 은신(무적), 상시 명중 -5%' },
        '악의로 가득찬 니힐리즘 단검': { key:'demonicNihilismDagger', label:'상시 치명타 확률 +10%, 치명타 저항 -5%' },
        '피의 거래 흉갑': { key:'demonicBloodTradeArmor', label:'적 처치 시 10% 확률 HP 3% 회복, 상시 방어 -4%' },
        '악의의 인장': { key:'demonicMaliceSigil', label:'악의의 바이러스 지속시간 25% 증가, 상시 공격력 +2%' },
        '대악마의 봉인': { key:'demonicArchdemonSeal', label:'대악마 아키토/토우야 존재 시 공격력 +10%, 상시 방어 -2%' },
        '잔영 건틀릿': { key:'demonicAfterimageGauntlet', label:'버서크 지속시간 +5초, 상시 방어 -10%' },
        '에너지 드레인 인장': { key:'demonicEnergyDrainSigil', label:'치명타 시 10% 확률 액티브 스킬 쿨타임 1초 감소, 상시 공격력 -2%' },
        '도주자의 절단검': { key:'demonicRunnerCutter', label:'HP 40% 이하 치확 +5%, 치명타 저항 -8%' }
    };
    if (rarityKey === 'demonic' && demonicFixedMap[namedName]) {
        const m = demonicFixedMap[namedName];
        return [{ key:m.key, type:'boolean', label:m.label, tier:'—', value:true, source:'signature' }].slice(0,budget);
    }

    if (!NAMED_SPECIALS_MODE || NAMED_SPECIALS_MODE === 'off') return [];

    // ---------------------------------------------------------
    // NOTE: 레어 옵션(specialMods) 전용 키는 fixedSpecialMods(스페셜 옵션)에서 제외
    //  - reduce 5종 + immune 1종 + conditional 5종은 SPECIAL_POOL(레어 옵션 풀)로만 굴립니다.
    //  - 따라서 (angelicFixedMap 같은 '고유 스페셜 옵션'을 제외하면) 여기서 추가로 고정 스페셜 옵션을 생성하지 않습니다.
    // ---------------------------------------------------------
    return [];
}




        function getEnemyCategory(enemy) {
            if (!enemy) return 'normal';
            if (enemy.isArchdemon) return 'archdemon';
            if (enemy.isBoss) return 'boss';
            if (enemy.isRoyal) return 'royal';
            if (enemy.isElite) return 'elite';
            return 'normal';
        }

        function getEnemyDropSourceLabel(enemy) {
            if (!enemy) return '';

            const exKey = getEnemyExclusiveKey(enemy);
            if (exKey) return getExclusiveLabel(exKey);

            if (enemy.isAgent) {
                if (enemy.agentType === 'curse') return '공작원(저주)';
                if (enemy.agentType === 'pain') return '공작원(고통)';
                return '공작원(실명)';
            }

            if (enemy.normalType === 'rapist') {
                if (enemy.isStealth) return '강간범 (은신)';
                if (enemy.isAmbush) return '강간범 (매복)';
                return '강간범';
            }

            if (enemy.normalType === 'summoner') {
                if (enemy.eliteType === 1) return '소환사(테러범)';
                if (enemy.eliteType === 2) return '소환사(역병)';
                return '소환사(덮치기범)';
            }

            if (enemy.isZako) {
                if (enemy.zakoType === 'terrorist') return '자코(테러범)';
                if (enemy.zakoType === 'plague') return '자코(역병)';
                return '자코(덮치기범)';
            }

            return '';
        }


        // ---------------------------------------------------------
        // 전용 네임드(특정 적 전용 드랍) 키/룰 (장비패치.txt 7-7, 9)
        // ---------------------------------------------------------
        function getEnemyExclusiveKey(enemy) {
            if (!enemy) return null;

            // 대악마
            if (enemy.isArchdemon) {
                const n = String(enemy.archdemonName || '');
                if (n.includes('아키토')) return 'akito';
                if (n.includes('토우야')) return 'touya';
                return null;
            }

            // 보스
            if (enemy.isBoss) {
                if (enemy.isArthur) return 'arthur';
                return 'cain';
            }

            // 로열
            if (enemy.isRoyal) {
                if (enemy.isMasakuni) return 'masakuni';
                if (enemy.isKaito) return 'kaito';
                if (enemy.isQuesta) return 'questa';
                if (enemy.isTetora) return 'tetora';
                return null;
            }

            // 엘리트 (아키 복제는 제외, 카이 보스는 제외)
            if (enemy.isElite) {
                if (enemy.isRyuon) return 'ryuon';
                if (enemy.isLuca) return 'luca';
                if (enemy.isOzma) return 'ozma';
                if (enemy.isTaro) return 'taro';
                if (enemy.isGawain) return 'gawain';
                if (enemy.isAki && !enemy.isAkiClone) return 'aki';
                if (enemy.isHiro) return 'hiro';
                if (enemy.isKai && !enemy.isBoss) return 'kai';
                if (enemy.isJacques) return 'jacques';
                if (enemy.isCassias) return 'cassias';
            }

            return null;
        }

        function getExclusiveLabel(exKey) {
            if (!exKey) return '';
            return (EXCLUSIVE_NAMED_LABELS && EXCLUSIVE_NAMED_LABELS[exKey]) ? EXCLUSIVE_NAMED_LABELS[exKey] : exKey;
        }

        function isRarityWithinRange(rarityKey, minKey, maxKey) {
            const r = EQUIP_RARITY_ORDER[rarityKey] ?? 0;
            const mn = EQUIP_RARITY_ORDER[minKey] ?? 0;
            const mx = EQUIP_RARITY_ORDER[maxKey] ?? 0;
            return (r >= mn && r <= mx);
        }

        function pickExclusiveNamedItem(exKey, rarityKey, slot) {
            const pool = (EXCLUSIVE_NAMED_ITEMS && EXCLUSIVE_NAMED_ITEMS[exKey]) ? EXCLUSIVE_NAMED_ITEMS[exKey] : [];
            if (!pool || !pool.length) return null;
            const filtered = pool.filter(it => it && it.slot === slot && isRarityWithinRange(rarityKey, it.minRarity, it.maxRarity));
            if (!filtered.length) return null;
            return filtered[randInt(0, filtered.length - 1)];
        }

        function rollTier(rarityKey) {
            const w = EQUIP_TIER_WEIGHTS[rarityKey] || EQUIP_TIER_WEIGHTS.common;
            const idx = chooseWeighted([0,1,2,3,4], w);
            return EQUIP_TIER_LABELS[idx] || 'T5';
        }

        function roundEquipStatValue(statKey, v) {
            if (statKey === 'atk' || statKey === 'def' || statKey === 'critChance' || statKey === 'critResist') {
                return Math.round(v * 10) / 10;
            }
            // acc/eva/magicChance/reduceDebuff는 소수(확률)
            return Math.round(v * 10000) / 10000;
        }

        function rollStatValue(statKey, tierLabel) {
            const ranges = (EQUIP_STAT_RANGES[statKey] && EQUIP_STAT_RANGES[statKey][tierLabel]) ? EQUIP_STAT_RANGES[statKey][tierLabel] : [0, 0];
            const v = randFloat(ranges[0], ranges[1]);
            return roundEquipStatValue(statKey, v);
        }

        function computeRarityWeights(scoreSec, enemyCategory, magicChance) {
            const t = 1 - Math.exp(-(scoreSec || 0) / 150);
            const w = {};
            for (const r of EQUIP_RARITIES) {
                const w0 = (EQUIP_RARITY_WEIGHT_W0[r] ?? 0);
                const w1 = (EQUIP_RARITY_WEIGHT_W1[r] ?? 0);
                w[r] = w0 * (1 - t) + w1 * t;
            }

            // 매직 찬스: 상위 등급일수록 가중치 보너스(7-4)
            const mc = clampVal((magicChance || 0), 0, 0.25);
            if (mc > 0) {
                for (const r of EQUIP_RARITIES) {
                    const idx = EQUIP_RARITY_ORDER[r] || 0;
                    w[r] *= (1 + mc * idx * 1.25);
                }
            }

            // 적 카테고리별 상위 등급 가중치 보정(7-5)
            const applyMulFrom = (fromRarityKey, mul) => {
                const fromIdx = EQUIP_RARITY_ORDER[fromRarityKey] || 0;
                for (const r of EQUIP_RARITIES) {
                    if ((EQUIP_RARITY_ORDER[r] || 0) >= fromIdx) w[r] *= mul;
                }
            };

            if (enemyCategory === 'elite') {
                applyMulFrom('rare', 1.15);
            } else if (enemyCategory === 'royal') {
                applyMulFrom('rare', 1.30);
            } else if (enemyCategory === 'boss') {
                applyMulFrom('rare', 1.55);
            } else if (enemyCategory === 'archdemon') {
                applyMulFrom('rare', 1.70);
                // 엔젤릭 드랍 차단(장비패치.txt 7-6)
                w.angelic = 0;
            }

            return w;
        }

        function rollRarity(scoreSec, enemyCategory, magicChance) {
            const w = computeRarityWeights(scoreSec, enemyCategory, magicChance);
            const options = EQUIP_RARITIES.slice();
            const weights = options.map(r => w[r] || 0);
            return chooseWeighted(options, weights);
        }

        function rollSlot() {
            const options = EQUIP_SLOT_WEIGHTS.map(o => o.slot);
            const weights = EQUIP_SLOT_WEIGHTS.map(o => o.weight);
            return chooseWeighted(options, weights);
        }

        function pickBaseItem(slot) {
            const pool = (EQUIP_BASE_ITEMS && EQUIP_BASE_ITEMS[slot]) ? EQUIP_BASE_ITEMS[slot] : [];
            if (!pool.length) return { name: '이름 없는 장비', desc: '' };
            return pool[randInt(0, pool.length - 1)];
        }

        function pickNamedItem(rarityKey, slot) {
            const pool = (WORLD_NAMED_ITEMS && WORLD_NAMED_ITEMS[rarityKey]) ? WORLD_NAMED_ITEMS[rarityKey] : [];
            const filtered = pool.filter(it => it.slot === slot);
            if (!filtered.length) return null;
            return filtered[randInt(0, filtered.length - 1)];
        }


        // ---------------------------------------------------------
        // [FIX] 장비 부위별(투구/갑옷/신발/장갑/무기/목걸이/반지) 옵션 편향
        //  - 접두/접미 옵션 풀 자체는 유지하되, 부위별로 가중치를 달리하여
        //    모든 부위가 '비슷하게' 뜨는 느낌을 완화합니다.
        // ---------------------------------------------------------
        const SLOT_AFFIX_STAT_WEIGHT = {
            Sword:    { atk:1.60, acc:1.30, critChance:1.20, def:0.35, eva:0.35, critResist:0.35, magicChance:0.10 },
            Armor:    { def:1.60, eva:1.10, critResist:1.20, acc:0.45, critChance:0.45, atk:0.35, magicChance:0.10 },
            Helmet:   { def:1.40, critResist:1.30, acc:0.80, eva:0.60, critChance:0.50, atk:0.30, magicChance:0.10 },
            Gloves:   { acc:1.40, critChance:1.20, atk:0.90, def:0.60, eva:0.60, critResist:0.50, magicChance:0.10 },
            Boots:    { eva:1.40, acc:1.00, critResist:0.90, def:0.70, critChance:0.60, atk:0.30, magicChance:0.10 },
            Ring:     { magicChance:1.60, acc:1.00, critChance:0.90, def:0.70, eva:0.70, critResist:0.70, atk:0.15 },
            Necklace: { magicChance:1.60, def:1.00, critResist:0.90, acc:0.70, critChance:0.70, eva:0.60, atk:0.15 }
        };

        function affixWeightForSlot(mods, slot, baseWeight) {
            const map = SLOT_AFFIX_STAT_WEIGHT[slot];
            if (!map || !Array.isArray(mods)) return baseWeight;

            let mul = 1;
            for (const m of mods) {
                const k = m && m.key;
                if (!k) continue;
                const km = map[k];
                if (km != null) mul *= km;
            }

            const w = (baseWeight || 1) * mul;
            return Math.max(0.0001, w);
        }

        function choosePrefix(rarityKey, slot) {
            const noneW = PREFIX_NONE_WEIGHT[rarityKey] ?? 0;
            const pool = PREFIX_POOL.filter(p => !p.onlySlots || p.onlySlots.includes(slot));
            const options = [];
            const weights = [];
            if (noneW > 0) {
                options.push(null);
                weights.push(noneW);
            }
            for (const p of pool) {
                options.push(p);
                weights.push(affixWeightForSlot(p.mods, slot, p.weight || 1));
            }
            return chooseWeighted(options, weights);
        }

        function chooseSuffix(rarityKey, slot) {
            const noneW = SUFFIX_NONE_WEIGHT[rarityKey] ?? 0;
            const pool = SUFFIX_POOL.filter(s => !s.onlySlots || s.onlySlots.includes(slot));
            const options = [];
            const weights = [];
            if (noneW > 0) {
                options.push(null);
                weights.push(noneW);
            }
            for (const s of pool) {
                options.push(s);
                weights.push(affixWeightForSlot(s.mods, slot, s.weight || 1));
            }
            return chooseWeighted(options, weights);
        }

        function buildName(prefixObj, baseName, suffixObj) {
            let name = '';
            if (prefixObj && prefixObj.name) name += prefixObj.name + ' ';
            name += baseName;
            if (suffixObj && suffixObj.suffix) name += suffixObj.suffix;
            return name;
        }

        // ---------------------------------------------------------
        // Special 옵션(유니크/레전더리/데모닉/엔젤릭) - 장비패치.txt 6)
        // ---------------------------------------------------------
        const SPECIAL_POOL = [
            // 디버프 감소(지속/도트)
            { key:'reduceBleedDuration',        type:'reduce', label:'출혈 지속시간 감소',        weight: 9 },
            { key:'reducePoisonDotDamage',      type:'reduce', label:'독(가스) 도트 피해 감소',   weight: 9 },
            { key:'reduceDarknessDuration',     type:'reduce', label:'어둠 지속시간 감소',        weight: 9 },
            { key:'reducePoopPoisonDotDamage',  type:'reduce', label:'똥독 도트 피해 감소',      weight: 9 },
            { key:'reduceFishyDotDamage',       type:'reduce', label:'비린내 도트 피해 감소',    weight: 9 },

            // 저주 종료 피해 면역(레전더리+)
            { key:'immuneCurseEndDamage', type:'boolean', label:'저주 종료 피해 면역', weight: 2, minRarity:'legendary' },

            // 조건부(유니크+)
            { key:'lowHpEvasion',       type:'conditional', label:'체력 30% 이하 회피 증가', weight: 7 },
            { key:'highHpDefense',      type:'conditional', label:'체력 50% 이상 방어 증가', weight: 7 },
            { key:'noHitAccuracy',      type:'conditional', label:'3초 피격 없음 명중 증가', weight: 7 },
            { key:'doubleCritCritChance', type:'conditional', label:'연속 치명타(2회) 치확 증가(4초)', weight: 6 },
            { key:'bossPresentDefense', type:'conditional', label:'보스 존재 시 방어 증가', weight: 6 },

            { key:'lowHpCritChance',    type:'conditional', label:'체력 30% 이하 치확 증가', weight: 6 },
            { key:'lowHpAttackSpeed',   type:'conditional', label:'체력 30% 이하 공속 증가', weight: 6 },
            { key:'highHpEvasion',      type:'conditional', label:'체력 60% 이상 회피 증가', weight: 6 },
            { key:'highHpMoveSpeed',    type:'conditional', label:'체력 60% 이상 이동속도 증가', weight: 5 },

            { key:'noHitEvasion',       type:'conditional', label:'3초 피격 없음 회피 증가', weight: 6 },
            { key:'noHitAttack',        type:'conditional', label:'3초 피격 없음 공격 증가', weight: 6 },
            { key:'recentlyHitDefense', type:'conditional', label:'최근 2초 피격 시 방어 증가', weight: 6 },

            { key:'debuffedDefense',        type:'conditional', label:'디버프 50중첩 이상 시 방어 증가', weight: 5 },
            { key:'debuffedAttackSpeed',    type:'conditional', label:'디버프 50중첩 이상 시 공속 증가', weight: 5 },
            { key:'cleanseWindowAccuracy',  type:'conditional', label:'정화 직후 5초 명중 증가', weight: 5 },

            { key:'shieldedDefense', type:'conditional', label:'상태이상 보호막 보유 시 방어 증가', weight: 5 },
            { key:'shieldedAttack',  type:'conditional', label:'상태이상 보호막 보유 시 공격 증가', weight: 5 },
            { key:'shieldedEvasion', type:'conditional', label:'상태이상 보호막 보유 시 회피 증가', weight: 5 },

            { key:'crowdDefense', type:'conditional', label:'주변 적 5명 이상 시 방어 증가', weight: 5 },
            { key:'crowdAttack',  type:'conditional', label:'주변 적 5명 이상 시 공격 증가', weight: 5 },

            { key:'streakKillAttack',      type:'conditional', label:'5초 내 3연속 처치 시 공격 증가', weight: 5 },
            { key:'streakCritAttackSpeed', type:'conditional', label:'4초 내 2연속 치명타 시 공속 증가', weight: 5 }
        ];

        // NOTE: SPECIAL_POOL(레어 옵션 풀)에 있는 키들은 "레어 옵션"(specialMods) 전용입니다.
        // fixedSpecialMods("스페셜 옵션")에는 절대 포함되지 않도록 아래 Set으로 차단합니다.
        const SPECIAL_MODS_ONLY_KEYS = new Set(SPECIAL_POOL.map(x => x.key));


        function isRarityAtLeast(rarityKey, minRarityKey) {
            return (EQUIP_RARITY_ORDER[rarityKey] || 0) >= (EQUIP_RARITY_ORDER[minRarityKey] || 0);
        }

        function rollReduceValue(rarityKey) {
            const tier = rollTier(rarityKey);
            const v = rollStatValue('reduceDebuff', tier);
            return { tier, value: clampVal(v, 0, 0.95) };
        }

        function rollConditionalValue(rarityKey, condKey) {
            // 조건부 값은 스탯 범위 기반 * 계수 (6-4)
            let baseStat = 'def';
            let mult = 0.8;
            const tier = rollTier(rarityKey);

            const rollFlatByTier = (ranges) => {
                const rr = (ranges && ranges[tier]) ? ranges[tier] : [0, 0];
                return Math.round(randFloat(rr[0], rr[1]) * 10000) / 10000;
            };

            if (condKey === 'lowHpEvasion') { baseStat = 'eva'; mult = 0.8; }
            if (condKey === 'highHpDefense') { baseStat = 'def'; mult = 0.8; }
            if (condKey === 'noHitAccuracy') { baseStat = 'acc'; mult = 0.8; }
            if (condKey === 'doubleCritCritChance') { baseStat = 'critChance'; mult = 0.8; }
            if (condKey === 'bossPresentDefense') { baseStat = 'def'; mult = 0.6; }

            if (condKey === 'lowHpCritChance') { baseStat = 'critChance'; mult = 0.6; }
            if (condKey === 'highHpEvasion') { baseStat = 'eva'; mult = 0.6; }
            if (condKey === 'noHitEvasion') { baseStat = 'eva'; mult = 0.55; }
            if (condKey === 'noHitAttack') { baseStat = 'atk'; mult = 0.55; }
            if (condKey === 'recentlyHitDefense') { baseStat = 'def'; mult = 0.65; }
            if (condKey === 'debuffedDefense') { baseStat = 'def'; mult = 0.6; }
            if (condKey === 'cleanseWindowAccuracy') { baseStat = 'acc'; mult = 0.65; }
            if (condKey === 'shieldedDefense') { baseStat = 'def'; mult = 0.55; }
            if (condKey === 'shieldedAttack') { baseStat = 'atk'; mult = 0.5; }
            if (condKey === 'shieldedEvasion') { baseStat = 'eva'; mult = 0.55; }
            if (condKey === 'crowdDefense') { baseStat = 'def'; mult = 0.6; }
            if (condKey === 'crowdAttack') { baseStat = 'atk'; mult = 0.5; }
            if (condKey === 'streakKillAttack') { baseStat = 'atk'; mult = 0.6; }

            if (condKey === 'lowHpAttackSpeed') {
                return { tier, value: rollFlatByTier({ T5:[0.01,0.02], T4:[0.015,0.025], T3:[0.02,0.035], T2:[0.03,0.05], T1:[0.04,0.06] }), baseStat: 'atkSpeed' };
            }
            if (condKey === 'highHpMoveSpeed') {
                return { tier, value: rollFlatByTier({ T5:[0.01,0.02], T4:[0.015,0.025], T3:[0.02,0.035], T2:[0.03,0.05], T1:[0.04,0.06] }), baseStat: 'moveSpeed' };
            }
            if (condKey === 'debuffedAttackSpeed') {
                return { tier, value: rollFlatByTier({ T5:[0.01,0.02], T4:[0.015,0.025], T3:[0.02,0.03], T2:[0.025,0.04], T1:[0.03,0.05] }), baseStat: 'atkSpeed' };
            }
            if (condKey === 'streakCritAttackSpeed') {
                return { tier, value: rollFlatByTier({ T5:[0.01,0.02], T4:[0.015,0.025], T3:[0.02,0.035], T2:[0.03,0.05], T1:[0.04,0.06] }), baseStat: 'atkSpeed' };
            }

            const raw = rollStatValue(baseStat, tier);
            let v = raw * mult;

            // 정수/소수 포맷 보정
            v = roundEquipStatValue(baseStat, v);

            return { tier, value: v, baseStat };
        }

        function rollSpecialCount(rarityKey) {
            const idx = EQUIP_RARITY_ORDER[rarityKey] || 0;
            if (idx < EQUIP_RARITY_ORDER.unique) return 0;

            if (rarityKey === 'unique') {
                return (Math.random() < 0.30) ? 1 : 0; // 낮은 확률(구현치)
            } else if (rarityKey === 'legendary') {
                return 1;
            } else if (rarityKey === 'demonic') {
                return 2;
            } else if (rarityKey === 'angelic') {
                return 3;
            }
            return 0;
        }

        function rollSpecialOptions(rarityKey, opts = {}) {
            const idx = EQUIP_RARITY_ORDER[rarityKey] || 0;
            if (idx < EQUIP_RARITY_ORDER.unique) return [];

            // opts.count가 있으면 그대로 사용(고정/시그니처 특수옵션과 슬롯 수 맞추기)
            let count = (opts && typeof opts.count === 'number') ? opts.count : rollSpecialCount(rarityKey);
            if (count <= 0) return [];

            const picked = [];
            const usedKeys = new Set((opts && opts.usedKeys) ? opts.usedKeys : []);
            let reduceCount = (opts && typeof opts.reduceCount === 'number') ? opts.reduceCount : 0;

            for (let i = 0; i < 50 && picked.length < count; i++) {
                const pool = SPECIAL_POOL.filter(s => {
                    if (usedKeys.has(s.key)) return false;
                    if (s.type === 'reduce' && reduceCount >= 2) return false; // reduce*는 최대 2종류
                    if (s.minRarity && !isRarityAtLeast(rarityKey, s.minRarity)) return false;
                    return true;
                });
                if (!pool.length) break;
                const opt = chooseWeighted(pool, pool.map(s => s.weight || 1));
                if (!opt) break;

                let payload = { key: opt.key, type: opt.type, label: opt.label };

                if (opt.type === 'boolean') {
                    payload.value = true;
                } else if (opt.type === 'reduce') {
                    const r = rollReduceValue(rarityKey);
                    payload.tier = r.tier;
                    payload.value = r.value;
                    reduceCount++;
                } else if (opt.type === 'conditional') {
                    const c = rollConditionalValue(rarityKey, opt.key);
                    payload.tier = c.tier;
                    payload.value = c.value;
                    payload.baseStat = c.baseStat;
                }

                picked.push(payload);
                usedKeys.add(opt.key);
            }

            return picked;
        }

        function makeGearItem(enemy, enemyCategory, scoreSec, magicChance) {
            const rarity = rollRarity(scoreSec, enemyCategory, magicChance);
            const slot = rollSlot();

            const exKey = getEnemyExclusiveKey(enemy);

            // -----------------------------------------------------
            // 베이스 선택 우선순위 (장비패치.txt 7-7)
            // 1) 전용 네임드(해당 적 전용 풀에 있고, 등급 범위가 맞을 때)
            // 2) 유니크+ : 전역 네임드(해당 등급 풀)
            // 3) 에픽    : 25% 전역 네임드(에픽 풀)
            // 4) 그 외   : 일반 베이스 풀
            // -----------------------------------------------------
            let base = pickBaseItem(slot);
            let named = null;       // base source object (world/exclusive)
            let namedScope = '';    // '', 'world', 'exclusive'
            let dropFromLabel = getEnemyDropSourceLabel(enemy);

            // 1) 전용 네임드 우선
            if (exKey) {
                const exItem = pickExclusiveNamedItem(exKey, rarity, slot);
                if (exItem) {
                    named = exItem;
                    base = { name: exItem.name, desc: exItem.desc || '' };
                    namedScope = 'exclusive';
                    dropFromLabel = `${getExclusiveLabel(exKey)} 전용`;
                }
            }

            // 2) 전역 네임드
            if (!named) {
                if (isRarityAtLeast(rarity, 'unique')) {
                    const wItem = pickNamedItem(rarity, slot);
                    if (wItem) {
                        named = wItem;
                        base = { name: wItem.name, desc: wItem.desc || '' };
                        namedScope = 'world';
                    }
                } else if (rarity === 'epic') {
                    const wItem = pickNamedItem('epic', slot);
                    if (wItem) {
                        named = wItem;
                        base = { name: wItem.name, desc: wItem.desc || '' };
                        namedScope = 'world';
                    }
                }
            }

            // [RULE] 레전더리/데모닉/엔젤릭은 '기본 베이스 풀'에서 나오지 않게 강제
            //  - 전용 네임드/전역 네임드가 안 뽑히면, 같은 슬롯의 '전역 네임드'를 등급 하향 포함해 반드시 선택
            if (!named && (rarity === 'legendary' || rarity === 'demonic' || rarity === 'angelic')) {
                const order = [];
                // 같은 등급부터 시도
                order.push(rarity);
                // 혹시 데이터가 비었을 때를 대비한 하향 폴백(그래도 '네임드'만 사용)
                for (const r of ['angelic','demonic','legendary','unique','epic']) {
                    if (!order.includes(r)) order.push(r);
                }
                for (const r of order) {
                    const wItem = pickNamedItem(r, slot);
                    if (wItem) {
                        named = wItem;
                        base = { name: wItem.name, desc: wItem.desc || '' };
                        namedScope = 'world';
                        break;
                    }
                }
                // 최후 폴백: 슬롯 일치하는 전역 네임드 전체에서 아무거나(등급 무관)
                if (!named) {
                    const pool = [];
                    for (const rr in WORLD_NAMED_ITEMS) {
                        const arr = WORLD_NAMED_ITEMS[rr] || [];
                        for (const it of arr) if (it && it.slot === slot) pool.push(it);
                    }
                    if (pool.length > 0) {
                        const wItem = pool[Math.floor(Math.random() * pool.length)];
                        named = wItem;
                        base = { name: wItem.name, desc: wItem.desc || '' };
                        namedScope = 'world';
                    }
                }
            }


            const prefix = choosePrefix(rarity, slot);
            const suffix = chooseSuffix(rarity, slot);

            const name = buildName(prefix, base.name, suffix);
            const rarityOptionMult = getRarityOptionMultiplier(rarity);

            // implicit 2줄
            const implicitMods = [];
            const imp = EQUIP_IMPLICIT[slot] || [];
            for (const m of imp) {
                const tier = rollTier(rarity);
                const v = rollStatValue(m.key, tier) * (m.mult ?? 1) * rarityOptionMult;
                implicitMods.push({ key: m.key, value: roundEquipStatValue(m.key, v), tier, source: 'implicit' });
            }

            // prefix/suffix mods
            const affixMods = [];
            if (prefix && prefix.mods) {
                for (const mod of prefix.mods) {
                    const tier = rollTier(rarity);
                    const v0 = rollStatValue(mod.key, tier);
                    const v = v0 * (mod.mult ?? 1) * rarityOptionMult;
                    affixMods.push({ key: mod.key, value: roundEquipStatValue(mod.key, v), tier, source: 'prefix', affix: prefix.name });
                }
            }
            if (suffix && suffix.mods) {
                for (const mod of suffix.mods) {
                    const tier = rollTier(rarity);
                    const v0 = rollStatValue(mod.key, tier);
                    const v = v0 * (mod.mult ?? 1) * rarityOptionMult;
                    affixMods.push({ key: mod.key, value: roundEquipStatValue(mod.key, v), tier, source: 'suffix', affix: suffix.suffix });
                }
            }

            // -----------------------------------------------------
            // 특수옵션 개수(장비패치.txt 6-1)
            //  - Unique   : 0~1(낮은 확률)
            //  - Legendary: 1(확정)
            //  - Demonic: 2(확정)
            //  - Angelic: 3(확정)
            //
            // 전용 네임드(특정 적 전용)는 '시그니처 특수옵션'을 최대 1개 먼저 배정하되,
            // 총 특수옵션 슬롯(specialBudget)은 '레어 옵션(specialMods)'의 기본 롤 개수에 사용되며,
            // 스페셜 옵션(fixedSpecialMods)은 네임드 고유 옵션이 있을 때 추가로 붙을 수 있습니다.
            // -----------------------------------------------------
            const isNamedItem = !!named;

            // 총 특수옵션 슬롯 수
            let specialBudget = rollSpecialCount(rarity);

            // legacy 모드(옛 방식)에서는 네임드만 특수옵션 수를 고정(원본 20.txt 느낌)
            if (isNamedItem && NAMED_SPECIALS_MODE === 'legacy') {
                if (rarity === 'unique') specialBudget = 1;
                else if (rarity === 'legendary') specialBudget = 1;
                else if (rarity === 'demonic') specialBudget = 2;
                else if (rarity === 'angelic') specialBudget = 3;
                else specialBudget = 0;
            }

            const meta = {
                namedScope,
                exclusiveKey: (namedScope === 'exclusive') ? exKey : '',
                dropFromLabel,
                enemyCategory,
                specialBudget
            };

            // [옵션] 네임드 고정 스탯 (기본 OFF)
            const fixedModsRaw = isNamedItem ? buildNamedFixedMods(base.name, rarity, slot, meta) : [];
            const fixedMods = scaleGearModsByRarity(fixedModsRaw, rarity);

            // [옵션] 네임드 시그니처/고정 특수옵션 (budget 안에서만)
            const fixedSpecialModsRaw = isNamedItem ? buildNamedFixedSpecials(base.name, rarity, slot, meta) : [];
            const fixedSpecialMods = (fixedSpecialModsRaw || []).filter(m => m && !SPECIAL_MODS_ONLY_KEYS.has(m.key)).slice(0, specialBudget);

            // 나머지 특수옵션을 랜덤으로 채우기 (중복/감소 제한 유지)
            const randomSpecialCount = (rarity === 'demonic' || rarity === 'angelic')
                ? specialBudget
                : Math.max(0, specialBudget - fixedSpecialMods.length);

            const specials = rollSpecialOptions(rarity, {
                count: randomSpecialCount,
                usedKeys: fixedSpecialMods.map(s => s.key),
                reduceCount: fixedSpecialMods.filter(s => s.type === 'reduce').length
            });

            const item = {
                uid: (Date.now().toString(36) + Math.random().toString(36).slice(2, 8)).toUpperCase(),
                slot,
                rarity,
                name,
                baseName: base.name,
                desc: base.desc || '',
                prefixName: prefix ? prefix.name : '',
                suffixName: suffix ? suffix.suffix : '',
                isNamed: isNamedItem,
                namedScope: namedScope,
                dropFromLabel: dropFromLabel,
                exclusiveKey: (namedScope === 'exclusive') ? exKey : '',
                namedKey: isNamedItem ? base.name : '',
                implicitMods,
                fixedMods,
                affixMods,
                fixedSpecialMods,
                specialMods: specials,
                seed: Math.floor(Math.random() * 2147483647)
            };

            // 아이콘 생성(로컬 저장)
            ensureGearIcon(item);

            return item;
        }


        // ---------------------------------------------------------
        // [NEW] 장비 합성용 고정 생성기
        //  - 등급/부위를 고정하여 장비를 생성합니다.
        //  - 전용 네임드(특정 적 전용)는 합성으로는 나오지 않게 제외합니다.
        // ---------------------------------------------------------
        function makeGearItemFixed(rarity, slot, opts = {}) {
            const r = (EQUIP_RARITY_ORDER[rarity] !== undefined) ? rarity : 'common';
            const s = (EQUIP_SLOT_TYPES.includes(slot)) ? slot : 'Sword';

            const enemyCategory = opts.enemyCategory || 'normal';
            const dropFromLabel = (opts.dropFromLabel !== undefined) ? String(opts.dropFromLabel || '') : '장비 합성';

            // -----------------------------------------------------
            // 베이스 선택 우선순위
            // 1) 유니크+ : 전역 네임드(해당 등급 풀)
            // 2) 에픽    : 25% 전역 네임드(에픽 풀)
            // 3) 그 외   : 일반 베이스 풀
            // (전용 네임드는 합성에서 제외)
            // -----------------------------------------------------
            let base = pickBaseItem(s);
            let named = null;       // base source object (world)
            let namedScope = '';    // '', 'world'

            // 전역 네임드
            if (isRarityAtLeast(r, 'unique')) {
                const wItem = pickNamedItem(r, s);
                if (wItem) {
                    named = wItem;
                    base = { name: wItem.name, desc: wItem.desc || '' };
                    namedScope = 'world';
                }
            } else if (r === 'epic') {
                const wItem = pickNamedItem('epic', s);
                if (wItem) {
                    named = wItem;
                    base = { name: wItem.name, desc: wItem.desc || '' };
                    namedScope = 'world';
                }
            }

            const prefix = choosePrefix(r, s);
            const suffix = chooseSuffix(r, s);

            const name = buildName(prefix, base.name, suffix);
            const rarityOptionMult = getRarityOptionMultiplier(r);

            // implicit 2줄
            const implicitMods = [];
            const imp = EQUIP_IMPLICIT[s] || [];
            for (const m of imp) {
                const tier = rollTier(r);
                const v = rollStatValue(m.key, tier) * (m.mult ?? 1) * rarityOptionMult;
                implicitMods.push({ key: m.key, value: roundEquipStatValue(m.key, v), tier, source: 'implicit' });
            }

            // prefix/suffix mods
            const affixMods = [];
            if (prefix && prefix.mods) {
                for (const mod of prefix.mods) {
                    const tier = rollTier(r);
                    const v0 = rollStatValue(mod.key, tier);
                    const v = v0 * (mod.mult ?? 1) * rarityOptionMult;
                    affixMods.push({ key: mod.key, value: roundEquipStatValue(mod.key, v), tier, source: 'prefix', affix: prefix.name });
                }
            }
            if (suffix && suffix.mods) {
                for (const mod of suffix.mods) {
                    const tier = rollTier(r);
                    const v0 = rollStatValue(mod.key, tier);
                    const v = v0 * (mod.mult ?? 1) * rarityOptionMult;
                    affixMods.push({ key: mod.key, value: roundEquipStatValue(mod.key, v), tier, source: 'suffix', affix: suffix.suffix });
                }
            }

            const isNamedItem = !!named;

            // 총 특수옵션 슬롯 수
            let specialBudget = rollSpecialCount(r);

            if (isNamedItem && NAMED_SPECIALS_MODE === 'legacy') {
                if (r === 'unique') specialBudget = 1;
                else if (r === 'legendary') specialBudget = 1;
                else if (r === 'demonic') specialBudget = 2;
                else if (r === 'angelic') specialBudget = 3;
                else specialBudget = 0;
            }

            const meta = {
                namedScope,
                exclusiveKey: '',
                dropFromLabel,
                enemyCategory,
                specialBudget
            };

            // [옵션] 네임드 고정 스탯 (기본 OFF)
            const fixedModsRaw = isNamedItem ? buildNamedFixedMods(base.name, r, s, meta) : [];
            const fixedMods = scaleGearModsByRarity(fixedModsRaw, r);

            // [옵션] 네임드 시그니처/고정 특수옵션 (budget 안에서만)
            const fixedSpecialModsRaw = isNamedItem ? buildNamedFixedSpecials(base.name, r, s, meta) : [];
            const fixedSpecialMods = (fixedSpecialModsRaw || []).filter(m => m && !SPECIAL_MODS_ONLY_KEYS.has(m.key)).slice(0, specialBudget);

            // 나머지 특수옵션을 랜덤으로 채우기 (중복/감소 제한 유지)
            const randomSpecialCount = (r === 'demonic' || r === 'angelic')
                ? specialBudget
                : Math.max(0, specialBudget - fixedSpecialMods.length);

            const specials = rollSpecialOptions(r, {
                count: randomSpecialCount,
                usedKeys: fixedSpecialMods.map(s => s.key),
                reduceCount: fixedSpecialMods.filter(s => s.type === 'reduce').length
            });

            const item = {
                uid: (Date.now().toString(36) + Math.random().toString(36).slice(2, 8)).toUpperCase(),
                slot: s,
                rarity: r,
                name,
                baseName: base.name,
                desc: base.desc || '',
                prefixName: prefix ? prefix.name : '',
                suffixName: suffix ? suffix.suffix : '',
                isNamed: isNamedItem,
                namedScope: namedScope,
                dropFromLabel: dropFromLabel,
                exclusiveKey: '',
                namedKey: isNamedItem ? base.name : '',
                implicitMods,
                fixedMods,
                affixMods,
                fixedSpecialMods,
                specialMods: specials,
                seed: Math.floor(Math.random() * 2147483647)
            };

            ensureGearIcon(item);

            return item;
        }

        // ---------------------------------------------------------
        // 아이콘 렌더링 (간단한 RPG풍 캔버스 드로잉)
        // ---------------------------------------------------------

        // =========================================================
        // [NEW] 장비 PNG 아이콘(유저 파일) 연결
        //  - 랜덤 접두/접미(조합 이름)는 제외하고 baseName 기준으로 아이콘을 찾습니다.
        //  - 폴더 구조(HTML 파일과 같은 위치 기준, 상대경로):
        //      ./gear_icons/helmet/
        //      ./gear_icons/sword/
        //      ./gear_icons/armor/
        //      ./gear_icons/gloves/
        //      ./gear_icons/boots/
        //      ./gear_icons/ring/
        //      ./gear_icons/necklace/
        //
        //  - 기본 파일명 규칙:
        //      sanitizeGearIconFileName(baseName) + ".png"
        //
        //  - 특정 장비만 파일명을 강제하고 싶으면 GEAR_ICON_OVERRIDES에 넣으세요.
        // =========================================================
        const USE_GEAR_FILE_ICONS = true;

        // 폴더 루트(원하면 바꿔도 됩니다)
        const GEAR_ICON_BASE = './gear_icons/';

        // 슬롯 → 폴더 매핑
        const GEAR_ICON_FOLDERS = {
            Helmet: 'helmet/',
            Sword: 'sword/',
            Armor: 'armor/',
            Gloves: 'gloves/',
            Boots: 'boots/',
            Ring: 'ring/',
            Necklace: 'necklace/'
        };

        // 기본 확장자 탐색 순서(권장: png)
        const GEAR_ICON_EXTS = ['png', 'jpg', 'jpeg', 'webp'];

        // 개별 오버라이드(키: baseName / 값: 파일명 또는 경로)
        const GEAR_ICON_OVERRIDES = {
            // 예시) '허름한 대검 ‘뒷골목’': 'special_backalley_greatsword.png',
            // 예시) '낡은 표찰(도그태그)': 'dogtag.png',
            // 예시) '피맹세 파쇄대검': 'boss/ryuon_oathbreaker.png',
        };

        function isPathLikeFile(file) {
            const f = String(file || '').trim();
            if (!f) return false;
            return (
                f.startsWith('data:') ||
                f.startsWith('http://') ||
                f.startsWith('https://') ||
                f.startsWith('/') ||
                f.startsWith('./') ||
                f.startsWith('../') ||
                f.includes('/')
            );
        }

        function sanitizeGearIconFileName(name) {
            // 1) 공백 → _
            // 2) 파일명에 까다로운 문자를 제거(따옴표/괄호/특수기호 등)
            // 3) 한글/영문/숫자/언더스코어/하이픈만 남김
            return String(name || '')
                .trim()
                .replace(/\s+/g, '_')
                .replace(/[’‘“”"']/g, '')
                .replace(/[·]/g, '_')
                .replace(/[(){}\[\]]/g, '')
                .replace(/[\\/:*?<>|]/g, '')
                .replace(/[\u0000-\u001F]/g, '')
                .replace(/[^0-9a-zA-Zㄱ-ㅎㅏ-ㅣ가-힣_-]/g, '')
                .replace(/_+/g, '_')
                .replace(/^_+|_+$/g, '');
        }

        function getGearBaseNameForIcon(item) {
            if (!item) return '';
            // 랜덤 접두/접미가 붙는 display name(name)이 아니라,
            // baseName(베이스/네임드 고유명)을 기준으로 아이콘을 찾습니다.
            const bn = String(item.baseName || '').trim();
            if (bn) return bn;
            return String(item.name || '').trim();
        }

        function getGearIconCandidates(item) {
            if (!USE_GEAR_FILE_ICONS) return [];
            if (!item) return [];

            const slot = String(item.slot || '').trim();
            const baseName = getGearBaseNameForIcon(item);
            if (!slot || !baseName) return [];

            const folder = (GEAR_ICON_FOLDERS && GEAR_ICON_FOLDERS[slot]) ? GEAR_ICON_FOLDERS[slot] : '';
            const baseDir = `${GEAR_ICON_BASE}${folder}`;

            const candidates = [];
            const add = (p) => {
                const v = String(p || '').trim();
                if (!v) return;
                if (!candidates.includes(v)) candidates.push(v);
            };

            // 1) override가 있으면 우선 탐색
            const override = (GEAR_ICON_OVERRIDES && GEAR_ICON_OVERRIDES[baseName]) ? String(GEAR_ICON_OVERRIDES[baseName] || '').trim() : '';
            if (override) {
                if (isPathLikeFile(override)) {
                    add(override);
                } else {
                    add(`${baseDir}${override}`);
                    add(`./${override}`);
                }
            }

            // 2) 추가 규칙: baseName '그대로' 파일명이면 그것도 시도 (공백 포함 가능)
            //    예: ./gear_icons/sword/무딘 단검.png
            const raw = String(baseName || '').trim();
            if (raw) {
                for (const ext of GEAR_ICON_EXTS) {
                    const fn = `${raw}.${ext}`;
                    add(`${baseDir}${fn}`);
                    add(`./${fn}`);
                }

                // 공백을 '_' 로 바꾼 버전도 시도
                const rawUS = raw.replace(/\s+/g, '_');
                if (rawUS && rawUS !== raw) {
                    for (const ext of GEAR_ICON_EXTS) {
                        const fn2 = `${rawUS}.${ext}`;
                        add(`${baseDir}${fn2}`);
                        add(`./${fn2}`);
                    }
                }
            }

            // 3) 기본 규칙(권장): sanitize(baseName).png (특수문자 제거)
            const safe = sanitizeGearIconFileName(baseName);
            if (safe) {
                for (const ext of GEAR_ICON_EXTS) {
                    const fn = `${safe}.${ext}`;
                    add(`${baseDir}${fn}`);
                    add(`./${fn}`);
                }
            }

            return candidates;
        }

        function setImageWithCandidates(imgEl, candidates, fallbackSrc) {
            if (!imgEl) return;

            const list = Array.isArray(candidates) ? candidates.filter(Boolean) : [];
            const fallback = String(fallbackSrc || '').trim();

            // 기존 핸들러 제거(중복 방지)
            imgEl.onerror = null;
            imgEl.onload = null;

            if (!list.length) {
                imgEl.src = fallback;
                return;
            }

            let i = 0;

            const trySet = () => {
                imgEl.src = list[i];
            };

            imgEl.onload = () => {
                // 성공하면 핸들러 정리
                imgEl.onerror = null;
                imgEl.onload = null;
            };

            imgEl.onerror = () => {
                i++;
                if (i < list.length) {
                    trySet();
                } else {
                    imgEl.onerror = null;
                    imgEl.onload = null;
                    imgEl.src = fallback;
                }
            };

            trySet();
        }

        function setGearItemIconToImg(imgEl, gearItem, placeholderSrc) {
            if (!imgEl) return;

            if (!gearItem) {
                imgEl.onerror = null;
                imgEl.onload = null;
                imgEl.src = String(placeholderSrc || '');
                return;
            }

            // fallback(기존 캔버스 아이콘)
            ensureGearIcon(gearItem);
            const fallback = gearItem.icon || String(placeholderSrc || '');

            const candidates = getGearIconCandidates(gearItem);
            if (!candidates.length) {
                imgEl.onerror = null;
                imgEl.onload = null;
                imgEl.src = fallback;
                return;
            }

            setImageWithCandidates(imgEl, candidates, fallback);
        }

        // (선택) 장비 아이콘 파일명 목록을 한번에 뽑고 싶을 때:
        //  - 브라우저 콘솔에서: downloadGearIconManifest()
        function buildGearIconManifest() {
            const rows = [];
            const seen = new Set();

            const push = (slot, name, srcLabel) => {
                const s = String(slot || '').trim();
                const n = String(name || '').trim();
                if (!s || !n) return;

                const key = `${s}|${n}`;
                if (seen.has(key)) return;
                seen.add(key);

                const folder = (GEAR_ICON_FOLDERS && GEAR_ICON_FOLDERS[s]) ? GEAR_ICON_FOLDERS[s] : '';
                const safe = sanitizeGearIconFileName(n);
                const path = safe ? `${GEAR_ICON_BASE}${folder}${safe}.png` : '';

                rows.push({
                    slot: s,
                    slotKo: EQUIP_SLOT_KO[s] || s,
                    name: n,
                    file: safe ? `${safe}.png` : '',
                    relPath: path,
                    source: srcLabel || ''
                });
            };

            // base
            for (const slot of EQUIP_SLOT_TYPES) {
                const pool = (EQUIP_BASE_ITEMS && EQUIP_BASE_ITEMS[slot]) ? EQUIP_BASE_ITEMS[slot] : [];
                for (const it of pool) {
                    if (!it) continue;
                    push(slot, it.name, 'base');
                }
            }

            // world named
            if (typeof WORLD_NAMED_ITEMS === 'object' && WORLD_NAMED_ITEMS) {
                for (const r in WORLD_NAMED_ITEMS) {
                    const pool = WORLD_NAMED_ITEMS[r] || [];
                    for (const it of pool) {
                        if (!it) continue;
                        push(it.slot, it.name, `world:${r}`);
                    }
                }
            }

            // exclusive named
            if (typeof EXCLUSIVE_NAMED_ITEMS === 'object' && EXCLUSIVE_NAMED_ITEMS) {
                for (const k in EXCLUSIVE_NAMED_ITEMS) {
                    const pool = EXCLUSIVE_NAMED_ITEMS[k] || [];
                    for (const it of pool) {
                        if (!it) continue;
                        push(it.slot, it.name, `exclusive:${k}`);
                    }
                }
            }

            // 정렬: 슬롯 → 이름
            rows.sort((a,b) => {
                const sa = EQUIP_SLOT_TYPES.indexOf(a.slot);
                const sb = EQUIP_SLOT_TYPES.indexOf(b.slot);
                if (sa !== sb) return sa - sb;
                return (a.name || '').localeCompare(b.name || '');
            });

            return rows;
        }

        function downloadGearIconManifest() {
            try {
                const rows = buildGearIconManifest();
                const lines = [];
                lines.push('# Gear Icon Manifest');
                lines.push('# Place icons under: ./gear_icons/<slot_folder>/');
                lines.push('# slot_folder: helmet / sword / armor / gloves / boots / ring / necklace');
                lines.push('# Format: [slot]\t[name]\t[relative_path]');
                lines.push('');

                for (const r of rows) {
                    lines.push(`${r.slotKo}\t${r.name}\t${r.relPath}`);
                }

                const blob = new Blob([lines.join('\n')], { type: 'text/plain;charset=utf-8' });
                const url = URL.createObjectURL(blob);

                const a = document.createElement('a');
                a.href = url;
                a.download = 'gear_icon_manifest.txt';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);

                setTimeout(() => URL.revokeObjectURL(url), 1000);
                console.log(`[Gear Icon] Manifest saved: gear_icon_manifest.txt (${rows.length} entries)`);
            } catch (e) {
                console.warn('[Gear Icon] Manifest export failed:', e);
            }
        }

        // 콘솔에서 바로 쓸 수 있게 노출
        window.downloadGearIconManifest = downloadGearIconManifest;


        const _gearSlotPlaceholder = {};

        // 아이콘 렌더 변경 시 올려서 기존 아이콘을 강제 재생성
        const GEAR_ICON_VERSION = 10;


        function drawRoundedRect(g, x, y, w, h, r) {
            const rr = Math.min(r, w/2, h/2);
            g.beginPath();
            g.moveTo(x+rr, y);
            g.arcTo(x+w, y, x+w, y+h, rr);
            g.arcTo(x+w, y+h, x, y+h, rr);
            g.arcTo(x, y+h, x, y, rr);
            g.arcTo(x, y, x+w, y, rr);
            g.closePath();
        }

        function renderSlotPlaceholderIcon(slot) {
            const size = 64;
            const canvas = document.createElement('canvas');
            canvas.width = canvas.height = size;
            const g = canvas.getContext('2d');
            g.clearRect(0,0,size,size);

            g.fillStyle = 'rgba(0,0,0,0.35)';
            drawRoundedRect(g, 3, 3, size-6, size-6, 14);
            g.fill();

            g.strokeStyle = 'rgba(255,255,255,0.18)';
            g.lineWidth = 2;
            drawRoundedRect(g, 4, 4, size-8, size-8, 12);
            g.stroke();

            g.fillStyle = 'rgba(255,255,255,0.55)';
            g.font = '700 12px system-ui, sans-serif';
            g.textAlign = 'center';
            g.textBaseline = 'middle';
            g.fillText(EQUIP_SLOT_KO[slot] || slot, size/2, size/2);

            return canvas.toDataURL('image/png');
        }

        function ensureGearIcon(item) {
            if (!item) return;
            // 기존 저장 데이터의 아이콘이 남아있는 경우(캐시) -> 버전 불일치면 재생성
            if (item.icon && item.iconV === GEAR_ICON_VERSION) return;
            item.icon = renderGearIcon(item, 96);
            item.iconV = GEAR_ICON_VERSION;
        }

        
        // =========================================================
        // [ICON UPGRADE] 디아/POE풍 3D 장비 아이콘 렌더링 (도형감 최소화)
        // - 유기적 실루엣(비대칭), 재질 텍스처(노이즈/스크래치), 베벨/림라이트, AO/내부그림자
        // - item.seed 기반 deterministic (저장/로드해도 동일 아이콘)
        // =========================================================

        function _mulberry32(seed) {
            let a = seed >>> 0;
            return function () {
                a |= 0;
                a = (a + 0x6D2B79F5) | 0;
                let t = Math.imul(a ^ (a >>> 15), 1 | a);
                t = (t + Math.imul(t ^ (t >>> 7), 61 | t)) ^ t;
                return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
            };
        }

        function _hexToRgb(hex) {
            const h = (hex || '#888888').replace('#', '');
            return {
                r: parseInt(h.slice(0, 2), 16),
                g: parseInt(h.slice(2, 4), 16),
                b: parseInt(h.slice(4, 6), 16),
            };
        }
        function _rgba(rgb, a) { return `rgba(${rgb.r},${rgb.g},${rgb.b},${a})`; }
        function _mixRgb(a, b, t) {
            return {
                r: (a.r + (b.r - a.r) * t) | 0,
                g: (a.g + (b.g - a.g) * t) | 0,
                b: (a.b + (b.b - a.b) * t) | 0,
            };
        }
        // =========================================================
        // [ICON DISPATCH]
        // - Legendary+ 는 완전히 분리된 전용 렌더러(renderGearIconLegendary) 사용
        // - 그 외(common~unique)는 기본 렌더러(renderGearIconBase)
        // =========================================================
        function renderGearIcon(item, size) {
            if (!item) return '';
            if (isRarityAtLeast(item.rarity, 'legendary')) return renderGearIconLegendary(item, size);
            return renderGearIconBase(item, size);
        }

        function renderGearIconBase(item, size) {
            return renderGearIconFromSvg(item, size, false);
        }

        function renderGearIconLegendary(item, size) {
            return renderGearIconFromSvg(item, size, true);
        }

        function renderGearIconFromSvg(item, size, isHighTier) {
            try {
                if (!item) return '';
                const safeSize = Math.max(32, Number(size) || 96);
                return buildGearIconSvg(item, safeSize, isHighTier);
            } catch (e) {
                return '';
            }
        }

        function getGearMaterialBaseColor(slot, profile) {
            const p = profile || {};
            const accent = Number.isFinite(p.accent) ? (p.accent % 4) : 0;
            if (slot === 'Gloves') {
                if (p.gloveMaterial === 'cloth') {
                    const clothTones = [
                        { r: 156, g: 124, b: 178 }, // 보라 천
                        { r: 126, g: 154, b: 188 }, // 청색 천
                        { r: 168, g: 116, b: 108 }, // 붉은 천
                        { r: 126, g: 166, b: 132 }  // 녹색 천
                    ];
                    return clothTones[accent];
                }
                if (p.gloveMaterial === 'metal') {
                    const metalTones = [
                        { r: 156, g: 162, b: 174 },
                        { r: 170, g: 150, b: 130 },
                        { r: 134, g: 152, b: 174 },
                        { r: 154, g: 146, b: 160 }
                    ];
                    return metalTones[accent];
                }
                const leatherTones = [
                    { r: 126, g: 86, b: 62 },
                    { r: 146, g: 98, b: 68 },
                    { r: 112, g: 74, b: 54 },
                    { r: 136, g: 96, b: 76 }
                ];
                return leatherTones[accent];
            }
            if (slot === 'Boots') {
                if (p.bootMaterial === 'cloth') return { r: 132, g: 150, b: 168 };
                if (p.bootMaterial === 'metal') return { r: 154, g: 160, b: 172 };
                return { r: 116, g: 88, b: 62 };
            }
            if (slot === 'Armor') {
                if (p.armorStyle === 'robe' || p.armorStyle === 'dobok') {
                    const robeTones = [
                        { r: 124, g: 132, b: 176 },
                        { r: 162, g: 118, b: 164 },
                        { r: 98, g: 144, b: 152 },
                        { r: 148, g: 136, b: 106 }
                    ];
                    return robeTones[accent];
                }
                if (p.armorStyle === 'coat' || p.armorStyle === 'overcoat') {
                    const coatTones = [
                        { r: 112, g: 92, b: 74 },
                        { r: 88, g: 108, b: 134 },
                        { r: 126, g: 84, b: 84 },
                        { r: 106, g: 114, b: 92 }
                    ];
                    return coatTones[accent];
                }
                if (p.armorStyle === 'leather') return { r: 124, g: 88, b: 62 };
                if (p.armorStyle === 'plate' || p.armorStyle === 'armor') {
                    const plateTones = [
                        { r: 154, g: 160, b: 170 },
                        { r: 164, g: 146, b: 124 },
                        { r: 138, g: 152, b: 174 },
                        { r: 166, g: 142, b: 150 }
                    ];
                    return plateTones[accent];
                }
                return { r: 140, g: 126, b: 110 };
            }
            if (slot === 'Helmet') {
                if (p.helmetStyle === 'hood' || p.helmetStyle === 'clothcap' || p.helmetStyle === 'bandana') {
                    const hoodTones = [
                        { r: 128, g: 136, b: 174 },
                        { r: 164, g: 110, b: 126 },
                        { r: 102, g: 148, b: 122 },
                        { r: 164, g: 142, b: 92 }
                    ];
                    return hoodTones[accent];
                }
                if (p.helmetStyle === 'mask' || p.helmetStyle === 'respirator') {
                    const maskTones = [
                        { r: 148, g: 154, b: 166 },
                        { r: 166, g: 146, b: 126 },
                        { r: 132, g: 150, b: 170 },
                        { r: 156, g: 138, b: 158 }
                    ];
                    return maskTones[accent];
                }
                if (p.helmetStyle === 'crown') return { r: 182, g: 156, b: 88 };
                return { r: 154, g: 144, b: 120 };
            }
            if (slot === 'Necklace') {
                if (p.necklaceTone === 'gold') return { r: 186, g: 150, b: 82 };
                if (p.necklaceTone === 'obsidian') return { r: 88, g: 88, b: 100 };
                return { r: 162, g: 168, b: 178 };
            }
            if (slot === 'Ring') return { r: 164, g: 156, b: 136 };
            if (slot === 'Sword') {
                if (p.swordType === 'dagger') return { r: 150, g: 146, b: 136 };
                if (p.swordType === 'rapier') return { r: 158, g: 166, b: 178 };
                if (p.swordType === 'greatsword') return { r: 144, g: 142, b: 132 };
                return { r: 156, g: 160, b: 170 };
            }
            return { r: 142, g: 144, b: 152 };
        }

        function buildGearIconSvg(item, size, isHighTier) {
            const slot = item.slot || 'Armor';
            const rarityKey = item.rarity || 'common';
            const seedBase = ((item.seed || 0) ^ (hashStringToSeed ? hashStringToSeed(String(item.baseName || item.name || slot)) : 0x9e3779b9)) >>> 0;
            const seed = (seedBase ^ (isHighTier ? 0x85ebca6b : 0x27d4eb2d)) >>> 0;
            const rng = _mulberry32(seed || 1);

            const rarityHex = (EQUIP_RARITY_COLORS && EQUIP_RARITY_COLORS[rarityKey]) ? EQUIP_RARITY_COLORS[rarityKey] : '#8b8b8b';
            const rarityRgb = _hexToRgb(rarityHex);
            const profile = buildGearVisualProfile(item, isHighTier, seedBase);
            const variant = profile.variant;
            const materialRgb = getGearMaterialBaseColor(slot, profile);
            const cool = _mixRgb(materialRgb, { r: 196, g: 210, b: 232 }, isHighTier ? 0.34 : 0.22);
            const warm = _mixRgb(materialRgb, { r: 188, g: 150, b: 102 }, isHighTier ? 0.36 : 0.24);
            const dark = _mixRgb(materialRgb, { r: 16, g: 18, b: 22 }, 0.78);
            const light = _mixRgb(materialRgb, { r: 240, g: 242, b: 246 }, isHighTier ? 0.52 : 0.34);

            const glowAlpha = isHighTier ? 0.58 : 0.34;
            const vignetteAlpha = isHighTier ? 0.74 : 0.82;

            const slotSvg = buildGearSlotSvg(slot, rarityKey, variant, {
                dark: _rgba(dark, 0.95),
                warm: _rgba(warm, 0.95),
                cool: _rgba(cool, 0.95),
                light: _rgba(light, 0.95),
                edge: _rgba(_mixRgb(materialRgb, { r: 230, g: 232, b: 236 }, 0.36), isHighTier ? 0.82 : 0.68),
                shadow: _rgba({ r: 0, g: 0, b: 0 }, 0.82)
            }, profile);
            const ornamentSvg = buildGearOrnamentSvg(slot, rarityKey, variant, {
                dark: _rgba(dark, 0.88),
                warm: _rgba(warm, 0.90),
                cool: _rgba(cool, 0.88),
                light: _rgba(light, 0.90),
                edge: _rgba(_mixRgb(materialRgb, { r: 232, g: 234, b: 240 }, 0.30), 0.82),
                shadow: _rgba({ r: 0, g: 0, b: 0 }, 0.70)
            }, profile);
            const rarityFx = { back: '', front: '' };

            const frameStroke = _rgba(rarityRgb, isHighTier ? 0.72 : 0.52);
            const frameGlow = _rgba(rarityRgb, glowAlpha);
            const bgTop = _rgba(_mixRgb(dark, { r: 38, g: 42, b: 50 }, 0.35), 1);
            const bgBottom = _rgba(_mixRgb(dark, { r: 8, g: 8, b: 10 }, 0.62), 1);

            const svg = `
<svg xmlns="http://www.w3.org/2000/svg" width="${size}" height="${size}" viewBox="0 0 96 96" fill="none">
  <defs>
    <linearGradient id="bg" x1="0" y1="0" x2="0" y2="1">
      <stop offset="0%" stop-color="${bgTop}"/>
      <stop offset="100%" stop-color="${bgBottom}"/>
    </linearGradient>
    <radialGradient id="spot" cx="36%" cy="22%" r="68%">
      <stop offset="0%" stop-color="${_rgba(warm, isHighTier ? 0.30 : 0.18)}"/>
      <stop offset="48%" stop-color="${_rgba(cool, isHighTier ? 0.12 : 0.08)}"/>
      <stop offset="100%" stop-color="rgba(0,0,0,0)"/>
    </radialGradient>
    <filter id="grain" x="-20%" y="-20%" width="140%" height="140%">
      <feTurbulence type="fractalNoise" baseFrequency="0.95" numOctaves="2" seed="${(seed % 991) + 7}"/>
      <feColorMatrix type="saturate" values="0"/>
      <feComponentTransfer>
        <feFuncA type="table" tableValues="0 0.05"/>
      </feComponentTransfer>
    </filter>
    <filter id="shadow" x="-40%" y="-40%" width="180%" height="180%">
      <feDropShadow dx="0" dy="2" stdDeviation="2.8" flood-color="black" flood-opacity="0.55"/>
      <feDropShadow dx="0" dy="0" stdDeviation="1.1" flood-color="${frameGlow}" flood-opacity="${isHighTier ? '0.65' : '0.28'}"/>
    </filter>
    <filter id="organicWarp" x="-28%" y="-28%" width="156%" height="156%">
      <feTurbulence type="fractalNoise" baseFrequency="${profile.warpFreq.toFixed(4)}" numOctaves="2" seed="${(seed + profile.brushSeed) % 997}" result="noise"/>
      <feDisplacementMap in="SourceGraphic" in2="noise" scale="${profile.warp.toFixed(2)}" xChannelSelector="R" yChannelSelector="G"/>
    </filter>
    <filter id="paintGrain" x="-20%" y="-20%" width="140%" height="140%">
      <feTurbulence type="fractalNoise" baseFrequency="0.8" numOctaves="2" seed="${(seed + 19) % 991}" result="n"/>
      <feColorMatrix in="n" type="saturate" values="0"/>
      <feComponentTransfer>
        <feFuncA type="table" tableValues="0 ${profile.grainAlpha.toFixed(3)}"/>
      </feComponentTransfer>
      <feBlend mode="soft-light" in="SourceGraphic"/>
    </filter>
    <linearGradient id="steel" x1="0" y1="0" x2="1" y2="1">
      <stop offset="0%" stop-color="${_rgba(light, 0.94)}"/>
      <stop offset="50%" stop-color="${_rgba(cool, 0.88)}"/>
      <stop offset="100%" stop-color="${_rgba(dark, 0.96)}"/>
    </linearGradient>
    <linearGradient id="leather" x1="0" y1="0" x2="0" y2="1">
      <stop offset="0%" stop-color="${_rgba(warm, 0.98)}"/>
      <stop offset="100%" stop-color="${_rgba(dark, 0.96)}"/>
    </linearGradient>
  </defs>

  <rect x="2" y="2" width="92" height="92" rx="16" fill="url(#bg)"/>
  <rect x="2" y="2" width="92" height="92" rx="16" fill="url(#spot)"/>
  <rect x="2" y="2" width="92" height="92" rx="16" filter="url(#grain)"/>

  ${rarityFx.back}
  <g filter="url(#shadow)">
    <g transform="rotate(${profile.tilt.toFixed(2)} 48 48) translate(${profile.asymmetry ? (variant % 2 === 0 ? '-0.9' : '0.9') : '0'} 0) scale(${profile.stretchX.toFixed(3)} ${profile.stretchY.toFixed(3)}) translate(${((1 - profile.stretchX) * 48).toFixed(2)} ${((1 - profile.stretchY) * 48).toFixed(2)})" filter="url(#organicWarp)">
      <g filter="url(#paintGrain)">
        ${slotSvg}
        ${ornamentSvg}
      </g>
    </g>
  </g>
  ${rarityFx.front}

  <rect x="4" y="4" width="88" height="88" rx="14" fill="none" stroke="${frameStroke}" stroke-width="1.8"/>
  <rect x="6" y="6" width="84" height="84" rx="12" fill="none" stroke="${_rgba(light, 0.25)}" stroke-width="0.9"/>
  <ellipse cx="48" cy="80" rx="26" ry="8" fill="${_rgba({r:0,g:0,b:0}, vignetteAlpha)}"/>
</svg>`.trim();

            return 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(svg);
        }

        function buildGearOrnamentSvg(slot, rarityKey, variant, palette, profile) {
            const p = profile || {};
            const motif = ((variant || 0) + (p.accent || 0) * 3 + (p.silhouette || 0)) % 4;
            const rareBoost = (EQUIP_RARITY_ORDER[rarityKey] || 0) >= 4 ? 1 : 0;
            const strokeMain = palette.edge;
            const strokeSoft = _rgba(_hexToRgb('#ffffff'), 0.22 + rareBoost * 0.08);
            const fillSoft = _rgba(_hexToRgb('#ffffff'), 0.06 + rareBoost * 0.04);

            if (slot === 'Sword') {
                return motif === 0
                    ? `<path d="M39 44L57 48M37 55L55 59" stroke="${strokeMain}" stroke-width="1.1" stroke-linecap="round"/>`
                    : motif === 1
                        ? `<path d="M44 18L52 23M42 28L50 33M40 38L48 43" stroke="${strokeSoft}" stroke-width="1.1"/>`
                        : motif === 2
                            ? `<path d="M43 57L55 60L53 68L41 66Z" fill="${fillSoft}"/><path d="M44 61H53" stroke="${strokeMain}" stroke-width="1"/>`
                            : `<path d="M46 22L50 26L46 30L42 26Z" fill="${palette.cool}" fill-opacity="0.35"/>`;
            }
            if (slot === 'Helmet') {
                return motif === 0
                    ? `<path d="M36 46H60" stroke="${strokeMain}" stroke-width="1.4"/><path d="M40 52H56" stroke="${strokeSoft}" stroke-width="1.1"/>`
                    : motif === 1
                        ? `<path d="M34 41C38 37 43 35 48 35C53 35 58 37 62 41" stroke="${strokeMain}" stroke-width="1.2" fill="none"/>`
                        : motif === 2
                            ? `<path d="M43 52L48 48L53 52L48 57Z" fill="${palette.cool}" fill-opacity="0.35"/>`
                            : `<path d="M33 45L40 39L48 45L56 39L63 45" stroke="${strokeSoft}" stroke-width="1.1" fill="none"/>`;
            }
            if (slot === 'Armor') {
                return motif === 0
                    ? `<path d="M38 41H58M37 51H59M36 61H60" stroke="${strokeMain}" stroke-width="1.1"/>`
                    : motif === 1
                        ? `<path d="M39 41C42 39 46 39 48 41C50 39 54 39 57 41M39 51C42 49 46 49 48 51C50 49 54 49 57 51" stroke="${strokeSoft}" stroke-width="1.05" fill="none"/>`
                        : motif === 2
                            ? `<path d="M42 38L48 34L54 38V46L48 50L42 46Z" fill="${fillSoft}" stroke="${strokeMain}" stroke-width="1"/>`
                            : `<path d="M48 34V68" stroke="${strokeMain}" stroke-width="1.1"/><path d="M43 44H53M42 56H54" stroke="${strokeSoft}" stroke-width="1"/>`;
            }
            if (slot === 'Gloves') {
                return motif === 0
                    ? `<path d="M33 48L47 61" stroke="${strokeMain}" stroke-width="1.2"/><path d="M38 42L52 55" stroke="${strokeSoft}" stroke-width="1"/>`
                    : motif === 1
                        ? `<path d="M36 36L54 31L59 37L41 42Z" fill="${fillSoft}" stroke="${strokeMain}" stroke-width="1"/>`
                        : motif === 2
                            ? `<path d="M42 33L45 28L48 33L51 28L54 33" stroke="${strokeSoft}" stroke-width="1.1"/>`
                            : `<path d="M33 56H48" stroke="${strokeMain}" stroke-width="1.1"/><path d="M35 62H50" stroke="${strokeSoft}" stroke-width="1"/>`;
            }
            if (slot === 'Boots') {
                return motif === 0
                    ? `<path d="M23 68H58M45 68H73" stroke="${strokeMain}" stroke-width="1.4"/>`
                    : motif === 1
                        ? `<path d="M30 40H40M56 40H66" stroke="${strokeSoft}" stroke-width="1.1"/>`
                        : motif === 2
                            ? `<path d="M27 31H45M52 31H71" stroke="${strokeMain}" stroke-width="1"/>`
                            : `<path d="M29 56H45M54 56H70" stroke="${strokeSoft}" stroke-width="1"/>`;
            }
            if (slot === 'Ring') {
                return motif === 0
                    ? `<path d="M48 36L52 42L58 42L53 46L56 52L48 48L40 52L43 46L38 42L44 42Z" fill="none" stroke="${strokeMain}" stroke-width="1"/>`
                    : motif === 1
                        ? `<circle cx="44" cy="40" r="2" fill="${palette.cool}"/><circle cx="48" cy="37" r="2.2" fill="${palette.light}"/><circle cx="52" cy="40" r="2" fill="${palette.cool}"/>`
                        : motif === 2
                            ? `<path d="M39 45H57" stroke="${strokeSoft}" stroke-width="1.2"/><path d="M41 49H55" stroke="${strokeMain}" stroke-width="1.1"/>`
                            : `<circle cx="48" cy="50" r="15" fill="none" stroke="${strokeSoft}" stroke-width="0.9" stroke-dasharray="2 2"/>`;
            }
            if (slot === 'Necklace') {
                return motif === 0
                    ? `<path d="M24 34C30 22 40 16 48 16C56 16 66 22 72 34" stroke="${strokeMain}" stroke-width="1.1" fill="none"/>`
                    : motif === 1
                        ? `<path d="M48 38L55 46L48 54L41 46L48 38Z" fill="${fillSoft}" stroke="${strokeMain}" stroke-width="1"/>`
                        : motif === 2
                            ? `<path d="M39 49L48 35L57 49L52 63H44L39 49Z" fill="none" stroke="${strokeSoft}" stroke-width="1.1"/>`
                            : `<circle cx="48" cy="52" r="4" fill="${palette.cool}" fill-opacity="0.32"/>`;
            }
            return '';
        }

        function buildRarityFxSvg(rarityKey, tone, profile, seed) {
            if (!tone || (tone.order ?? 0) < 3) return { back: '', front: '' };
            const twinkleA = (0.18 + ((seed >>> 3) % 7) * 0.02).toFixed(2);
            const twinkleB = (0.14 + ((seed >>> 5) % 9) * 0.015).toFixed(2);
            const orbit = profile && profile.asymmetry ? 'rotate(-7 48 48)' : 'rotate(0 48 48)';

            if (rarityKey === 'epic') {
                return {
                    back: `<g opacity="0.92"><ellipse cx="48" cy="48" rx="30" ry="30" fill="none" stroke="${tone.edge}" stroke-opacity="0.28" stroke-width="1.2" stroke-dasharray="2 4" transform="${orbit}"/><path d="M22 56C31 44 65 43 74 56" stroke="${tone.cool}" stroke-opacity="0.32" stroke-width="2" fill="none"/><path d="M30 26L34 30L30 34L26 30Z" fill="${tone.light}" fill-opacity="${twinkleA}"/><path d="M66 28L70 32L66 36L62 32Z" fill="${tone.light}" fill-opacity="${twinkleB}"/></g>`,
                    front:`<g opacity="0.88"><path d="M24 68C32 62 64 62 72 68" stroke="${tone.edge}" stroke-opacity="0.24" stroke-width="1.7" fill="none"/></g>`
                };
            }
            if (rarityKey === 'unique') {
                return {
                    back: `<g opacity="0.92"><path d="M48 15L52 28L66 30L55 39L58 53L48 45L38 53L41 39L30 30L44 28Z" fill="${tone.warm}" fill-opacity="0.14" stroke="${tone.edge}" stroke-opacity="0.32" stroke-width="1.2"/><circle cx="48" cy="48" r="29" fill="none" stroke="${tone.warm}" stroke-opacity="0.2" stroke-width="1.0"/></g>`,
                    front:`<g opacity="0.90"><path d="M18 46H30M66 46H78M48 74V82" stroke="${tone.light}" stroke-opacity="0.30" stroke-linecap="round" stroke-width="1.6"/></g>`
                };
            }
            if (rarityKey === 'legendary') {
                return {
                    back: `<g opacity="0.95"><path d="M20 66C28 50 36 44 48 42C60 44 68 50 76 66" fill="none" stroke="${tone.warm}" stroke-opacity="0.35" stroke-width="2.6"/><path d="M28 32L34 22L40 32L48 20L56 32L62 22L68 32" stroke="${tone.edge}" stroke-opacity="0.38" stroke-width="1.6" fill="none"/></g>`,
                    front:`<g opacity="0.90"><path d="M26 74C34 70 62 70 70 74" stroke="${tone.warm}" stroke-opacity="0.32" stroke-width="1.8" fill="none"/></g>`
                };
            }
            if (rarityKey === 'demonic') {
                return {
                    back: `<g opacity="0.95"><path d="M19 71C24 60 30 54 38 50C33 44 31 38 31 32" stroke="${tone.edge}" stroke-opacity="0.42" stroke-width="2.0" fill="none"/><path d="M77 71C72 60 66 54 58 50C63 44 65 38 65 32" stroke="${tone.edge}" stroke-opacity="0.42" stroke-width="2.0" fill="none"/><ellipse cx="48" cy="73" rx="20" ry="7" fill="${tone.core}"/></g>`,
                    front:`<g opacity="0.90"><path d="M30 24C36 18 42 18 48 24C54 18 60 18 66 24" stroke="${tone.warm}" stroke-opacity="0.30" stroke-width="1.4" fill="none"/></g>`
                };
            }
            if (rarityKey === 'angelic') {
                return {
                    back: `<g opacity="0.95"><ellipse cx="48" cy="20" rx="17" ry="5" fill="none" stroke="${tone.light}" stroke-opacity="0.50" stroke-width="1.4"/><path d="M24 66C18 58 16 51 18 44C22 49 28 52 35 54" stroke="${tone.light}" stroke-opacity="0.34" stroke-width="1.8" fill="none"/><path d="M72 66C78 58 80 51 78 44C74 49 68 52 61 54" stroke="${tone.light}" stroke-opacity="0.34" stroke-width="1.8" fill="none"/></g>`,
                    front:`<g opacity="0.92"><path d="M48 18V27M42 22H54" stroke="${tone.cool}" stroke-opacity="0.42" stroke-width="1.5" stroke-linecap="round"/></g>`
                };
            }
            return { back: '', front: '' };
        }

        function getSlotOrganicTuning(slot, isHighTier) {
            const baseBySlot = {
                Sword:    { warpMin: 0.85, warpMax: 1.85, tilt: 6.4, stretch: 0.14, freq: 0.020, grain: 0.085 },
                Helmet:   { warpMin: 0.70, warpMax: 1.45, tilt: 4.4, stretch: 0.10, freq: 0.018, grain: 0.078 },
                Armor:    { warpMin: 1.05, warpMax: 2.05, tilt: 3.0, stretch: 0.11, freq: 0.024, grain: 0.095 },
                Gloves:   { warpMin: 1.00, warpMax: 2.10, tilt: 6.0, stretch: 0.14, freq: 0.025, grain: 0.098 },
                Boots:    { warpMin: 0.88, warpMax: 1.70, tilt: 4.4, stretch: 0.12, freq: 0.020, grain: 0.088 },
                Ring:     { warpMin: 0.22, warpMax: 0.66, tilt: 2.1, stretch: 0.06, freq: 0.011, grain: 0.052 },
                Necklace: { warpMin: 0.34, warpMax: 0.86, tilt: 2.7, stretch: 0.08, freq: 0.013, grain: 0.060 }
            };
            const t = baseBySlot[slot] || { warpMin: 0.75, warpMax: 1.55, tilt: 4.2, stretch: 0.10, freq: 0.019, grain: 0.078 };
            if (!isHighTier) return t;
            return {
                warpMin: t.warpMin * 0.95,
                warpMax: t.warpMax * 1.06,
                tilt: t.tilt * 1.06,
                stretch: t.stretch * 1.06,
                freq: t.freq * 1.04,
                grain: t.grain * 1.08
            };
        }

        function buildGearVisualProfile(item, isHighTier, seedBase) {
            const modSig = [
                ...(Array.isArray(item?.implicitMods) ? item.implicitMods : []),
                ...(Array.isArray(item?.fixedMods) ? item.fixedMods : []),
                ...(Array.isArray(item?.affixMods) ? item.affixMods : []),
                ...(Array.isArray(item?.specialMods) ? item.specialMods : []),
                ...(Array.isArray(item?.fixedSpecialMods) ? item.fixedSpecialMods : [])
            ].map(m => {
                if (!m) return '';
                if (typeof m === 'string') return m;
                return `${m.id || ''}:${m.key || m.stat || m.type || m.name || ''}:${m.value || m.amount || ''}`;
            }).join('|');

            const featureText = [
                item?.slot || '',
                item?.rarity || '',
                item?.baseName || '',
                item?.name || '',
                item?.isNamed ? 'named' : '',
                modSig
            ].join('||');

            const h = hashStringToSeed ? hashStringToSeed(featureText) : 0x9e3779b9;
            const rng = _mulberry32(((seedBase ^ h ^ (isHighTier ? 0x7f4a7c15 : 0x632be59b)) >>> 0) || 1);
            const slot = item?.slot || '';
            const t = getSlotOrganicTuning(slot, isHighTier);
            const n = String((item?.baseName || item?.name || '')).toLowerCase();
            const has = (arr) => arr.some(k => n.includes(k));

            const helmetStyle = has(['방진면','가스마스크','respirator']) ? 'respirator'
                : has(['마스크','mask','가면']) ? 'mask'
                : has(['후드','hood']) ? 'hood'
                : has(['두건','bandana']) ? 'bandana'
                : has(['면갑','천모','clothcap']) ? 'clothcap'
                : has(['왕관','관','crown']) ? 'crown'
                : ['helm','visor','hood','crown','mask'][Math.floor(rng() * 5)];
            const helmetForm = has(['투구','greathelm','헬름']) ? 'greathelm'
                : has(['뿔','horn']) ? 'horned'
                : has(['서클릿','circlet']) ? 'circlet'
                : ['knight','horned','greathelm','circlet'][Math.floor(rng() * 4)];
            const helmetBulk = has(['중갑','heavy']) ? 'heavy'
                : has(['경량','light']) ? 'light'
                : (rng() > 0.56 ? 'heavy' : (rng() > 0.32 ? 'mid' : 'light'));

            const armorStyle = has(['코트','coat']) ? 'coat'
                : has(['외투','overcoat']) ? 'overcoat'
                : has(['도복','robe-suit','uniform']) ? 'dobok'
                : has(['로브','robe']) ? 'robe'
                : has(['갑주','mail']) ? 'armor'
                : has(['판금','plate']) ? 'plate'
                : has(['가죽','leather']) ? 'leather'
                : ['plate','armor','robe','coat','leather','overcoat','dobok'][Math.floor(rng() * 7)];
            const armorForm = has(['흉갑','cuirass']) ? 'cuirass'
                : has(['사슬','mail']) ? 'mail'
                : has(['로브','robe']) ? 'robe'
                : ['cuirass','mail','brigandine','robe'][Math.floor(rng() * 4)];
            const armorBulk = has(['중갑','heavy']) ? 'heavy'
                : has(['경량','light']) ? 'light'
                : (rng() > 0.54 ? 'heavy' : (rng() > 0.30 ? 'mid' : 'light'));

            const ringStyle = has(['룬','문양','인장','sigil']) ? 'sigil'
                : has(['보석','gem','크리스탈']) ? 'gemcluster'
                : ['gemcluster','sigil','band'][Math.floor(rng() * 3)];
            const ringForm = has(['도장','signet','seal']) ? 'signet'
                : has(['꼬임','twist']) ? 'twisted'
                : has(['쌍','double']) ? 'double'
                : ['round','signet','twisted','double'][Math.floor(rng() * 4)];
            const ringWidth = has(['굵','thick']) ? 'thick'
                : has(['얇','thin']) ? 'thin'
                : (rng() > 0.58 ? 'thick' : (rng() > 0.34 ? 'mid' : 'thin'));

            const swordType = has(['레이피어','rapier']) ? 'rapier'
                : has(['단검','dagger','숏소드','shortsword']) ? 'dagger'
                : has(['대검','그레이트','great']) ? 'greatsword'
                : 'sword';
            const swordForm = has(['카타나','사브르','scimitar','곡검']) ? 'curved'
                : has(['톱','saw','serrated']) ? 'serrated'
                : has(['브로드','넓','클레이모어']) ? 'broad'
                : ['straight','curved','serrated','broad'][Math.floor(rng() * 4)];
            const swordLength = has(['롱','long']) ? 'long'
                : has(['숏','short']) ? 'short'
                : (rng() > 0.55 ? 'long' : 'mid');

            const necklaceStyle = has(['십자','cross']) ? 'cross'
                : has(['룬','문양','인장','sigil']) ? 'sigil'
                : has(['진주','pearl']) ? 'pearl'
                : has(['송곳니','fang']) ? 'fang'
                : has(['펜던트','pendant']) ? 'pendant'
                : ['pendant','sigil','cross','pearl'][Math.floor(rng() * 4)];
            const necklaceForm = has(['초커','choker']) ? 'choker'
                : has(['비즈','bead']) ? 'beaded'
                : has(['체인','chain']) ? 'chain'
                : ['chain','choker','beaded','relic'][Math.floor(rng() * 4)];
            const necklaceDrop = has(['롱','long']) ? 'long'
                : has(['짧','short']) ? 'short'
                : (rng() > 0.54 ? 'long' : (rng() > 0.32 ? 'mid' : 'short'));

            const necklaceTone = has(['금','gold']) ? 'gold'
                : has(['은','silver']) ? 'silver'
                : has(['흑','검','어둠','obsidian']) ? 'obsidian'
                : ['gold','silver','obsidian'][Math.floor(rng() * 3)];

            const gloveMaterial = has(['천','cloth']) ? 'cloth'
                : has(['가죽','leather']) ? 'leather'
                : has(['금속','steel','철']) ? 'metal'
                : ['leather','metal','cloth'][Math.floor(rng() * 3)];
            const gloveType = has(['건틀릿','gauntlet']) ? 'gauntlet'
                : has(['장갑','glove']) ? 'glove'
                : (rng() > 0.55 ? 'gauntlet' : 'glove');
            const gloveForm = has(['갈퀴','claw']) ? 'claw'
                : has(['벙어리','mitt']) ? 'mitt'
                : has(['손목보호','bracer']) ? 'bracer'
                : ['bracer','claw','mitt','gauntlet'][Math.floor(rng() * 4)];
            const gloveLength = has(['롱','긴']) ? 'long'
                : has(['숏','짧']) ? 'short'
                : (rng() > 0.56 ? 'long' : (rng() > 0.33 ? 'mid' : 'short'));

            const stretchBase = 1 - t.stretch * 0.55;
            const gloveFlip = has(['왼','left']) ? false : has(['오른','right']) ? true : (rng() > 0.5);
            const bootFlip = has(['왼','left']) ? false : has(['오른','right']) ? true : (rng() > 0.5);
            const bootTall = has(['장화','롱','long']) ? true : has(['단화','쇼트','short']) ? false : (rng() > 0.45);
            const bootType = has(['장화','long']) ? 'longboot'
                : has(['부츠','boots']) ? 'boots'
                : has(['신발','shoe']) ? 'shoe'
                : ['boots','longboot','shoe'][Math.floor(rng() * 3)];
            const bootMaterial = has(['천','cloth']) ? 'cloth'
                : has(['가죽','leather']) ? 'leather'
                : has(['금속','steel','철']) ? 'metal'
                : ['leather','metal','cloth'][Math.floor(rng() * 3)];
            const bootForm = has(['사바톤','sabaton']) ? 'sabaton'
                : has(['그리브','greave']) ? 'greave'
                : has(['신발','shoe']) ? 'shoe'
                : ['adventurer','greave','sabaton','shoe'][Math.floor(rng() * 4)];
            const bootHeight = has(['장화','롱','long']) ? 'long'
                : has(['단화','숏','short']) ? 'short'
                : (rng() > 0.52 ? 'long' : (rng() > 0.30 ? 'mid' : 'short'));

            return {
                variant: Math.floor(rng() * 8),
                silhouette: Math.floor(rng() * 4),
                accent: Math.floor(rng() * 4),
                asymmetry: rng() > 0.5,
                spikes: rng() > 0.38,
                gem: rng() > 0.55,
                tilt: (rng() * 2 - 1) * t.tilt,
                stretchX: stretchBase + rng() * t.stretch,
                stretchY: stretchBase + rng() * t.stretch,
                warp: t.warpMin + rng() * (t.warpMax - t.warpMin),
                warpFreq: t.freq + rng() * 0.004,
                grainAlpha: t.grain + rng() * 0.024,
                helmetStyle,
                helmetForm,
                helmetBulk,
                armorStyle,
                armorForm,
                armorBulk,
                ringStyle,
                ringForm,
                ringWidth,
                swordType,
                swordForm,
                swordLength,
                necklaceStyle,
                necklaceForm,
                necklaceDrop,
                necklaceTone,
                gloveMaterial,
                gloveType,
                gloveForm,
                gloveLength,
                gloveFlip,
                bootType,
                bootMaterial,
                bootForm,
                bootHeight,
                bootFlip,
                bootTall,
                brushSeed: Math.floor(rng() * 997)
            };
        }

        function buildHighTierSlotSvg(slot, variant, palette, profile, rarityKey) {
            const p = profile || {};
            const crown = (rarityKey === 'legendary' || rarityKey === 'unique')
                ? `<path d="M28 27L35 19L42 27L48 17L54 27L61 19L68 27" stroke="${palette.edge}" stroke-width="1.4" fill="none"/>`
                : '';
            const demonic = rarityKey === 'demonic'
                ? `<path d="M30 24L35 16L40 25M56 25L61 16L66 24" stroke="${palette.edge}" stroke-width="1.4"/>`
                : '';
            const angelic = rarityKey === 'angelic'
                ? `<path d="M22 47C18 41 18 34 21 29C27 34 31 40 33 46M74 47C78 41 78 34 75 29C69 34 65 40 63 46" stroke="${palette.light}" stroke-width="1.3" fill="none"/>`
                : '';
            const mode = (((variant || 0) + ((p.silhouette) || 0) * 2 + ((p.accent) || 0)) % 4 + 4) % 4;
            const gloveWrapOpen = p.gloveFlip ? `<g transform="translate(96 0) scale(-1 1)">` : '<g>';
            const gloveWrapClose = '</g>';
            const bootWrapOpen = p.bootFlip ? `<g transform="translate(96 0) scale(-1 1)">` : '<g>';
            const bootWrapClose = '</g>';
            const bootCuff = p.bootTall ? `<path d="M25 22H47M52 22H72" stroke="${palette.edge}" stroke-width="1.2"/>` : '';
            const helmetFlavor = p.helmetStyle === 'respirator'
                ? `<rect x="34" y="48" width="28" height="12" rx="6" fill="${palette.shadow}" opacity="0.7"/><circle cx="41" cy="54" r="2.2" fill="${palette.light}"/><circle cx="55" cy="54" r="2.2" fill="${palette.light}"/>`
                : p.helmetStyle === 'mask'
                    ? `<path d="M37 53H43M53 53H59" stroke="${palette.light}" stroke-width="1.4" stroke-linecap="round"/><rect x="35" y="49" width="26" height="10" rx="5" fill="${palette.shadow}" opacity="0.55"/>`
                    : p.helmetStyle === 'hood'
                        ? `<path d="M28 60C24 43 30 29 40 23C31 30 27 42 27 55" stroke="${palette.dark}" stroke-width="2" fill="none"/>`
                        : p.helmetStyle === 'bandana'
                            ? `<path d="M33 45H63" stroke="${palette.warm}" stroke-width="2.1"/><path d="M62 45L67 51" stroke="${palette.warm}" stroke-width="1.3"/>`
                            : p.helmetStyle === 'clothcap'
                                ? `<path d="M33 42C37 36 42 33 48 33C54 33 59 36 63 42" stroke="${palette.cool}" stroke-width="1.8" fill="none"/>`
                                : p.helmetStyle === 'crown'
                                    ? `<path d="M33 30L38 22L43 30L48 20L53 30L58 22L63 30" stroke="${palette.edge}" stroke-width="1.3" fill="none"/>`
                                    : `<path d="M36 48C39 41 44 37 48 37C52 37 57 41 60 48" stroke="${palette.edge}" stroke-width="1.7" fill="none"/>`;
            const armorFlavor = p.armorStyle === 'robe'
                ? `<path d="M40 34L48 30L56 34V76H40V34Z" fill="${palette.dark}" opacity="0.28"/><path d="M48 30V76" stroke="${palette.cool}" stroke-width="1.1"/>`
                : p.armorStyle === 'coat'
                    ? `<path d="M35 33L61 33L57 75H39L35 33Z" fill="${palette.dark}" opacity="0.26"/><path d="M48 33V75" stroke="${palette.edge}" stroke-width="1.2"/>`
                    : p.armorStyle === 'overcoat'
                        ? `<path d="M33 31L63 31L59 75H37L33 31Z" fill="${palette.shadow}" opacity="0.28"/><path d="M36 42H60M35 54H61" stroke="${palette.warm}" stroke-width="1.0"/>`
                        : p.armorStyle === 'dobok'
                            ? `<path d="M38 34L48 41L58 34" stroke="${palette.light}" stroke-width="1.3" fill="none"/><path d="M41 52H55" stroke="${palette.warm}" stroke-width="2"/>`
                            : p.armorStyle === 'armor'
                                ? `<path d="M36 40H60M35 50H61M34 60H62" stroke="${palette.edge}" stroke-width="1.2"/><path d="M48 34V74" stroke="${palette.light}" stroke-width="1.0"/>`
                                : p.armorStyle === 'plate'
                                    ? `<path d="M39 42H57M38 53H58M37 64H59" stroke="${palette.light}" stroke-width="1.1"/>`
                                    : p.armorStyle === 'leather'
                                        ? `<path d="M36 40H60M35 50H61M34 60H62" stroke="${palette.warm}" stroke-width="1.1" stroke-opacity="0.65"/>`
                                        : `<path d="M38 40C41 38 45 38 48 40C51 38 55 38 58 40M38 50C41 48 45 48 48 50C51 48 55 48 58 50M38 60C41 58 45 58 48 60C51 58 55 58 58 60" stroke="${palette.edge}" stroke-width="1.1" fill="none"/>`;
            const bootMainFill = p.bootMaterial === 'metal' ? 'url(#steel)' : (p.bootMaterial === 'cloth' ? palette.cool : 'url(#leather)');
            const bootAltFill = p.bootMaterial === 'metal' ? 'url(#leather)' : 'url(#steel)';
            const bootFlavor = p.bootType === 'longboot'
                ? `<path d="M24 24H47M52 24H72" stroke="${palette.edge}" stroke-width="1.3"/>`
                : p.bootType === 'shoe'
                    ? `<path d="M22 69H60M45 69H74" stroke="${palette.warm}" stroke-width="1.8"/>`
                    : `<path d="M30 40H40M56 40H66" stroke="${palette.light}" stroke-width="1.2"/>`;
            const bootHeightMark = p.bootHeight === 'long'
                ? `<path d="M24 20H47M52 20H72" stroke="${palette.edge}" stroke-width="1.2"/>`
                : p.bootHeight === 'short'
                    ? `<path d="M24 33H47M52 33H72" stroke="${palette.edge}" stroke-width="1.1"/>`
                    : '';
            const ringFlavor = p.ringStyle === 'sigil'
                ? `<path d="M48 36L52 44L60 44L53 49L56 57L48 52L40 57L43 49L36 44L44 44Z" fill="none" stroke="${palette.edge}" stroke-width="1.1"/>`
                : p.ringStyle === 'gemcluster'
                    ? `<circle cx="44" cy="40" r="2.4" fill="${palette.cool}"/><circle cx="48" cy="37" r="2.7" fill="${palette.light}"/><circle cx="52" cy="40" r="2.4" fill="${palette.cool}"/>`
                    : `<path d="M39 45H57" stroke="${palette.edge}" stroke-width="1.2"/>`;
            const gloveMainFill = p.gloveMaterial === 'metal' ? 'url(#steel)' : (p.gloveMaterial === 'cloth' ? palette.cool : 'url(#leather)');
            const gloveSecondaryFill = p.gloveMaterial === 'metal' ? 'url(#leather)' : 'url(#steel)';
            const gloveFlavor = p.gloveType === 'gauntlet'
                ? `<path d="M37 31H56L61 37L55 44H38L34 37Z" fill="url(#steel)" stroke="${palette.edge}" stroke-width="1.0"/>`
                : `<path d="M36 31L54 26L60 32L42 38L36 31Z" fill="url(#leather)" stroke="${palette.warm}" stroke-width="0.8"/>`;
            const necklaceChain = p.necklaceTone === 'gold'
                ? palette.warm : (p.necklaceTone === 'silver' ? palette.light : palette.dark);
            const necklacePendant = p.necklaceStyle === 'cross'
                ? `<path d="M48 40V64M39 50H57" stroke="${palette.cool}" stroke-width="2.1" stroke-linecap="round"/>`
                : p.necklaceStyle === 'sigil'
                    ? `<path d="M48 36L55 45L51 58H45L41 45L48 36Z" fill="url(#steel)"/><circle cx="48" cy="48" r="3" fill="${palette.cool}"/>`
                    : p.necklaceStyle === 'pearl'
                        ? `<circle cx="48" cy="52" r="8" fill="${palette.light}"/><circle cx="46" cy="49" r="2.3" fill="${palette.cool}"/>`
                        : p.necklaceStyle === 'fang'
                            ? `<path d="M48 38L54 49L48 69L42 49L48 38Z" fill="${palette.warm}"/>`
                            : `<path d="M38 49L48 35L58 49L53 67H43L38 49Z" fill="url(#steel)"/>`;
            const rapierBlade = p.swordLength === 'short'
                ? `<path d="M47 18L52 18L51 58L49 72L46 72L47 58L47 18Z" fill="url(#steel)"/>`
                : p.swordLength === 'long'
                    ? `<path d="M47 6L52 6L51 64L49 84L46 84L47 64L47 6Z" fill="url(#steel)"/>`
                    : `<path d="M47 8L52 8L51 60L49 78L46 78L47 60L47 8Z" fill="url(#steel)"/>`;

            switch (slot) {
                case 'Sword':
                    if (p.swordForm === 'curved') return `
<path d="M30 62C46 54 58 40 64 18L70 20C63 44 49 60 31 69L30 62Z" fill="url(#steel)"/>
<path d="M32 63C48 55 59 41 64 20" stroke="${palette.light}" stroke-width="1.1" fill="none"/>
<path d="M28 60L42 56L46 63L31 68L28 60Z" fill="${palette.dark}"/>
<path d="M24 66L46 59L48 67L26 74L24 66Z" fill="${palette.warm}"/>
${crown}${demonic}${angelic}
`;
                    if (p.swordForm === 'serrated') return `
<path d="M49 10L58 17L55 27L60 34L55 43L60 50L53 73L47 72L49 49L44 42L49 33L44 25L49 10Z" fill="url(#steel)"/>
<path d="M39 48L56 51L65 58L61 64L50 57L37 55L39 48Z" fill="${palette.dark}"/>
<path d="M35 60L56 63L55 73L34 70L35 60Z" fill="${palette.warm}"/>
${crown}${demonic}${angelic}
`;
                    if (p.swordType === 'rapier') return `
${rapierBlade}
<path d="M33 56H63L61 62H35L33 56Z" fill="${palette.warm}"/>
<circle cx="48" cy="59" r="4" fill="${palette.cool}"/>
<path d="M48 8L50 8" stroke="${palette.light}" stroke-width="1.2"/>
${crown}${demonic}${angelic}
`;
                    if (p.swordType === 'dagger') return `
<path d="M48 16L58 28L50 44L42 28L48 16Z" fill="url(#steel)"/>
<path d="M41 44H55L54 54H42L41 44Z" fill="${palette.dark}"/>
<path d="M38 54H58L56 66H40L38 54Z" fill="${palette.warm}"/>
<circle cx="48" cy="50" r="2.6" fill="${palette.cool}"/>
${crown}${demonic}${angelic}
`;
                    if (p.swordType === 'greatsword') return `
<path d="M34 9L63 16L57 33L38 28L34 9Z" fill="url(#steel)"/>
<path d="M38 28L57 33L48 67L32 62L38 28Z" fill="url(#steel)"/>
<path d="M31 62L48 67L45 77L28 72L31 62Z" fill="${palette.dark}"/>
<rect x="24" y="69" width="24" height="8" rx="4" fill="${palette.warm}" transform="rotate(9 36 73)"/>
${crown}${demonic}${angelic}
`;
                    if (mode === 0) return `
<path d="M50 8L62 16L58 36L49 73L43 71L45 36L50 8Z" fill="url(#steel)"/>
<path d="M44 36L58 39L69 49L65 56L55 50L41 48L44 36Z" fill="${palette.dark}"/>
<path d="M39 56L59 59L57 70L37 67L39 56Z" fill="${palette.warm}"/>
<path d="M48 13L52 16" stroke="${palette.light}" stroke-width="1.4" stroke-linecap="round"/>
${crown}${demonic}${angelic}
`;
                    if (mode === 1) return `
<path d="M33 15L67 21L60 34L38 30L33 15Z" fill="url(#steel)"/>
<path d="M38 30L60 34L51 63L32 57L38 30Z" fill="url(#steel)"/>
<path d="M31 57L51 63L47 74L27 68L31 57Z" fill="${palette.dark}"/>
<rect x="23" y="65" width="22" height="8" rx="4" fill="${palette.warm}" transform="rotate(11 34 69)"/>
${p.gem ? `<circle cx="43" cy="66" r="2.6" fill="${palette.cool}"/>` : ''}
${crown}${demonic}${angelic}
`;
                    if (mode === 2) return `
<path d="M49 10L58 17L54 47L46 73L41 71L43 46L49 10Z" fill="url(#steel)"/>
<path d="M39 45L56 48L66 54L62 60L51 54L37 52L39 45Z" fill="${palette.dark}"/>
<path d="M35 58L56 61L55 72L34 69L35 58Z" fill="${palette.warm}"/>
<path d="M48 19L52 23" stroke="${palette.light}" stroke-width="1.3" stroke-linecap="round"/>
${crown}${demonic}${angelic}
`;
                    return `
<path d="M44 10L64 24L55 33L35 20L44 10Z" fill="url(#steel)"/>
<path d="M35 20L55 33L40 59L31 53L35 20Z" fill="url(#steel)"/>
<path d="M30 53L39 59L28 70L18 63L30 53Z" fill="${palette.dark}"/>
<rect x="18" y="65" width="24" height="8" rx="4" fill="${palette.warm}" transform="rotate(-39 30 69)"/>
${crown}${demonic}${angelic}
`;

                case 'Helmet':
                    if (p.helmetForm === 'circlet') return `
<path d="M26 48C26 34 36 24 48 24C60 24 70 34 70 48V60H26V48Z" fill="url(#steel)"/>
<path d="M30 42H66" stroke="${palette.warm}" stroke-width="3"/>
<circle cx="48" cy="42" r="4" fill="${palette.cool}"/>
${helmetFlavor}${crown}${demonic}${angelic}
`;
                    if (p.helmetForm === 'horned') return `
<path d="M24 60C24 36 35 20 48 20C61 20 72 36 72 60V67H24V60Z" fill="url(#steel)"/>
<path d="M28 36C25 29 23 24 22 18M68 36C71 29 73 24 74 18" stroke="${palette.edge}" stroke-width="2" fill="none"/>
<path d="M35 53H61" stroke="${palette.light}" stroke-width="1.8"/>
${helmetFlavor}${crown}${demonic}${angelic}
`;
                    if (p.helmetForm === 'greathelm' || p.helmetBulk === 'heavy') return `
<path d="M24 26H72V67H24V26Z" fill="url(#steel)"/>
<path d="M34 40H62M34 48H62" stroke="${palette.edge}" stroke-width="2"/>
<rect x="35" y="54" width="26" height="7" rx="3.5" fill="${palette.shadow}"/>
${helmetFlavor}${crown}${demonic}${angelic}
`;
                    if (mode === 0) return `
<path d="M23 59C23 35 35 20 48 20C61 20 73 35 73 59V67H23V59Z" fill="url(#steel)"/>
<path d="M34 34L28 50H68L62 34" fill="${palette.dark}" opacity="0.52"/>
<path d="M36 53H60" stroke="${palette.edge}" stroke-width="2"/>
<path d="M42 58H54" stroke="${palette.light}" stroke-width="1.4"/>
${helmetFlavor}${crown}${demonic}${angelic}
`;
                    if (mode === 1) return `
<path d="M25 61C25 40 35 24 48 24C61 24 71 40 71 61V67H25V61Z" fill="url(#steel)"/>
<path d="M48 18L57 30H39L48 18Z" fill="${palette.edge}"/>
<path d="M34 49C38 42 43 39 48 39C53 39 58 42 62 49" stroke="${palette.light}" stroke-width="1.8" fill="none"/>
<rect x="34" y="54" width="28" height="8" rx="4" fill="${palette.shadow}"/>
${helmetFlavor}${crown}${demonic}${angelic}
`;
                    if (mode === 2) return `
<path d="M27 58C27 39 36 27 48 27C60 27 69 39 69 58V67H27V58Z" fill="url(#steel)"/>
<path d="M32 44L48 34L64 44" stroke="${palette.edge}" stroke-width="2" fill="none"/>
<circle cx="48" cy="53" r="5" fill="${palette.cool}"/>
<path d="M39 58H57" stroke="${palette.light}" stroke-width="1.3"/>
${helmetFlavor}${crown}${demonic}${angelic}
`;
                    return `
<path d="M24 58C24 36 34 22 48 22C62 22 72 36 72 58V67H24V58Z" fill="url(#steel)"/>
<path d="M33 36H63L58 50H38L33 36Z" fill="${palette.dark}" opacity="0.46"/>
<path d="M36 52H60M40 58H56" stroke="${palette.edge}" stroke-width="1.5"/>
${helmetFlavor}${crown}${demonic}${angelic}
`;

                case 'Armor':
                    if (p.armorForm === 'robe') return `
<path d="M34 18H62L69 30L62 76H34L27 30L34 18Z" fill="url(#leather)"/>
<path d="M48 22V76" stroke="${palette.cool}" stroke-width="1.3"/>
<path d="M38 41H58M37 54H59M36 66H60" stroke="${palette.light}" stroke-width="1.1"/>
${armorFlavor}${crown}${demonic}${angelic}
`;
                    if (p.armorForm === 'mail') return `
<path d="M30 19H66L72 31L65 75H31L24 31L30 19Z" fill="url(#steel)"/>
<path d="M36 38H60M35 48H61M34 58H62M33 68H63" stroke="${palette.edge}" stroke-width="1.1"/>
<path d="M40 26H56" stroke="${palette.light}" stroke-width="1.3"/>
${armorFlavor}${crown}${demonic}${angelic}
`;
                    if (p.armorForm === 'cuirass' || p.armorBulk === 'heavy') return `
<path d="M29 18L40 14L48 22L56 14L67 18L72 31L64 76H32L24 31L29 18Z" fill="url(#steel)"/>
<path d="M37 34H59M36 46H60M35 58H61" stroke="${palette.light}" stroke-width="1.3"/>
<path d="M46 22H50V75H46Z" fill="${palette.shadow}" opacity="0.4"/>
${armorFlavor}${crown}${demonic}${angelic}
`;
                    if (mode === 0) return `
<path d="M28 19L40 15L48 24L56 15L68 19L72 31L64 75H32L24 31L28 19Z" fill="url(#steel)"/>
<path d="M36 33H60L56 75H40L36 33Z" fill="${palette.shadow}" opacity="0.32"/>
<path d="M38 41H58M37 52H59M36 63H60" stroke="${palette.edge}" stroke-width="1.2"/>
<path d="M48 26V75" stroke="${palette.light}" stroke-width="1.1"/>
${variant % 2 === 0 ? `<circle cx="48" cy="45" r="4" fill="${palette.cool}"/>` : `<path d="M42 45H54" stroke="${palette.cool}" stroke-width="2"/>`}
${armorFlavor}${crown}${demonic}${angelic}
`;
                    if (mode === 1) return `
<path d="M30 18H66L72 29L65 75H31L24 29L30 18Z" fill="url(#leather)"/>
<path d="M34 33L48 26L62 33V73H34V33Z" fill="url(#steel)" opacity="0.9"/>
<path d="M48 26V73" stroke="${palette.edge}" stroke-width="1.3"/>
<path d="M39 42H57M39 52H57M39 62H57" stroke="${palette.light}" stroke-width="1.1"/>
${p.gem ? `<circle cx="48" cy="50" r="4" fill="${palette.cool}"/>` : ''}
${armorFlavor}${crown}${demonic}${angelic}
`;
                    if (mode === 2) return `
<path d="M27 20L40 16L48 23L56 16L69 20L71 34L63 75H33L25 34L27 20Z" fill="url(#steel)"/>
<path d="M39 31H57L54 75H42L39 31Z" fill="${palette.dark}" opacity="0.38"/>
<path d="M38 40H58M37 51H59M36 62H60" stroke="${palette.edge}" stroke-width="1.2"/>
<path d="M43 27H53" stroke="${palette.light}" stroke-width="1.4"/>
${armorFlavor}${crown}${demonic}${angelic}
`;
                    return `
<path d="M31 17H65L73 30L66 75H30L23 30L31 17Z" fill="url(#steel)"/>
<path d="M34 35H62L58 75H38L34 35Z" fill="${palette.shadow}" opacity="0.30"/>
<path d="M36 44H60M35 55H61M34 66H62" stroke="${palette.light}" stroke-width="1.2"/>
${armorFlavor}${crown}${demonic}${angelic}
`;

                case 'Gloves':
                    if (p.gloveForm === 'mitt') return `
${gloveWrapOpen}
<path d="M24 68L31 36L42 30L48 36L44 58L53 63L47 77L30 78L24 68Z" fill="${gloveMainFill}"/>
<path d="M50 76L65 61L71 66L58 82L42 82L50 76Z" fill="${gloveSecondaryFill}"/>
${demonic}${angelic}
${gloveWrapClose}
`;
                    if (p.gloveForm === 'claw') return `
${gloveWrapOpen}
<path d="M24 65L31 35L41 29L46 34L43 47L50 41L55 45L49 55L58 49L63 53L55 64L63 59L69 64L57 77L32 78L24 65Z" fill="${gloveMainFill}"/>
<path d="M40 29L43 22L46 29M49 30L52 23L55 30M58 32L61 25L64 32" stroke="${palette.edge}" stroke-width="1.2"/>
${demonic}${angelic}
${gloveWrapClose}
`;
                    if (p.gloveForm === 'bracer' || p.gloveLength === 'long') return `
${gloveWrapOpen}
<path d="M25 69L34 30L45 25L50 31L46 47L54 41L59 46L52 57L61 51L66 56L58 73L33 79L25 69Z" fill="${gloveMainFill}"/>
<path d="M31 40L48 35L52 42L34 47Z" fill="${palette.warm}"/>
${demonic}${angelic}
${gloveWrapClose}
`;
                    if (mode === 0) return `
${gloveWrapOpen}
<path d="M22 66L30 34L40 28L45 33L42 46L49 40L54 44L48 54L57 48L62 52L54 63L62 58L68 63L56 76L31 77L22 66Z" fill="${gloveMainFill}"/>
<path d="M50 75L67 57L74 63L59 81L42 81L50 75Z" fill="${gloveSecondaryFill}"/>
${gloveFlavor}
<path d="M34 50L51 66" stroke="${palette.edge}" stroke-width="1.4"/>
${demonic}${angelic}
${gloveWrapClose}
`;
                    if (mode === 1) return `
${gloveWrapOpen}
<path d="M24 62L29 36L37 30L42 34L41 46L47 42L51 45L48 54L55 51L59 55L53 64L59 61L64 65L55 74L34 76L24 62Z" fill="${gloveMainFill}"/>
${gloveFlavor}
<path d="M36 30L54 25L60 31L42 37L36 30Z" fill="${palette.warm}"/>
<path d="M31 51L48 66" stroke="${palette.edge}" stroke-width="1.3"/>
${demonic}${angelic}
${gloveWrapClose}
`;
                    if (mode === 2) return `
${gloveWrapOpen}
<path d="M26 67L34 34L45 30L49 36L47 48L54 43L59 47L53 58L61 53L66 58L58 72L34 76L26 67Z" fill="${gloveMainFill}"/>
${gloveFlavor}
<path d="M33 50L50 65" stroke="${palette.edge}" stroke-width="1.4"/>
${p.spikes ? `<path d="M43 32L47 25L51 32" stroke="${palette.edge}" stroke-width="1.2"/>` : ''}
${demonic}${angelic}
${gloveWrapClose}
`;
                    return `
${gloveWrapOpen}
<path d="M23 65L31 35L41 29L46 34L43 47L50 41L55 45L49 55L58 49L63 53L55 64L63 59L69 64L57 77L32 78L23 65Z" fill="${gloveMainFill}"/>
<path d="M51 76L68 58L74 64L60 82L43 82L51 76Z" fill="${gloveSecondaryFill}"/>
${gloveFlavor}
${demonic}${angelic}
${gloveWrapClose}
`;

                case 'Boots':
                    if (p.bootForm === 'shoe' || p.bootHeight === 'short') return `
${bootWrapOpen}
<path d="M24 37H47V57L63 64L59 76H22L18 64L24 57V37Z" fill="${bootMainFill}"/>
<path d="M52 37H71V58L78 64L74 76H45L43 66L52 58V37Z" fill="${bootAltFill}"/>
<path d="M22 68H58M45 68H74" stroke="${palette.shadow}" stroke-width="2.2"/>
${bootFlavor}${bootHeightMark}
${bootWrapClose}
`;
                    if (p.bootForm === 'sabaton' || p.bootMaterial === 'metal') return `
${bootWrapOpen}
<path d="M23 24H47V56L62 64L58 77H22L18 64L23 56V24Z" fill="${bootMainFill}"/>
<path d="M51 24H72V58L79 64L74 77H45L43 67L51 58V24Z" fill="${bootAltFill}"/>
<path d="M26 33H45M54 33H70M24 43H46M52 43H71" stroke="${palette.edge}" stroke-width="1.1"/>
${bootFlavor}${bootCuff}${bootHeightMark}${crown}${demonic}${angelic}
${bootWrapClose}
`;
                    if (mode === 0) return `
${bootWrapOpen}
<path d="M24 27H47V56L63 64L59 77H22L18 64L24 56V27Z" fill="${bootMainFill}"/>
<path d="M51 27H71V58L79 64L74 77H45L43 67L51 58V27Z" fill="${bootAltFill}"/>
<path d="M22 69H60M45 69H74" stroke="${palette.shadow}" stroke-width="2.5"/>
${bootFlavor}
${bootCuff}${crown}${demonic}${angelic}
${bootWrapClose}
`;
                    if (mode === 1) return `
${bootWrapOpen}
<path d="M27 25H45V54L56 61L53 74H23L20 62L27 54V25Z" fill="${bootMainFill}"/>
<path d="M52 25H69V56L76 62L72 74H47L44 64L52 56V25Z" fill="${bootAltFill}"/>
<path d="M24 67H53M47 67H72" stroke="${palette.edge}" stroke-width="1.7"/>
${bootFlavor}
${bootCuff}${crown}${demonic}${angelic}
${bootWrapClose}
`;
                    if (mode === 2) return `
${bootWrapOpen}
<path d="M25 30H46V58L60 64L57 76H23L19 65L25 58V30Z" fill="${bootMainFill}"/>
<path d="M51 30H72V57L80 64L75 76H46L44 66L51 57V30Z" fill="${bootAltFill}"/>
${bootFlavor}
${bootCuff}${crown}${demonic}${angelic}
${bootWrapClose}
`;
                    return `
${bootWrapOpen}
<path d="M24 29H47V57L62 64L58 76H22L18 64L24 57V29Z" fill="${bootMainFill}"/>
<path d="M52 29H71V58L78 64L74 76H45L43 66L52 58V29Z" fill="${bootAltFill}"/>
<path d="M22 68H58M45 68H74" stroke="${palette.shadow}" stroke-width="2.3"/>
${bootFlavor}
${bootCuff}${crown}${demonic}${angelic}
${bootWrapClose}
`;

                case 'Ring':
                    if (p.ringForm === 'signet' || p.ringWidth === 'thick') return `
<ellipse cx="48" cy="52" rx="24" ry="16" fill="none" stroke="url(#steel)" stroke-width="8"/>
<rect x="38" y="31" width="20" height="16" rx="4" fill="${palette.warm}"/>
<circle cx="48" cy="39" r="4.2" fill="${palette.cool}"/>
${ringFlavor}${angelic}${demonic}
`;
                    if (p.ringForm === 'twisted') return `
<path d="M26 52C26 42 36 34 48 34C60 34 70 42 70 52C70 62 60 70 48 70C36 70 26 62 26 52Z" fill="none" stroke="url(#steel)" stroke-width="7"/>
<path d="M32 45C38 53 58 53 64 45M32 59C38 51 58 51 64 59" stroke="${palette.edge}" stroke-width="1.2" fill="none"/>
${ringFlavor}${angelic}${demonic}
`;
                    if (mode === 0) return `
<ellipse cx="48" cy="52" rx="23" ry="17" fill="none" stroke="url(#steel)" stroke-width="7"/>
<path d="M34 39L48 27L62 39L58 50H38L34 39Z" fill="${palette.warm}"/>
<circle cx="48" cy="41" r="5" fill="${palette.light}"/>
<circle cx="48" cy="52" r="25" fill="none" stroke="${palette.edge}" stroke-opacity="0.24" stroke-width="1.1"/>
${ringFlavor}${angelic}${demonic}
`;
                    if (mode === 1) return `
<circle cx="48" cy="52" r="20" fill="none" stroke="url(#steel)" stroke-width="8"/>
<path d="M30 46L48 30L66 46L58 58H38L30 46Z" fill="${palette.dark}"/>
<path d="M39 45H57" stroke="${palette.edge}" stroke-width="1.6"/>
${ringFlavor}${angelic}${demonic}
`;
                    if (mode === 2) return `
<ellipse cx="48" cy="51" rx="24" ry="16" fill="none" stroke="url(#steel)" stroke-width="7"/>
<path d="M36 39L48 30L60 39L56 48H40L36 39Z" fill="${palette.warm}"/>
<circle cx="48" cy="40" r="4.5" fill="${palette.cool}"/>
${ringFlavor}${angelic}${demonic}
`;
                    return `
<circle cx="48" cy="50" r="21" fill="none" stroke="url(#steel)" stroke-width="8"/>
<circle cx="48" cy="50" r="10" fill="${palette.shadow}"/>
<path d="M48 23L54 34H42L48 23Z" fill="${palette.warm}"/>
<circle cx="48" cy="33" r="5" fill="${palette.cool}"/>
${ringFlavor}${angelic}${demonic}
`;

                case 'Necklace':
                    if (p.necklaceForm === 'choker' || p.necklaceDrop === 'short') return `
<path d="M30 35C35 28 41 25 48 25C55 25 61 28 66 35" stroke="${necklaceChain}" stroke-width="6" fill="none"/>
${necklacePendant}
${crown}${demonic}${angelic}
`;
                    if (p.necklaceForm === 'beaded') return `
<path d="M26 34C30 23 39 17 48 17C57 17 66 23 70 34" stroke="${necklaceChain}" stroke-width="2.4" fill="none"/>
<circle cx="31" cy="28" r="2.3" fill="${palette.light}"/><circle cx="38" cy="22" r="2.3" fill="${palette.light}"/><circle cx="48" cy="19" r="2.5" fill="${palette.light}"/><circle cx="58" cy="22" r="2.3" fill="${palette.light}"/><circle cx="65" cy="28" r="2.3" fill="${palette.light}"/>
${necklacePendant}
${crown}${demonic}${angelic}
`;
                    if (mode === 0) return `
<path d="M24 34C30 20 39 14 48 14C57 14 66 20 72 34" stroke="${necklaceChain}" stroke-width="4" fill="none"/>
${necklacePendant}
<circle cx="48" cy="68" r="2.3" fill="${palette.light}"/>
${crown}${demonic}${angelic}
`;
                    if (mode === 1) return `
<path d="M26 33C30 24 39 18 48 18C57 18 66 24 70 33" stroke="${necklaceChain}" stroke-width="4.2" fill="none"/>
<circle cx="48" cy="52" r="15" fill="url(#leather)"/>
${necklacePendant}
${crown}${demonic}${angelic}
`;
                    if (mode === 2) return `
<path d="M24 35C29 21 39 14 48 14C57 14 67 21 72 35" stroke="${necklaceChain}" stroke-width="4" fill="none"/>
<path d="M48 34L62 52L48 76L34 52L48 34Z" fill="url(#leather)"/>
${necklacePendant}
${crown}${demonic}${angelic}
`;
                    return `
<path d="M25 34C30 22 40 16 48 16C56 16 66 22 71 34" stroke="${necklaceChain}" stroke-width="3.8" fill="none"/>
${necklacePendant}
${crown}${demonic}${angelic}
`;

                default:
                    return '';
            }
        }

        function buildGearSlotSvg(slot, rarityKey, variant, palette, profile) {
            const p = profile || { silhouette: 0, accent: 0, asymmetry: false, spikes: false, gem: false };
            if (isRarityAtLeast(rarityKey, 'epic')) {
                const high = buildHighTierSlotSvg(slot, variant, palette, p, rarityKey);
                if (high) return high;
            }
            switch (slot) {
                case 'Sword':
                    if (p.swordForm === 'curved') return `
<path d="M30 61C45 54 57 40 64 19L69 21C62 44 49 60 31 68L30 61Z" fill="url(#steel)"/>
<path d="M32 62C47 55 58 41 63 21" stroke="${palette.light}" stroke-width="1.0" fill="none"/>
<path d="M28 60L42 56L46 62L31 67L28 60Z" fill="${palette.dark}"/>
<path d="M24 66L45 59L47 66L26 73L24 66Z" fill="${palette.warm}"/>
`;
                    if (p.swordForm === 'serrated') return `
<path d="M49 11L57 17L54 26L59 33L54 42L59 49L53 71L47 70L49 49L44 42L49 34L44 26L49 11Z" fill="url(#steel)"/>
<path d="M39 47L55 50L64 57L60 63L50 56L37 54L39 47Z" fill="${palette.dark}"/>
<path d="M35 59L55 62L54 71L34 68L35 59Z" fill="${palette.warm}"/>
`;
                    if (p.silhouette === 0) return `
<path d="M52 9L69 24L59 34L42 18L52 9Z" fill="url(#steel)"/>
<path d="M41 20L56 35L33 59L27 53L41 20Z" fill="url(#steel)"/>
<path d="M26 53L33 59L23 70L15 62L26 53Z" fill="${palette.dark}"/>
<rect x="16" y="63" width="23" height="8" rx="4" fill="${palette.warm}" transform="rotate(-45 28 67)"/>
${p.gem ? `<circle cx="31" cy="64" r="2.7" fill="${palette.cool}"/>` : ''}
`;
                    if (p.silhouette === 1) return `
<path d="M49 10L60 18L57 44L49 74L43 72L45 43L49 10Z" fill="url(#steel)"/>
<path d="M46 44L58 46L66 52L63 58L55 54L44 53L46 44Z" fill="${palette.dark}"/>
<path d="M41 57L57 60L56 69L40 67L41 57Z" fill="${palette.warm}"/>
<path d="M48 15L52 18" stroke="${palette.light}" stroke-width="1.3" stroke-linecap="round"/>
`;
                    if (p.silhouette === 2) return `
<path d="M34 16L66 22L60 34L40 30L34 16Z" fill="url(#steel)"/>
<path d="M39 30L60 34L52 61L34 56L39 30Z" fill="url(#steel)"/>
<path d="M33 56L52 61L49 71L30 66L33 56Z" fill="${palette.dark}"/>
<rect x="26" y="63" width="20" height="7" rx="3.5" fill="${palette.warm}" transform="rotate(12 36 66)"/>
`;
                    return `
<path d="M52 10L66 24L56 34L43 22L52 10Z" fill="url(#steel)"/>
<path d="M41 24L54 37L35 56L29 50L41 24Z" fill="url(#steel)"/>
<path d="M29 50L35 56L25 66L19 60L29 50Z" fill="${palette.dark}"/>
<rect x="21" y="61" width="18" height="7" rx="3" fill="${palette.warm}" transform="rotate(-45 30 64)"/>
${variant === 0 ? `<path d="M58 18L63 23" stroke="${palette.light}" stroke-width="1.2" stroke-linecap="round"/>` : `<path d="M56 16L64 24" stroke="${palette.edge}" stroke-width="1.4" stroke-linecap="round"/>`}
`;
                case 'Helmet':
                    if (p.silhouette === 0) return `
<path d="M23 56C23 34 35 18 48 18C61 18 73 34 73 56V64H23V56Z" fill="url(#steel)"/>
<path d="M35 34L28 52H68L61 34" fill="${palette.dark}" opacity="0.55"/>
<rect x="33" y="50" width="30" height="9" rx="4.5" fill="${palette.shadow}"/>
`;
                    if (p.silhouette === 1) return `
<path d="M24 60C24 40 34 24 48 24C62 24 72 40 72 60V66H24V60Z" fill="url(#steel)"/>
<path d="M48 19L56 30H40L48 19Z" fill="${palette.edge}"/>
<path d="M37 53H59" stroke="${palette.light}" stroke-width="2"/>
${p.spikes ? `<path d="M32 34L36 26L40 34M56 34L60 26L64 34" stroke="${palette.edge}" stroke-width="1.3"/>` : ''}
`;
                    if (p.silhouette === 2) return `
<path d="M28 56C28 38 37 27 48 27C59 27 68 38 68 56V66H28V56Z" fill="url(#steel)"/>
<path d="M34 44C38 38 43 35 48 35C53 35 58 38 62 44" stroke="${palette.edge}" stroke-width="2" fill="none"/>
<circle cx="48" cy="52" r="5" fill="${palette.cool}"/>
`;
                    return `
<path d="M24 54C24 35 34 20 48 20C62 20 72 35 72 54V63H24V54Z" fill="url(#steel)"/>
<path d="M33 48C33 38 39 32 48 32C57 32 63 38 63 48" stroke="${palette.edge}" stroke-width="2" fill="none"/>
<rect x="34" y="50" width="28" height="8" rx="4" fill="${palette.shadow}"/>
<path d="M40 53H44M52 53H56" stroke="${palette.light}" stroke-width="1.4" stroke-linecap="round"/>
`;
                case 'Armor':
                    if (p.silhouette === 0) return `
<path d="M31 17H65L73 30L66 74H30L23 30L31 17Z" fill="url(#steel)"/>
<path d="M40 17L37 31H59L56 17" stroke="${palette.light}" stroke-width="1.8"/>
<path d="M34 38L62 38M33 49L63 49M32 60L64 60" stroke="${palette.edge}" stroke-width="1.3"/>
${p.gem ? `<circle cx="48" cy="44" r="4" fill="${palette.cool}"/>` : ''}
`;
                    if (p.silhouette === 1) return `
<path d="M28 19L40 16L48 24L56 16L68 19L70 32L62 74H34L26 32L28 19Z" fill="url(#steel)"/>
<path d="M38 33H58L55 73H41L38 33Z" fill="${palette.dark}" opacity="0.42"/>
<path d="M38 41H58M37 53H59M36 65H60" stroke="${palette.light}" stroke-width="1.2"/>
`;
                    if (p.silhouette === 2) return `
<path d="M29 20H67L71 28L64 74H32L25 28L29 20Z" fill="url(#leather)"/>
<path d="M33 33L48 26L63 33V72H33V33Z" fill="url(#steel)" opacity="0.88"/>
<path d="M48 26V72" stroke="${palette.edge}" stroke-width="1.3"/>
`;
                    return `
<path d="M32 18H64L70 30L64 72H32L26 30L32 18Z" fill="url(#steel)"/>
<path d="M40 18L38 30H58L56 18" stroke="${palette.light}" stroke-width="1.5"/>
${variant === 1 ? `<path d="M38 38H58M37 48H59M36 58H60" stroke="${palette.edge}" stroke-width="1.2"/>` : `<path d="M38 40H58M37 50H59M36 60H60" stroke="${palette.light}" stroke-width="1.1"/>`}
<path d="M46 30H50V72H46Z" fill="${palette.shadow}" opacity="0.45"/>
`;
                case 'Gloves':
                    if (p.silhouette === 0) return `
<path d="M22 65L29 35L38 29L43 33L40 46L47 40L52 43L47 53L55 48L60 51L53 61L60 57L65 62L54 74L31 75L22 65Z" fill="url(#leather)"/>
<path d="M52 73L67 57L73 62L59 79L44 79L52 73Z" fill="url(#steel)"/>
`;
                    if (p.silhouette === 1) return `
<path d="M24 60L28 36L35 31L40 34L39 46L44 43L48 45L46 54L52 51L56 53L51 61L57 58L61 61L53 72L34 74L24 60Z" fill="url(#steel)"/>
<path d="M38 32L53 27L58 33L43 38L38 32Z" fill="${palette.warm}"/>
`;
                    if (p.silhouette === 2) return `
<path d="M27 66L35 34L45 31L49 36L47 48L53 44L58 47L52 58L60 54L65 58L57 70L35 73L27 66Z" fill="url(#leather)"/>
<path d="M33 50L49 64" stroke="${palette.edge}" stroke-width="1.4"/>
${p.spikes ? `<path d="M44 32L47 26L50 32" stroke="${palette.edge}" stroke-width="1.2"/>` : ''}
`;
                    return `
<path d="M24 64L30 36L38 30L42 34L40 46L45 40L50 42L46 52L52 46L57 48L51 58L58 54L62 58L52 70L32 72L24 64Z" fill="url(#leather)"/>
<path d="M52 70L68 54L73 58L59 76L45 76L52 70Z" fill="url(#steel)"/>
<path d="M34 47L48 61" stroke="${palette.edge}" stroke-width="1.2"/>
`;
                case 'Boots':
                    if (p.silhouette === 0) return `
<path d="M25 28H47V56L62 64L59 76H23L19 64L25 56V28Z" fill="url(#leather)"/>
<path d="M51 29H70V58L77 64L73 76H45L43 66L51 58V29Z" fill="url(#steel)"/>
<path d="M23 68H59M45 68H73" stroke="${palette.shadow}" stroke-width="2.4"/>
`;
                    if (p.silhouette === 1) return `
<path d="M28 26H45V54L55 61L52 73H24L21 62L28 54V26Z" fill="url(#steel)"/>
<path d="M52 26H68V56L74 62L71 73H48L45 64L52 56V26Z" fill="url(#leather)"/>
<path d="M25 67H52M48 67H71" stroke="${palette.edge}" stroke-width="1.6"/>
`;
                    if (p.silhouette === 2) return `
<path d="M26 31H46V58L59 64L57 75H24L20 65L26 58V31Z" fill="url(#leather)"/>
<path d="M52 31H71V57L78 64L74 75H47L45 66L52 57V31Z" fill="url(#leather)"/>
<path d="M33 41H41M58 41H66" stroke="${palette.light}" stroke-width="1.2"/>
`;
                    return `
<path d="M26 30H46V56L60 64L58 74H24L20 63L26 56V30Z" fill="url(#leather)"/>
<path d="M52 30H70V58L76 64L72 74H46L44 65L52 58V30Z" fill="url(#steel)"/>
<path d="M24 67H58M46 67H72" stroke="${palette.shadow}" stroke-width="2.2"/>
`;
                case 'Ring':
                    if (p.silhouette === 0) return `
<circle cx="48" cy="50" r="21" fill="none" stroke="url(#steel)" stroke-width="8"/>
<circle cx="48" cy="50" r="10" fill="${palette.shadow}"/>
<path d="M48 23L54 34H42L48 23Z" fill="${palette.warm}"/>
<circle cx="48" cy="33" r="5" fill="${palette.cool}"/>
`;
                    if (p.silhouette === 1) return `
<ellipse cx="48" cy="51" rx="23" ry="17" fill="none" stroke="url(#steel)" stroke-width="7"/>
<path d="M34 39L48 28L62 39L58 49H38L34 39Z" fill="${palette.warm}"/>
<circle cx="48" cy="40" r="5" fill="${palette.light}"/>
`;
                    if (p.silhouette === 2) return `
<circle cx="48" cy="52" r="20" fill="none" stroke="url(#steel)" stroke-width="8"/>
<path d="M30 46L48 30L66 46L58 58H38L30 46Z" fill="${palette.dark}"/>
<path d="M39 45H57" stroke="${palette.edge}" stroke-width="1.6"/>
`;
                    return `
<circle cx="48" cy="50" r="20" fill="none" stroke="url(#steel)" stroke-width="8"/>
<circle cx="48" cy="50" r="9" fill="${palette.shadow}"/>
<path d="M48 24L53 34H43L48 24Z" fill="${palette.warm}"/>
<circle cx="48" cy="33" r="5" fill="${palette.cool}"/>
`;
                case 'Necklace':
                    if (p.silhouette === 0) return `
<path d="M24 35C29 21 39 14 48 14C57 14 67 21 72 35" stroke="url(#steel)" stroke-width="4" fill="none"/>
<path d="M48 34L62 52L48 76L34 52L48 34Z" fill="url(#leather)"/>
<path d="M48 41L56 52L48 67L40 52L48 41Z" fill="${palette.cool}"/>
`;
                    if (p.silhouette === 1) return `
<path d="M27 33C31 24 39 18 48 18C57 18 65 24 69 33" stroke="url(#steel)" stroke-width="4.2" fill="none"/>
<circle cx="48" cy="52" r="15" fill="url(#leather)"/>
<path d="M48 40L56 52L48 64L40 52L48 40Z" fill="${palette.light}"/>
`;
                    if (p.silhouette === 2) return `
<path d="M25 34C30 22 40 16 48 16C56 16 66 22 71 34" stroke="url(#steel)" stroke-width="3.8" fill="none"/>
<path d="M38 49L48 35L58 49L53 67H43L38 49Z" fill="url(#steel)"/>
<circle cx="48" cy="52" r="4" fill="${palette.cool}"/>
`;
                    return `
<path d="M26 34C30 22 40 16 48 16C56 16 66 22 70 34" stroke="url(#steel)" stroke-width="4" fill="none"/>
<path d="M48 34L60 52L48 74L36 52L48 34Z" fill="url(#leather)"/>
<path d="M48 40L55 52L48 65L41 52L48 40Z" fill="${palette.cool}"/>
<circle cx="48" cy="52" r="3" fill="${palette.light}"/>
`;
                default:
                    return `
<path d="M32 20H64L70 30L62 72H34L26 30L32 20Z" fill="url(#steel)"/>
<path d="M36 36H60M35 46H61M34 56H62" stroke="${palette.edge}" stroke-width="1.2"/>
`;
            }
        }




        


// ---------------------------------------------------------
        // 저장/불러오기
        // ---------------------------------------------------------
        function saveGearToStorage() {
            try {
                localStorage.setItem(GEAR_INV_STORAGE_KEY, JSON.stringify(gearInventorySlots));
                localStorage.setItem(EQUIPPED_GEAR_STORAGE_KEY, JSON.stringify(equippedGear));
                localStorage.setItem(PENDING_GEAR_STORAGE_KEY, JSON.stringify(pendingGearDrops));
                localStorage.setItem(GEAR_LOCK_STORAGE_KEY, JSON.stringify(gearLockMap));
            } catch (e) {
                console.warn('saveGearToStorage failed', e);
            }
        }

        function normalizeGearItem(item) {
            if (!item || typeof item !== 'object') return null;

            const _tierOrder = new Set(EQUIP_TIER_LABELS || ['T5','T4','T3','T2','T1']);
            const _getTierMax = (key, tier) => {
                const ranges = EQUIP_STAT_RANGES[key] || null;
                if (!ranges) return 0;
                const t = (_tierOrder.has(tier) && ranges[tier]) ? tier : 'T1';
                const rr = ranges[t] || ranges.T1 || [0, 0];
                return rr[1] || 0;
            };

            const _implicitMultFor = (slot, key) => {
                const arr = EQUIP_IMPLICIT[slot] || [];
                for (const m of arr) {
                    if (m && m.key === key) return (m.mult ?? 1);
                }
                return 1;
            };

            const _affixMultFor = (source, affixName, key, slot) => {
                const pool = source === 'prefix'
                    ? (PREFIX_POOL || [])
                    : source === 'suffix'
                        ? (SUFFIX_POOL || [])
                        : [];
                for (const a of pool) {
                    const name = source === 'prefix' ? a.name : a.suffix;
                    if (name !== affixName) continue;
                    if (Array.isArray(a.onlySlots) && !a.onlySlots.includes(slot)) continue;
                    for (const m of (a.mods || [])) {
                        if (m && m.key === key) return (m.mult ?? 1);
                    }
                }
                return 1;
            };

            const _clampCoreStatMod = (m, slot, itemRef) => {
                if (!m || !m.key || typeof m.value !== 'number') return m;
                if (!EQUIP_STAT_RANGES[m.key]) return m;

                let mult = 1;
                if (m.source === 'implicit') {
                    mult = _implicitMultFor(slot, m.key);
                } else if (m.source === 'prefix' || m.source === 'suffix') {
                    const fallbackAffixName = (m.source === 'prefix') ? (itemRef?.prefixName || '') : (itemRef?.suffixName || '');
                    const affixName = m.affix || fallbackAffixName;
                    mult = _affixMultFor(m.source, affixName, m.key, slot);
                }

                const maxV = roundEquipStatValue(m.key, _getTierMax(m.key, m.tier) * mult);
                const minV = 0;
                m.value = roundEquipStatValue(m.key, clampVal(m.value, minV, maxV));
                return m;
            };

            // 필수 키 보정
            if (!item.uid) item.uid = (Date.now().toString(36) + Math.random().toString(36).slice(2, 8)).toUpperCase();
            if (!item.slot || !EQUIP_SLOT_TYPES.includes(item.slot)) return null;
            if (!item.rarity || !EQUIP_RARITIES.includes(item.rarity)) item.rarity = 'common';
            if (!item.name) item.name = item.baseName || '이름 없는 장비';
            if (!item.baseName) item.baseName = item.name;
            if (!item.implicitMods) item.implicitMods = [];
            if (!item.fixedMods) item.fixedMods = [];
            if (!item.affixMods) item.affixMods = [];
            if (!item.fixedSpecialMods) item.fixedSpecialMods = [];
            if (!item.specialMods) item.specialMods = [];

            // [마이그레이션] 코어 스탯(암묵/고정/접두/접미) 값 재클램프 + 접두/접미 이름 동기화
            item.implicitMods = (item.implicitMods || []).map(m => _clampCoreStatMod(m, item.slot, item));
            item.fixedMods = (item.fixedMods || []).map(m => _clampCoreStatMod(m, item.slot, item));
            item.affixMods = (item.affixMods || []).map(m => _clampCoreStatMod(m, item.slot, item));

            const _pickRandomAffixName = (source, slot) => {
                const pool = source === 'prefix' ? (PREFIX_POOL || []) : (SUFFIX_POOL || []);
                const keyField = source === 'prefix' ? 'name' : 'suffix';
                const valid = pool.filter(a => a && (!Array.isArray(a.onlySlots) || a.onlySlots.includes(slot)));
                if (!valid.length) return '';
                const picked = valid[Math.floor(Math.random() * valid.length)];
                return picked ? (picked[keyField] || '') : '';
            };

            const _isValidAffixName = (source, name, slot) => {
                if (!name) return false;
                const pool = source === 'prefix' ? (PREFIX_POOL || []) : (SUFFIX_POOL || []);
                const keyField = source === 'prefix' ? 'name' : 'suffix';
                return pool.some(a => a && a[keyField] === name && (!Array.isArray(a.onlySlots) || a.onlySlots.includes(slot)));
            };

            const _resolveAffixName = (source, mods, slot, fallbackName) => {
                if (!mods.length) return '';

                if (_isValidAffixName(source, fallbackName, slot)) return fallbackName;

                for (const m of mods) {
                    if (!m || !m.affix) continue;
                    if (_isValidAffixName(source, m.affix, slot)) return m.affix;
                }

                return _pickRandomAffixName(source, slot);
            };

            const _prefixMods = (item.affixMods || []).filter(m => m && m.source === 'prefix');
            const _suffixMods = (item.affixMods || []).filter(m => m && m.source === 'suffix');
            item.prefixName = _resolveAffixName('prefix', _prefixMods, item.slot, item.prefixName || '');
            item.suffixName = _resolveAffixName('suffix', _suffixMods, item.slot, item.suffixName || '');

            for (const m of _prefixMods) if (m) m.affix = item.prefixName || '';
            for (const m of _suffixMods) if (m) m.affix = item.suffixName || '';

            const _prefixObj = (PREFIX_POOL || []).find(a => a && a.name === item.prefixName) || null;
            const _suffixObj = (SUFFIX_POOL || []).find(a => a && a.suffix === item.suffixName) || null;
            item.name = buildName(_prefixObj, item.baseName || item.name || '이름 없는 장비', _suffixObj);

            // 레어 옵션(specialMods) 전용 키가 fixedSpecialMods(스페셜 옵션)에 남아있지 않도록 정리(세이브 호환)
            //  - 기존 세이브에 섞여 있던 옵션은 specialMods로 옮겨서 보존합니다.
            const _movedSpecials = [];
            const _fixedKept = [];
            const _specialKeys = new Set((item.specialMods || []).map(x => x && x.key).filter(Boolean));
            for (const sm of (item.fixedSpecialMods || [])) {
                if (!sm || !sm.key) continue;
                if (SPECIAL_MODS_ONLY_KEYS.has(sm.key)) {
                    if (!_specialKeys.has(sm.key)) {
                        _specialKeys.add(sm.key);
                        _movedSpecials.push(sm);
                    }
                } else {
                    _fixedKept.push(sm);
                }
            }
            if (_movedSpecials.length) item.specialMods = (item.specialMods || []).concat(_movedSpecials);
            item.fixedSpecialMods = _fixedKept;

            // 네임드 감지/보정(이전 세이브 호환)
            if (item.isNamed == null) {
                let detected = false;
                const bn = item.baseName || '';
                for (const rk of Object.keys(WORLD_NAMED_ITEMS || {})) {
                    const arr = WORLD_NAMED_ITEMS[rk] || [];
                    for (const x of arr) {
                        if (x && x.name === bn) { detected = true; break; }
                    }
                    if (detected) break;
                }
                item.isNamed = detected;
            }
            if (!item.namedKey) item.namedKey = item.isNamed ? (item.baseName || item.name) : '';

            // 네임드 고정 옵션/전용 특수옵션 자동 생성(없을 때만)
            //  - 기본(signature) 모드에서는 기존 아이템을 건드리지 않기 위해 자동 생성하지 않습니다.
            //  - legacy 모드에서만(결정적/재현 가능) 누락분을 채웁니다.
            if (item.isNamed && NAMED_FIXED_MODS_MODE !== 'off' && (!item.fixedMods || item.fixedMods.length === 0)) {
                item.fixedMods = buildNamedFixedMods(item.namedKey, item.rarity, item.slot, {
                    namedScope: item.namedScope || 'world',
                    exclusiveKey: item.exclusiveKey || ''
                });
            }
            if (item.isNamed && NAMED_SPECIALS_MODE === 'legacy' && (!item.fixedSpecialMods || item.fixedSpecialMods.length === 0)) {
                const b = (item.rarity === 'demonic' || item.rarity === 'angelic') ? 2 :
                          (item.rarity === 'unique' || item.rarity === 'legendary') ? 1 : 0;
                item.fixedSpecialMods = (buildNamedFixedSpecials(item.namedKey, item.rarity, item.slot, {
                    namedScope: item.namedScope || 'world',
                    exclusiveKey: item.exclusiveKey || '',
                    specialBudget: b
                }) || []).filter(m => m && !SPECIAL_MODS_ONLY_KEYS.has(m.key));
            }

            if (!item.seed) item.seed = Math.floor(Math.random() * 2147483647);
            ensureGearIcon(item);
            return item;
        }

        function loadGearFromStorage() {
            try {
                const invRaw = localStorage.getItem(GEAR_INV_STORAGE_KEY);
                const eqRaw  = localStorage.getItem(EQUIPPED_GEAR_STORAGE_KEY);
                const pdRaw  = localStorage.getItem(PENDING_GEAR_STORAGE_KEY);
                const lockRaw = localStorage.getItem(GEAR_LOCK_STORAGE_KEY);

                if (invRaw) {
                    const arr = JSON.parse(invRaw);
                    if (Array.isArray(arr)) {
                        gearInventorySlots = new Array(GEAR_INV_SIZE).fill(null);
                        for (let i=0;i<Math.min(arr.length, GEAR_INV_SIZE); i++) {
                            const it = normalizeGearItem(arr[i]);
                            gearInventorySlots[i] = it;
                        }
                    }
                }

                if (eqRaw) {
                    const obj = JSON.parse(eqRaw);
                    if (obj && typeof obj === 'object') {
                        for (const s of EQUIP_SLOT_TYPES) {
                            equippedGear[s] = normalizeGearItem(obj[s]);
                        }
                    }
                }

                if (lockRaw) {
                    const lockObj = JSON.parse(lockRaw);
                    if (lockObj && typeof lockObj === 'object') gearLockMap = lockObj;
                }

                if (pdRaw) {
                    const arr = JSON.parse(pdRaw);
                    if (Array.isArray(arr)) {
                        pendingGearDrops = arr.map(normalizeGearItem).filter(Boolean);
                    }
                }
            } catch (e) {
                console.warn('loadGearFromStorage failed', e);
            }
        }

        function findFirstEmptyGearSlot() {
            for (let i=0;i<gearInventorySlots.length;i++) {
                if (!gearInventorySlots[i]) return i;
            }
            return -1;
        }

        function addGearToInventory(item) {
            const idx = findFirstEmptyGearSlot();
            if (idx < 0) return false;
            gearInventorySlots[idx] = item;
            saveGearToStorage();
            return true;
        }

        function isGearInventoryFull() {
            return findFirstEmptyGearSlot() < 0;
        }

        let _gearInvFullNotified = false;
        function notifyGearInventoryFull() {
            if (_gearInvFullNotified) return;
            _gearInvFullNotified = true;
            setTimeout(() => { _gearInvFullNotified = false; }, 800);

            alert('장비 인벤토리가 꽉 찼습니다.\n확인을 누르면 장비 인벤토리로 이동합니다.\n(장비를 분해하거나 버려 공간을 확보하세요.)');
            openEquipPanel();
        }

        function flushPendingGearDrops() {
            if (!pendingGearDrops.length) return;

            let moved = 0;
            while (pendingGearDrops.length > 0) {
                const idx = findFirstEmptyGearSlot();
                if (idx < 0) break;
                const it = pendingGearDrops.shift();
                if (!it) continue;
                gearInventorySlots[idx] = it;
                moved++;
                // 유니크+ 효과음 재생
                if (isRarityAtLeast(it.rarity, 'unique')) playGearDropSfx(it.rarity);
            }

            if (moved > 0) {
                saveGearToStorage();
                if (isEquipPanelOpen) updateEquipPanelUI();
            }
        }

        // ---------------------------------------------------------
        // 전투/드랍 연동
        // ---------------------------------------------------------
        function handleEquipmentDrop(enemy) {
            const cat = getEnemyCategory(enemy);
            const chance = EQUIP_DROP_CHANCE[cat] ?? EQUIP_DROP_CHANCE.normal;

            if (Math.random() > chance) return;

            // 플레이어 매직 찬스(0~0.25)
            const mc = clampVal((player.magicChance || 0), 0, 0.25);

            const it = makeGearItem(enemy, cat, score || 0, mc);

            // 인벤토리 저장 or 대기
            const stored = addGearToInventory(it);
            if (!stored) {
                pendingGearDrops.push(it);
                saveGearToStorage();
                notifyGearInventoryFull();
            } else {
                // 유니크+ 효과음
                if (isRarityAtLeast(it.rarity, 'unique')) playGearDropSfx(it.rarity);
            }

            // 획득 이펙트 텍스트
            const px = enemy ? enemy.x : player.x;
            const py = enemy ? enemy.y : player.y;
            const rarityKo = EQUIP_RARITY_KO[it.rarity] || it.rarity;
            showPickupEffect(px, py - 26, `${rarityKo} 장비 획득!`, false, true, null);

            if (isEquipPanelOpen) updateEquipPanelUI();
        }

        // ---------------------------------------------------------
        // 장착 보너스 적용 (플레이어 스탯에 반영)
        // ---------------------------------------------------------
        function applyGearStatDelta(statKey, delta) {
            if (!delta) return;

            if (statKey === 'atk') {
                player.weapon.baseDamage += delta;
                player.weapon.damage += delta;
            } else if (statKey === 'def') {
                player.defense += delta;
            } else if (statKey === 'acc') {
                player.bonusAccuracy += delta;
            } else if (statKey === 'eva') {
                player.bonusEvasion += delta;
            } else if (statKey === 'critChance') {
                player.baseCritChance += delta;
                player.critChance += delta;
            } else if (statKey === 'critResist') {
                player.baseCritResist += delta;
                player.critResist += delta;
            } else if (statKey === 'magicChance') {
                player.magicChance = (player.magicChance || 0) + delta;
            } else if (statKey === 'atkSpeed') {
                player.bonusAttackSpeed = (player.bonusAttackSpeed || 0) + delta;
                player.weapon.baseAutoAttackInterval = Math.max(8, Math.floor(player.weapon.originalAutoAttackInterval / (1 + player.bonusAttackSpeed)));
                player.weapon.autoAttackInterval = player.weapon.baseAutoAttackInterval;
            } else if (statKey === 'moveSpeed') {
                player.baseSpeed += delta;
                player.speed += delta;
            }
        }

        
        function getCurrentDebuffStackTotal() {
            const keys = [
                'poisonTimers','poopPoisonTimers','maliceTimers','kissTimers','semenTimers','oralTimers',
                'byururutTimers','fractureTimers','blindTimers','paralysisTimers',
                'curseTimers','gnawingLifeTimers','darkScentTimers','darkSmellTimers','darkSeedTimers','darkKissTimers','darkReceiverTimers',
                'fatalScarTimers','corruptedBloodTimers','shadingTimers','darknessTimers','confusionTimers',
                'evilMindTimers','evilLightTimers'
            ];
            let total = 0;
            for (const k of keys) {
                if (Array.isArray(player[k])) total += player[k].length;
            }
            return total;
        }

        function countNearbyAliveEnemies(range = 240) {
            const rr = range * range;
            let c = 0;
            for (const en of enemies) {
                if (!en || en.isDead) continue;
                const dx = en.x - player.x;
                const dy = en.y - player.y;
                if ((dx * dx + dy * dy) <= rr) c++;
            }
            return c;
        }

        function hasEquippedNamedGear(name) {
            for (const slot of EQUIP_SLOT_TYPES) {
                const it = equippedGear[slot];
                if (!it) continue;
                if ((it.baseName || it.name) === name) return true;
            }
            return false;
        }

function computeEquippedGearTotals() {
            const totals = { atk:0, def:0, acc:0, eva:0, critChance:0, critResist:0, magicChance:0 };
            const reduceBuckets = {
                reduceBleedDuration: [],
                reducePoisonDotDamage: [],
                reduceDarknessDuration: [],
                reducePoopPoisonDotDamage: [],
                reduceFishyDotDamage: []
            };
            let immuneCurseEndDamage = false;

            const specialMax = {
                lowHpEvasion: 0,
                highHpDefense: 0,
                noHitAccuracy: 0,
                doubleCritCritChance: 0,
                bossPresentDefense: 0,
                lowHpCritChance: 0,
                lowHpAttackSpeed: 0,
                highHpEvasion: 0,
                highHpMoveSpeed: 0,
                noHitEvasion: 0,
                noHitAttack: 0,
                recentlyHitDefense: 0,
                debuffedDefense: 0,
                debuffedAttackSpeed: 0,
                cleanseWindowAccuracy: 0,
                shieldedDefense: 0,
                shieldedAttack: 0,
                shieldedEvasion: 0,
                crowdDefense: 0,
                crowdAttack: 0,
                streakKillAttack: 0,
                streakCritAttackSpeed: 0
            };

            for (const slot of EQUIP_SLOT_TYPES) {
                const it = equippedGear[slot];
                if (!it) continue;

                const mods = []
                    .concat(it.implicitMods || [])
                    .concat(it.fixedMods || [])
                    .concat(it.affixMods || []);

                for (const m of mods) {
                    if (!m || !m.key) continue;
                    if (totals[m.key] === undefined) continue;
                    totals[m.key] += (m.value || 0);
                }

                for (const sm of ([]
                    .concat(it.fixedSpecialMods || [])
                    .concat(it.specialMods || []))) {
                    if (!sm || !sm.key) continue;
                    if (sm.key === 'immuneCurseEndDamage' && sm.value) immuneCurseEndDamage = true;

                    if (reduceBuckets[sm.key]) {
                        reduceBuckets[sm.key].push(clampVal(sm.value || 0, 0, 0.95));
                    }

                    if (specialMax[sm.key] !== undefined) {
                        specialMax[sm.key] = Math.max(specialMax[sm.key], sm.value || 0);
                    }
                }
            }

            // 디버프 감소는 곱연산(누적 시 과도한 폭주 방지)
            const combinedReduce = {};
            for (const k of Object.keys(reduceBuckets)) {
                let mult = 1;
                for (const r of reduceBuckets[k]) mult *= (1 - r);
                combinedReduce[k] = clampVal(1 - mult, 0, 0.95);
            }

            // 매직 찬스 상한 (7-4)
            totals.magicChance = clampVal(totals.magicChance, 0, 0.25);

            return { totals, combinedReduce, immuneCurseEndDamage, specialMax };
        }

        function applyEquippedGearBonuses(forceRebuild = false) {
            // 적용 트래커 초기화(스타트 시점)
            if (!player._gearApplied || forceRebuild) {
                player._gearApplied = { atk:0, def:0, acc:0, eva:0, critChance:0, critResist:0, magicChance:0 };
                player._gearDynamicApplied = { atk:0, def:0, acc:0, eva:0, critChance:0, critResist:0, magicChance:0, atkSpeed:0, moveSpeed:0 };
                player._gearSpecial = { lowHpEvasion:0, highHpDefense:0, noHitAccuracy:0, doubleCritCritChance:0, bossPresentDefense:0 };
                player._gearDoubleCritTimer = 0;
                player._gearCritStreak = 0;
                player.lastDamageFrame = 0;

                // 장비 기반 디버프 감소/면역도 초기화
                player.reduceBleedDuration = 0;
                player.reducePoisonDotDamage = 0;
                player.reduceDarknessDuration = 0;
                player.reducePoopPoisonDotDamage = 0;
                player.reduceFishyDotDamage = 0;
                player.immuneCurseEndDamage = false;

                // 매직 찬스
                player.magicChance = 0;
            }

            // 기존 적용분 제거
            for (const k of Object.keys(player._gearApplied)) {
                if (player._gearApplied[k]) applyGearStatDelta(k, -player._gearApplied[k]);
            }

            // 새 totals 계산 및 적용
            const res = computeEquippedGearTotals();
            const totals = res.totals;

            for (const k of Object.keys(totals)) {
                if (totals[k]) applyGearStatDelta(k, totals[k]);
            }

            player._gearApplied = totals;

            // 디버프 감소/면역/특수(조건부) 저장
            player.reduceBleedDuration = res.combinedReduce.reduceBleedDuration || 0;
            player.reducePoisonDotDamage = res.combinedReduce.reducePoisonDotDamage || 0;
            player.reduceDarknessDuration = res.combinedReduce.reduceDarknessDuration || 0;
            player.reducePoopPoisonDotDamage = res.combinedReduce.reducePoopPoisonDotDamage || 0;
            player.reduceFishyDotDamage = res.combinedReduce.reduceFishyDotDamage || 0;
            player.immuneCurseEndDamage = !!res.immuneCurseEndDamage;

            // [NEW] 엔젤릭 고정 옵션 등 런타임 보정용: 장비 '기본' 디버프 감소 수치 스냅샷
            player._gearBaseReduce = {
                reduceBleedDuration: player.reduceBleedDuration || 0,
                reducePoisonDotDamage: player.reducePoisonDotDamage || 0,
                reduceDarknessDuration: player.reduceDarknessDuration || 0,
                reducePoopPoisonDotDamage: player.reducePoopPoisonDotDamage || 0,
                reduceFishyDotDamage: player.reduceFishyDotDamage || 0
            };

            player._gearSpecial = res.specialMax || player._gearSpecial;

            // dynamic 적용분(조건부)은 리셋 후 다음 프레임부터 반영
            for (const k of Object.keys(player._gearDynamicApplied)) {
                player._gearDynamicApplied[k] = 0;
            }

            if (isEquipPanelOpen) updateEquipPanelUI();
        }

        // 매 프레임 갱신(조건부 옵션)
        function updateGearDynamicBonuses() {
            if (!player._gearDynamicApplied) return;

            // double-crit timer tick
            if (player._gearDoubleCritTimer && player._gearDoubleCritTimer > 0) {
                player._gearDoubleCritTimer--;
            }

            const dyn = { atk:0, def:0, acc:0, eva:0, critChance:0, critResist:0, magicChance:0, atkSpeed:0, moveSpeed:0 };
            const sp = player._gearSpecial || {};
            const hpRatio = player.maxHealth > 0 ? (player.health / player.maxHealth) : 1;

            // 체력 30% 이하
            if ((sp.lowHpEvasion || 0) > 0 && hpRatio <= 0.30) dyn.eva += sp.lowHpEvasion;
            if ((sp.lowHpCritChance || 0) > 0 && hpRatio <= 0.30) dyn.critChance += sp.lowHpCritChance;
            if ((sp.lowHpAttackSpeed || 0) > 0 && hpRatio <= 0.30) dyn.atkSpeed += sp.lowHpAttackSpeed;

            // 체력 50% 이상: 방어+
            if ((sp.highHpDefense || 0) > 0 && hpRatio >= 0.50) dyn.def += sp.highHpDefense;

            // 체력 60% 이상
            if ((sp.highHpEvasion || 0) > 0 && hpRatio >= 0.60) dyn.eva += sp.highHpEvasion;
            if ((sp.highHpMoveSpeed || 0) > 0 && hpRatio >= 0.60) dyn.moveSpeed += sp.highHpMoveSpeed;

            // 3초 피격 없음
            const framesSinceHit = (frameCount - (player.lastDamageFrame || 0));
            if ((sp.noHitAccuracy || 0) > 0 && framesSinceHit >= 180) dyn.acc += sp.noHitAccuracy;
            if ((sp.noHitEvasion || 0) > 0 && framesSinceHit >= 180) dyn.eva += sp.noHitEvasion;
            if ((sp.noHitAttack || 0) > 0 && framesSinceHit >= 180) dyn.atk += sp.noHitAttack;

            // 최근 2초 내 피격
            if ((sp.recentlyHitDefense || 0) > 0 && framesSinceHit <= 120) dyn.def += sp.recentlyHitDefense;

            // 연속 치명타(2회): 4초 치확+
            if ((sp.doubleCritCritChance || 0) > 0 && (player._gearDoubleCritTimer || 0) > 0) {
                dyn.critChance += sp.doubleCritCritChance;
            }

            // 보스 존재 중: 방어+
            if ((sp.bossPresentDefense || 0) > 0) {
                let bossAlive = false;
                for (const en of enemies) {
                    if (!en || en.isDead) continue;
                    if (en.isBoss || en.isArchdemon) { bossAlive = true; break; }
                }
                if (bossAlive) dyn.def += sp.bossPresentDefense;
            }

            // 디버프 50중첩 이상
            const debuffStacks = getCurrentDebuffStackTotal();
            if ((sp.debuffedDefense || 0) > 0 && debuffStacks >= 50) dyn.def += sp.debuffedDefense;
            if ((sp.debuffedAttackSpeed || 0) > 0 && debuffStacks >= 50) dyn.atkSpeed += sp.debuffedAttackSpeed;

            // 정화 직후 5초
            if ((sp.cleanseWindowAccuracy || 0) > 0) {
                const sinceCleanse = frameCount - (player._lastCleanseFrame || -999999);
                if (sinceCleanse >= 0 && sinceCleanse <= 300) dyn.acc += sp.cleanseWindowAccuracy;
            }

            // 상태이상 보호막 보유
            const hasShield = (player.shieldStacks || 0) > 0;
            if (hasShield) {
                if ((sp.shieldedDefense || 0) > 0) dyn.def += sp.shieldedDefense;
                if ((sp.shieldedAttack || 0) > 0) dyn.atk += sp.shieldedAttack;
                if ((sp.shieldedEvasion || 0) > 0) dyn.eva += sp.shieldedEvasion;
            }

            // 주변 적 5명 이상
            const nearbyCount = countNearbyAliveEnemies(240);
            if ((sp.crowdDefense || 0) > 0 && nearbyCount >= 5) dyn.def += sp.crowdDefense;
            if ((sp.crowdAttack || 0) > 0 && nearbyCount >= 5) dyn.atk += sp.crowdAttack;

            // 연속 처치: 5초 내 3킬
            const killFrames = Array.isArray(player._gearKillFrames) ? player._gearKillFrames : [];
            while (killFrames.length && frameCount - killFrames[0] > 300) killFrames.shift();
            if ((sp.streakKillAttack || 0) > 0 && killFrames.length >= 3) dyn.atk += sp.streakKillAttack;

            // 연속 치명타: 4초 내 2회
            const critFrames = Array.isArray(player._gearCritFrames) ? player._gearCritFrames : [];
            while (critFrames.length && frameCount - critFrames[0] > 240) critFrames.shift();
            if ((sp.streakCritAttackSpeed || 0) > 0 && critFrames.length >= 2) dyn.atkSpeed += sp.streakCritAttackSpeed;

            // delta 적용
            for (const k of Object.keys(dyn)) {
                const prev = player._gearDynamicApplied[k] || 0;
                const next = dyn[k] || 0;
                const delta = next - prev;
                if (delta) applyGearStatDelta(k, delta);
                player._gearDynamicApplied[k] = next;
            }
        }

        // ---------------------------------------------------------
        // 장비 분해/버리기
        // ---------------------------------------------------------
        // [NEW] 패널이 열려 animate가 멈춘 상태에서도 즉시 보이는 토스트 메시지
        function showUiToast(text, { duration = 2200, good = true } = {}) {
            try {
                const el = document.createElement('div');
                el.textContent = String(text ?? '');
                el.style.position = 'fixed';
                el.style.left = '50%';
                el.style.top = '18%';
                el.style.transform = 'translate(-50%, -12px)';
                el.style.padding = '10px 14px';
                el.style.background = 'rgba(0,0,0,0.78)';
                el.style.border = '1px solid rgba(255,255,255,0.35)';
                el.style.borderRadius = '12px';
                el.style.boxShadow = '0 10px 24px rgba(0,0,0,0.35)';
                el.style.color = good ? '#8aff8a' : '#ffffff';
                el.style.fontSize = '18px';
                el.style.fontFamily = 'var(--ui-font-clean)';
                el.style.zIndex = '999999';
                el.style.pointerEvents = 'none';
                el.style.textAlign = 'center';
                el.style.whiteSpace = 'pre-line';
                document.body.appendChild(el);

                const dur = Math.max(600, Number(duration) || 2200);

                if (typeof el.animate === 'function') {
                    el.animate([
                        { opacity: 0, transform: 'translate(-50%, -14px) scale(0.98)' },
                        { opacity: 1, transform: 'translate(-50%, 0px) scale(1)' },
                        { opacity: 1, transform: 'translate(-50%, 0px) scale(1)' },
                        { opacity: 0, transform: 'translate(-50%, -14px) scale(0.98)' }
                    ], { duration: dur, easing: 'ease-out', fill: 'forwards' });
                } else {
                    el.style.opacity = '1';
                    el.style.transform = 'translate(-50%, 0px)';
                }

                setTimeout(() => { try { el.remove(); } catch (e) {} }, dur);
            } catch (e) {
                // fallback: 최소 보장
                try { alert(String(text ?? '')); } catch (_) {}
            }
        }

        function getGearCategoryForDisassemble(item) {
            if (!item) return 'armor';
            if (item.slot === 'Sword') return 'weapon';
            if (item.slot === 'Ring' || item.slot === 'Necklace') return 'accessory';
            return 'armor';
        }

        function getDisassembleLootId(item) {
            const r = item.rarity || 'common';
            const cat = getGearCategoryForDisassemble(item);
            if (cat === 'weapon') return `${r}_hardener`;
            if (cat === 'accessory') return `${r}_metal`;
            return `${r}_cloth`;
        }

        function disassembleGearItem(item) {
            const lootId = getDisassembleLootId(item);
            const qty = randInt(1, 5);
            const ok = addLootToInventory(lootId, qty);
            if (!ok) {
                alert('전리품 인벤토리가 가득 차서 분해 결과를 받을 수 없습니다.');
                return false;
            }

            const lootName = (LOOT_DEFS[lootId] && LOOT_DEFS[lootId].name) ? LOOT_DEFS[lootId].name : lootId;

            // [NEW] 어떤 재료를 몇 개 얻었는지 즉시 출력 (패널 열림/일시정지 상태에서도 보임)
            let hardener = 0, cloth = 0, metal = 0;
            const mi = parseEquipSynthesisMaterial(lootId);
            if (mi && mi.matType === 'hardener') hardener = qty;
            else if (mi && mi.matType === 'cloth') cloth = qty;
            else if (mi && mi.matType === 'metal') metal = qty;

            showUiToast(`분해 성공!\n획득: ${lootName} x${qty}\n(경화제 ${hardener} · 헝겊 조각 ${cloth} · 금속 조각 ${metal})`, { duration: 2600, good: true });

            // (선택) 게임 진행 중에는 기존 플로팅 텍스트도 함께 표시
            const px = player ? player.x : (W/2);
            const py = player ? player.y : (H/2);
            showPickupEffect(px, py - 26, `${lootName} x${qty}`, false, true, null);

            updateInventoryUI();
            return true;
        }

        // ---------------------------------------------------------
        // 장비 툴팁(마우스 오버)
        // ---------------------------------------------------------
        function formatEquipNumber(v, decimals = 1) {
            const p = Math.pow(10, decimals);
            const r = Math.round((v || 0) * p) / p;
            // 1.0 → 1, 2.5 → 2.5
            if (Math.abs(r - Math.round(r)) < 1e-9) return String(Math.round(r));
            return String(r);
        }

        function formatEquipValue(key, value) {
            if (key === 'acc' || key === 'eva' || key === 'magicChance' || key === 'atkSpeed') {
                return `+${Math.round((value || 0) * 1000) / 10}%`;
            }
            if (key === 'moveSpeed') return `+${Math.round((value || 0) * 10000) / 10000}`;
            if (key === 'reduceBleedDuration' || key === 'reducePoisonDotDamage' || key === 'reduceDarknessDuration' || key === 'reducePoopPoisonDotDamage' || key === 'reduceFishyDotDamage') {
                return `-${Math.round((value || 0) * 1000) / 10}%`;
            }
            if (key === 'critChance' || key === 'critResist') {
                return `+${formatEquipNumber(value, 1)}`;
            }
            if (key === 'atk' || key === 'def') {
                return `+${formatEquipNumber(value, 1)}`;
            }
            return `+${value}`;
        }

        function gearNameColor(rarityKey) {
            return EQUIP_RARITY_COLORS[rarityKey] || '#ffffff';
        }

        function escapeHTML(str) {
            return String(str ?? '').replace(/[&<>"']/g, (ch) => {
                switch (ch) {
                    case '&': return '&amp;';
                    case '<': return '&lt;';
                    case '>': return '&gt;';
                    case '"': return '&quot;';
                    case "'": return '&#39;';
                    default: return ch;
                }
            });
        }

        function rarityTextClass(rarityKey) {
            const rk = (rarityKey && EQUIP_RARITY_ORDER[rarityKey] !== undefined) ? rarityKey : 'common';
            return `rarity-${rk}`;
        }

        function rarityNameHTML(name, rarityKey) {
            return `<span class="rarity-name ${rarityTextClass(rarityKey)}">${escapeHTML(name)}</span>`;
        }

        function equipNameHTML(name, rarityKey) {
            const color = gearNameColor(rarityKey);
            return `<span class="equip-name-flat" style="--equip-name-color:${color};">${escapeHTML(name)}</span>`;
        }

        // ---------------------------------------------------------
        // [UI] 장비 옵션 티어(T5~T1) 표시 유틸
        // - overall(대표 티어): 옵션/암묵/특수옵션 tier 평균을 반올림
        // - best~worst 범위도 함께 표기(분포 확인)
        // ---------------------------------------------------------
        function _tierRank(tierLabel) {
            if (!tierLabel || typeof tierLabel !== 'string') return NaN;
            const m = tierLabel.match(/^T([1-5])$/);
            if (!m) return NaN;
            return parseInt(m[1], 10);
        }
        function _collectGearTierLabels(item) {
            const out = [];
            const pushTier = (t) => {
                if (!t || typeof t !== 'string') return;
                if (/^T[1-5]$/.test(t)) out.push(t);
            };
            const scan = (arr) => {
                if (!arr || !arr.length) return;
                for (const m of arr) {
                    if (!m) continue;
                    pushTier(m.tier);
                }
            };
            scan(item?.implicitMods);
            scan(item?.fixedMods);
            scan(item?.affixMods);
            scan(item?.fixedSpecialMods);
            scan(item?.specialMods);
            return out;
        }
        function computeGearTierSummary(item) {
            const tiers = _collectGearTierLabels(item);
            if (!tiers.length) return null;
            const nums = tiers.map(_tierRank).filter(n => !isNaN(n));
            if (!nums.length) return null;

            const bestN = Math.min(...nums);
            const worstN = Math.max(...nums);
            const avg = nums.reduce((a, b) => a + b, 0) / nums.length;
            const overallN = Math.max(1, Math.min(5, Math.round(avg)));

            return { best: `T${bestN}`, worst: `T${worstN}`, avg, overall: `T${overallN}` };
        }

        function getGearTooltipHTML(item, whereLabel) {
            const rKo = EQUIP_RARITY_KO[item.rarity] || item.rarity;
            const slotKo = EQUIP_SLOT_KO[item.slot] || item.slot;

            const lines = [];

            let badge = '';
            // 저장된 구버전 아이템 호환: isNamed=true지만 namedScope가 없으면 전역 네임드로 취급
            if (item.namedScope === 'exclusive') {
                badge = ` <span class="named-badge"><span class="dot"></span>전용 네임드</span>`;
            } else if (item.namedScope === 'world' || item.isNamed) {
                badge = ` <span class="named-badge"><span class="dot"></span>전역 네임드</span>`;
            }
            lines.push(`<div class="tt-name">${rarityNameHTML(item.name, item.rarity)}${badge}</div>`);
            const originLabel = item.dropFromLabel ? (' · 드랍: <b>' + escapeHTML(item.dropFromLabel) + '</b>') : '';
            const tierSum = computeGearTierSummary(item);
            const tierMeta = tierSum ? (` · 티어: <b>${tierSum.overall}</b><span class="tt-tier-range">(${tierSum.best}~${tierSum.worst})</span>`) : '';
            lines.push(`<div class="tt-meta">등급: <b>${rKo}</b> · 부위: <b>${slotKo}</b>${tierMeta}${originLabel}${whereLabel ? (' · <b>' + escapeHTML(whereLabel) + '</b>') : ''}</div>`);
            if (item.desc) lines.push(`<div class="tt-desc">${escapeHTML(item.desc)}</div>`);

            const pushStatSection = (title, mods) => {
                if (!mods || !mods.length) return;
                lines.push(`<div class="tt-section"><div class="tt-section-title">${title}</div>`);
                for (const m of mods) {
                    if (!m || !m.key) continue;
                    const label = EQUIP_STAT_LABELS[m.key] || m.key;
                    const t = (m.tier && /^T[1-5]$/.test(m.tier)) ? m.tier : '';
                    const badge = t ? `<span class="tier-badge tier-${t}">${t}</span>` : '';
                    lines.push(`<div class="tt-line"><span>${escapeHTML(label)}</span><span class="tt-v">${badge}<span class="tt-value">${escapeHTML(formatEquipValue(m.key, m.value || 0))}</span></span></div>`);
                }
                lines.push(`</div>`);
            };

            const pushSpecialSection = (title, specials, emphasize = false) => {
                if (!specials || !specials.length) return;
                const t = emphasize ? `${title} ✦` : title;
                lines.push(`<div class="tt-section"><div class="tt-section-title">${t}</div>`);
                for (const sm of specials) {
                    if (!sm || !sm.key) continue;
                    if (sm.type === 'boolean') {
                        const t = (sm.tier && /^T[1-5]$/.test(sm.tier)) ? sm.tier : '';
                        const badge = t ? `<span class="tier-badge tier-${t}">${t}</span>` : '';
                        lines.push(`<div class="tt-line"><span>${escapeHTML(sm.label || sm.key)}</span><span class="tt-v">${badge}<span class="tt-value">ON</span></span></div>`);
                    } else if (sm.type === 'reduce') {
                        const t = (sm.tier && /^T[1-5]$/.test(sm.tier)) ? sm.tier : '';
                        const badge = t ? `<span class="tier-badge tier-${t}">${t}</span>` : '';
                        lines.push(`<div class="tt-line"><span>${escapeHTML(sm.label || sm.key)}</span><span class="tt-v">${badge}<span class="tt-value">${escapeHTML(formatEquipValue(sm.key, sm.value || 0))}</span></span></div>`);
                    } else if (sm.type === 'conditional') {
                        const k = sm.baseStat || 'def';
                        const v = sm.value || 0;
                        const t = (sm.tier && /^T[1-5]$/.test(sm.tier)) ? sm.tier : '';
                        const badge = t ? `<span class="tier-badge tier-${t}">${t}</span>` : '';
                        lines.push(`<div class="tt-line"><span>${escapeHTML(sm.label || sm.key)}</span><span class="tt-v">${badge}<span class="tt-value">${escapeHTML(formatEquipValue(k, v))}</span></span></div>`);
                    }
                }
                lines.push(`</div>`);
            };

            pushStatSection('암묵 옵션', item.implicitMods || []);
            pushStatSection('고정 옵션', item.fixedMods || []);
            pushStatSection('옵션', item.affixMods || []);
            pushSpecialSection('스페셜 옵션', item.fixedSpecialMods || [], true);
            pushSpecialSection('레어 옵션', item.specialMods || []);

            return lines.join('');
        }

        function showGearTooltip(item, ev, whereLabel) {
            if (!item || !invTooltipEl) return;
            invTooltipEl.innerHTML = getGearTooltipHTML(item, whereLabel);
            invTooltipEl.dataset.cat = '';
            invTooltipEl.dataset.rarity = item.rarity || '';
            invTooltipEl.style.display = 'block';
            moveInvTooltip(ev);
        }

        function hideGearTooltip() {
            if (!invTooltipEl) return;
            invTooltipEl.style.display = 'none';
            invTooltipEl.dataset.rarity = '';
        }

        // ---------------------------------------------------------
        // 장비 인벤토리 UI
        // ---------------------------------------------------------
        function initEquipPanelUI() {
            equipPanelEl = document.getElementById('equipPanel');
            closeEquipPanelBtnEl = document.getElementById('closeEquipPanelBtn');
            gearInventoryGridEl = document.getElementById('gearInventoryGrid');
            equipSlotsUIEl = document.getElementById('equipSlotsUI');
            gearSortBtnEl = document.getElementById('gearSortBtn');
            gearBulkDisassembleBtnEl = document.getElementById('gearBulkDisassembleBtn');
            gearBulkRaritySelectEl = document.getElementById('gearBulkRaritySelect');
            gearEquipBtnEl = document.getElementById('gearEquipBtn');
            gearUnequipBtnEl = document.getElementById('gearUnequipBtn');
            gearDisassembleBtnEl = document.getElementById('gearDisassembleBtn');
            gearDropBtnEl = document.getElementById('gearDropBtn');
            gearSelectionInfoEl = document.getElementById('gearSelectionInfo');
            pendingGearInfoEl = document.getElementById('pendingGearInfo');
            equipStatsSummaryEl = document.getElementById('equipStatsSummary');

            if (!equipPanelEl) return;

            closeEquipPanelBtnEl?.addEventListener('click', () => closeEquipPanel());

            // inventory grid build
            gearInventoryGridEl.innerHTML = '';
            gearInventorySlotEls = [];
            for (let i=0; i<GEAR_INV_SIZE; i++) {
                const slotEl = document.createElement('div');
                slotEl.className = 'inv-slot';
                slotEl.dataset.index = i;
                slotEl.draggable = false;
                slotEl.innerHTML = `
                    <div class="inv-slot-inner">
                        <img class="inv-icon" alt="" style="display:none;" />
                        <div class="inv-empty-hint">EMPTY</div>
                        <div class="inv-reserved"></div>
                    </div>
                `;

                slotEl.addEventListener('mouseenter', (ev) => {
                    const it = gearInventorySlots[i];
                    if (!it) return;
                    showGearTooltip(it, ev, '인벤토리');
                });
                slotEl.addEventListener('mousemove', moveInvTooltip);
                slotEl.addEventListener('mouseleave', () => hideGearTooltip());

                slotEl.addEventListener('click', () => {
                    selectedGearInvIndex = i;
                    selectedEquipSlotKey = null;
                    updateEquipPanelUI();
                });
                slotEl.addEventListener('dblclick', () => {
                    selectedGearInvIndex = i;
                    selectedEquipSlotKey = null;
                    equipSelectedGear();
                });
                slotEl.addEventListener('contextmenu', (ev) => {
                    ev.preventDefault();
                    toggleGearLockByInventoryIndex(i);
                });

                // Drag (슬롯 이동/교환)
                slotEl.addEventListener('dragstart', (ev) => onGearInventoryDragStart(ev, i));
                slotEl.addEventListener('dragend',  (ev) => onGearInventoryDragEnd(ev, i));
                slotEl.addEventListener('dragover',  (ev) => onGearInventorySlotDragOver(ev, i));
                slotEl.addEventListener('dragleave', (ev) => onGearInventorySlotDragLeave(ev, i));
                slotEl.addEventListener('drop',      (ev) => onGearInventorySlotDrop(ev, i));

                gearInventoryGridEl.appendChild(slotEl);
                gearInventorySlotEls.push(slotEl);
            }

            // equip slots build
            equipSlotsUIEl.innerHTML = '';
            equipSlotEls = {};
            for (const slot of EQUIP_SLOT_TYPES) {
                const el = document.createElement('div');
                el.className = 'equip-slot';
                el.dataset.slot = slot;

                // placeholder icon
                if (!_gearSlotPlaceholder[slot]) _gearSlotPlaceholder[slot] = renderSlotPlaceholderIcon(slot);

                el.innerHTML = `
                    <div class="slot-icon"><img /></div>
                    <div class="slot-text">
                        <div class="slot-name">${EQUIP_SLOT_KO[slot] || slot}</div>
                        <div class="item-empty">비어 있음</div>
                    </div>
                `;

                el.querySelector('img').src = _gearSlotPlaceholder[slot];

                el.addEventListener('mouseenter', (ev) => {
                    const it = equippedGear[slot];
                    if (!it) return;
                    showGearTooltip(it, ev, '장착중');
                });
                el.addEventListener('mousemove', moveInvTooltip);
                el.addEventListener('mouseleave', () => hideGearTooltip());

                el.addEventListener('click', () => {
                    selectedEquipSlotKey = slot;
                    selectedGearInvIndex = null;
                    updateEquipPanelUI();
                });
                el.addEventListener('contextmenu', (ev) => {
                    ev.preventDefault();
                    const it = equippedGear[slot];
                    if (!it) return;
                    toggleGearLockByItem(it);
                });

                equipSlotsUIEl.appendChild(el);
                equipSlotEls[slot] = el;
            }

            gearSortBtnEl?.addEventListener('click', () => {
                sortGearInventory();
                updateEquipPanelUI();
            });
            gearBulkRaritySelectEl?.addEventListener('change', () => {
                gearBulkDisassembleRarity = gearBulkRaritySelectEl.value || 'epic';
            });
            gearBulkDisassembleBtnEl?.addEventListener('click', () => bulkDisassembleGearByRarity(gearBulkDisassembleRarity));

            gearEquipBtnEl?.addEventListener('click', () => equipSelectedGear());
            gearUnequipBtnEl?.addEventListener('click', () => unequipSelectedSlot());
            gearDisassembleBtnEl?.addEventListener('click', () => disassembleSelectedGear());
            gearDropBtnEl?.addEventListener('click', () => dropSelectedGear());
        }

        function openEquipPanel() {
            if (!isGameRunning || isLevelUpPaused) return;
            if (isGearPanelOpen) closeGearPanel(false);

            isEquipPanelOpen = true;
            hideGearTooltip();
            equipPanelEl.style.display = 'flex';
            updateEquipPanelUI();
        }

        function closeEquipPanel(resume = true) {
            isEquipPanelOpen = false;
            hideGearTooltip();
            clearGearInventoryDragOver();
            gearInvDragSourceIndex = null;
            if (equipPanelEl) equipPanelEl.style.display = 'none';
            selectedGearInvIndex = null;
            selectedEquipSlotKey = null;

            if (resume && isGameRunning && !isLevelUpPaused && !isGearPanelOpen) {
                requestAnimationFrame(animate);
            }
        }

        function toggleEquipPanel() {
            if (isEquipPanelOpen) closeEquipPanel();
            else openEquipPanel();
        }

        function sortGearInventory() {
            // null은 뒤로, 등급 높은 순 → 슬롯 순 → 이름
            const items = gearInventorySlots.filter(Boolean);
            items.sort((a, b) => {
                const ra = EQUIP_RARITY_ORDER[a.rarity] || 0;
                const rb = EQUIP_RARITY_ORDER[b.rarity] || 0;
                if (ra !== rb) return rb - ra;
                const sa = EQUIP_SLOT_TYPES.indexOf(a.slot);
                const sb = EQUIP_SLOT_TYPES.indexOf(b.slot);
                if (sa !== sb) return sa - sb;
                return (a.name || '').localeCompare(b.name || '');
            });
            gearInventorySlots = new Array(GEAR_INV_SIZE).fill(null);
            for (let i=0;i<Math.min(items.length, GEAR_INV_SIZE);i++) {
                gearInventorySlots[i] = items[i];
            }
            saveGearToStorage();
        }

        // ---------------------------
        // [NEW] 장비 인벤토리 슬롯 드래그 이동/교환
        //  - 슬롯끼리 드래그하면 서로 교환됩니다.
        //  - 빈 슬롯으로 드래그하면 해당 위치로 이동합니다. (swap with null)
        // ---------------------------
        function clearGearInventoryDragOver() {
            if (!gearInventoryGridEl) return;
            gearInventoryGridEl.querySelectorAll('.inv-slot.drag-over').forEach(el => el.classList.remove('drag-over'));
        }

        function swapGearInventoryIndices(i, j) {
            if (i === j) return;

            const tmp = gearInventorySlots[i];
            gearInventorySlots[i] = gearInventorySlots[j];
            gearInventorySlots[j] = tmp;

            // 선택 인덱스 보정
            if (selectedGearInvIndex === i) selectedGearInvIndex = j;
            else if (selectedGearInvIndex === j) selectedGearInvIndex = i;

            saveGearToStorage();
            updateEquipPanelUI();
        }

        function onGearInventoryDragStart(ev, invIndex) {
            const it = gearInventorySlots[invIndex];
            if (!it) { ev.preventDefault(); return; }

            gearInvDragSourceIndex = invIndex;

            const el = gearInventorySlotEls?.[invIndex];
            if (el) el.classList.add('dragging');

            try {
                ev.dataTransfer.setData('text/plain', JSON.stringify({ gearInvIndex: invIndex }));
                ev.dataTransfer.effectAllowed = 'move';
            } catch (e) {}
        }

        function onGearInventoryDragEnd(ev, invIndex) {
            const el = gearInventorySlotEls?.[invIndex];
            if (el) el.classList.remove('dragging');
            clearGearInventoryDragOver();
            gearInvDragSourceIndex = null;
        }

        function onGearInventorySlotDragOver(ev, targetIndex) {
            if (gearInvDragSourceIndex == null) return;
            ev.preventDefault();

            const el = gearInventorySlotEls?.[targetIndex];
            if (!el) return;

            clearGearInventoryDragOver();
            el.classList.add('drag-over');

            try { ev.dataTransfer.dropEffect = 'move'; } catch (e) {}
        }

        function onGearInventorySlotDragLeave(ev, targetIndex) {
            const el = gearInventorySlotEls?.[targetIndex];
            if (el) el.classList.remove('drag-over');
        }

        function onGearInventorySlotDrop(ev, targetIndex) {
            if (gearInvDragSourceIndex == null) return;
            ev.preventDefault();
            clearGearInventoryDragOver();

            // 우선 dataTransfer를 시도하고, 실패하면 내부 상태 사용
            let fromIndex = null;
            try {
                const payload = JSON.parse(ev.dataTransfer.getData('text/plain'));
                if (payload && payload.gearInvIndex != null) fromIndex = payload.gearInvIndex;
            } catch (e) {}

            if (fromIndex == null) fromIndex = gearInvDragSourceIndex;

            const a = Number(fromIndex);
            const b = Number(targetIndex);
            if (!Number.isFinite(a) || !Number.isFinite(b)) return;
            if (a === b) return;

            swapGearInventoryIndices(a, b);
        }


        function equipSelectedGear() {
            if (selectedGearInvIndex == null) return;
            const it = gearInventorySlots[selectedGearInvIndex];
            if (!it) return;

            const slot = it.slot;
            const prev = equippedGear[slot];

            // swap: 기존 장착 장비는 선택 슬롯에 들어감(공간 필요 없음)
            equippedGear[slot] = it;
            gearInventorySlots[selectedGearInvIndex] = prev ? prev : null;

            saveGearToStorage();
            applyEquippedGearBonuses(false);
            flushPendingGearDrops();
            updateEquipPanelUI();
        }

        function unequipSelectedSlot() {
            if (!selectedEquipSlotKey) return;
            const slot = selectedEquipSlotKey;
            const it = equippedGear[slot];
            if (!it) return;

            const idx = findFirstEmptyGearSlot();
            if (idx < 0) {
                alert('장비 인벤토리가 가득 차서 해제할 수 없습니다.\n(분해/버리기로 공간을 확보하세요.)');
                return;
            }

            equippedGear[slot] = null;
            gearInventorySlots[idx] = it;

            saveGearToStorage();
            applyEquippedGearBonuses(false);
            updateEquipPanelUI();
        }

        function disassembleSelectedGear() {
            let it = null;
            let src = '';
            if (selectedGearInvIndex != null) {
                it = gearInventorySlots[selectedGearInvIndex];
                src = 'inv';
            } else if (selectedEquipSlotKey) {
                it = equippedGear[selectedEquipSlotKey];
                src = 'equip';
            }
            if (!it) return;
            if (isGearLocked(it)) { showUiToast('잠긴 장비는 분해할 수 없습니다.', { good:false }); return; }

            if (!confirm(`'${it.name}' 를 분해할까요?\n(등급/부위에 따라 경화제/헝겊/금속 조각을 1~5개 획득)`)) return;

            const ok = disassembleGearItem(it);
            if (!ok) return;

            // remove item
            if (src === 'inv') {
                gearInventorySlots[selectedGearInvIndex] = null;
            } else {
                equippedGear[selectedEquipSlotKey] = null;
                applyEquippedGearBonuses(false);
            }

            saveGearToStorage();
            flushPendingGearDrops();
            updateEquipPanelUI();
        }

        function dropSelectedGear() {
            let it = null;
            let src = '';
            if (selectedGearInvIndex != null) {
                it = gearInventorySlots[selectedGearInvIndex];
                src = 'inv';
            } else if (selectedEquipSlotKey) {
                it = equippedGear[selectedEquipSlotKey];
                src = 'equip';
            }
            if (!it) return;

            if (!confirm(`'${it.name}' 를 버릴까요?\n(버리면 복구할 수 없습니다)`)) return;

            if (src === 'inv') {
                gearInventorySlots[selectedGearInvIndex] = null;
            } else {
                equippedGear[selectedEquipSlotKey] = null;
                applyEquippedGearBonuses(false);
            }

            saveGearToStorage();
            flushPendingGearDrops();
            updateEquipPanelUI();
        }


        function getGearUid(item) { return item && item.uid ? String(item.uid) : ''; }
        function isGearLocked(item) {
            const uid = getGearUid(item);
            return !!(uid && gearLockMap[uid]);
        }
        function setGearLocked(item, locked) {
            const uid = getGearUid(item);
            if (!uid) return;
            if (locked) gearLockMap[uid] = 1;
            else delete gearLockMap[uid];
            saveGearToStorage();
        }
        function toggleGearLockByItem(item) {
            if (!item) return;
            const next = !isGearLocked(item);
            setGearLocked(item, next);
            showUiToast(next ? '장비 잠금' : '장비 잠금 해제', { good: true });
            updateEquipPanelUI();
        }
        function toggleGearLockByInventoryIndex(idx) {
            const it = gearInventorySlots[idx];
            if (!it) return;
            selectedGearInvIndex = idx;
            selectedEquipSlotKey = null;
            toggleGearLockByItem(it);
        }
        function bulkDisassembleGearByRarity(maxRarity = 'epic') {
            const maxOrder = EQUIP_RARITY_ORDER[maxRarity] ?? EQUIP_RARITY_ORDER.epic;
            let cnt = 0;
            for (let i=0;i<gearInventorySlots.length;i++) {
                const it = gearInventorySlots[i];
                if (!it) continue;
                if (isGearLocked(it)) continue;
                const ord = EQUIP_RARITY_ORDER[it.rarity] ?? 999;
                if (ord > maxOrder) continue;
                if (disassembleGearItem(it)) {
                    gearInventorySlots[i] = null;
                    cnt++;
                }
            }
            if (cnt > 0) {
                saveGearToStorage();
                flushPendingGearDrops();
                updateEquipPanelUI();
                showUiToast(`일괄 분해 완료: ${cnt}개`, { good:true });
            } else {
                showUiToast('분해 가능한 장비가 없습니다.', { good:false });
            }
        }

        function updateEquipPanelUI() {
            updateEquipSlotsUI();
            updateGearInventoryUI();
            updateGearSelectionUI();
            updateEquipSummaryUI();
        }

        function fitEquipNameToTwoLines(nameEl) {
            if (!nameEl) return false;

            const textSpan = nameEl.querySelector('.equip-name-flat, .rarity-name') || nameEl;
            if (!textSpan) return false;

            const defaultSize = 12.5;
            const minSize = 10.5;
            const step = 0.25;

            textSpan.style.fontSize = defaultSize + 'px';
            textSpan.style.lineHeight = '1.18';
            textSpan.style.letterSpacing = '0px';

            const getLineHeight = () => {
                const lh = parseFloat(getComputedStyle(textSpan).lineHeight);
                return Number.isFinite(lh) ? lh : (parseFloat(getComputedStyle(textSpan).fontSize) * 1.15);
            };
            const CLIP_SAFE_PX = 4;
            const isOverflowing = () => {
                const lineH = getLineHeight();
                const maxH = (lineH * 2) + CLIP_SAFE_PX;
                return textSpan.scrollHeight > maxH || textSpan.getBoundingClientRect().height > maxH;
            };

            let guard = 0;
            while (isOverflowing() && parseFloat(getComputedStyle(textSpan).fontSize) > minSize && guard < 20) {
                const cur = parseFloat(getComputedStyle(textSpan).fontSize);
                textSpan.style.fontSize = Math.max(minSize, cur - step) + 'px';
                guard++;
            }

            const stillOverflow = isOverflowing();
            const finalMaxHeight = (getLineHeight() * 2) + CLIP_SAFE_PX;
            nameEl.style.maxHeight = Math.ceil(finalMaxHeight) + 'px';
            nameEl.style.overflow = 'hidden';
            return stillOverflow;
        }




        function updateEquipSlotsUI() {
            for (const slot of EQUIP_SLOT_TYPES) {
                const el = equipSlotEls[slot];
                if (!el) continue;
                const it = equippedGear[slot];
                el.classList.toggle('selected', selectedEquipSlotKey === slot);

                // 등급/네임드 데이터셋(아이콘 글로우 등 UI용)
                el.dataset.rarity = it ? (it.rarity || '') : '';
                el.dataset.named = (it && it.isNamed) ? '1' : '0';

                const img = el.querySelector('img');
                const nameEl = el.querySelector('.item-empty');
                el.classList.remove('long-name');

                if (it) {
                    if (img) {
                        setGearItemIconToImg(img, it, _gearSlotPlaceholder[slot]);
                        img.style.filter = '';
                    }
                    if (nameEl) {
                        const lockBadge = isGearLocked(it) ? '<span class="equip-lock-badge" title="잠금">🔒</span>' : '';
                        nameEl.innerHTML = `<span class="equip-name-pill">${equipNameHTML(it.name, it.rarity)}</span>${lockBadge}`;
                        nameEl.style.opacity = '0.98';
                        fitEquipNameToTwoLines(nameEl);
                    }
                } else {
                    if (img) {
                        img.src = _gearSlotPlaceholder[slot];
                        img.style.filter = 'grayscale(1)';
                    }
                    if (nameEl) {
                        nameEl.textContent = '비어 있음';
                        nameEl.style.opacity = '0.60';
                        nameEl.style.maxHeight = '';
                    }
                }
            }
        }

        function updateGearInventoryUI() {
            for (let i=0;i<GEAR_INV_SIZE;i++) {
                const el = gearInventorySlotEls[i];
                if (!el) continue;
                const it = gearInventorySlots[i];

                el.classList.toggle('selected', selectedGearInvIndex === i);
                el.dataset.gearRarity = it ? (it.rarity || '') : '';
                el.dataset.gearEquipped = '0';
                el.dataset.gearNamed = (it && it.isNamed) ? '1' : '0';
                el.dataset.gearLocked = (it && isGearLocked(it)) ? '1' : '0';

                const iconEl = el.querySelector('.inv-icon');
                const emptyEl = el.querySelector('.inv-empty-hint');
                const tagEl = el.querySelector('.inv-reserved');

                if (!it) {
                    if (iconEl) { iconEl.style.display = 'none'; iconEl.src = ''; }
                    if (emptyEl) emptyEl.style.display = 'block';
                    if (tagEl) { tagEl.style.display = 'none'; tagEl.textContent = ''; }
                    el.classList.remove('dragging', 'drag-over');
                    el.draggable = false;
                } else {
                    if (iconEl) { iconEl.style.display = 'block'; setGearItemIconToImg(iconEl, it, ''); }
                    if (emptyEl) emptyEl.style.display = 'none';
                    if (tagEl) { tagEl.style.display = 'block'; tagEl.textContent = (isGearLocked(it) ? '🔒 ' : '') + (EQUIP_SLOT_KO[it.slot] || ''); }
                    el.draggable = true;
                }
            }

            // pending 표시
            if (pendingGearInfoEl) {
                if (pendingGearDrops.length > 0) {
                    pendingGearInfoEl.textContent = `보관 대기: ${pendingGearDrops.length}개`;
                } else {
                    pendingGearInfoEl.textContent = '';
                }
            }
        }

        function updateGearSelectionUI() {
            // 버튼 enable/disable
            let invItem = (selectedGearInvIndex != null) ? gearInventorySlots[selectedGearInvIndex] : null;
            let eqItem = (selectedEquipSlotKey != null) ? equippedGear[selectedEquipSlotKey] : null;

            if (gearEquipBtnEl) gearEquipBtnEl.disabled = !invItem;
            if (gearUnequipBtnEl) gearUnequipBtnEl.disabled = !eqItem;
            if (gearDisassembleBtnEl) gearDisassembleBtnEl.disabled = !(invItem || eqItem);
            if (gearDropBtnEl) gearDropBtnEl.disabled = !(invItem || eqItem);

            if (gearSelectionInfoEl) {
                if (invItem) {
                    const rKo = EQUIP_RARITY_KO[invItem.rarity] || invItem.rarity;
                    const named = invItem.isNamed ? ' <span class="named-badge"><span class="dot"></span>네임드</span>' : '';
                    const locked = isGearLocked(invItem) ? ' <span class="named-badge">🔒잠금</span>' : '';
                    gearSelectionInfoEl.innerHTML = `선택: ${rarityNameHTML(invItem.name, invItem.rarity)}${named}${locked} <span style="opacity:0.78;">(${rKo} · ${EQUIP_SLOT_KO[invItem.slot]})</span>`;
                } else if (eqItem) {
                    const rKo = EQUIP_RARITY_KO[eqItem.rarity] || eqItem.rarity;
                    const named = eqItem.isNamed ? ' <span class="named-badge"><span class="dot"></span>네임드</span>' : '';
                    const locked = isGearLocked(eqItem) ? ' <span class="named-badge">🔒잠금</span>' : '';
                    gearSelectionInfoEl.innerHTML = `선택: ${rarityNameHTML(eqItem.name, eqItem.rarity)}${named}${locked} <span style="opacity:0.78;">(장착 · ${rKo} · ${EQUIP_SLOT_KO[eqItem.slot]})</span>`;
                } else {
                    gearSelectionInfoEl.textContent = '선택된 장비가 없습니다.';
                }
            }
        }

        function updateEquipSummaryUI() {
            if (!equipStatsSummaryEl) return;

            const res = computeEquippedGearTotals();
            const t = res.totals;

            const lines = [];
            lines.push(`<div style="opacity:0.9;">[장착 합산]</div>`);
            const pushIf = (label, v, fmt) => {
                if (!v) return;
                lines.push(`<div>${label}: <b>${fmt(v)}</b></div>`);
            };
            pushIf('공격', t.atk, v => `+${Math.round(v)}`);
            pushIf('방어', t.def, v => `+${Math.round(v)}`);
            pushIf('명중', t.acc, v => `+${Math.round(v*1000)/10}%`);
            pushIf('회피', t.eva, v => `+${Math.round(v*1000)/10}%`);
            pushIf('치확', t.critChance, v => `+${Math.round(v*10)/10}`);
            pushIf('치저', t.critResist, v => `+${Math.round(v*10)/10}`);
            pushIf('매직 찬스', t.magicChance, v => `+${Math.round(v*1000)/10}% (최대 25%)`);

            const cr = res.combinedReduce || {};
            const reduceLines = [];
            const pushReduce = (label, v) => {
                if (!v) return;
                reduceLines.push(`<div>${label}: <b>-${Math.round(v*1000)/10}%</b></div>`);
            };
            pushReduce('출혈 지속시간', cr.reduceBleedDuration || 0);
            pushReduce('독(가스) 도트 피해', cr.reducePoisonDotDamage || 0);
            pushReduce('어둠 지속시간', cr.reduceDarknessDuration || 0);
            pushReduce('똥독 도트 피해', cr.reducePoopPoisonDotDamage || 0);
            pushReduce('비린내 도트 피해', cr.reduceFishyDotDamage || 0);

            if (reduceLines.length) {
                lines.push('<div style="margin-top:8px; opacity:0.9;">[디버프 감소]</div>');
                lines.push(reduceLines.join(''));
            }

            if (res.immuneCurseEndDamage) {
                lines.push('<div style="margin-top:8px; opacity:0.9;">[면역]</div>');
                lines.push('<div>저주 종료 피해: <b>면역</b></div>');
            }

            const sp = res.specialMax || {};
            const cond = [];
            const pushCond = (label, v, isPct) => {
                if (!v) return;
                cond.push(`<div>${label}: <b>+${isPct ? (Math.round(v*1000)/10)+'%' : v}</b></div>`);
            };
            pushCond('체력 30%↓ 회피', sp.lowHpEvasion || 0, true);
            pushCond('체력 30%↓ 치확', sp.lowHpCritChance || 0, false);
            pushCond('체력 30%↓ 공속', sp.lowHpAttackSpeed || 0, true);
            pushCond('체력 50%↑ 방어', sp.highHpDefense || 0, false);
            pushCond('체력 60%↑ 회피', sp.highHpEvasion || 0, true);
            pushCond('체력 60%↑ 이속', sp.highHpMoveSpeed || 0, false);
            pushCond('3초 무피격 명중', sp.noHitAccuracy || 0, true);
            pushCond('3초 무피격 회피', sp.noHitEvasion || 0, true);
            pushCond('3초 무피격 공격', sp.noHitAttack || 0, false);
            pushCond('최근 2초 피격 방어', sp.recentlyHitDefense || 0, false);
            pushCond('연속 치명타 치확(4초)', sp.doubleCritCritChance || 0, false);
            pushCond('보스 존재 시 방어', sp.bossPresentDefense || 0, false);
            pushCond('디버프 50중첩 방어', sp.debuffedDefense || 0, false);
            pushCond('디버프 50중첩 공속', sp.debuffedAttackSpeed || 0, true);
            pushCond('정화 5초 명중', sp.cleanseWindowAccuracy || 0, true);
            pushCond('보호막 보유 방어', sp.shieldedDefense || 0, false);
            pushCond('보호막 보유 공격', sp.shieldedAttack || 0, false);
            pushCond('보호막 보유 회피', sp.shieldedEvasion || 0, true);
            pushCond('근처 5명↑ 방어', sp.crowdDefense || 0, false);
            pushCond('근처 5명↑ 공격', sp.crowdAttack || 0, false);
            pushCond('5초 3킬 공격', sp.streakKillAttack || 0, false);
            pushCond('4초 2치명 공속', sp.streakCritAttackSpeed || 0, true);

            if (cond.length) {
                lines.push('<div style="margin-top:8px; opacity:0.9;">[조건부]</div>');
                lines.push(cond.join(''));
            }

            equipStatsSummaryEl.innerHTML = lines.join('');
        }

        // ---------------------------------------------------------
        // 장비 획득 효과음(유니크+)
        // ---------------------------------------------------------
        let _gearAudioCtx = null;
        function playGearDropSfx(rarityKey) {
            try {
                if (!_gearAudioCtx) _gearAudioCtx = new (window.AudioContext || window.webkitAudioContext)();
                const ctx = _gearAudioCtx;

                const now = ctx.currentTime;
                const gain = ctx.createGain();
                gain.gain.setValueAtTime(0.0001, now);
                gain.gain.exponentialRampToValueAtTime(0.18, now + 0.01);
                gain.gain.exponentialRampToValueAtTime(0.0001, now + 1.0);
                gain.connect(ctx.destination);

                const idx = EQUIP_RARITY_ORDER[rarityKey] || 0;

                // 기본 멜로디 (유니크)
                let seq = [660, 880, 990, 1320];
                if (rarityKey === 'legendary') seq = [660, 990, 1320, 1760, 1320];
                if (rarityKey === 'demonic')   seq = [220, 330, 277, 415, 311];
                if (rarityKey === 'angelic')  seq = [880, 1174, 1568, 1760, 2349];

                const oscType = (rarityKey === 'demonic') ? 'sawtooth' : 'triangle';

                seq.forEach((freq, i) => {
                    const o = ctx.createOscillator();
                    o.type = oscType;
                    o.frequency.setValueAtTime(freq, now + i*0.08);
                    o.connect(gain);
                    o.start(now + i*0.08);
                    o.stop(now + i*0.08 + 0.12);
                });

                // 상위 등급은 얇은 하모닉 추가
                if (idx >= EQUIP_RARITY_ORDER.legendary) {
                    const o2 = ctx.createOscillator();
                    const g2 = ctx.createGain();
                    o2.type = 'sine';
                    o2.frequency.setValueAtTime(seq[seq.length-1] * 2, now + 0.02);
                    g2.gain.setValueAtTime(0.0001, now);
                    g2.gain.exponentialRampToValueAtTime(0.06, now + 0.02);
                    g2.gain.exponentialRampToValueAtTime(0.0001, now + 0.6);
                    o2.connect(g2); g2.connect(ctx.destination);
                    o2.start(now);
                    o2.stop(now + 0.6);
                }
            } catch (e) {
                // ignore
            }
        }

// ---------------------------
// [드랍] 적 처치 시 전리품 자동 획득

function handleLootDrop(enemy) {
            // =========================
            // [일반 전리품] (기존 드랍)
            // =========================
            let dropId = null;
            let chance = 0;

            // 엘리트(20%)
            if (enemy.isRyuon)        { dropId = 'ryuon_emblem';  chance = 0.30; }
            else if (enemy.isLuca)    { dropId = 'luca_diary';    chance = 0.30; }
            else if (enemy.isOzma)    { dropId = 'ozma_orb';      chance = 0.30; }
            else if (enemy.isTaro)    { dropId = 'taro_chain';    chance = 0.30; }
            else if (enemy.isGawain)  { dropId = 'gawain_flag';   chance = 0.30; }
            else if (enemy.isAki && !enemy.isAkiClone) { dropId = 'aki_potion'; chance = 0.30; }
            else if (enemy.isHiro)    { dropId = 'hiro_radio';    chance = 0.30; }
            else if (enemy.isKai && !enemy.isBoss) { dropId = 'kai_grimoire'; chance = 0.30; }
            else if (enemy.isJacques) { dropId = 'jacques_note';  chance = 0.30; }
            else if (enemy.isCassias) { dropId = 'cassias_badge'; chance = 0.30; }

            // 로열(15%)
            else if (enemy.isMasakuni) { dropId = 'masakuni_mask'; chance = 0.25; }
            else if (enemy.isKaito)    { dropId = 'kaito_orb';     chance = 0.25; }
            else if (enemy.isQuesta)   { dropId = 'questa_bottle'; chance = 0.25; }
            else if (enemy.isTetora)   { dropId = 'tetora_note';   chance = 0.25; }

            // 보스(10%)
            else if (enemy.isBoss && !enemy.isArchdemon && !enemy.isArthur) { dropId = 'dark_virus'; chance = 0.15; } // 방구킹 카인
            else if (enemy.isArthur) { dropId = 'blood_hilt'; chance = 0.15; } // 타락한 로드 아서

            if (dropId && Math.random() < chance) {
                const ok = addLootToInventory(dropId, 1);
                const itemName = LOOT_DEFS[dropId]?.name || dropId;

                if (ok) {
                    showPickupEffect(enemy.x, enemy.y - 70, `전리품 +1: ${itemName}`, true, false, "goddess-text");
                } else {
                    showPickupEffect(enemy.x, enemy.y - 70, `인벤토리 가득! ${itemName} 소실`, false, false, "weak-text");
                }
            }

            // =========================
            // [레어 전리품] (신규 드랍)
            //  - 0.75% -> 1%
            //  - 0.5%  -> 0.75%
            //  - 0.1%  -> 0.5%
            // =========================
            let rareId = null;
            let rareChance = 0;

            // 엘리트 레어(1%)
            if (enemy.isRyuon)        { rareId = 'oath_blooddrop';      rareChance = 0.01; }
            else if (enemy.isLuca)    { rareId = 'broken_aim_lens';     rareChance = 0.01; }
            else if (enemy.isOzma)    { rareId = 'arcane_echo_dust';    rareChance = 0.01; }
            else if (enemy.isTaro)    { rareId = 'torn_letter';         rareChance = 0.01; }
            else if (enemy.isGawain)  { rareId = 'oath_wind_shard';     rareChance = 0.01; }
            else if (enemy.isAki && !enemy.isAkiClone) { rareId = 'dark_sediment';   rareChance = 0.01; }
            else if (enemy.isHiro)    { rareId = 'call_sign_noise';     rareChance = 0.01; }
            else if (enemy.isKai && !enemy.isBoss) { rareId = 'greed_ink_trace';     rareChance = 0.01; }
            else if (enemy.isJacques) { rareId = 'dissonance_meter';    rareChance = 0.01; }
            else if (enemy.isCassias) { rareId = 'rank_seal_wax';       rareChance = 0.01; }

            // 로열 레어(0.75%)
            else if (enemy.isMasakuni) { rareId = 'abyss_orb';                 rareChance = 0.0075; }
            else if (enemy.isKaito)    { rareId = 'black_confession_thread';   rareChance = 0.0075; }
            else if (enemy.isQuesta)   { rareId = 'black_veil_strand';         rareChance = 0.0075; }
            else if (enemy.isTetora)   { rareId = 'abyss_phrase';              rareChance = 0.0075; }

            // 보스 레어(0.5%)
            else if (enemy.isBoss && !enemy.isArchdemon && !enemy.isArthur) { rareId = 'abyss_residual_spore'; rareChance = 0.005; } // 방구킹 카인
            else if (enemy.isArthur) { rareId = 'true_ancestor_mark'; rareChance = 0.005; } // 타락한 로드 아서

            if (rareId && Math.random() < rareChance) {
                const ok = addLootToInventory(rareId, 1);
                const itemName = LOOT_DEFS[rareId]?.name || rareId;

                if (ok) {
                    showPickupEffect(enemy.x, enemy.y - 70, `레어 전리품 +1: ${itemName}`, true, true, "evil-purple-text");
                } else {
                    showPickupEffect(enemy.x, enemy.y - 70, `인벤토리 가득! ${itemName} 소실`, false, false, "weak-text");
                }
            }

                        // =========================
            // [일반 빌런 전리품] (신규 드랍)
            //  - 공작원(저주/실명/고통): 일반 1% / 레어 0.75%
            //  - 소환사(역병/덮치기범/테러범): 일반 1% / 레어 0.75%
            //  - 강간범(일반/은신/매복): 일반 1% / 레어 0.75%
            // =========================
            let nvId = null;
            let nvChance = 0;
            let nvRareId = null;
            let nvRareChance = 0;

            if (enemy.isAgent) {
                nvId = 'curse_vial'; nvChance = 0.01;
                nvRareId = 'poisoned_hilt'; nvRareChance = 0.0075;
            } else if (!enemy.isElite && enemy.normalType === 'summoner') {
                nvId = 'dark_cloak_fragment'; nvChance = 0.01;
                nvRareId = 'ebony_powder'; nvRareChance = 0.0075;
            } else if (!enemy.isElite && enemy.normalType === 'rapist') {
                nvId = 'used_condom'; nvChance = 0.01;
                nvRareId = 'aphrodisiac_perfume'; nvRareChance = 0.0075;
            }

            if (nvId && Math.random() < nvChance) {
                const ok = addLootToInventory(nvId, 1);
                const itemName = LOOT_DEFS[nvId]?.name || nvId;

                if (ok) {
                    showPickupEffect(enemy.x, enemy.y - 70, `전리품 +1: ${itemName}`, true, false, "goddess-text");
                } else {
                    showPickupEffect(enemy.x, enemy.y - 70, `인벤토리 가득! ${itemName} 소실`, false, false, "weak-text");
                }
            }

            if (nvRareId && Math.random() < nvRareChance) {
                const ok = addLootToInventory(nvRareId, 1);
                const itemName = LOOT_DEFS[nvRareId]?.name || nvRareId;

                if (ok) {
                    showPickupEffect(enemy.x, enemy.y - 70, `레어 전리품 +1: ${itemName}`, true, true, "evil-purple-text");
                } else {
                    showPickupEffect(enemy.x, enemy.y - 70, `인벤토리 가득! ${itemName} 소실`, false, false, "weak-text");
                }
            }

updateInventoryUI();
            updateEnhanceUI();
        }

        // ---------------------------
        // [강화] 요구 재료 계산
        // ---------------------------
        function getWeaponUpgradeRequirement(curLv) {
            const nextLv = curLv + 1;
            if (nextLv % 10 === 0) {
                const bossCount = Math.floor(nextLv / 10);
                return {
                    type: 'boss',
                    nextLv,
                    bossCount,
                    text: `'다크 바이러스' x${bossCount} + '피로 물든 칼자루' x${bossCount}`
                };
            }
            const eliteNeed = (curLv * 2) + 1;            // 1->2:3, 2->3:5 ...
            const royalNeed = Math.max(0, curLv - 1);     // 1->2:0, 2->3:1 ...
            return {
                type: 'normal',
                nextLv,
                eliteNeed,
                royalNeed,
                text: `엘리트 전리품 x${eliteNeed}` + (royalNeed > 0 ? ` + 로열 전리품 x${royalNeed}` : '')
            };
        }

        function getArmorUpgradeRequirement(curLv) {
            const nextLv = curLv + 1;
            if (nextLv % 10 === 0) {
                const bossNeed = Math.floor(nextLv / 10);
                return {
                    type: 'bossAny',
                    nextLv,
                    bossNeed,
                    text: `보스 전리품(아무거나) x${bossNeed}`
                };
            }
            const eliteNeed = curLv;                      // 1->2:1, 2->3:2 ...
            const royalNeed = Math.max(0, curLv - 1);     // 1->2:0, 2->3:1 ...
            return {
                type: 'normal',
                nextLv,
                eliteNeed,
                royalNeed,
                text: `엘리트 전리품 x${eliteNeed}` + (royalNeed > 0 ? ` + 로열 전리품 x${royalNeed}` : '')
            };
        }


        // ---------------------------
        // [NEW] 장비 등급 업그레이드(레어 전리품 소모)
        //  - Lv.30에서만 가능
        //  - 커먼 → 언커먼 → 레어 → 유니크 → 히로익 → 아티팩트 → 미스틱 → 레전더리 → 기간틱 → 데모닉 → 엔젤릭
        // ---------------------------
        const GRADE_UPGRADE_REQ = [
            { elite: 10,  royal: 0,  boss: 0  },  // 커먼 -> 언커먼
            { elite: 20,  royal: 5,  boss: 0  },  // 언커먼 -> 레어
            { elite: 30,  royal: 10, boss: 0  },  // 레어 -> 유니크
            { elite: 40,  royal: 15, boss: 1  },  // 유니크 -> 히로익
            { elite: 50,  royal: 20, boss: 3  },  // 히로익 -> 아티팩트
            { elite: 60,  royal: 25, boss: 5  },  // 아티팩트 -> 미스틱
            { elite: 70,  royal: 30, boss: 7  },  // 미스틱 -> 레전더리
            { elite: 80,  royal: 35, boss: 9  },  // 레전더리 -> 기간틱
            { elite: 90,  royal: 40, boss: 12 },  // 기간틱 -> 데모닉
            { elite: 100, royal: 45, boss: 15 }   // 데모닉 -> 엔젤릭
        ];

        function getGearUpgradeMode(gear) {
            const lv = (gear === 'weapon') ? weaponEnhanceLevel : armorEnhanceLevel;
            const g  = (gear === 'weapon') ? weaponGradeIndex : armorGradeIndex;

            if (lv < MAX_ENHANCE_LEVEL) return 'level';
            if (g < MAX_GEAR_GRADE_INDEX) return 'grade';
            return 'max';
        }

        function getGradeUpgradeRequirement(curGradeIndex) {
            if (curGradeIndex >= MAX_GEAR_GRADE_INDEX) {
                return { type: 'max' };
            }

            const req = GRADE_UPGRADE_REQ[curGradeIndex] || { elite: 0, royal: 0, boss: 0 };
            const nextGrade = curGradeIndex + 1;

            const parts = [];
            if ((req.elite || 0) > 0) parts.push(`엘리트 빌런 레어 전리품 x${req.elite}`);
            if ((req.royal || 0) > 0) parts.push(`로열 빌런 레어 전리품 x${req.royal}`);
            if ((req.boss || 0) > 0) parts.push(`보스 빌런 레어 전리품 x${req.boss}`);

            return {
                type: 'grade',
                curGrade: curGradeIndex,
                nextGrade,
                eliteNeed: req.elite || 0,
                royalNeed: req.royal || 0,
                bossNeed: req.boss || 0,
                text: parts.join(' + ')
            };
        }

        function getGearUpgradeRequirement(gear) {
            const mode = getGearUpgradeMode(gear);
            const lv = (gear === 'weapon') ? weaponEnhanceLevel : armorEnhanceLevel;
            const g  = (gear === 'weapon') ? weaponGradeIndex : armorGradeIndex;

            if (mode === 'level') {
                return (gear === 'weapon') ? getWeaponUpgradeRequirement(lv) : getArmorUpgradeRequirement(lv);
            }
            if (mode === 'grade') {
                return getGradeUpgradeRequirement(g);
            }
            return { type: 'max' };
        }

        // [스탯] 등급별 강화 효율
        function getWeaponAtkPerLevel(gradeIndex) {
            return 1 + (Math.max(0, gradeIndex) * 0.5);
        }
        function getArmorDefPerLevel(gradeIndex) {
            return 0.5 + (Math.max(0, gradeIndex) * 0.25);
        }

        function getTotalWeaponAttackBonus(gradeIndex, level) {
            const g = Math.max(0, Math.min(MAX_GEAR_GRADE_INDEX, Math.floor(gradeIndex || 0)));
            const lv = Math.max(1, Math.min(MAX_ENHANCE_LEVEL, Math.floor(level || 1)));
            let total = 0;
            for (let i = 0; i < g; i++) total += (MAX_ENHANCE_LEVEL - 1) * getWeaponAtkPerLevel(i);
            total += (lv - 1) * getWeaponAtkPerLevel(g);
            return total;
        }

        function getTotalArmorDefenseBonus(gradeIndex, level) {
            const g = Math.max(0, Math.min(MAX_GEAR_GRADE_INDEX, Math.floor(gradeIndex || 0)));
            const lv = Math.max(1, Math.min(MAX_ENHANCE_LEVEL, Math.floor(level || 1)));
            let total = 0;
            for (let i = 0; i < g; i++) total += (MAX_ENHANCE_LEVEL - 1) * getArmorDefPerLevel(i);
            total += (lv - 1) * getArmorDefPerLevel(g);
            return total;
        }

        function formatNumberMaybeFloat(n, digits = 1) {
            if (!Number.isFinite(n)) return '0';
            const pow = Math.pow(10, digits);
            const rounded = Math.round(n * pow) / pow;
            // 정수면 소수점 제거
            if (Math.abs(rounded - Math.round(rounded)) < 1e-9) return String(Math.round(rounded));
            return rounded.toFixed(digits);
        }

        function canUpgradeWeapon() {
            const mode = getGearUpgradeMode('weapon');
            if (mode === 'max') return false;
            return areEnhanceSlotsComplete('weapon');
        }

        function canUpgradeArmor() {
            const mode = getGearUpgradeMode('armor');
            if (mode === 'max') return false;
            return areEnhanceSlotsComplete('armor');
        }

        function doUpgradeWeapon() {
            const mode = getGearUpgradeMode('weapon');

            if (mode === 'max') {
                showPickupEffect(player.x, player.y - 70, "무기는 이미 최대 등급/레벨입니다!", false, true, "weak-text");
                return;
            }

            if (!areEnhanceSlotsComplete('weapon')) {
                showPickupEffect(player.x, player.y - 70, "재료가 부족합니다!", false, true, "weak-text");
                return;
            }

            // 재료 소비(예약된 투입분만)
            const slots = enhancePanelState.weapon.slots || [];
            for (const s of slots) {
                for (const [k, v] of Object.entries(s.contributions || {})) {
                    const invIndex = Number(k);
                    const take = Number(v);
                    if (!Number.isFinite(invIndex) || !Number.isFinite(take) || take <= 0) continue;
                    const stack = inventorySlots[invIndex];
                    if (!stack) continue;
                    stack.qty -= take;
                    if (stack.qty <= 0) inventorySlots[invIndex] = null;
                }
            }
            saveInventoryToStorage();
            clearGearSlots('weapon', false);

            if (mode === 'level') {
                weaponEnhanceLevel++;
                saveEnhanceToStorage();

                const inc = getWeaponAtkPerLevel(weaponGradeIndex);
                player.weapon.baseDamage += inc;
                player.weapon.damage = player.weapon.baseDamage;

                showPickupEffect(player.x, player.y - 70,
                    `무기 강화 성공! (${GEAR_GRADES[weaponGradeIndex]} Lv.${weaponEnhanceLevel})`,
                    false, true, "gold-text"
                );
            } else if (mode === 'grade') {
                const before = weaponGradeIndex;
                weaponGradeIndex = Math.min(MAX_GEAR_GRADE_INDEX, weaponGradeIndex + 1);
                weaponEnhanceLevel = 1;
                saveEnhanceToStorage();

                // 등급 업그레이드 보너스(단 1회): 명중 +2%, 치확 +1%
                player.bonusAccuracy += 0.02;
                player.baseCritChance += 1;
                player.critChance = player.baseCritChance;

                showPickupEffect(player.x, player.y - 70,
                    `무기 등급 업그레이드 성공! (${GEAR_GRADES[before]} → ${GEAR_GRADES[weaponGradeIndex]})`,
                    false, true, "gold-text"
                );
            }

            if (isGearPanelOpen) {
                updateInventoryUI();
                updateEnhanceUI();
            }
        }

        function doUpgradeArmor() {
            const mode = getGearUpgradeMode('armor');

            if (mode === 'max') {
                showPickupEffect(player.x, player.y - 70, "방어구는 이미 최대 등급/레벨입니다!", false, true, "weak-text");
                return;
            }

            if (!areEnhanceSlotsComplete('armor')) {
                showPickupEffect(player.x, player.y - 70, "재료가 부족합니다!", false, true, "weak-text");
                return;
            }

            // 재료 소비(예약된 투입분만)
            const slots = enhancePanelState.armor.slots || [];
            for (const s of slots) {
                for (const [k, v] of Object.entries(s.contributions || {})) {
                    const invIndex = Number(k);
                    const take = Number(v);
                    if (!Number.isFinite(invIndex) || !Number.isFinite(take) || take <= 0) continue;
                    const stack = inventorySlots[invIndex];
                    if (!stack) continue;
                    stack.qty -= take;
                    if (stack.qty <= 0) inventorySlots[invIndex] = null;
                }
            }
            saveInventoryToStorage();
            clearGearSlots('armor', false);

            if (mode === 'level') {
                armorEnhanceLevel++;
                saveEnhanceToStorage();

                const inc = getArmorDefPerLevel(armorGradeIndex);
                player.defense += inc;

                showPickupEffect(player.x, player.y - 70,
                    `방어구 강화 성공! (${GEAR_GRADES[armorGradeIndex]} Lv.${armorEnhanceLevel})`,
                    false, true, "gold-text"
                );
            } else if (mode === 'grade') {
                const before = armorGradeIndex;
                armorGradeIndex = Math.min(MAX_GEAR_GRADE_INDEX, armorGradeIndex + 1);
                armorEnhanceLevel = 1;
                saveEnhanceToStorage();

                // 등급 업그레이드 보너스(단 1회): 회피 +2%, 치저 +1%
                player.bonusEvasion += 0.02;
                player.baseCritResist += 1;
                player.critResist = player.baseCritResist;

                showPickupEffect(player.x, player.y - 70,
                    `방어구 등급 업그레이드 성공! (${GEAR_GRADES[before]} → ${GEAR_GRADES[armorGradeIndex]})`,
                    false, true, "gold-text"
                );
            }

            if (isGearPanelOpen) {
                updateInventoryUI();
                updateEnhanceUI();
            }
        }

                
        // ---------------------------
        // [강화] 사망/재시작 시에도 유지되는 보너스 재적용
        //  - startGame()에서 기본 스탯을 리셋한 뒤 호출
        // ---------------------------
        function applyEnhanceBonusesFromLevels() {
            // 레벨/등급 범위 보정
            const wLv = Math.max(1, Math.min(MAX_ENHANCE_LEVEL, Math.floor(weaponEnhanceLevel || 1)));
            const aLv = Math.max(1, Math.min(MAX_ENHANCE_LEVEL, Math.floor(armorEnhanceLevel || 1)));
            const wG  = Math.max(0, Math.min(MAX_GEAR_GRADE_INDEX, Math.floor(weaponGradeIndex || 0)));
            const aG  = Math.max(0, Math.min(MAX_GEAR_GRADE_INDEX, Math.floor(armorGradeIndex || 0)));

            // 레벨(강화) 보너스: 공격/방어만
            const wAtkBonus = getTotalWeaponAttackBonus(wG, wLv);
            const aDefBonus = getTotalArmorDefenseBonus(aG, aLv);

            if (wAtkBonus > 0) {
                player.weapon.baseDamage += wAtkBonus;
                player.weapon.damage = player.weapon.baseDamage;
            }
            if (aDefBonus > 0) {
                player.defense += aDefBonus;
            }

            // 등급 업그레이드 보너스(단 1회씩): 무기=명중+2%/치확+1%, 방어구=회피+2%/치저+1%
            if (wG > 0) {
                player.bonusAccuracy += 0.02 * wG;
                player.baseCritChance += 1 * wG;
                player.critChance = player.baseCritChance;
            }

            if (aG > 0) {
                player.bonusEvasion += 0.02 * aG;
                player.baseCritResist += 1 * aG;
                player.critResist = player.baseCritResist;
            }
        }

        // ---------------------------
        // [NEW] 강화 레벨에 따른 적 스탯 보정(너무 과하지 않게)
        //  - 적 생성 직후(업데이트 첫 프레임)에 1회만 적용
        // ---------------------------
        function getEnemyEnhanceScaleSnapshot() {
            const wLv = Math.max(1, Math.min(MAX_ENHANCE_LEVEL, Math.floor(weaponEnhanceLevel || 1)));
            const aLv = Math.max(1, Math.min(MAX_ENHANCE_LEVEL, Math.floor(armorEnhanceLevel || 1)));
            const wG  = Math.max(0, Math.min(MAX_GEAR_GRADE_INDEX, Math.floor(weaponGradeIndex || 0)));
            const aG  = Math.max(0, Math.min(MAX_GEAR_GRADE_INDEX, Math.floor(armorGradeIndex || 0)));

            // 누적 스텝(디버그/표시용)
            const wSteps = (wG * (MAX_ENHANCE_LEVEL - 1)) + (wLv - 1);
            const aSteps = (aG * (MAX_ENHANCE_LEVEL - 1)) + (aLv - 1);
            const total = wSteps + aSteps;

            // [핵심] 플레이어 장비 강화로 실제로 오른 스탯(공격/방어)을 기준으로 적 스탯을 완만하게 보정
            const wAtkBonus = getTotalWeaponAttackBonus(wG, wLv);
            const aDefBonus = getTotalArmorDefenseBonus(aG, aLv);

            // 최대치(엔젤릭 Lv.30) 기준 정규화(0~1)
            const MAX_W_ATK = getTotalWeaponAttackBonus(MAX_GEAR_GRADE_INDEX, MAX_ENHANCE_LEVEL);
            const MAX_A_DEF = getTotalArmorDefenseBonus(MAX_GEAR_GRADE_INDEX, MAX_ENHANCE_LEVEL);

            const wNorm = (MAX_W_ATK > 0) ? Math.max(0, Math.min(1, wAtkBonus / MAX_W_ATK)) : 0;
            const aNorm = (MAX_A_DEF > 0) ? Math.max(0, Math.min(1, aDefBonus / MAX_A_DEF)) : 0;

            // 등급 업그레이드 시 즉시 증가하는 보너스(명중/회피/치확/치저)도 반영되도록 등급 비중을 약간 섞음
            const wGradeNorm = (MAX_GEAR_GRADE_INDEX > 0) ? Math.max(0, Math.min(1, wG / MAX_GEAR_GRADE_INDEX)) : 0;
            const aGradeNorm = (MAX_GEAR_GRADE_INDEX > 0) ? Math.max(0, Math.min(1, aG / MAX_GEAR_GRADE_INDEX)) : 0;

            // 최종 파워(0~1): 스탯 상승분 90% + 등급 10%
            const wPower = Math.max(0, Math.min(1, (wNorm * 0.90) + (wGradeNorm * 0.10)));
            const aPower = Math.max(0, Math.min(1, (aNorm * 0.90) + (aGradeNorm * 0.10)));

            // 너무 과하지 않게: 초반은 변화가 작고, 후반(엔젤릭)에도 폭발하지 않도록 '완만한 지수' + 상한
            //  - 무기 파워(wPower): 적 HP/방어/회피/치저(=플레이어 딜 대응)에 더 큰 영향
            //  - 방어구 파워(aPower): 적 명중/치확(=플레이어 탱킹 대응)에 더 큰 영향
            // [난이도 조정] 덜 답답하게(피통↑ 위주): (상한: HP +900%(x10), DEF +300)
            //  - 주의: wPower/aPower는 0~1이라 '상한만' 올리면 체감 변화가 없습니다.
            //  - 따라서 상한과 함께 계수/지수(곡선)도 조정합니다.
            const HP_BONUS_CAP  = 9.00;  // hpMult = 1 + hpBonus  => 최대 x10
            const DEF_BONUS_CAP = 300;   // additive defense (데미지에서 단순 차감)

            // 초반은 완만 / 후반은 강하게: HP는 중후반부터, DEF는 최상위 구간에서 더 체감되도록 DEF 지수를 크게.
            const hpBonus  = Math.max(0, Math.min(HP_BONUS_CAP,
                ((HP_BONUS_CAP * 0.88) * Math.pow(wPower, 1.25)) +
                ((HP_BONUS_CAP * 0.12) * Math.pow(aPower, 1.35))
            ));
            const defBonus = Math.max(0, Math.min(DEF_BONUS_CAP,
                ((DEF_BONUS_CAP * 0.75) * Math.pow(wPower, 2.00)) +
                ((DEF_BONUS_CAP * 0.25) * Math.pow(aPower, 2.10))
            ));
            const accBonus     = Math.max(0, Math.min(0.10, (0.10 * Math.pow(aPower, 0.80)))); // 최대 +10%
            const evaBonus     = Math.max(0, Math.min(0.08, (0.08 * Math.pow(wPower, 0.80)))); // 최대 +8%
            const critBonus    = Math.max(0, Math.min(6,    (6    * Math.pow(aPower, 0.90)))); // 최대 +6pt
            const critResBonus = Math.max(0, Math.min(6,    (6    * Math.pow(wPower, 0.90)))); // 최대 +6pt

            const hpMult = 1 + hpBonus;

            return { total, wSteps, aSteps, wAtkBonus, aDefBonus, wPower, aPower, hpMult, defBonus, accBonus, evaBonus, critBonus, critResBonus };
        }

        function applyEnhanceScalingToEnemyOnce(enemy) {
            if (!enemy || enemy.__enhanceScaled) return;

            const sc = getEnemyEnhanceScaleSnapshot();
            enemy.__enhanceScaled = true;

            if (sc.total <= 0) return;

            // HP
            if (typeof enemy.maxHp === 'number' && typeof enemy.hp === 'number') {
                const oldMax = enemy.maxHp;
                const ratio = oldMax > 0 ? enemy.hp / oldMax : 1;
                const newMax = Math.max(1, Math.floor(oldMax * sc.hpMult));
                enemy.maxHp = newMax;
                enemy.hp = Math.min(newMax, Math.max(1, Math.floor(newMax * ratio)));
            } else if (typeof enemy.hp === 'number') {
                enemy.hp = Math.max(1, Math.floor(enemy.hp * sc.hpMult));
            }

            // Defense (additive)
            enemy.defense = (enemy.defense || 0) + sc.defBonus;

            // Accuracy / Evasion (fraction)
            enemy.accuracy = (enemy.accuracy || 0) + sc.accBonus;
            if (enemy.baseAccuracy !== undefined) enemy.baseAccuracy += sc.accBonus;

            enemy.evasion = Math.min(0.65, (enemy.evasion || 0) + sc.evaBonus);

            // Crit
            enemy.critChance = (enemy.critChance || 0) + sc.critBonus;
            enemy.critResist = (enemy.critResist || 0) + sc.critResBonus;
            if (enemy.baseCritChance !== undefined) enemy.baseCritChance += sc.critBonus;
            if (enemy.baseCritResist !== undefined) enemy.baseCritResist += sc.critResBonus;
        }

        
        const ENEMY_SCORE_SCALING = {
            stepSeconds: 10,
            attackPerStep: 0.09,
            moveSpeedPerStep: 0.004,
            scoreHpPer100: 1.7,
            baseDefenseFlat: 0,
            statusResistPerStep: 0.005,
            defensePerStep: 0.02,
            evasionPerStep: 0.004,
            critPerStep: 0.7,
            accuracyPerStep: 0.007
        };

        function getEnemySpawnHp(baseHp) {
            const scoreHpMultiplier = 1 + (score / 100 * ENEMY_SCORE_SCALING.scoreHpPer100);
            return Math.max(1, Math.floor(baseHp * scoreHpMultiplier));
        }

function applyEnemyDifficultyRebalance(enemy) {
            if (!enemy) return;
            if (!enemy.__difficultyRebalanced) {
                enemy.__difficultyRebalanced = true;

                enemy.baseDefense = (enemy.defense || 0) + ENEMY_SCORE_SCALING.baseDefenseFlat;
                enemy.defense = enemy.baseDefense;
                const baseAccBonus = 0.05;
                const baseEvaBonus = 0.05;
                const baseCritChanceBonus = 5;
                const baseCritResistBonus = 5;
                const initialEvasion = (enemy.baseEvasion !== undefined ? enemy.baseEvasion : (enemy.evasion || 0));

                enemy.accuracy = (enemy.accuracy || 0) + baseAccBonus;
                enemy.evasion = (enemy.evasion || 0) + baseEvaBonus;
                enemy.critChance = (enemy.critChance || 0) + baseCritChanceBonus;
                enemy.critResist = (enemy.critResist || 0) + baseCritResistBonus;

                if (enemy.baseAccuracy !== undefined) enemy.baseAccuracy = (enemy.baseAccuracy || 0) + baseAccBonus;
                if (enemy.baseCritChance !== undefined) enemy.baseCritChance = (enemy.baseCritChance || 0) + baseCritChanceBonus;
                if (enemy.baseCritResist !== undefined) enemy.baseCritResist = (enemy.baseCritResist || 0) + baseCritResistBonus;
                enemy.baseEvasion = initialEvasion + baseEvaBonus;

                if (enemy.attackPower == null) {
                    if (enemy.isArthur || (enemy.isBoss && !enemy.isArthur && !enemy.isArchdemon)) enemy.attackPower = 15;
                    else if (enemy.isRoyal) enemy.attackPower = 10;
                    else if (enemy.isElite) enemy.attackPower = 5;
                    else enemy.attackPower = 2;
                }
                enemy.baseAttackPower = enemy.attackPower;
                enemy.baseMoveSpeed = enemy.baseSpeed || enemy.speed || 0;
            }

            const timeFactor = Math.floor(score / ENEMY_SCORE_SCALING.stepSeconds);
            enemy.attackPower = (enemy.baseAttackPower || 0) + (timeFactor * ENEMY_SCORE_SCALING.attackPerStep);
            enemy.defense = (enemy.baseDefense || 0) + Math.floor(timeFactor * ENEMY_SCORE_SCALING.defensePerStep);
            enemy.timeMoveSpeedBonus = 1 + (timeFactor * ENEMY_SCORE_SCALING.moveSpeedPerStep);
        }

// ---------------------------
        // [UI] 인벤토리 + 강화 패널 (Panel형)
        //  - P 로 열고 닫기
        //  - 열려있는 동안 시간은 일시정지(animate 중지)
        //  - 드래그&드롭 / 클릭으로 재료 슬롯에 투입
        // ---------------------------

        function initGearPanelUI() {
            gearPanelEl = document.getElementById('gearPanel');
            closeGearPanelBtnEl = document.getElementById('closeGearPanelBtn');

            if (closeGearPanelBtnEl) {
                closeGearPanelBtnEl.addEventListener('click', () => closeGearPanel());
            }
        }

        function openGearPanel() {
            if (!gearPanelEl) return;
            if (!isGameRunning) return;
            if (isLevelUpPaused) return;

            if (isEquipPanelOpen) closeEquipPanel(false);

            isGearPanelOpen = true;
            gearPanelEl.style.display = 'flex';
            document.body.classList.add('allow-scroll-ui');
            isTouching = false;

            // 패널 오픈 시: 재료 투입(예약) 상태를 초기화
            resetEnhancePanelSession();

            // 합성 선택 초기화
            selectedSynthInvIndex = null;
            clearSynthMixSelection(false);

            updateInventoryUI();
            updateEnhanceUI();
        }

        function closeGearPanel(resume = true) {
            if (!gearPanelEl) return;

            isGearPanelOpen = false;
            gearPanelEl.style.display = 'none';
            document.body.classList.remove('allow-scroll-ui');
            isTouching = false;
            hideInvTooltip();
            clearInventoryDragOver();
            selectedSynthInvIndex = null;
            clearSynthMixSelection(false);

            // 패널 닫을 때: 투입중이던 재료는 모두 되돌림(예약 해제)
            resetEnhancePanelSession(false);

            if (resume && isGameRunning && !isLevelUpPaused && !isEquipPanelOpen) {
                requestAnimationFrame(animate);
            }
        }

        function toggleGearPanel() {
            if (isGearPanelOpen) closeGearPanel();
            else openGearPanel();
        }

        // (호환) 과거 함수명 유지
        function toggleInventory() { toggleGearPanel(); }
        function toggleEnhance()   { toggleGearPanel(); }

        // ---------------------------
        // [UI] 인벤토리
        // ---------------------------
        function initInventoryUI() {
            inventoryGridEl = document.getElementById('inventoryGrid');
            invTooltipEl = document.getElementById('invTooltip');
            invSortBtnEl = document.getElementById('invSortBtn');
            invSynthesisBtnEl = document.getElementById('invSynthesisBtn');
            invSynthClearBtnEl = document.getElementById('invSynthClearBtn');
            invSynthesisInfoEl = document.getElementById('invSynthesisInfo');

            // 버튼 이벤트 (정렬 / 합성)
            if (invSortBtnEl) invSortBtnEl.addEventListener('click', autoSortInventory);
            if (invSynthesisBtnEl) invSynthesisBtnEl.addEventListener('click', trySynthesizeSelectedLoot);
            if (invSynthClearBtnEl) invSynthClearBtnEl.addEventListener('click', () => clearSynthesisSelection(true));

            if (!inventoryGridEl) return;

            inventoryGridEl.innerHTML = '';
            for (let i = 0; i < INVENTORY_SIZE; i++) {
                const slot = document.createElement('div');
                slot.className = 'inv-slot';
                slot.dataset.index = String(i);
                slot.draggable = false;

                slot.innerHTML = `
                    <div class="inv-slot-inner">
                        <img class="inv-icon" alt="" style="display:none;" />
                        <div class="inv-empty-hint">EMPTY</div>
                        <div class="inv-reserved"></div>
                    </div>
                    <div class="inv-count" style="display:none;"></div>
                `;

                // Tooltip
                slot.addEventListener('mouseenter', (ev) => showInvTooltip(i, ev));
                slot.addEventListener('mousemove', moveInvTooltip);
                slot.addEventListener('mouseleave', hideInvTooltip);

                // 클릭 투입/합성 선택(패널 열려있을 때만)
                slot.addEventListener('click', (ev) => onInventorySlotClick(ev, i));
                // 우클릭(또는 길게 누르기)로 합성(멀티) 선택 해제
                slot.addEventListener('contextmenu', (ev) => onInventorySlotContextMenu(ev, i));

                // Drag 시작/종료
                slot.addEventListener('dragstart', (ev) => onInventoryDragStart(ev, i));
                slot.addEventListener('dragend',  (ev) => onInventoryDragEnd(ev, i));

                // Drag over/drop (슬롯 위치 교환)
                slot.addEventListener('dragover',  (ev) => onInventorySlotDragOver(ev, i));
                slot.addEventListener('dragleave', (ev) => onInventorySlotDragLeave(ev, i));
                slot.addEventListener('drop',      (ev) => onInventorySlotDrop(ev, i));

                inventoryGridEl.appendChild(slot);
            }
        }

        function updateInventoryUI() {
            if (!inventoryGridEl) return;

            const children = inventoryGridEl.children;
            for (let i = 0; i < INVENTORY_SIZE; i++) {
                const slotEl = children[i];
                const data = inventorySlots[i];

                const iconEl = slotEl.querySelector('.inv-icon');
                const emptyEl = slotEl.querySelector('.inv-empty-hint');
                const countEl = slotEl.querySelector('.inv-count');
                const reservedEl = slotEl.querySelector('.inv-reserved');

                // 예약(강화/합성) 상태
                const reservedEnh = (enhancePanelState.reservedByInvIndex[i] || 0);
                const reservedSynth = (synthState.reservedByInvIndex[i] || 0);
                const reservedTotal = reservedEnh + reservedSynth;

                if (!data) {
                    iconEl.style.display = 'none';
                    iconEl.src = '';
                    emptyEl.style.display = 'block';
                    countEl.style.display = 'none';
                    reservedEl.style.display = 'none';
                    slotEl.classList.remove('has-item', 'inv-fully-reserved', 'dragging', 'inv-selected', 'drag-over');
                    slotEl.draggable = false;
                    continue;
                }

                // 아이콘
                iconEl.style.display = 'block';
                emptyEl.style.display = 'none';
                iconEl.src = LOOT_ICON[data.id] || '';

                // 수량
                const qty = data.qty || 1;
                if (qty > 1) {
                    countEl.style.display = 'block';
                    countEl.textContent = `x${qty}`;
                } else {
                    countEl.style.display = 'none';
                    countEl.textContent = '';
                }

                // 예약 표시 (강화 투입 / 합성 선택)
                if (reservedTotal > 0) {
                    reservedEl.style.display = 'block';
                    const parts = [];
                    if (reservedEnh > 0) parts.push(`투입 ${reservedEnh}`);
                    if (reservedSynth > 0) parts.push(`합성 ${reservedSynth}`);
                    reservedEl.textContent = parts.join(' · ');
                } else {
                    reservedEl.style.display = 'none';
                    reservedEl.textContent = '';
                }

                const available = Math.max(0, qty - reservedTotal);
                if (available <= 0 && reservedTotal > 0) slotEl.classList.add('inv-fully-reserved');
                else slotEl.classList.remove('inv-fully-reserved');

                // 드래그 가능 여부: 남은 수량이 있을 때만
                if (available > 0) {
                    slotEl.classList.add('has-item');
                    slotEl.draggable = true;
                } else {
                    slotEl.classList.remove('has-item');
                    slotEl.draggable = false;
                }

                // 선택(합성)
                if (selectedSynthInvIndex === i || reservedSynth > 0) slotEl.classList.add('inv-selected');
                else slotEl.classList.remove('inv-selected');
            }

            // 합성 안내 갱신
            updateSynthesisUI();
        }

        function showInvTooltip(index, ev) {
            if (!invTooltipEl) return;
            const data = inventorySlots[index];
            if (!data) return;

            const def = LOOT_DEFS[data.id];
            if (!def) return;

            const reserved = (enhancePanelState.reservedByInvIndex[index] || 0);
            const qty = data.qty || 1;
            const usable = Math.max(0, qty - reserved);

            const catName = def.category === LOOT_CATEGORY.NORMAL ? '일반' :
                            def.category === LOOT_CATEGORY.ELITE ? '엘리트' :
                            def.category === LOOT_CATEGORY.ROYAL ? '로열' : '보스';
            const rarityName = (def.rarity === 'rare') ? '레어' : '일반';

            invTooltipEl.dataset.cat = def.category || '';

            invTooltipEl.innerHTML = `
                <div class="tt-name">${def.name}</div>
                <div class="tt-desc">${def.desc || ''}</div>
                <div class="tt-meta">등급: <b>${rarityName}</b> · 분류: <b>${catName}</b> · 사용 가능: <b>${usable}</b> / 보유: <b>${qty}</b></div>
                <div class="tt-meta">드랍: ${def.dropFrom || '-'}</div>
            `;

            invTooltipEl.style.display = 'block';
            moveInvTooltip(ev);
        }

        function moveInvTooltip(ev) {
            if (!invTooltipEl) return;
            const pad = 14;
            const w = invTooltipEl.offsetWidth || 260;
            const h = invTooltipEl.offsetHeight || 120;

            let x = ev.clientX + pad;
            let y = ev.clientY + pad;

            const vw = window.innerWidth;
            const vh = window.innerHeight;
            if (x + w + 8 > vw) x = ev.clientX - w - pad;
            if (y + h + 8 > vh) y = ev.clientY - h - pad;

            invTooltipEl.style.left = x + 'px';
            invTooltipEl.style.top = y + 'px';
        }

        function hideInvTooltip() {
            if (!invTooltipEl) return;
            invTooltipEl.style.display = 'none';
            invTooltipEl.dataset.rarity = '';
        }

        // ---------------------------
        // [NEW] 강화 재료 슬롯 로직
        // ---------------------------

        function resetEnhancePanelSession(updateUI = true) {
            // 모든 예약 해제
            enhancePanelState.activeTarget = null;
            enhancePanelState.reservedByInvIndex = new Array(INVENTORY_SIZE).fill(0);

            // 슬롯 투입 정보 초기화(요구사항 구조는 유지)
            ['weapon', 'armor'].forEach(g => {
                const slots = enhancePanelState[g].slots || [];
                slots.forEach(s => {
                    s.filled = 0;
                    s.contributions = {};
                });
            });

            if (updateUI && isGearPanelOpen) {
                updateInventoryUI();
                updateEnhanceUI();
            }
        }

        function buildSlotsForRequirement(gear, req) {
            const slots = [];

            if (!req || req.type === 'max') return slots;

            // [등급 업그레이드] 레어 전리품
            if (req.type === 'grade') {
                if (req.eliteNeed > 0) slots.push(makeMatSlotDef('category', LOOT_CATEGORY.ELITE, '엘리트 빌런 레어 전리품', req.eliteNeed, 'rare'));
                if (req.royalNeed > 0) slots.push(makeMatSlotDef('category', LOOT_CATEGORY.ROYAL, '로열 빌런 레어 전리품', req.royalNeed, 'rare'));
                if (req.bossNeed > 0) slots.push(makeMatSlotDef('category', LOOT_CATEGORY.BOSS, '보스 빌런 레어 전리품', req.bossNeed, 'rare'));
                return slots;
            }

            // [일반 강화] 일반 전리품
            if (gear === 'weapon') {
                if (req.type === 'boss') {
                    slots.push(makeMatSlotDef('id', 'dark_virus', '다크 바이러스', req.bossCount, 'normal'));
                    slots.push(makeMatSlotDef('id', 'blood_hilt', '피로 물든 칼자루', req.bossCount, 'normal'));
                } else {
                    slots.push(makeMatSlotDef('category', LOOT_CATEGORY.ELITE, '엘리트 전리품', req.eliteNeed, 'normal'));
                    if (req.royalNeed > 0) slots.push(makeMatSlotDef('category', LOOT_CATEGORY.ROYAL, '로열 전리품', req.royalNeed, 'normal'));
                }
            } else {
                // armor
                if (req.type === 'bossAny') {
                    slots.push(makeMatSlotDef('category', LOOT_CATEGORY.BOSS, '보스 전리품', req.bossNeed, 'normal'));
                } else {
                    slots.push(makeMatSlotDef('category', LOOT_CATEGORY.ELITE, '엘리트 전리품', req.eliteNeed, 'normal'));
                    if (req.royalNeed > 0) slots.push(makeMatSlotDef('category', LOOT_CATEGORY.ROYAL, '로열 전리품', req.royalNeed, 'normal'));
                }
            }

            return slots;
        }

        function makeMatSlotDef(acceptType, acceptValue, label, required, acceptRarity = null) {
            return {
                acceptType,      // 'id' | 'category'
                acceptValue,     // itemId or category
                acceptRarity,    // 'normal' | 'rare' | null
                label,
                required: Math.max(0, Math.floor(required || 0)),
                filled: 0,
                contributions: {} // invIndex -> qty
            };
        }

        function makeRequirementSignature(req) {
            if (!req) return 'none';
            // JSON stringify는 순서가 보장되므로 간단 시그니처로 사용
            return JSON.stringify(req);
        }

        function recomputeReservedByInvIndex() {
            enhancePanelState.reservedByInvIndex = new Array(INVENTORY_SIZE).fill(0);
            ['weapon', 'armor'].forEach(g => {
                const slots = enhancePanelState[g].slots || [];
                slots.forEach(s => {
                    const contrib = s.contributions || {};
                    for (const k in contrib) {
                        const idx = Number(k);
                        const amt = contrib[k] || 0;
                        enhancePanelState.reservedByInvIndex[idx] += amt;
                    }
                });
            });
        }

        function clearGearSlots(gear, updateUI = true) {
            const slots = enhancePanelState[gear].slots || [];
            slots.forEach(s => { s.filled = 0; s.contributions = {}; });

            if (enhancePanelState.activeTarget && enhancePanelState.activeTarget.gear === gear) {
                enhancePanelState.activeTarget = null;
            }
            recomputeReservedByInvIndex();

            if (updateUI && isGearPanelOpen) {
                updateInventoryUI();
                updateEnhanceUI();
            }
        }

        function ensureEnhanceSlotsForGear(gear) {
            const req = getGearUpgradeRequirement(gear);
            const sig = makeRequirementSignature(req);

            if (enhancePanelState[gear].reqSig !== sig) {
                // 요구사항이 바뀌면 해당 장비의 투입분만 되돌림
                enhancePanelState[gear].reqSig = sig;
                enhancePanelState[gear].slots = buildSlotsForRequirement(gear, req);

                if (enhancePanelState.activeTarget && enhancePanelState.activeTarget.gear === gear) {
                    enhancePanelState.activeTarget = null;
                }

                recomputeReservedByInvIndex();
            }
        }

        function isMatSlotAccepts(slot, itemId) {
            if (!slot || !itemId) return false;
            const def = LOOT_DEFS[itemId];
            if (!def) return false;

            if (slot.acceptType === 'id') {
                if (itemId !== slot.acceptValue) return false;
                if (slot.acceptRarity && def.rarity !== slot.acceptRarity) return false;
                return true;
            }

            // category
            if (def.category !== slot.acceptValue) return false;
            if (slot.acceptRarity && def.rarity !== slot.acceptRarity) return false;
            return true;
        }

        function getAvailableInInventory(invIndex) {
            const stack = inventorySlots[invIndex];
            if (!stack) return 0;
            const qty = stack.qty || 1;
            const reservedEnh = enhancePanelState.reservedByInvIndex[invIndex] || 0;
            const reservedSynth = synthState.reservedByInvIndex[invIndex] || 0;
            return Math.max(0, qty - reservedEnh - reservedSynth);
        }

        function tryInsertToMatSlot(invIndex, gear, slotIndex, qtyOverride = null) {
            const stack = inventorySlots[invIndex];
            if (!stack) return false;

            ensureEnhanceSlotsForGear(gear);

            const slots = enhancePanelState[gear].slots || [];
            const slot = slots[slotIndex];
            if (!slot) return false;

            if (slot.required <= 0) return false;
            if (slot.filled >= slot.required) return false;

            const itemId = stack.id;
            if (!isMatSlotAccepts(slot, itemId)) return false;

            const available = getAvailableInInventory(invIndex);
            if (available <= 0) return false;

            const need = Math.max(0, slot.required - slot.filled);
            let add = Math.min(available, need);
            if (qtyOverride !== null && qtyOverride !== undefined) {
                const q = Math.floor(Number(qtyOverride));
                if (Number.isFinite(q)) add = Math.min(add, Math.max(1, q));
            }
            if (add <= 0) return false;

            slot.filled += add;
            slot.contributions[invIndex] = (slot.contributions[invIndex] || 0) + add;
            enhancePanelState.reservedByInvIndex[invIndex] = (enhancePanelState.reservedByInvIndex[invIndex] || 0) + add;

            // 자동으로 다음 슬롯으로 이동(선택 상태일 때만)
            if (enhancePanelState.activeTarget && enhancePanelState.activeTarget.gear === gear && enhancePanelState.activeTarget.index === slotIndex) {
                autoAdvanceActiveTarget();
            }

            if (isGearPanelOpen) {
                updateInventoryUI();
                updateEnhanceUI();
            }
            return true;
        }

        function clearMatSlot(gear, slotIndex) {
            const slots = enhancePanelState[gear].slots || [];
            const slot = slots[slotIndex];
            if (!slot) return;

            const contrib = slot.contributions || {};
            for (const k in contrib) {
                const idx = Number(k);
                const amt = contrib[k] || 0;
                enhancePanelState.reservedByInvIndex[idx] = Math.max(0, (enhancePanelState.reservedByInvIndex[idx] || 0) - amt);
            }
            slot.filled = 0;
            slot.contributions = {};

            if (isGearPanelOpen) {
                updateInventoryUI();
                updateEnhanceUI();
            }
        }

        function areEnhanceSlotsComplete(gear) {
            ensureEnhanceSlotsForGear(gear);
            const slots = enhancePanelState[gear].slots || [];
            if (slots.length === 0) return false;
            return slots.every(s => (s.required <= 0) || (s.filled >= s.required));
        }

        function setActiveMatTarget(gear, slotIndex) {
            enhancePanelState.focusGear = gear;
            enhancePanelState.activeTarget = { gear, index: slotIndex };

            if (isGearPanelOpen) updateEnhanceUI();
        }

        function autoAdvanceActiveTarget() {
            const t = enhancePanelState.activeTarget;
            if (!t) return;

            const gear = t.gear;
            const slots = enhancePanelState[gear].slots || [];
            for (let i = 0; i < slots.length; i++) {
                if (slots[i].required > 0 && slots[i].filled < slots[i].required) {
                    enhancePanelState.activeTarget = { gear, index: i };
                    if (isGearPanelOpen) updateEnhanceUI();
                    return;
                }
            }
            // 모두 완료면 선택 해제
            enhancePanelState.activeTarget = null;
            if (isGearPanelOpen) updateEnhanceUI();
        }

        function findFirstCompatibleSlot(gear, itemId) {
            ensureEnhanceSlotsForGear(gear);
            const slots = enhancePanelState[gear].slots || [];
            for (let i = 0; i < slots.length; i++) {
                const s = slots[i];
                if (s.required > 0 && s.filled < s.required && isMatSlotAccepts(s, itemId)) return i;
            }
            return -1;
        }

        

        // [NEW] 여러 개 보유한 전리품 클릭 투입 시, 투입 수량 지정
        function askInsertQuantity(maxQty) {
            if (maxQty <= 1) return 1;
            const raw = prompt(`투입할 개수를 입력하세요 (1~${maxQty})`, String(maxQty));
            if (raw === null) return null;
            const n = Math.floor(Number(raw));
            if (!Number.isFinite(n)) return null;
            return Math.min(maxQty, Math.max(1, n));
        }

        function getMaxInsertAmount(invIndex, gear, slotIndex) {
            const stack = inventorySlots[invIndex];
            if (!stack) return 0;

            ensureEnhanceSlotsForGear(gear);
            const slots = enhancePanelState[gear].slots || [];
            const slot = slots[slotIndex];
            if (!slot) return 0;

            if (slot.required <= 0 || slot.filled >= slot.required) return 0;
            if (!isMatSlotAccepts(slot, stack.id)) return 0;

            const available = getAvailableInInventory(invIndex);
            const need = Math.max(0, slot.required - slot.filled);
            return Math.min(available, need);
        }
function onInventorySlotClick(ev, invIndex) {
            if (!isGearPanelOpen) return;

            const stack = inventorySlots[invIndex];
            if (!stack) {
                // 빈 슬롯 클릭: 레어 선택만 해제 (멀티 선택은 유지)
                selectedSynthInvIndex = null;
                updateInventoryUI();
                return;
            }

            const itemId = stack.id;
            const def = LOOT_DEFS[itemId];

            // ===========================
            // [합성] 일반 빌런 전리품
            // ===========================
            if (def && (def.category === LOOT_CATEGORY.NORMAL || def.category === LOOT_CATEGORY.ELITE || def.category === LOOT_CATEGORY.ROYAL)) {
                // [NEW] 장비 합성(경화제/헝겊/금속 조각): 같은 등급/종류 100개 → 상위 등급 랜덤 장비
                const matInfo = parseEquipSynthesisMaterial(itemId);
                if (matInfo) {
                    selectedSynthInvIndex = null; // 합성 선택은 멀티로 관리
                    setSynthMode('equip');

                    // [NEW] 토글: 이미 선택된 장비 합성 재료를 다시 클릭하면 해제(두 번 클릭하면 해제)
                    const alreadyReserved = synthState.reservedByInvIndex[invIndex] || 0;
                    if (alreadyReserved > 0 && !(ev && ev.shiftKey)) {
                        synthState.reservedByInvIndex[invIndex] = 0;
                        pruneSynthModeIfEmpty();
                        updateInventoryUI();
                        return;
                    }

                    const selectedMatId = getEquipSynthSelectedMatId();
                    if (selectedMatId === '__MIXED__') {
                        showPickupEffect(player.x, player.y - 70, "장비 합성 재료가 섞여 있습니다. (선택 초기화 후 다시 시도)", false, true, "weak-text");
                        updateInventoryUI();
                        return;
                    }
                    if (selectedMatId && selectedMatId !== itemId) {
                        showPickupEffect(player.x, player.y - 70, "장비 합성은 같은 등급/종류 재료만 선택할 수 있습니다. (선택 초기화 후 다시 시도)", false, true, "weak-text");
                        updateInventoryUI();
                        return;
                    }

                    const remaining = Math.max(0, SYNTH_EQUIP_NEED - getSynthTotal());
                    if (remaining <= 0) {
                        showPickupEffect(player.x, player.y - 70, `장비 합성 재료가 이미 ${SYNTH_EQUIP_NEED}개 선택되었습니다.`, false, true, "weak-text");
                        updateInventoryUI();
                        return;
                    }

                    const maxAdd = Math.min(getAvailableInInventory(invIndex), remaining);
                    if (maxAdd <= 0) {
                        showPickupEffect(player.x, player.y - 70, "선택할 수 있는 수량이 없습니다. (강화/합성 예약 확인)", false, true, "weak-text");
                        updateInventoryUI();
                        return;
                    }

                    const addQty = (ev && ev.shiftKey) ? 1 : maxAdd;
                    addToSynthSelection(invIndex, addQty);

                    updateInventoryUI();
                    return;
                }


                if (def.category === LOOT_CATEGORY.ELITE && def.rarity === 'normal') {
                    selectedSynthInvIndex = null;
                    setSynthMode('eliteNormal');
                    const remaining = Math.max(0, SYNTH_MIX_NEED - getSynthTotal());
                    if (remaining <= 0) { showPickupEffect(player.x, player.y - 70, `상위 일반 합성 재료가 이미 ${SYNTH_MIX_NEED}개 선택되었습니다.`, false, true, "weak-text"); updateInventoryUI(); return; }
                    const maxAdd = Math.min(getAvailableInInventory(invIndex), remaining);
                    if (maxAdd <= 0) { showPickupEffect(player.x, player.y - 70, "선택할 수 있는 수량이 없습니다. (강화/합성 예약 확인)", false, true, "weak-text"); updateInventoryUI(); return; }
                    addToSynthSelection(invIndex, (ev && ev.shiftKey) ? 1 : maxAdd);
                    updateInventoryUI();
                    return;
                }

                if (def.category === LOOT_CATEGORY.ELITE && def.rarity === 'rare') {
                    selectedSynthInvIndex = null;
                    setSynthMode('eliteRare');
                    const remaining = Math.max(0, SYNTH_RARE_NEED - getSynthTotal());
                    if (remaining <= 0) { showPickupEffect(player.x, player.y - 70, `상위 레어 합성 재료가 이미 ${SYNTH_RARE_NEED}개 선택되었습니다.`, false, true, "weak-text"); updateInventoryUI(); return; }
                    const maxAdd = Math.min(getAvailableInInventory(invIndex), remaining);
                    if (maxAdd <= 0) { showPickupEffect(player.x, player.y - 70, "선택할 수 있는 수량이 없습니다. (강화/합성 예약 확인)", false, true, "weak-text"); updateInventoryUI(); return; }
                    addToSynthSelection(invIndex, (ev && ev.shiftKey) ? 1 : maxAdd);
                    updateInventoryUI();
                    return;
                }

                if (def.category === LOOT_CATEGORY.ROYAL && def.rarity === 'normal') {
                    selectedSynthInvIndex = null;
                    setSynthMode('royalNormal');
                    const remaining = Math.max(0, SYNTH_MIX_NEED - getSynthTotal());
                    if (remaining <= 0) { showPickupEffect(player.x, player.y - 70, `최상위 일반 합성 재료가 이미 ${SYNTH_MIX_NEED}개 선택되었습니다.`, false, true, "weak-text"); updateInventoryUI(); return; }
                    const maxAdd = Math.min(getAvailableInInventory(invIndex), remaining);
                    if (maxAdd <= 0) { showPickupEffect(player.x, player.y - 70, "선택할 수 있는 수량이 없습니다. (강화/합성 예약 확인)", false, true, "weak-text"); updateInventoryUI(); return; }
                    addToSynthSelection(invIndex, (ev && ev.shiftKey) ? 1 : maxAdd);
                    updateInventoryUI();
                    return;
                }

                if (def.category === LOOT_CATEGORY.ROYAL && def.rarity === 'rare') {
                    selectedSynthInvIndex = null;
                    setSynthMode('royalRare');
                    const remaining = Math.max(0, SYNTH_RARE_NEED - getSynthTotal());
                    if (remaining <= 0) { showPickupEffect(player.x, player.y - 70, `최상위 레어 합성 재료가 이미 ${SYNTH_RARE_NEED}개 선택되었습니다.`, false, true, "weak-text"); updateInventoryUI(); return; }
                    const maxAdd = Math.min(getAvailableInInventory(invIndex), remaining);
                    if (maxAdd <= 0) { showPickupEffect(player.x, player.y - 70, "선택할 수 있는 수량이 없습니다. (강화/합성 예약 확인)", false, true, "weak-text"); updateInventoryUI(); return; }
                    addToSynthSelection(invIndex, (ev && ev.shiftKey) ? 1 : maxAdd);
                    updateInventoryUI();
                    return;
                }

                // 1) 일반 등급: 멀티 선택/합산(혼합 가능) - 총합 10개
                if (def.rarity === 'normal' && def.category === LOOT_CATEGORY.NORMAL) {
                    selectedSynthInvIndex = null; // 합성 선택은 멀티로 관리

                    // 모드 전환(레어→일반) 시 선택 초기화
                    setSynthMode('normal');

                    const remaining = Math.max(0, SYNTH_MIX_NEED - getSynthTotal());
                    if (remaining <= 0) {
                        showPickupEffect(player.x, player.y - 70, `일반 합성 재료가 이미 ${SYNTH_MIX_NEED}개 선택되었습니다.`, false, true, "weak-text");
                        updateInventoryUI();
                        return;
                    }

                    const maxAdd = Math.min(getAvailableInInventory(invIndex), remaining);
                    if (maxAdd <= 0) {
                        showPickupEffect(player.x, player.y - 70, "선택할 수 있는 수량이 없습니다. (강화/합성 예약 확인)", false, true, "weak-text");
                        updateInventoryUI();
                        return;
                    }

                    // Shift 클릭: 1개만 선택 (세밀 조정용)
                    const addQty = (ev && ev.shiftKey) ? 1 : maxAdd;
                    addToSynthSelection(invIndex, addQty);

                    updateInventoryUI();
                    return;
                }

                // 2) 레어 등급: 멀티 선택/합산(혼합 가능) - 총합 5개
                if (def.rarity === 'rare' && def.category === LOOT_CATEGORY.NORMAL) {
                    selectedSynthInvIndex = null;

                    // 모드 전환(일반→레어) 시 선택 초기화
                    setSynthMode('rare');

                    const remaining = Math.max(0, SYNTH_RARE_NEED - getSynthTotal());
                    if (remaining <= 0) {
                        showPickupEffect(player.x, player.y - 70, `레어 합성 재료가 이미 ${SYNTH_RARE_NEED}개 선택되었습니다.`, false, true, "weak-text");
                        updateInventoryUI();
                        return;
                    }

                    const maxAdd = Math.min(getAvailableInInventory(invIndex), remaining);
                    if (maxAdd <= 0) {
                        showPickupEffect(player.x, player.y - 70, "선택할 수 있는 수량이 없습니다. (강화/합성 예약 확인)", false, true, "weak-text");
                        updateInventoryUI();
                        return;
                    }

                    const addQty = (ev && ev.shiftKey) ? 1 : maxAdd;
                    addToSynthSelection(invIndex, addQty);

                    updateInventoryUI();
                    return;
                }

                // 그 외는 선택만
                selectedSynthInvIndex = invIndex;
                updateInventoryUI();
                return;
            }

            // ===========================
            // [강화] (일반 빌런 전리품 제외)
            // ===========================
            // 클릭 시 선택(합성 안내용)
            selectedSynthInvIndex = invIndex;
            updateInventoryUI();

            // 1) 선택된 타겟 슬롯이 있으면 우선 투입
            if (enhancePanelState.activeTarget) {
                const t = enhancePanelState.activeTarget;

                const maxAdd = getMaxInsertAmount(invIndex, t.gear, t.index);
                if (maxAdd > 0) {
                    let qty = 1;
                    if (maxAdd > 1) {
                        const asked = askInsertQuantity(maxAdd);
                        if (asked === null) return;
                        qty = asked;
                    }
                    const ok = tryInsertToMatSlot(invIndex, t.gear, t.index, qty);
                    if (ok) return;
                }
            }

            // 2) 포커스 장비 -> 반대 장비 순으로 자동 슬롯 찾기
            const primary = enhancePanelState.focusGear || 'weapon';
            const secondary = (primary === 'weapon') ? 'armor' : 'weapon';

            let slotIndex = findFirstCompatibleSlot(primary, itemId);
            if (slotIndex >= 0) {
                setActiveMatTarget(primary, slotIndex);

                const maxAdd = getMaxInsertAmount(invIndex, primary, slotIndex);
                let qty = 1;
                if (maxAdd > 1) {
                    const asked = askInsertQuantity(maxAdd);
                    if (asked === null) return;
                    qty = asked;
                }
                tryInsertToMatSlot(invIndex, primary, slotIndex, qty);
                return;
            }

            slotIndex = findFirstCompatibleSlot(secondary, itemId);
            if (slotIndex >= 0) {
                setActiveMatTarget(secondary, slotIndex);

                const maxAdd = getMaxInsertAmount(invIndex, secondary, slotIndex);
                let qty = 1;
                if (maxAdd > 1) {
                    const asked = askInsertQuantity(maxAdd);
                    if (asked === null) return;
                    qty = asked;
                }
                tryInsertToMatSlot(invIndex, secondary, slotIndex, qty);
                return;
            }

            showPickupEffect(player.x, player.y - 70, "현재 필요한 재료 슬롯이 없습니다!", false, true, "weak-text");
        }


        function onInventorySlotContextMenu(ev, invIndex) {
            // 우클릭으로 해당 슬롯의 '합성(멀티)' 선택을 해제
            if (ev) ev.preventDefault();
            if (!isGearPanelOpen) return;

            const amt = synthState.reservedByInvIndex[invIndex] || 0;
            if (amt <= 0) return;

            synthState.reservedByInvIndex[invIndex] = 0;
            pruneSynthModeIfEmpty();

            updateInventoryUI();
            showPickupEffect(player.x, player.y - 70, "합성 재료에서 제외했습니다.", false, true, "weak-text");
        }


        function onInventoryDragStart(ev, invIndex) {
            const stack = inventorySlots[invIndex];
            if (!stack) { ev.preventDefault(); return; }
            if (getAvailableInInventory(invIndex) <= 0) { ev.preventDefault(); return; }

            const slotEl = inventoryGridEl?.children?.[invIndex];
            if (slotEl) slotEl.classList.add('dragging');

            try {
                ev.dataTransfer.setData('text/plain', JSON.stringify({ invIndex }));
                ev.dataTransfer.effectAllowed = 'copyMove';
            } catch (e) {
                // 일부 환경에서 dataTransfer가 제한될 수 있음
            }
        }

        function onInventoryDragEnd(ev, invIndex) {
            const slotEl = inventoryGridEl?.children?.[invIndex];
            if (slotEl) slotEl.classList.remove('dragging');
            clearInventoryDragOver();
        }



        // ---------------------------
        // [NEW] 인벤토리 슬롯 정렬/교환/합성
        // ---------------------------
        function clearInventoryDragOver() {
            if (!inventoryGridEl) return;
            inventoryGridEl.querySelectorAll('.inv-slot.drag-over').forEach(el => el.classList.remove('drag-over'));
        }

        function swapInventoryIndices(i, j) {
            if (i === j) return;

            // 스택 교환
            const tmp = inventorySlots[i];
            inventorySlots[i] = inventorySlots[j];
            inventorySlots[j] = tmp;

            // 선택 인덱스 보정
            if (selectedSynthInvIndex === i) selectedSynthInvIndex = j;
            else if (selectedSynthInvIndex === j) selectedSynthInvIndex = i;

            // 합성(멀티) 선택 인덱스 보정
            const tmpSynth = (synthState.reservedByInvIndex[i] || 0);
            synthState.reservedByInvIndex[i] = (synthState.reservedByInvIndex[j] || 0);
            synthState.reservedByInvIndex[j] = tmpSynth;

            // 강화 패널 투입(예약) 인덱스 보정: contributions의 invIndex 키를 swap
            const gears = ['weapon', 'armor'];
            for (const g of gears) {
                const slots = enhancePanelState[g]?.slots || [];
                for (const slot of slots) {
                    const c = slot.contributions || {};
                    const keyI = String(i);
                    const keyJ = String(j);
                    const vi = c[keyI] || 0;
                    const vj = c[keyJ] || 0;
                    if (vi === 0 && vj === 0) continue;

                    if (vi > 0) c[keyJ] = vi; else delete c[keyJ];
                    if (vj > 0) c[keyI] = vj; else delete c[keyI];
                }
            }

            recomputeReservedByInvIndex();
            saveInventoryToStorage();
            updateInventoryUI();
            updateEnhanceUI();
        }

        function onInventorySlotDragOver(ev, targetIndex) {
            ev.preventDefault();
            const slotEl = inventoryGridEl?.children?.[targetIndex];
            if (!slotEl) return;

            clearInventoryDragOver();
            slotEl.classList.add('drag-over');

            try { ev.dataTransfer.dropEffect = 'move'; } catch (e) {}
        }

        function onInventorySlotDragLeave(ev, targetIndex) {
            const slotEl = inventoryGridEl?.children?.[targetIndex];
            if (slotEl) slotEl.classList.remove('drag-over');
        }

        function onInventorySlotDrop(ev, targetIndex) {
            ev.preventDefault();
            clearInventoryDragOver();

            let payload = null;
            try {
                payload = JSON.parse(ev.dataTransfer.getData('text/plain'));
            } catch (e) {}

            const fromIndex = payload?.invIndex;
            if (fromIndex === undefined || fromIndex === null) return;

            const a = Number(fromIndex);
            const b = Number(targetIndex);
            if (!Number.isFinite(a) || !Number.isFinite(b)) return;
            if (a === b) return;

            swapInventoryIndices(a, b);
        }

        function getInventorySortKey(stack) {
            if (!stack) return { cat: 99, rar: 99, name: '', id: '' };
            const def = LOOT_DEFS[stack.id] || {};
            // 높은 티어가 먼저 오도록: BOSS -> ROYAL -> ELITE -> NORMAL
            const catOrder = (cat) => {
                if (cat === LOOT_CATEGORY.BOSS) return 0;
                if (cat === LOOT_CATEGORY.ROYAL) return 1;
                if (cat === LOOT_CATEGORY.ELITE) return 2;
                if (cat === LOOT_CATEGORY.NORMAL) return 3;
                return 9;
            };
            // 레어가 먼저 오도록
            const rarOrder = (r) => (r === 'rare' ? 0 : 1);

            return {
                cat: catOrder(def.category),
                rar: rarOrder(def.rarity),
                name: String(def.name || ''),
                id: String(stack.id || '')
            };
        }

        function applyInventoryPermutation(newSlots, oldSlots) {
            // oldSlots를 기준으로 강화 패널 contributions의 invIndex 키를 새 인덱스로 이관
            const objToNewIndex = new Map();
            for (let i = 0; i < newSlots.length; i++) {
                const s = newSlots[i];
                if (s) objToNewIndex.set(s, i);
            }

            const gears = ['weapon', 'armor'];
            for (const g of gears) {
                const slots = enhancePanelState[g]?.slots || [];
                for (const slot of slots) {
                    const oldContrib = slot.contributions || {};
                    const newContrib = {};

                    for (const k in oldContrib) {
                        const oldIdx = Number(k);
                        const qty = oldContrib[k] || 0;
                        if (!Number.isFinite(oldIdx) || qty <= 0) continue;

                        const obj = oldSlots[oldIdx];
                        const newIdx = obj ? objToNewIndex.get(obj) : undefined;
                        if (newIdx === undefined) continue;

                        newContrib[newIdx] = (newContrib[newIdx] || 0) + qty;
                    }

                    slot.contributions = newContrib;

                    // filled 재계산
                    let filled = 0;
                    for (const nk in newContrib) filled += newContrib[nk] || 0;
                    slot.filled = filled;
                }
            }

            // 선택 인덱스 보정 (선택된 스택 객체가 어디로 갔는지 추적)
            if (selectedSynthInvIndex !== null && selectedSynthInvIndex !== undefined) {
                const selObj = oldSlots[selectedSynthInvIndex];
                if (selObj) {
                    const nextIdx = objToNewIndex.get(selObj);
                    selectedSynthInvIndex = (nextIdx === undefined) ? null : nextIdx;
                } else {
                    selectedSynthInvIndex = null;
                }
            }

            // 합성(멀티) 선택 이관
            const oldSynth = synthState.reservedByInvIndex.slice();
            const newSynth = new Array(INVENTORY_SIZE).fill(0);
            for (let oi = 0; oi < oldSlots.length; oi++) {
                const amt = oldSynth[oi] || 0;
                if (amt <= 0) continue;
                const obj = oldSlots[oi];
                const ni = obj ? objToNewIndex.get(obj) : undefined;
                if (ni === undefined) continue;
                newSynth[ni] = (newSynth[ni] || 0) + amt;
            }
            synthState.reservedByInvIndex = newSynth;

            inventorySlots = newSlots;
            recomputeReservedByInvIndex();
            saveInventoryToStorage();
            updateInventoryUI();
            updateEnhanceUI();
        }

        function autoSortInventory() {
            const oldSlots = inventorySlots.slice();
            const items = oldSlots.filter(Boolean);

            items.sort((a, b) => {
                const ka = getInventorySortKey(a);
                const kb = getInventorySortKey(b);
                if (ka.cat !== kb.cat) return ka.cat - kb.cat;
                if (ka.rar !== kb.rar) return ka.rar - kb.rar;
                const nameCmp = ka.name.localeCompare(kb.name, 'ko');
                if (nameCmp !== 0) return nameCmp;
                return ka.id.localeCompare(kb.id);
            });

            const newSlots = new Array(INVENTORY_SIZE).fill(null);
            for (let i = 0; i < Math.min(items.length, INVENTORY_SIZE); i++) {
                newSlots[i] = items[i];
            }

            applyInventoryPermutation(newSlots, oldSlots);
            showPickupEffect(player.x, player.y - 70, "인벤토리 자동 정렬 완료!", false, true, "goddess-text");
        }

        
        // ---------------------------
        // [NEW] 합성(멀티 선택/합산) 유틸
        // ---------------------------

        function escapeHtml(str) {
            return String(str).replace(/[&<>"']/g, (m) => ({
                '&': '&amp;',
                '<': '&lt;',
                '>': '&gt;',
                '"': '&quot;',
                "'": '&#39;'
            }[m]));
        }

        function ensureSynthStateSize() {
            if (!synthState || typeof synthState !== 'object') return;
            if (!synthState.reservedByInvIndex || synthState.reservedByInvIndex.length !== INVENTORY_SIZE) {
                synthState.reservedByInvIndex = new Array(INVENTORY_SIZE).fill(0);
            }
            if (synthState.mode !== 'normal' && synthState.mode !== 'rare' && synthState.mode !== 'equip' && synthState.mode !== 'eliteNormal' && synthState.mode !== 'eliteRare' && synthState.mode !== 'royalNormal' && synthState.mode !== 'royalRare') {
                synthState.mode = null;
            }
        }

        function getSynthNeedForMode(mode) {
            if (mode === 'rare' || mode === 'eliteRare' || mode === 'royalRare') return SYNTH_RARE_NEED;
            if (mode === 'equip') return SYNTH_EQUIP_NEED;
            return SYNTH_MIX_NEED;
        }

        function getLootSynthConfig(mode) {
            if (mode === 'normal') return { sourceCategory: LOOT_CATEGORY.NORMAL, sourceRarity: 'normal', targetCategory: LOOT_CATEGORY.ELITE, title: '일반 합성', consumeLabel: '일반 빌런 일반 전리품', rewardLabel: '엘리트 빌런 일반 전리품 랜덤 1개' };
            if (mode === 'rare') return { sourceCategory: LOOT_CATEGORY.NORMAL, sourceRarity: 'rare', targetCategory: LOOT_CATEGORY.ELITE, title: '레어 합성', consumeLabel: '일반 빌런 레어 전리품', rewardLabel: '엘리트 빌런 레어 전리품 랜덤 1개' };
            if (mode === 'eliteNormal') return { sourceCategory: LOOT_CATEGORY.ELITE, sourceRarity: 'normal', targetCategory: LOOT_CATEGORY.ROYAL, title: '상위 일반 합성', consumeLabel: '엘리트 빌런 일반 전리품', rewardLabel: '로열 빌런 일반 전리품 랜덤 1개' };
            if (mode === 'eliteRare') return { sourceCategory: LOOT_CATEGORY.ELITE, sourceRarity: 'rare', targetCategory: LOOT_CATEGORY.ROYAL, title: '상위 레어 합성', consumeLabel: '엘리트 빌런 레어 전리품', rewardLabel: '로열 빌런 레어 전리품 랜덤 1개' };
            if (mode === 'royalNormal') return { sourceCategory: LOOT_CATEGORY.ROYAL, sourceRarity: 'normal', targetCategory: LOOT_CATEGORY.BOSS, title: '최상위 일반 합성', consumeLabel: '로열 빌런 일반 전리품', rewardLabel: '보스 빌런 일반 전리품 랜덤 1개' };
            if (mode === 'royalRare') return { sourceCategory: LOOT_CATEGORY.ROYAL, sourceRarity: 'rare', targetCategory: LOOT_CATEGORY.BOSS, title: '최상위 레어 합성', consumeLabel: '로열 빌런 레어 전리품', rewardLabel: '보스 빌런 레어 전리품 랜덤 1개' };
            return null;
        }

        function getSynthNeed() {
            return getSynthNeedForMode(synthState.mode);
        }

        function setSynthMode(mode) {
            ensureSynthStateSize();
            const next = (mode === 'normal' || mode === 'rare' || mode === 'equip' || mode === 'eliteNormal' || mode === 'eliteRare' || mode === 'royalNormal' || mode === 'royalRare') ? mode : null;

            // 모드가 바뀌면(일반 ↔ 레어) 재료가 섞일 수 없으므로 선택을 초기화
            if (synthState.mode !== next) {
                synthState.reservedByInvIndex.fill(0);
                synthState.mode = next;
            }

            // next가 null이면 강제 초기화
            if (next === null) {
                synthState.reservedByInvIndex.fill(0);
            }
        }

        function getSynthTotal() {
            ensureSynthStateSize();
            let total = 0;
            for (let i = 0; i < INVENTORY_SIZE; i++) total += (synthState.reservedByInvIndex[i] || 0);
            return total;
        }

        function pruneSynthModeIfEmpty() {
            ensureSynthStateSize();
            if (getSynthTotal() <= 0) synthState.mode = null;
        }

        function clearSynthSelection(updateUI = true) {
            ensureSynthStateSize();
            synthState.reservedByInvIndex.fill(0);
            synthState.mode = null;

            if (updateUI && isGearPanelOpen) {
                updateInventoryUI();
            }
        }

        // (호환) 기존 함수명 유지 — 예전 코드가 남아있어도 동작하도록
        function clearSynthMixSelection(updateUI = true) {
            clearSynthSelection(updateUI);
        }

        function clearSynthesisSelection(updateUI = true) {
            selectedSynthInvIndex = null;
            clearSynthSelection(false);

            if (updateUI && isGearPanelOpen) {
                updateInventoryUI();
            }
        }

        function getSynthConsumePlan() {
            // invIndex 별로 실제 소비할 수량(=선택된 수량)
            ensureSynthStateSize();
            const plan = [];
            for (let i = 0; i < INVENTORY_SIZE; i++) {
                const amt = synthState.reservedByInvIndex[i] || 0;
                if (amt <= 0) continue;
                const stack = inventorySlots[i];
                if (!stack) continue;
                plan.push({ invIndex: i, id: stack.id, qty: amt });
            }
            return plan;
        }

        function getSynthSummary() {
            // id 단위로 합산하여 표시(동일 아이템이 여러 슬롯에 있어도 합쳐서 표시)
            const plan = getSynthConsumePlan();
            const byId = {};
            for (const p of plan) {
                byId[p.id] = (byId[p.id] || 0) + (p.qty || 0);
            }

            const rows = Object.keys(byId).map(id => ({
                id,
                qty: byId[id],
                name: LOOT_DEFS[id]?.name || id
            }));

            rows.sort((a, b) => String(a.name).localeCompare(String(b.name), 'ko'));
            return rows;
        }

        // ---------------------------------------------------------
        // [NEW] 장비 합성(경화제/헝겊/금속 조각) 유틸
        //  - (rarityKey)_(hardener|cloth|metal) 100개 → 상위 등급 랜덤 장비 1개
        // ---------------------------------------------------------
        function parseEquipSynthesisMaterial(itemId) {
            if (!itemId || typeof itemId !== 'string') return null;
            const m = itemId.match(/^([a-z]+)_(hardener|cloth|metal)$/);
            if (!m) return null;
            const rarityKey = m[1];
            const matType = m[2];
            if (EQUIP_RARITY_ORDER[rarityKey] === undefined) return null;
            return { rarityKey, matType };
        }

        function getNextEquipRarityKey(rarityKey) {
            const idx = EQUIP_RARITY_ORDER[rarityKey];
            if (idx === undefined || idx === null) return null;
            return EQUIP_RARITIES[idx + 1] || null;
        }

        function getEquipSynthesisRewardLabel(matType) {
            if (matType === 'hardener') return '랜덤 무기';
            if (matType === 'cloth') return '랜덤 방어구(부위 랜덤)';
            if (matType === 'metal') return '랜덤 악세사리(반지/목걸이)';
            return '랜덤 장비';
        }

        function getEquipSynthesisMatTypeKo(matType) {
            if (matType === 'hardener') return '경화제';
            if (matType === 'cloth') return '헝겊 조각';
            if (matType === 'metal') return '금속 조각';
            return '재료';
        }

        function pickEquipSynthesisSlot(matType) {
            if (matType === 'hardener') return 'Sword';
            if (matType === 'cloth') {
                const slots = ['Helmet', 'Armor', 'Gloves', 'Boots'];
                return slots[Math.floor(Math.random() * slots.length)];
            }
            if (matType === 'metal') {
                const slots = ['Ring', 'Necklace'];
                return slots[Math.floor(Math.random() * slots.length)];
            }
            return 'Sword';
        }

        function getEquipSynthSelectedMatId() {
            const plan = getSynthConsumePlan();
            const ids = [];
            for (const p of plan) if (p && p.id) ids.push(p.id);
            const uniq = Array.from(new Set(ids));
            if (uniq.length === 1) return uniq[0];
            if (uniq.length === 0) return null;
            return '__MIXED__';
        }


        function addToSynthSelection(invIndex, qty) {
            ensureSynthStateSize();
            qty = Math.max(0, Math.floor(qty || 0));
            if (qty <= 0) return false;

            const mode = synthState.mode;
            if (mode !== 'normal' && mode !== 'rare' && mode !== 'equip' && mode !== 'eliteNormal' && mode !== 'eliteRare' && mode !== 'royalNormal' && mode !== 'royalRare') return false;

            const stack = inventorySlots[invIndex];
            if (!stack) return false;

            const def = LOOT_DEFS[stack.id];
            if (!def) return false;

            const lootCfg = getLootSynthConfig(mode);
            if (lootCfg) {
                if (def.category !== lootCfg.sourceCategory) return false;
                if (def.rarity !== lootCfg.sourceRarity) return false;
            }

            // [NEW] 장비 합성: 같은 등급/종류 재료만(혼합 불가)
            if (mode === 'equip') {
                const matInfo = parseEquipSynthesisMaterial(stack.id);
                if (!matInfo) return false;

                const selectedMatId = getEquipSynthSelectedMatId();
                if (selectedMatId === '__MIXED__') return false;
                if (selectedMatId && selectedMatId !== stack.id) return false;
            }

            const need = getSynthNeed();
            const remaining = Math.max(0, need - getSynthTotal());
            if (remaining <= 0) return false;

            const available = getAvailableInInventory(invIndex);
            const add = Math.min(qty, available, remaining);
            if (add <= 0) return false;

            synthState.reservedByInvIndex[invIndex] = (synthState.reservedByInvIndex[invIndex] || 0) + add;
            return true;
        }


        function canAddLootAfterPlannedConsume(rewardId, plan) {
            // 같은 아이템이 이미 있으면 스택 가능
            for (let i = 0; i < inventorySlots.length; i++) {
                const s = inventorySlots[i];
                if (s && s.id === rewardId) return true;
            }

            // 소비 후 빈 슬롯이 생길 수 있으니 시뮬레이션
            let empty = 0;
            for (let i = 0; i < inventorySlots.length; i++) {
                if (!inventorySlots[i]) empty++;
            }

            for (const p of plan) {
                const idx = p.invIndex;
                const qty = p.qty || 0;
                const stack = inventorySlots[idx];
                if (!stack || qty <= 0) continue;

                const after = (stack.qty || 1) - qty;
                if (after <= 0) empty++;
            }

            return empty > 0;
        }
        // ---------------------------
        // [NEW] 합성 이펙트/사운드 (파티클 캔버스)
        // ---------------------------
        let _synthAudioCtx = null;
        function playSynthesisSfx() {
            try {
                const AC = window.AudioContext || window.webkitAudioContext;
                if (!AC) return;

                if (!_synthAudioCtx) _synthAudioCtx = new AC();
                const ctx = _synthAudioCtx;

                if (ctx.state === 'suspended') {
                    ctx.resume().catch(() => {});
                }

                const now = ctx.currentTime;

                // 메인 "합성 성공" 치임
                const g = ctx.createGain();
                g.gain.setValueAtTime(0.0001, now);
                g.gain.exponentialRampToValueAtTime(0.18, now + 0.02);
                g.gain.exponentialRampToValueAtTime(0.0001, now + 0.28);

                const o1 = ctx.createOscillator();
                const o2 = ctx.createOscillator();
                o1.type = 'triangle';
                o2.type = 'sine';

                o1.frequency.setValueAtTime(680, now);
                o1.frequency.exponentialRampToValueAtTime(1600, now + 0.10);

                o2.frequency.setValueAtTime(480, now);
                o2.frequency.exponentialRampToValueAtTime(1200, now + 0.10);

                // 약한 "쉬익" 노이즈(필터)
                const noiseDur = 0.14;
                const bufferSize = Math.max(1, Math.floor(ctx.sampleRate * noiseDur));
                const noiseBuffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
                const data = noiseBuffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = (Math.random() * 2 - 1) * 0.35;
                }
                const noise = ctx.createBufferSource();
                noise.buffer = noiseBuffer;

                const bp = ctx.createBiquadFilter();
                bp.type = 'bandpass';
                bp.frequency.setValueAtTime(1400, now);
                bp.frequency.exponentialRampToValueAtTime(700, now + noiseDur);

                const ng = ctx.createGain();
                ng.gain.setValueAtTime(0.0001, now);
                ng.gain.exponentialRampToValueAtTime(0.10, now + 0.015);
                ng.gain.exponentialRampToValueAtTime(0.0001, now + noiseDur);

                // 연결
                o1.connect(g);
                o2.connect(g);

                noise.connect(bp);
                bp.connect(ng);

                g.connect(ctx.destination);
                ng.connect(ctx.destination);

                o1.start(now);
                o2.start(now);
                noise.start(now);

                o1.stop(now + 0.30);
                o2.stop(now + 0.30);
                noise.stop(now + noiseDur);
            } catch (e) {
                // ignore
            }
        }

        // ---------------------------
        // [NEW] 합성 파티클 FX (Canvas Overlay)
        // ---------------------------
        let _synthFxEl = null;
        let _synthFxCanvas = null;
        let _synthFxCtx = null;
        let _synthFxRAF = 0;
        let _synthFxParticles = [];
        let _synthFxStart = 0;
        let _synthFxLastT = 0;
        let _synthFxDpr = 1;

        const SYNTH_FX_DURATION = 920; // ms

        function initSynthesisFxCanvas() {
            _synthFxEl = document.getElementById('synthFx');
            _synthFxCanvas = document.getElementById('synthFxCanvas');
            if (!_synthFxEl || !_synthFxCanvas) return;

            _synthFxCtx = _synthFxCanvas.getContext('2d', { alpha: true });
            resizeSynthesisFxCanvas();

            window.addEventListener('resize', resizeSynthesisFxCanvas, { passive: true });
        }

        function resizeSynthesisFxCanvas() {
            if (!_synthFxCanvas) return;
            const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
            _synthFxDpr = dpr;

            const w = Math.max(1, Math.floor(window.innerWidth * dpr));
            const h = Math.max(1, Math.floor(window.innerHeight * dpr));
            _synthFxCanvas.width = w;
            _synthFxCanvas.height = h;

            if (_synthFxCtx) {
                _synthFxCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
            }
        }

        function rand(min, max) {
            return min + Math.random() * (max - min);
        }
        function lerp(a, b, t) {
            return a + (b - a) * t;
        }
        function easeOutCubic(t) {
            return 1 - Math.pow(1 - Math.max(0, Math.min(1, t)), 3);
        }

        function spawnSynthFxParticles(mode) {
            const w = window.innerWidth;
            const h = window.innerHeight;
            const cx = w * 0.5;
            const cy = h * 0.45;

            // 모드별 컬러(골드 + 그린/퍼플)
            const hueA = 46;   // gold
            const hueB = (mode === 'rare') ? 280 : 128;

            const countBurst = 140;
            for (let i = 0; i < countBurst; i++) {
                const ang = Math.random() * Math.PI * 2;
                const spd = lerp(180, 820, Math.pow(Math.random(), 0.45));
                const vx = Math.cos(ang) * spd;
                const vy = Math.sin(ang) * spd;

                const isShard = Math.random() < 0.28;
                const hue = (Math.random() < 0.55 ? hueA : hueB) + rand(-14, 14);

                _synthFxParticles.push({
                    x: cx + rand(-6, 6),
                    y: cy + rand(-6, 6),
                    vx,
                    vy,
                    drag: lerp(0.86, 0.95, Math.random()),
                    g: lerp(120, 280, Math.random()),
                    age: 0,
                    life: lerp(0.42, 0.95, Math.random()),
                    size: isShard ? lerp(2.4, 5.0, Math.random()) : lerp(1.4, 3.6, Math.random()),
                    rot: ang,
                    spin: rand(-8, 8),
                    hue,
                    sat: lerp(78, 100, Math.random()),
                    light: lerp(55, 70, Math.random()),
                    type: isShard ? 'shard' : 'spark'
                });
            }

            // 주변에서 중심으로 빨려드는 모트(소환 느낌)
            const countIn = 36;
            for (let i = 0; i < countIn; i++) {
                const ang = Math.random() * Math.PI * 2;
                const r = rand(140, 300);
                const x = cx + Math.cos(ang) * r;
                const y = cy + Math.sin(ang) * r;

                const toCenter = rand(260, 520);
                const tx = -Math.sin(ang) * rand(-220, 220);
                const ty =  Math.cos(ang) * rand(-220, 220);

                const hue = (Math.random() < 0.5 ? hueA : hueB) + rand(-10, 10);

                _synthFxParticles.push({
                    x, y,
                    vx: (-Math.cos(ang) * toCenter) + tx,
                    vy: (-Math.sin(ang) * toCenter) + ty,
                    drag: lerp(0.80, 0.92, Math.random()),
                    g: lerp(-80, 80, Math.random()),
                    age: 0,
                    life: lerp(0.22, 0.40, Math.random()),
                    size: lerp(1.0, 2.2, Math.random()),
                    rot: ang,
                    spin: rand(-10, 10),
                    hue,
                    sat: 95,
                    light: 68,
                    type: 'mote'
                });
            }
        }

        function drawShard(ctx, p, alpha) {
            const len = p.size * 6;
            const dx = Math.cos(p.rot) * len;
            const dy = Math.sin(p.rot) * len;

            ctx.lineWidth = Math.max(1, p.size * 0.9);
            ctx.strokeStyle = `hsla(${p.hue}, ${p.sat}%, ${p.light}%, ${alpha})`;
            ctx.beginPath();
            ctx.moveTo(p.x - dx, p.y - dy);
            ctx.lineTo(p.x + dx, p.y + dy);
            ctx.stroke();
        }

        function drawSpark(ctx, p, alpha) {
            const r = p.size;
            ctx.fillStyle = `hsla(${p.hue}, ${p.sat}%, ${p.light}%, ${alpha})`;
            ctx.beginPath();
            ctx.arc(p.x, p.y, r, 0, Math.PI * 2);
            ctx.fill();
        }

        function stepSynthFx(ts) {
            if (!_synthFxCtx || !_synthFxCanvas || !_synthFxEl) return;

            const now = ts || performance.now();
            if (!_synthFxStart) {
                _synthFxStart = now;
                _synthFxLastT = now;
            }

            const dt = Math.min(0.033, Math.max(0.001, (now - _synthFxLastT) / 1000));
            _synthFxLastT = now;

            const elapsed = now - _synthFxStart;
            const t = Math.max(0, Math.min(1, elapsed / SYNTH_FX_DURATION));

            const w = window.innerWidth;
            const h = window.innerHeight;
            const cx = w * 0.5;
            const cy = h * 0.45;

            const ctx = _synthFxCtx;

            // 잔상 페이드(배경을 검게 덮지 않도록 destination-out 사용)
            ctx.save();
            ctx.globalCompositeOperation = 'destination-out';
            ctx.fillStyle = 'rgba(0,0,0,0.22)';
            ctx.fillRect(0, 0, w, h);
            ctx.restore();

            // 중심 플레어
            ctx.save();
            ctx.globalCompositeOperation = 'lighter';
            const flareP = (t < 0.35) ? (1 - (t / 0.35)) : 0;
            if (flareP > 0.001) {
                const gr = ctx.createRadialGradient(cx, cy, 0, cx, cy, 240);
                gr.addColorStop(0, `rgba(255, 230, 160, ${0.55 * flareP})`);
                gr.addColorStop(0.35, `rgba(46, 204, 113, ${0.22 * flareP})`);
                gr.addColorStop(0.65, `rgba(138, 43, 226, ${0.18 * flareP})`);
                gr.addColorStop(1, 'rgba(0,0,0,0)');
                ctx.fillStyle = gr;
                ctx.beginPath();
                ctx.arc(cx, cy, 240, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.restore();

            // 링(충격파)
            ctx.save();
            ctx.globalCompositeOperation = 'lighter';
            const ringT = easeOutCubic(Math.min(1, t / 0.85));
            const ringR = 30 + ringT * 260;
            const ringA = Math.max(0, (1 - ringT) * 0.75);
            ctx.lineWidth = 3;
            ctx.strokeStyle = `rgba(255, 215, 0, ${ringA})`;
            ctx.beginPath();
            ctx.arc(cx, cy, ringR, 0, Math.PI * 2);
            ctx.stroke();
            ctx.restore();

            // 파티클 업데이트 + 드로우
            ctx.save();
            ctx.globalCompositeOperation = 'lighter';

            const next = [];
            for (const p of _synthFxParticles) {
                p.age += dt;
                if (p.age >= p.life) continue;

                const dragPow = Math.pow(p.drag, dt * 60);
                p.vx *= dragPow;
                p.vy *= dragPow;
                p.vy += (p.g || 0) * dt;

                p.x += p.vx * dt;
                p.y += p.vy * dt;
                p.rot += (p.spin || 0) * dt;

                const k = p.age / p.life;
                const alpha = Math.max(0, Math.pow(1 - k, 1.9));

                if (p.type === 'shard') drawShard(ctx, p, alpha);
                else drawSpark(ctx, p, alpha);

                next.push(p);
            }
            _synthFxParticles = next;

            ctx.restore();

            // 종료 처리
            if (elapsed >= SYNTH_FX_DURATION && _synthFxParticles.length <= 0) {
                cancelAnimationFrame(_synthFxRAF);
                _synthFxRAF = 0;
                _synthFxStart = 0;
                _synthFxLastT = 0;
                _synthFxParticles = [];

                // 완전 정리
                ctx.clearRect(0, 0, w, h);
                _synthFxEl.classList.remove('active');
                return;
            }

            _synthFxRAF = requestAnimationFrame(stepSynthFx);
        }

        function triggerSynthesisFX(mode = 'normal') {
            playSynthesisSfx();

            if (!_synthFxEl || !_synthFxCanvas || !_synthFxCtx) {
                // 아직 초기화 전이라면 시도
                initSynthesisFxCanvas();
            }
            if (!_synthFxEl || !_synthFxCanvas || !_synthFxCtx) return;

            // 리스타트
            cancelAnimationFrame(_synthFxRAF);
            _synthFxRAF = 0;
            _synthFxStart = 0;
            _synthFxLastT = 0;
            _synthFxParticles = [];

            resizeSynthesisFxCanvas();
            _synthFxEl.classList.add('active');

            spawnSynthFxParticles(mode);
            _synthFxRAF = requestAnimationFrame(stepSynthFx);
        }

        
        function updateSynthesisUI() {
            if (!invSynthesisInfoEl || !invSynthesisBtnEl) return;
            ensureSynthStateSize();

            const total = getSynthTotal();
            const mode = synthState.mode;

            if (total > 0 && (mode === 'normal' || mode === 'rare' || mode === 'equip' || mode === 'eliteNormal' || mode === 'eliteRare' || mode === 'royalNormal' || mode === 'royalRare')) {
                const need = getSynthNeed();
                const summary = getSynthSummary();
                const listHtml = summary.map(s => `<span style="white-space:nowrap;">${escapeHtml(s.name)} x${s.qty}</span>`).join(' · ') || '-';

                if (mode === 'equip') {
                    const selectedMatId = getEquipSynthSelectedMatId();
                    let invalid = false;

                    if (!selectedMatId) {
                        invSynthesisInfoEl.innerHTML =
                            `<b>[장비 합성]</b> 재료 총합 <b>${total}/${need}</b> → 상위 등급 랜덤 장비 1개` +
                            `<br/><span style="opacity:0.82;">선택: ${listHtml}</span>` +
                            `<br/><span style="opacity:0.55;">팁: Shift+클릭=1개만 선택 · 우클릭=해당 슬롯 해제 · '선택 초기화'=전체 해제</span>`;
                        invSynthesisBtnEl.disabled = true;
                        return;
                    }

                    if (selectedMatId === '__MIXED__') {
                        invalid = true;
                        invSynthesisInfoEl.innerHTML =
                            `<b>[장비 합성]</b> <span style="color:#ffb4b4;">재료가 섞여 있습니다</span> (혼합 불가)` +
                            `<br/><span style="opacity:0.82;">선택: ${listHtml}</span>` +
                            `<br/><span style="opacity:0.55;">'선택 초기화'로 모두 해제 후 다시 선택하세요.</span>`;
                        invSynthesisBtnEl.disabled = true;
                        return;
                    }

                    const matInfo = parseEquipSynthesisMaterial(selectedMatId);
                    if (!matInfo) {
                        invalid = true;
                        invSynthesisInfoEl.innerHTML =
                            `<b>[장비 합성]</b> <span style="color:#ffb4b4;">지원하지 않는 재료</span>` +
                            `<br/><span style="opacity:0.82;">선택: ${listHtml}</span>`;
                        invSynthesisBtnEl.disabled = true;
                        return;
                    }

                    const nextRarity = getNextEquipRarityKey(matInfo.rarityKey);
                    const curKo = EQUIP_RARITY_KO[matInfo.rarityKey] || matInfo.rarityKey;
                    const nextKo = nextRarity ? (EQUIP_RARITY_KO[nextRarity] || nextRarity) : null;
                    const matTypeKo = getEquipSynthesisMatTypeKo(matInfo.matType);

                    if (!nextRarity) {
                        invalid = true;
                        invSynthesisInfoEl.innerHTML =
                            `<b>[장비 합성]</b> ${curKo} ${matTypeKo} 총합 <b>${total}/${need}</b> → <span style="color:#ffb4b4;">상위 등급이 없어 합성 불가</span>` +
                            `<br/><span style="opacity:0.82;">선택: ${listHtml}</span>` +
                            `<br/><span style="opacity:0.55;">※ 엔젤릭 등급은 상위 등급이 없습니다.</span>`;
                        invSynthesisBtnEl.disabled = true;
                        return;
                    }

                    const rewardLabel = getEquipSynthesisRewardLabel(matInfo.matType);

                    invSynthesisInfoEl.innerHTML =
                        `<b>[장비 합성]</b> ${curKo} ${matTypeKo} 총합 <b>${total}/${need}</b> → ${nextKo} <b>${rewardLabel}</b> 1개` +
                        `<br/><span style="opacity:0.82;">선택: ${listHtml}</span>` +
                        `<br/><span style="opacity:0.55;">팁: Shift+클릭=1개만 선택 · 우클릭=해당 슬롯 해제 · '선택 초기화'=전체 해제</span>`;

                    invSynthesisBtnEl.disabled = invalid || (total < need);
                    return;
                }

                // 기존 전리품 합성(일반/레어)
                const lootCfg = getLootSynthConfig(mode);
                if (lootCfg) {
                    invSynthesisInfoEl.innerHTML =
                        `<b>[${lootCfg.title}]</b> ${lootCfg.consumeLabel} 총합 <b>${total}/${need}</b> (혼합 가능) → ${lootCfg.rewardLabel}` +
                        `<br/><span style="opacity:0.82;">선택: ${listHtml}</span>` +
                        `<br/><span style="opacity:0.55;">팁: Shift+클릭=1개만 선택 · 우클릭=해당 슬롯 해제 · '선택 초기화'=전체 해제</span>`;
                }

                invSynthesisBtnEl.disabled = (total < need);
                return;
            }

            // 선택 없음: 안내만 표시
            invSynthesisInfoEl.innerHTML =
                `일반 합성: 일반 빌런 <b>일반</b> 전리품 총합 <b>${SYNTH_MIX_NEED}개(혼합 가능)</b> → 엘리트 빌런 <b>일반</b> 전리품 랜덤 1개<br/>` +
                `레어 합성: 일반 빌런 <b>레어</b> 전리품 총합 <b>${SYNTH_RARE_NEED}개(혼합 가능)</b> → 엘리트 빌런 <b>레어</b> 전리품 랜덤 1개<br/>` +
                `상위 일반 합성: 엘리트 빌런 <b>일반</b> 전리품 총합 <b>${SYNTH_MIX_NEED}개(혼합 가능)</b> → 로열 빌런 <b>일반</b> 전리품 랜덤 1개<br/>` +
                `상위 레어 합성: 엘리트 빌런 <b>레어</b> 전리품 총합 <b>${SYNTH_RARE_NEED}개(혼합 가능)</b> → 로열 빌런 <b>레어</b> 전리품 랜덤 1개<br/>` +
                `최상위 일반 합성: 로열 빌런 <b>일반</b> 전리품 총합 <b>${SYNTH_MIX_NEED}개(혼합 가능)</b> → 보스 빌런 <b>일반</b> 전리품 랜덤 1개<br/>` +
                `최상위 레어 합성: 로열 빌런 <b>레어</b> 전리품 총합 <b>${SYNTH_RARE_NEED}개(혼합 가능)</b> → 보스 빌런 <b>레어</b> 전리품 랜덤 1개<br/>` +
                `장비 합성: <b>경화제/헝겊 조각/금속 조각</b> 총합 <b>${SYNTH_EQUIP_NEED}개</b> → 한 단계 상위 등급의 랜덤 장비 1개` +
                `<br/><span style="opacity:0.55;">팁: 재료를 클릭해 수량을 채우면 합성 버튼이 활성화됩니다.</span>`;

            invSynthesisBtnEl.disabled = true;
        }

function getRandomLootIdByCategoryAndRarity(category, rarity) {
            const pool = [];
            for (const id in LOOT_DEFS) {
                const d = LOOT_DEFS[id];
                if (!d) continue;
                if (d.category === category && d.rarity === rarity) pool.push(id);
            }
            if (pool.length <= 0) return null;
            return pool[Math.floor(Math.random() * pool.length)];
        }

        function canAddLootNow(id) {
            // 이미 같은 아이템이 있으면 스택 가능
            for (let i = 0; i < inventorySlots.length; i++) {
                const s = inventorySlots[i];
                if (s && s.id === id) return true;
            }
            // 빈 칸 여부
            for (let i = 0; i < inventorySlots.length; i++) {
                if (!inventorySlots[i]) return true;
            }
            return false;
        }

        function consumeFromInventorySlot(invIndex, qty) {
            qty = Math.max(0, Math.floor(qty));
            if (qty <= 0) return true;

            const stack = inventorySlots[invIndex];
            if (!stack) return false;

            const available = getAvailableInInventory(invIndex);
            if (available < qty) return false;

            stack.qty = (stack.qty || 1) - qty;
            if (stack.qty <= 0) {
                inventorySlots[invIndex] = null;
                if (selectedSynthInvIndex === invIndex) selectedSynthInvIndex = null;
            }

            saveInventoryToStorage();
            return true;
        }

        function trySynthesizeSelectedLoot() {
            if (!isGearPanelOpen) return;

            ensureSynthStateSize();

            const total = getSynthTotal();
            const mode = (synthState.mode === 'rare' || synthState.mode === 'normal' || synthState.mode === 'equip' || synthState.mode === 'eliteNormal' || synthState.mode === 'eliteRare' || synthState.mode === 'royalNormal' || synthState.mode === 'royalRare') ? synthState.mode : null;

            if (!mode || total <= 0) {
                showPickupEffect(player.x, player.y - 70, `합성 재료를 선택하세요. (일반: 총합 ${SYNTH_MIX_NEED}개 / 레어: 총합 ${SYNTH_RARE_NEED}개 / 장비: 총합 ${SYNTH_EQUIP_NEED}개)`, false, true, "weak-text");
                return;
            }

            const need = getSynthNeedForMode(mode);
            if (total < need) {
                const label = (mode === 'rare') ? '레어' : ((mode === 'equip') ? '장비' : '일반');
                showPickupEffect(player.x, player.y - 70, `${label} 합성 재료가 부족합니다. (${total}/${need})`, false, true, "weak-text");
                return;
            }
            if (total > need) {
                showPickupEffect(player.x, player.y - 70, "합성 재료 수량이 올바르지 않습니다. (선택 초기화 후 다시 시도)", false, true, "weak-text");
                return;
            }


            // -----------------------------------------------------
            // [NEW] 장비 합성: 경화제/헝겊/금속 100개 → 상위 등급 랜덤 장비 1개
            // -----------------------------------------------------
            if (mode === 'equip') {
                const plan = getSynthConsumePlan();
                const planTotal = plan.reduce((a, p) => a + (p.qty || 0), 0);
                if (planTotal !== need) {
                    showPickupEffect(player.x, player.y - 70, "합성 재료 수량이 올바르지 않습니다. (선택 초기화 후 다시 시도)", false, true, "weak-text");
                    return;
                }

                const byId = {};
                for (const p of plan) byId[p.id] = (byId[p.id] || 0) + (p.qty || 0);
                const ids = Object.keys(byId);
                if (ids.length !== 1) {
                    showPickupEffect(player.x, player.y - 70, "장비 합성은 동일한 재료만 사용할 수 있습니다. (선택 초기화 후 다시 시도)", false, true, "weak-text");
                    return;
                }

                const matId = ids[0];
                const matInfo = parseEquipSynthesisMaterial(matId);
                if (!matInfo) {
                    showPickupEffect(player.x, player.y - 70, "장비 합성 재료가 올바르지 않습니다. (선택 초기화 후 다시 시도)", false, true, "weak-text");
                    return;
                }

                const nextRarity = getNextEquipRarityKey(matInfo.rarityKey);
                if (!nextRarity) {
                    const curKo = EQUIP_RARITY_KO[matInfo.rarityKey] || matInfo.rarityKey;
                    showPickupEffect(player.x, player.y - 70, `${curKo} 등급은 상위 등급이 없어 합성할 수 없습니다.`, false, true, "weak-text");
                    return;
                }

                const nextKo = EQUIP_RARITY_KO[nextRarity] || nextRarity;
                const matName = LOOT_DEFS[matId]?.name || matId;
                const rewardLabel = getEquipSynthesisRewardLabel(matInfo.matType);

                const okConfirm = window.confirm(`[장비 합성]
선택한 ${matName} 총합 ${need}개를 합성합니다.

[소모]
- ${matName} x${need}

[보상]
${nextKo} ${rewardLabel} 1개

정말 합성할까요?`);
                if (!okConfirm) return;

                // 사전 검증: 모든 슬롯에서 해당 수량을 소비 가능한지 확인 (강화 예약분은 절대 소비하지 않음)
                for (const p of plan) {
                    const idx = p.invIndex;
                    const qty = Math.max(0, Math.floor(p.qty || 0));
                    if (qty <= 0) continue;

                    const stack = inventorySlots[idx];
                    if (!stack || stack.id !== matId) {
                        showPickupEffect(player.x, player.y - 70, "합성 재료가 변경되었습니다. (선택 초기화 후 다시 시도)", false, true, "weak-text");
                        return;
                    }

                    const d = LOOT_DEFS[stack.id];
                    if (!d || d.category !== LOOT_CATEGORY.NORMAL || !parseEquipSynthesisMaterial(stack.id)) {
                        showPickupEffect(player.x, player.y - 70, "합성 재료가 변경되었습니다. (선택 초기화 후 다시 시도)", false, true, "weak-text");
                        return;
                    }

                    const reservedEnh = enhancePanelState.reservedByInvIndex[idx] || 0;
                    const canConsume = Math.max(0, (stack.qty || 1) - reservedEnh);
                    if (canConsume < qty) {
                        showPickupEffect(player.x, player.y - 70, "합성 재료가 부족합니다. (선택 초기화 후 다시 시도)", false, true, "weak-text");
                        return;
                    }
                }

                // 실제 소비
                for (const p of plan) {
                    const idx = p.invIndex;
                    const qty = Math.max(0, Math.floor(p.qty || 0));
                    if (qty <= 0) continue;

                    const stack = inventorySlots[idx];
                    if (!stack) continue;

                    stack.qty = (stack.qty || 1) - qty;
                    if (stack.qty <= 0) {
                        inventorySlots[idx] = null;
                        if (selectedSynthInvIndex === idx) selectedSynthInvIndex = null;
                    }
                }

                // 선택 초기화 + 저장
                clearSynthSelection(false);
                saveInventoryToStorage();

                // 보상 장비 생성/지급
                const slot = pickEquipSynthesisSlot(matInfo.matType);
                const it = makeGearItemFixed(nextRarity, slot, { dropFromLabel: '장비 합성', enemyCategory: 'normal' });

                const stored = addGearToInventory(it);

                // 파티클 이펙트/사운드 (상위 등급은 rare 팔레트)
                const fxMode = (EQUIP_RARITY_ORDER[nextRarity] || 0) >= 4 ? 'rare' : 'normal';
                triggerSynthesisFX(fxMode);

                if (!stored) {
                    // 장비 인벤토리가 가득 차면 드랍 대기열로 저장(소실 방지)
                    pendingGearDrops.push(it);
                    saveGearToStorage();
                    notifyGearInventoryFull();
                    showPickupEffect(player.x, player.y - 70, `장비 합성 성공! (보상은 드랍 대기열에 저장됨)`, true, true, "goddess-text");
                } else {
                    if (isRarityAtLeast(it.rarity, 'unique')) playGearDropSfx(it.rarity);
                    const slotKo = EQUIP_SLOT_KO[it.slot] || it.slot;
                    showPickupEffect(player.x, player.y - 70, `장비 합성 성공! ${nextKo} ${slotKo} 획득!`, true, true, "goddess-text");
                }

                updateInventoryUI();
                updateEnhanceUI();
                if (isEquipPanelOpen) updateEquipPanelUI();
                return;
            }

            const lootCfg = getLootSynthConfig(mode);
            const rewardRarity = lootCfg ? lootCfg.sourceRarity : ((mode === 'rare') ? 'rare' : 'normal');
            const rewardCategory = lootCfg ? lootCfg.targetCategory : LOOT_CATEGORY.ELITE;
            const rewardId = getRandomLootIdByCategoryAndRarity(rewardCategory, rewardRarity);
            if (!rewardId) {
                showPickupEffect(player.x, player.y - 70, "합성 결과 아이템 풀을 찾지 못했습니다.", false, true, "weak-text");
                return;
            }

            const plan = getSynthConsumePlan();
            const planTotal = plan.reduce((a, p) => a + (p.qty || 0), 0);
            if (planTotal !== need) {
                showPickupEffect(player.x, player.y - 70, "합성 재료 수량이 올바르지 않습니다. (선택 초기화 후 다시 시도)", false, true, "weak-text");
                return;
            }

            if (!canAddLootAfterPlannedConsume(rewardId, plan)) {
                showPickupEffect(player.x, player.y - 70, "인벤토리가 가득 차서 합성할 수 없습니다.", false, true, "weak-text");
                return;
            }

            const summary = getSynthSummary();
            const lines = summary.map(s => `- ${s.name} x${s.qty}`).join('\n');

            const modeTitle = (lootCfg && lootCfg.title) ? lootCfg.title : ((mode === 'rare') ? '레어 합성' : '일반 합성');
            const consumeLabel = (lootCfg && lootCfg.consumeLabel) ? lootCfg.consumeLabel : ((mode === 'rare') ? '레어 전리품' : '일반 전리품');
            const rewardLabel = (lootCfg && lootCfg.rewardLabel) ? lootCfg.rewardLabel : ((mode === 'rare')
                ? '엘리트 빌런 레어 전리품 랜덤 1개'
                : '엘리트 빌런 일반 전리품 랜덤 1개');

            const okConfirm = window.confirm(`[${modeTitle}]
선택한 ${consumeLabel} 총합 ${need}개를 합성합니다.

[소모]
${lines || '-'}

[보상]
${rewardLabel}

정말 합성할까요?`);
            if (!okConfirm) return;

            // 사전 검증: 모든 슬롯에서 해당 수량을 소비 가능한지 확인 (강화 예약분은 절대 소비하지 않음)
            for (const p of plan) {
                const idx = p.invIndex;
                const qty = Math.max(0, Math.floor(p.qty || 0));
                if (qty <= 0) continue;

                const stack = inventorySlots[idx];
                if (!stack) {
                    showPickupEffect(player.x, player.y - 70, "합성 재료가 변경되었습니다. (선택 초기화 후 다시 시도)", false, true, "weak-text");
                    return;
                }

                const d = LOOT_DEFS[stack.id];
                const expectedRarity = lootCfg ? lootCfg.sourceRarity : ((mode === 'rare') ? 'rare' : 'normal');
                const expectedCategory = lootCfg ? lootCfg.sourceCategory : LOOT_CATEGORY.NORMAL;
                if (!d || d.category !== expectedCategory || d.rarity !== expectedRarity) {
                    showPickupEffect(player.x, player.y - 70, "합성 재료가 변경되었습니다. (선택 초기화 후 다시 시도)", false, true, "weak-text");
                    return;
                }

                const reservedEnh = enhancePanelState.reservedByInvIndex[idx] || 0;
                const canConsume = Math.max(0, (stack.qty || 1) - reservedEnh);
                if (canConsume < qty) {
                    showPickupEffect(player.x, player.y - 70, "합성 재료가 부족합니다. (선택 초기화 후 다시 시도)", false, true, "weak-text");
                    return;
                }
            }

            // 실제 소비
            for (const p of plan) {
                const idx = p.invIndex;
                const qty = Math.max(0, Math.floor(p.qty || 0));
                if (qty <= 0) continue;

                const stack = inventorySlots[idx];
                if (!stack) continue;

                stack.qty = (stack.qty || 1) - qty;
                if (stack.qty <= 0) {
                    inventorySlots[idx] = null;
                    if (selectedSynthInvIndex === idx) selectedSynthInvIndex = null;
                }
            }

            const rewardName = LOOT_DEFS[rewardId]?.name || rewardId;

            // 선택 초기화 + 저장
            clearSynthSelection(false);
            saveInventoryToStorage();

            const added = addLootToInventory(rewardId, 1);

            // 파티클 이펙트/사운드
            triggerSynthesisFX(mode);

            if (!added) {
                // 이론상 canAddLootAfterPlannedConsume로 막히지만, 안전장치
                showPickupEffect(player.x, player.y - 70, `인벤토리 가득! ${rewardName} 소실`, false, true, "weak-text");
            } else {
                showPickupEffect(player.x, player.y - 70, `합성 성공! ${rewardName} +1`, true, true, "goddess-text");
            }

            updateInventoryUI();
            updateEnhanceUI();
        }

        function clearDragOver(container) {
            if (!container) return;
            container.querySelectorAll('.mat-slot.drag-over').forEach(el => el.classList.remove('drag-over'));
        }

        function onMatSlotsDragOver(ev) {
            ev.preventDefault();
            const container = ev.currentTarget;
            const slotEl = ev.target.closest('.mat-slot');
            if (!slotEl) return;
            clearDragOver(container);
            slotEl.classList.add('drag-over');
        }

        function onMatSlotsDragLeave(ev) {
            const container = ev.currentTarget;
            // 컨테이너 밖으로 나갈 때만 정리
            if (!container.contains(ev.relatedTarget)) {
                clearDragOver(container);
            }
        }

        function onMatSlotsDrop(ev) {
            ev.preventDefault();
            const container = ev.currentTarget;
            clearDragOver(container);

            const slotEl = ev.target.closest('.mat-slot');
            if (!slotEl) return;

            const gear = slotEl.dataset.gear;
            const slotIndex = Number(slotEl.dataset.index);

            let payload = null;
            try {
                payload = JSON.parse(ev.dataTransfer.getData('text/plain'));
            } catch (e) { /* ignore */ }

            const invIndex = payload?.invIndex;
            if (invIndex === undefined || invIndex === null) return;

            setActiveMatTarget(gear, slotIndex);
            const ok = tryInsertToMatSlot(Number(invIndex), gear, slotIndex);
            if (!ok) showPickupEffect(player.x, player.y - 70, "투입할 수 없는 재료입니다.", false, true, "weak-text");
        }

        function onMatSlotsClick(ev) {
            const slotEl = ev.target.closest('.mat-slot');
            if (!slotEl) return;

            const gear = slotEl.dataset.gear;
            const slotIndex = Number(slotEl.dataset.index);

            // clear 버튼
            if (ev.target.classList.contains('mat-clear')) {
                clearMatSlot(gear, slotIndex);
                return;
            }

            setActiveMatTarget(gear, slotIndex);
        }

        function getSlotIconFor(slot) {
            if (!slot) return '';
            if (slot.acceptType === 'id') return LOOT_ICON[slot.acceptValue] || '';
            // category 대표 아이콘(희귀도에 따라)
            const isRare = (slot.acceptRarity === 'rare');
            if (slot.acceptValue === LOOT_CATEGORY.ELITE) return LOOT_ICON[isRare ? 'oath_blooddrop' : 'cassias_badge'] || '';
            if (slot.acceptValue === LOOT_CATEGORY.ROYAL) return LOOT_ICON[isRare ? 'abyss_orb' : 'masakuni_mask'] || '';
            return LOOT_ICON[isRare ? 'abyss_residual_spore' : 'dark_virus'] || '';
        }

        function renderMatSlots(gear) {
            const container = (gear === 'weapon') ? weaponMatSlotsEl : armorMatSlotsEl;
            if (!container) return;

            ensureEnhanceSlotsForGear(gear);
            const slots = enhancePanelState[gear].slots || [];
            const active = enhancePanelState.activeTarget;

            if (slots.length === 0) {
                container.innerHTML = `<div class="mat-sub">MAX 등급/레벨</div>`;
                return;
            }

            container.innerHTML = slots.map((s, idx) => {
                const icon = getSlotIconFor(s);
                const isSelected = active && active.gear === gear && active.index === idx;
                const done = (s.required <= 0) || (s.filled >= s.required);

                const hint = done ? '완료' : '드래그/클릭으로 투입';
                const countText = `${Math.min(s.filled, s.required)} / ${s.required}`;

                return `
                    <div class="mat-slot ${isSelected ? 'selected' : ''}" data-gear="${gear}" data-index="${idx}">
                        <div class="mat-slot-top">
                            <div>
                                <div class="mat-label">${s.label}</div>
                                <div class="mat-sub">${s.acceptType === 'id' ? (LOOT_DEFS[s.acceptValue]?.name || '') : (s.acceptRarity === 'rare' ? '레어만 가능' : (s.acceptRarity === 'normal' ? '일반만 가능' : '아무거나 가능'))}</div>
                            </div>
                            <button class="mat-clear" title="비우기" ${s.filled > 0 ? '' : 'style="opacity:0.35;"'}>✕</button>
                        </div>
                        <div class="mat-body">
                            <img class="mat-icon" src="${icon}" alt="" />
                            <div style="display:flex; flex-direction:column; gap:2px;">
                                <div class="mat-count"><b>${countText}</b></div>
                                <div class="mat-hint">${hint}</div>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');

            // 이벤트(드래그/클릭) — 매 렌더링마다 안전하게 재등록
            container.removeEventListener('dragover', onMatSlotsDragOver);
            container.removeEventListener('dragleave', onMatSlotsDragLeave);
            container.removeEventListener('drop', onMatSlotsDrop);
            container.removeEventListener('click', onMatSlotsClick);

            container.addEventListener('dragover', onMatSlotsDragOver);
            container.addEventListener('dragleave', onMatSlotsDragLeave);
            container.addEventListener('drop', onMatSlotsDrop);
            container.addEventListener('click', onMatSlotsClick);
        }

        // ---------------------------
        // [UI] 장비 강화
        // ---------------------------
        function initEnhanceUI() {
            weaponIconEl = document.getElementById('weaponIcon');
            armorIconEl  = document.getElementById('armorIcon');

            weaponMatSlotsEl = document.getElementById('weaponMatSlots');
            armorMatSlotsEl  = document.getElementById('armorMatSlots');

            weaponLevelTextEl = document.getElementById('weaponLevelText');
            armorLevelTextEl  = document.getElementById('armorLevelText');

            weaponStatsTextEl = document.getElementById('weaponStatsText');
            armorStatsTextEl  = document.getElementById('armorStatsText');

            weaponReqTextEl = document.getElementById('weaponReqText');
            armorReqTextEl  = document.getElementById('armorReqText');

            weaponHaveTextEl = document.getElementById('weaponHaveText');
            armorHaveTextEl  = document.getElementById('armorHaveText');

            weaponUpgradeBtnEl = document.getElementById('weaponUpgradeBtn');
            armorUpgradeBtnEl  = document.getElementById('armorUpgradeBtn');

            if (weaponUpgradeBtnEl) weaponUpgradeBtnEl.addEventListener('click', () => doUpgradeWeapon());
            if (armorUpgradeBtnEl) armorUpgradeBtnEl.addEventListener('click', () => doUpgradeArmor());
        }

        function updateEnhanceUI() {
            // 슬롯 구성 보장
            ensureEnhanceSlotsForGear('weapon');
            ensureEnhanceSlotsForGear('armor');

            const wGradeSafe = Math.max(0, Math.min(MAX_GEAR_GRADE_INDEX, Math.floor(weaponGradeIndex || 0)));
            const aGradeSafe = Math.max(0, Math.min(MAX_GEAR_GRADE_INDEX, Math.floor(armorGradeIndex || 0)));
            const wGradeName = GEAR_GRADES[wGradeSafe] || '커먼';
            const aGradeName = GEAR_GRADES[aGradeSafe] || '커먼';

            // 무기
            if (weaponLevelTextEl) weaponLevelTextEl.textContent = `${wGradeName} Lv.${weaponEnhanceLevel}`;
            if (weaponStatsTextEl) {
                const atkBonus = getTotalWeaponAttackBonus(wGradeSafe, weaponEnhanceLevel);
                const accBonus = wGradeSafe * 2;
                const critBonus = wGradeSafe * 1;
                const inc = getWeaponAtkPerLevel(wGradeSafe);
                weaponStatsTextEl.innerHTML =
                    `공격력 <b>+${formatNumberMaybeFloat(atkBonus, 1)}</b> · (강화 +${formatNumberMaybeFloat(inc, 1)}/Lv) · 명중 <b>+${accBonus}%</b> · 치확 <b>+${critBonus}%</b>`;
            }

            const wMode = getGearUpgradeMode('weapon');
            const wReq = getGearUpgradeRequirement('weapon');
            if (weaponReqTextEl) {
                if (wMode === 'max' || wReq.type === 'max') weaponReqTextEl.innerHTML = `최대 등급/레벨에 도달했습니다.`;
                else if (wMode === 'grade' && wReq.type === 'grade') {
                    weaponReqTextEl.innerHTML = `등급 업그레이드: <b>${GEAR_GRADES[wReq.curGrade]} → ${GEAR_GRADES[wReq.nextGrade]}</b> (Lv.${MAX_ENHANCE_LEVEL})`;
                } else {
                    weaponReqTextEl.innerHTML = `다음 강화: <b>${wGradeName} Lv.${weaponEnhanceLevel + 1}</b>`;
                }
            }

            // 방어구
            if (armorLevelTextEl) armorLevelTextEl.textContent = `${aGradeName} Lv.${armorEnhanceLevel}`;
            if (armorStatsTextEl) {
                const defBonus = getTotalArmorDefenseBonus(aGradeSafe, armorEnhanceLevel);
                const evaBonus = aGradeSafe * 2;
                const critResBonus = aGradeSafe * 1;
                const inc = getArmorDefPerLevel(aGradeSafe);
                armorStatsTextEl.innerHTML =
                    `방어력 <b>+${formatNumberMaybeFloat(defBonus, 1)}</b> · (강화 +${formatNumberMaybeFloat(inc, 2)}/Lv) · 회피 <b>+${evaBonus}%</b> · 치저 <b>+${critResBonus}%</b>`;
            }

            const aMode = getGearUpgradeMode('armor');
            const aReq = getGearUpgradeRequirement('armor');
            if (armorReqTextEl) {
                if (aMode === 'max' || aReq.type === 'max') armorReqTextEl.innerHTML = `최대 등급/레벨에 도달했습니다.`;
                else if (aMode === 'grade' && aReq.type === 'grade') {
                    armorReqTextEl.innerHTML = `등급 업그레이드: <b>${GEAR_GRADES[aReq.curGrade]} → ${GEAR_GRADES[aReq.nextGrade]}</b> (Lv.${MAX_ENHANCE_LEVEL})`;
                } else {
                    armorReqTextEl.innerHTML = `다음 강화: <b>${aGradeName} Lv.${armorEnhanceLevel + 1}</b>`;
                }
            }

            // 보유 현황
            if (weaponHaveTextEl) {
                if (wMode === 'grade') {
                    weaponHaveTextEl.innerHTML =
                        `레어(엘리트) <b>${getLootCountByCategoryAndRarity(LOOT_CATEGORY.ELITE, 'rare')}</b> · 레어(로열) <b>${getLootCountByCategoryAndRarity(LOOT_CATEGORY.ROYAL, 'rare')}</b> · 레어(보스) <b>${getLootCountByCategoryAndRarity(LOOT_CATEGORY.BOSS, 'rare')}</b>`;
                } else {
                    weaponHaveTextEl.innerHTML =
                        `엘리트 <b>${getLootCountByCategory(LOOT_CATEGORY.ELITE)}</b> · 로열 <b>${getLootCountByCategory(LOOT_CATEGORY.ROYAL)}</b> · 다크 바이러스 <b>${getLootCount('dark_virus')}</b> · 칼자루 <b>${getLootCount('blood_hilt')}</b>`;
                }
            }
            if (armorHaveTextEl) {
                if (aMode === 'grade') {
                    armorHaveTextEl.innerHTML =
                        `레어(엘리트) <b>${getLootCountByCategoryAndRarity(LOOT_CATEGORY.ELITE, 'rare')}</b> · 레어(로열) <b>${getLootCountByCategoryAndRarity(LOOT_CATEGORY.ROYAL, 'rare')}</b> · 레어(보스) <b>${getLootCountByCategoryAndRarity(LOOT_CATEGORY.BOSS, 'rare')}</b>`;
                } else {
                    armorHaveTextEl.innerHTML =
                        `엘리트 <b>${getLootCountByCategory(LOOT_CATEGORY.ELITE)}</b> · 로열 <b>${getLootCountByCategory(LOOT_CATEGORY.ROYAL)}</b> · 보스 <b>${getLootCountByCategory(LOOT_CATEGORY.BOSS)}</b>`;
                }
            }

            // 슬롯 렌더
            renderMatSlots('weapon');
            renderMatSlots('armor');

            // 버튼 활성/비활성 + 라벨
            if (weaponUpgradeBtnEl) {
                const can = (wMode !== 'max') && areEnhanceSlotsComplete('weapon');
                weaponUpgradeBtnEl.disabled = !can;
                weaponUpgradeBtnEl.style.opacity = can ? '1' : '0.45';
                weaponUpgradeBtnEl.style.cursor = can ? 'pointer' : 'not-allowed';
                weaponUpgradeBtnEl.textContent = (wMode === 'grade') ? '등급 업그레이드' : '강화';
            }
            if (armorUpgradeBtnEl) {
                const can = (aMode !== 'max') && areEnhanceSlotsComplete('armor');
                armorUpgradeBtnEl.disabled = !can;
                armorUpgradeBtnEl.style.opacity = can ? '1' : '0.45';
                armorUpgradeBtnEl.style.cursor = can ? 'pointer' : 'not-allowed';
                armorUpgradeBtnEl.textContent = (aMode === 'grade') ? '등급 업그레이드' : '강화';
            }
        }


        // ---------------------------
        // [아트] 아이콘 생성 (캔버스 드로잉)
        //  - 전리품: 고급스러운 프레임 + 고유 심볼
        //  - 장비: 순백의 검/갑옷
        // ---------------------------
        function hashString(str) {
            let h = 2166136261 >>> 0;
            for (let i = 0; i < str.length; i++) {
                h ^= str.charCodeAt(i);
                h = Math.imul(h, 16777619);
            }
            return h >>> 0;
        }
        function mulberry32(a) {
            return function() {
                let t = a += 0x6D2B79F5;
                t = Math.imul(t ^ (t >>> 15), t | 1);
                t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
                return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
            }
        }
        function pathRoundRect(ctx, x, y, w, h, r) {
            const rr = Math.min(r, w / 2, h / 2);
            ctx.beginPath();
            ctx.moveTo(x + rr, y);
            ctx.arcTo(x + w, y, x + w, y + h, rr);
            ctx.arcTo(x + w, y + h, x, y + h, rr);
            ctx.arcTo(x, y + h, x, y, rr);
            ctx.arcTo(x, y, x + w, y, rr);
            ctx.closePath();
        }

        function getAccentForCategory(category) {
            if (category === LOOT_CATEGORY.NORMAL) return '#2ecc71';
            if (category === LOOT_CATEGORY.ELITE) return '#d4af37';
            if (category === LOOT_CATEGORY.ROYAL) return '#8a2be2';
            if (category === LOOT_CATEGORY.BOSS)  return '#dc143c';
            return '#ffffff';
        }

        function drawOrnateFrame(ctx, s, accent) {
            ctx.save();
            // Background
            const bg = ctx.createRadialGradient(s * 0.35, s * 0.28, s * 0.06, s * 0.5, s * 0.5, s * 0.85);
            bg.addColorStop(0, 'rgba(255,255,255,0.10)');
            bg.addColorStop(0.45, 'rgba(18,18,26,0.95)');
            bg.addColorStop(1, 'rgba(0,0,0,0.95)');
            ctx.fillStyle = bg;
            pathRoundRect(ctx, s * 0.06, s * 0.06, s * 0.88, s * 0.88, s * 0.16);
            ctx.fill();

            // Outer metallic rim
            ctx.lineWidth = s * 0.06;
            const rim = ctx.createLinearGradient(s * 0.06, s * 0.06, s * 0.94, s * 0.94);
            rim.addColorStop(0, 'rgba(255,255,255,0.55)');
            rim.addColorStop(0.25, accent);
            rim.addColorStop(0.5, 'rgba(255,255,255,0.15)');
            rim.addColorStop(0.75, accent);
            rim.addColorStop(1, 'rgba(0,0,0,0.55)');
            ctx.strokeStyle = rim;
            pathRoundRect(ctx, s * 0.08, s * 0.08, s * 0.84, s * 0.84, s * 0.16);
            ctx.stroke();

            // Inner bevel
            ctx.lineWidth = s * 0.02;
            ctx.strokeStyle = 'rgba(255,255,255,0.15)';
            pathRoundRect(ctx, s * 0.12, s * 0.12, s * 0.76, s * 0.76, s * 0.14);
            ctx.stroke();

            // Corner ornaments
            ctx.strokeStyle = 'rgba(255,255,255,0.10)';
            ctx.lineWidth = s * 0.012;
            const c = s * 0.17;
            function corner(x, y, sx, sy) {
                ctx.beginPath();
                ctx.moveTo(x, y + c * sy);
                ctx.quadraticCurveTo(x + c * 0.35 * sx, y + c * 0.55 * sy, x + c * 0.7 * sx, y);
                ctx.stroke();
            }
            corner(s * 0.12, s * 0.12, +1, +1);
            corner(s * 0.88, s * 0.12, -1, +1);
            corner(s * 0.12, s * 0.88, +1, -1);
            corner(s * 0.88, s * 0.88, -1, -1);

            ctx.restore();
        }

        function drawSparkles(ctx, s, seedStr, accent) {
            const rnd = mulberry32(hashString(seedStr));
            ctx.save();
            for (let i = 0; i < 14; i++) {
                const x = s * (0.12 + rnd() * 0.76);
                const y = s * (0.12 + rnd() * 0.76);
                const r = s * (0.006 + rnd() * 0.012);
                ctx.globalAlpha = 0.15 + rnd() * 0.25;
                ctx.fillStyle = rnd() < 0.65 ? 'rgba(255,255,255,0.85)' : accent;
                ctx.beginPath();
                ctx.arc(x, y, r, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.restore();
        }

        function drawLootIcon(ctx, s, id) {
            const def = LOOT_DEFS[id];
            const accent = getAccentForCategory(def ? def.category : LOOT_CATEGORY.ELITE);

            drawOrnateFrame(ctx, s, accent);
            drawSparkles(ctx, s, id, accent);

            // Center stage
            ctx.save();
            ctx.translate(s * 0.5, s * 0.54);

            // subtle glow
            const glow = ctx.createRadialGradient(0, 0, s * 0.02, 0, 0, s * 0.38);
            glow.addColorStop(0, 'rgba(255,255,255,0.08)');
            glow.addColorStop(0.5, 'rgba(255,255,255,0.03)');
            glow.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = glow;
            ctx.beginPath();
            ctx.arc(0, 0, s * 0.36, 0, Math.PI * 2);
            ctx.fill();

            // Symbol switch
            // 강화 재료(헝겊/금속/경화제) 티어별 아이콘
            if (/^(common|uncommon|rare|epic|unique|legendary|demonic|angelic)_(cloth|metal|hardener)$/.test(id)) {
                if (/_cloth$/.test(id))      { drawSymbolClothScrap(ctx, s, accent, id); }
                else if (/_metal$/.test(id)) { drawSymbolMetalScrap(ctx, s, accent, id); }
                else                         { drawSymbolHardener(ctx, s, accent, id); }
                ctx.restore();
                return;
            }

            switch (id) {
                // --- 일반 빌런 ---
                case 'curse_vial':          drawSymbolCurseVial(ctx, s, accent); break;
                case 'dark_cloak_fragment': drawSymbolCloakFragment(ctx, s, accent); break;
                case 'used_condom':         drawSymbolEvidenceBag(ctx, s, accent); break;

                // --- 일반 빌런 레어 ---
                case 'poisoned_hilt':       drawSymbolPoisonedHilt(ctx, s, accent); break;
                case 'ebony_powder':        drawSymbolEbonyPowder(ctx, s, accent); break;
                case 'aphrodisiac_perfume': drawSymbolPerfume(ctx, s, accent); break;

                // --- 엘리트 일반 ---
                case 'ryuon_emblem':      drawSymbolEmblem(ctx, s, accent); break;
                case 'luca_diary':        drawSymbolDiary(ctx, s, accent); break;
                case 'ozma_orb':          drawSymbolCrystalOrb(ctx, s, accent); break;
                case 'taro_chain':        drawSymbolChain(ctx, s, accent); break;
                case 'gawain_flag':       drawSymbolBanner(ctx, s, accent); break;
                case 'aki_potion':        drawSymbolPotion(ctx, s, accent); break;
                case 'hiro_radio':        drawSymbolRadio(ctx, s, accent); break;
                case 'kai_grimoire':      drawSymbolGrimoire(ctx, s, accent); break;
                case 'jacques_note':      drawSymbolMusicShard(ctx, s, accent, false); break;
                case 'cassias_badge':     drawSymbolBadge(ctx, s, accent); break;

                // --- 로열 일반 ---
                case 'masakuni_mask':     drawSymbolSamuraiMask(ctx, s, accent); break;
                case 'kaito_orb':         drawSymbolInfectedOrb(ctx, s, accent); break;
                case 'questa_bottle':     drawSymbolGasBottle(ctx, s, accent); break;
                case 'tetora_note':       drawSymbolMusicShard(ctx, s, accent, true); break;

                // --- 보스 일반 ---
                case 'dark_virus':        drawSymbolVirus(ctx, s, accent); break;
                case 'blood_hilt':        drawSymbolHilt(ctx, s, accent); break;

                // --- 엘리트 레어 ---
                case 'oath_blooddrop':     drawSymbolOathBlooddrop(ctx, s, accent); break;
                case 'broken_aim_lens':    drawSymbolBrokenLens(ctx, s, accent); break;
                case 'arcane_echo_dust':   drawSymbolArcaneEchoDust(ctx, s, accent); break;
                case 'torn_letter':        drawSymbolTornLetter(ctx, s, accent); break;
                case 'oath_wind_shard':    drawSymbolOathWindShard(ctx, s, accent); break;
                case 'dark_sediment':      drawSymbolDarkSediment(ctx, s, accent); break;
                case 'call_sign_noise':    drawSymbolCallSignNoise(ctx, s, accent); break;
                case 'greed_ink_trace':    drawSymbolGreedInkTrace(ctx, s, accent); break;
                case 'dissonance_meter':   drawSymbolDissonanceMeter(ctx, s, accent); break;
                case 'rank_seal_wax':      drawSymbolRankSealWax(ctx, s, accent); break;

                // --- 로열 레어 ---
                case 'abyss_orb':               drawSymbolAbyssOrb(ctx, s, accent); break;
                case 'black_confession_thread': drawSymbolConfessionThread(ctx, s, accent); break;
                case 'black_veil_strand':       drawSymbolVeilStrand(ctx, s, accent); break;
                case 'abyss_phrase':            drawSymbolAbyssPhrase(ctx, s, accent); break;

                // --- 보스 레어 ---
                case 'abyss_residual_spore': drawSymbolResidualSpore(ctx, s, accent); break;
                case 'true_ancestor_mark':  drawSymbolAncestorMark(ctx, s, accent); break;

                default:
                    drawSymbolNameRelic(ctx, s, accent, (def && def.name) ? def.name : id);
            }

            ctx.restore();
        }

        // ----- Symbols -----
        function drawMetal(ctx, x0, y0, x1, y1, c1, c2, c3) {
            const g = ctx.createLinearGradient(x0, y0, x1, y1);
            g.addColorStop(0, c1);
            g.addColorStop(0.5, c2);
            g.addColorStop(1, c3);
            return g;
        }

        function drawSymbolEmblem(ctx, s, accent) {
            // Ring
            ctx.save();
            const r = s * 0.26;
            ctx.lineWidth = s * 0.04;
            ctx.strokeStyle = drawMetal(ctx, -r, -r, r, r, 'rgba(255,255,255,0.55)', accent, 'rgba(0,0,0,0.6)');
            ctx.beginPath();
            ctx.arc(0, 0, r, 0, Math.PI * 2);
            ctx.stroke();

            // Shield
            ctx.fillStyle = drawMetal(ctx, -r, -r, r, r, 'rgba(240,240,255,0.85)', 'rgba(140,140,160,0.85)', 'rgba(20,20,30,0.85)');
            ctx.strokeStyle = 'rgba(0,0,0,0.6)';
            ctx.lineWidth = s * 0.01;
            ctx.beginPath();
            ctx.moveTo(0, -s * 0.20);
            ctx.quadraticCurveTo(s * 0.16, -s * 0.16, s * 0.18, -s * 0.02);
            ctx.quadraticCurveTo(s * 0.20, s * 0.14, 0, s * 0.24);
            ctx.quadraticCurveTo(-s * 0.20, s * 0.14, -s * 0.18, -s * 0.02);
            ctx.quadraticCurveTo(-s * 0.16, -s * 0.16, 0, -s * 0.20);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            // Crossed swords
            ctx.lineWidth = s * 0.026;
            ctx.lineCap = 'round';
            ctx.strokeStyle = 'rgba(255,255,255,0.85)';
            function sword(angle) {
                ctx.save();
                ctx.rotate(angle);
                ctx.beginPath();
                ctx.moveTo(0, -s * 0.20);
                ctx.lineTo(0, s * 0.16);
                ctx.stroke();

                // tip
                ctx.fillStyle = 'rgba(255,255,255,0.92)';
                ctx.beginPath();
                ctx.moveTo(0, -s * 0.25);
                ctx.lineTo(s * 0.03, -s * 0.20);
                ctx.lineTo(-s * 0.03, -s * 0.20);
                ctx.closePath();
                ctx.fill();

                // guard
                ctx.strokeStyle = accent;
                ctx.lineWidth = s * 0.018;
                ctx.beginPath();
                ctx.moveTo(-s * 0.06, s * 0.12);
                ctx.lineTo(s * 0.06, s * 0.12);
                ctx.stroke();
                ctx.restore();
            }
            sword(Math.PI * 0.22);
            sword(-Math.PI * 0.22);

            // Blood stains
            ctx.globalAlpha = 0.9;
            ctx.fillStyle = 'rgba(180, 0, 0, 0.55)';
            for (let i = 0; i < 7; i++) {
                const x = (-s * 0.11) + (i * s * 0.03);
                const y = (-s * 0.05) + ((i % 2) * s * 0.03);
                ctx.beginPath();
                ctx.ellipse(x, y, s * 0.018, s * 0.012, i * 0.4, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.restore();
        }

        function drawSymbolDiary(ctx, s, accent) {
            ctx.save();
            const w = s * 0.42, h = s * 0.48;
            // Book cover
            ctx.fillStyle = drawMetal(ctx, -w, -h, w, h, 'rgba(120,90,50,0.95)', 'rgba(60,35,20,0.95)', 'rgba(20,10,5,0.95)');
            ctx.strokeStyle = 'rgba(0,0,0,0.65)';
            ctx.lineWidth = s * 0.012;
            pathRoundRect(ctx, -w * 0.5, -h * 0.5, w, h, s * 0.06);
            ctx.fill();
            ctx.stroke();

            // Spine
            ctx.fillStyle = 'rgba(0,0,0,0.25)';
            pathRoundRect(ctx, -w * 0.5, -h * 0.5, w * 0.16, h, s * 0.05);
            ctx.fill();

            // Strap
            ctx.strokeStyle = accent;
            ctx.lineWidth = s * 0.018;
            ctx.beginPath();
            ctx.moveTo(-w * 0.1, -h * 0.15);
            ctx.lineTo(w * 0.35, -h * 0.15);
            ctx.stroke();

            // Pages
            ctx.strokeStyle = 'rgba(255,255,255,0.25)';
            ctx.lineWidth = s * 0.008;
            for (let i = 0; i < 6; i++) {
                const y = -h * 0.20 + i * (h * 0.08);
                ctx.beginPath();
                ctx.moveTo(-w * 0.18, y);
                ctx.lineTo(w * 0.34, y);
                ctx.stroke();
            }

            // Faded title
            ctx.fillStyle = 'rgba(255,255,255,0.22)';
            ctx.font = `bold ${Math.floor(s * 0.08)}px Gugi`;
            ctx.textAlign = 'center';
            ctx.fillText('DIARY', w * 0.08, -h * 0.30);

            ctx.restore();
        }

        function drawSymbolCrystalOrb(ctx, s, accent) {
            ctx.save();
            const r = s * 0.23;

            // base
            ctx.fillStyle = 'rgba(0,0,0,0.35)';
            pathRoundRect(ctx, -s * 0.16, r * 0.95, s * 0.32, s * 0.12, s * 0.06);
            ctx.fill();

            // sphere
            const g = ctx.createRadialGradient(-r * 0.3, -r * 0.3, r * 0.05, 0, 0, r);
            g.addColorStop(0, 'rgba(255,255,255,0.55)');
            g.addColorStop(0.35, 'rgba(120,190,255,0.20)');
            g.addColorStop(1, 'rgba(20,30,50,0.65)');
            ctx.fillStyle = g;
            ctx.beginPath();
            ctx.arc(0, 0, r, 0, Math.PI * 2);
            ctx.fill();

            // dim glow ring
            ctx.strokeStyle = 'rgba(255,255,255,0.18)';
            ctx.lineWidth = s * 0.012;
            ctx.beginPath();
            ctx.arc(0, 0, r, 0, Math.PI * 2);
            ctx.stroke();

            // cracks
            ctx.strokeStyle = 'rgba(255,255,255,0.22)';
            ctx.lineWidth = s * 0.008;
            ctx.beginPath();
            ctx.moveTo(-r * 0.6, -r * 0.05);
            ctx.lineTo(-r * 0.1, -r * 0.15);
            ctx.lineTo(r * 0.15, -r * 0.55);
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(-r * 0.15, r * 0.10);
            ctx.lineTo(r * 0.35, r * 0.05);
            ctx.lineTo(r * 0.55, r * 0.35);
            ctx.stroke();

            // dead core
            ctx.fillStyle = 'rgba(0,0,0,0.35)';
            ctx.beginPath();
            ctx.arc(r * 0.18, r * 0.10, r * 0.22, 0, Math.PI * 2);
            ctx.fill();

            // accent highlight
            ctx.fillStyle = accent;
            ctx.globalAlpha = 0.12;
            ctx.beginPath();
            ctx.arc(-r * 0.25, -r * 0.20, r * 0.28, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();
        }

        function drawSymbolChain(ctx, s, accent) {
            ctx.save();
            ctx.rotate(-0.15);
            const linkR = s * 0.15;
            function link(x, y) {
                ctx.save();
                ctx.translate(x, y);
                ctx.strokeStyle = drawMetal(ctx, -linkR, -linkR, linkR, linkR, 'rgba(220,220,230,0.9)', 'rgba(120,120,140,0.9)', 'rgba(0,0,0,0.75)');
                ctx.lineWidth = s * 0.04;
                ctx.beginPath();
                ctx.ellipse(0, 0, linkR, linkR * 0.72, 0, 0, Math.PI * 2);
                ctx.stroke();
                ctx.restore();
            }
            link(-s * 0.09, -s * 0.02);
            link(s * 0.12, s * 0.04);

            // break crack
            ctx.strokeStyle = accent;
            ctx.lineWidth = s * 0.012;
            ctx.beginPath();
            ctx.moveTo(-s * 0.01, -s * 0.02);
            ctx.lineTo(s * 0.06, s * 0.02);
            ctx.lineTo(s * 0.02, s * 0.09);
            ctx.stroke();

            // shard
            ctx.fillStyle = 'rgba(255,255,255,0.16)';
            ctx.beginPath();
            ctx.moveTo(s * 0.02, s * 0.09);
            ctx.lineTo(s * 0.10, s * 0.12);
            ctx.lineTo(s * 0.05, s * 0.17);
            ctx.closePath();
            ctx.fill();

            ctx.restore();
        }

        function drawSymbolBanner(ctx, s, accent) {
            ctx.save();
            // pole
            ctx.strokeStyle = 'rgba(180,180,200,0.8)';
            ctx.lineWidth = s * 0.018;
            ctx.beginPath();
            ctx.moveTo(-s * 0.22, -s * 0.26);
            ctx.lineTo(-s * 0.22, s * 0.24);
            ctx.stroke();

            // flag fabric
            ctx.fillStyle = drawMetal(ctx, -s * 0.2, -s * 0.2, s * 0.25, s * 0.25, 'rgba(220,220,230,0.35)', 'rgba(80,80,90,0.55)', 'rgba(0,0,0,0.55)');
            ctx.beginPath();
            ctx.moveTo(-s * 0.22, -s * 0.22);
            ctx.quadraticCurveTo(-s * 0.05, -s * 0.18, s * 0.24, -s * 0.10);
            ctx.quadraticCurveTo(s * 0.10, 0, s * 0.24, s * 0.10);
            // torn bottom
            ctx.lineTo(s * 0.12, s * 0.22);
            ctx.lineTo(s * 0.04, s * 0.12);
            ctx.lineTo(-s * 0.02, s * 0.24);
            ctx.lineTo(-s * 0.10, s * 0.14);
            ctx.lineTo(-s * 0.16, s * 0.24);
            ctx.lineTo(-s * 0.22, s * 0.18);
            ctx.closePath();
            ctx.fill();

            // emblem cross
            ctx.strokeStyle = accent;
            ctx.lineWidth = s * 0.028;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(s * 0.04, -s * 0.10);
            ctx.lineTo(s * 0.04, s * 0.14);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(-s * 0.03, s * 0.02);
            ctx.lineTo(s * 0.11, s * 0.02);
            ctx.stroke();

            ctx.restore();
        }

        function drawSymbolPotion(ctx, s, accent) {
            ctx.save();
            // bottle silhouette
            ctx.fillStyle = 'rgba(20,20,25,0.7)';
            pathRoundRect(ctx, -s * 0.16, -s * 0.18, s * 0.32, s * 0.44, s * 0.10);
            ctx.fill();

            // liquid
            const g = ctx.createLinearGradient(0, -s * 0.10, 0, s * 0.22);
            g.addColorStop(0, 'rgba(120,0,140,0.20)');
            g.addColorStop(0.45, 'rgba(40,0,70,0.80)');
            g.addColorStop(1, 'rgba(0,0,0,0.85)');
            ctx.fillStyle = g;
            pathRoundRect(ctx, -s * 0.14, -s * 0.02, s * 0.28, s * 0.26, s * 0.08);
            ctx.fill();

            // glass highlight
            ctx.strokeStyle = 'rgba(255,255,255,0.25)';
            ctx.lineWidth = s * 0.010;
            ctx.beginPath();
            ctx.moveTo(-s * 0.08, -s * 0.15);
            ctx.quadraticCurveTo(-s * 0.12, 0, -s * 0.08, s * 0.20);
            ctx.stroke();

            // cork
            ctx.fillStyle = drawMetal(ctx, -s * 0.12, -s * 0.26, s * 0.12, -s * 0.18, 'rgba(160,110,60,0.9)', 'rgba(90,60,30,0.9)', 'rgba(30,15,5,0.9)');
            pathRoundRect(ctx, -s * 0.10, -s * 0.26, s * 0.20, s * 0.10, s * 0.04);
            ctx.fill();

            // poison symbol
            ctx.globalAlpha = 0.85;
            ctx.fillStyle = accent;
            ctx.beginPath();
            ctx.moveTo(0, -s * 0.02);
            ctx.quadraticCurveTo(s * 0.07, s * 0.05, 0, s * 0.14);
            ctx.quadraticCurveTo(-s * 0.07, s * 0.05, 0, -s * 0.02);
            ctx.closePath();
            ctx.fill();

            ctx.restore();
        }

        function drawSymbolRadio(ctx, s, accent) {
            ctx.save();
            const w = s * 0.46, h = s * 0.40;
            ctx.fillStyle = drawMetal(ctx, -w, -h, w, h, 'rgba(120,120,140,0.85)', 'rgba(50,50,60,0.85)', 'rgba(0,0,0,0.8)');
            pathRoundRect(ctx, -w * 0.5, -h * 0.35, w, h, s * 0.08);
            ctx.fill();

            // antenna
            ctx.strokeStyle = 'rgba(220,220,240,0.75)';
            ctx.lineWidth = s * 0.010;
            ctx.beginPath();
            ctx.moveTo(w * 0.10, -h * 0.45);
            ctx.lineTo(w * 0.24, -h * 0.75);
            ctx.stroke();

            // screen
            ctx.fillStyle = 'rgba(0,0,0,0.55)';
            pathRoundRect(ctx, -w * 0.34, -h * 0.20, w * 0.48, h * 0.22, s * 0.05);
            ctx.fill();

            // knobs
            ctx.fillStyle = accent;
            ctx.globalAlpha = 0.75;
            for (let i = 0; i < 4; i++) {
                ctx.beginPath();
                ctx.arc(-w * 0.30 + i * (w * 0.20), h * 0.10, s * 0.03, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1;

            // crack
            ctx.strokeStyle = 'rgba(255,255,255,0.25)';
            ctx.lineWidth = s * 0.010;
            ctx.beginPath();
            ctx.moveTo(-w * 0.05, -h * 0.08);
            ctx.lineTo(w * 0.10, h * 0.02);
            ctx.lineTo(w * 0.02, h * 0.16);
            ctx.stroke();

            // spark
            ctx.strokeStyle = accent;
            ctx.lineWidth = s * 0.008;
            ctx.beginPath();
            ctx.moveTo(w * 0.20, h * 0.18);
            ctx.lineTo(w * 0.26, h * 0.10);
            ctx.lineTo(w * 0.30, h * 0.20);
            ctx.stroke();

            ctx.restore();
        }

        function drawSymbolGrimoire(ctx, s, accent) {
            ctx.save();
            const w = s * 0.44, h = s * 0.46;
            ctx.rotate(-0.10);
            ctx.fillStyle = drawMetal(ctx, -w, -h, w, h, 'rgba(90,0,120,0.65)', 'rgba(20,0,40,0.75)', 'rgba(0,0,0,0.85)');
            pathRoundRect(ctx, -w * 0.5, -h * 0.5, w, h, s * 0.06);
            ctx.fill();

            // torn corner
            ctx.fillStyle = 'rgba(255,255,255,0.10)';
            ctx.beginPath();
            ctx.moveTo(w * 0.18, -h * 0.5);
            ctx.lineTo(w * 0.5, -h * 0.22);
            ctx.lineTo(w * 0.5, -h * 0.5);
            ctx.closePath();
            ctx.fill();

            // runes
            ctx.strokeStyle = accent;
            ctx.lineWidth = s * 0.010;
            for (let i = 0; i < 5; i++) {
                const y = -h * 0.25 + i * (h * 0.12);
                ctx.beginPath();
                ctx.moveTo(-w * 0.30, y);
                ctx.lineTo(w * 0.26, y);
                ctx.stroke();
            }
            ctx.beginPath();
            ctx.moveTo(-w * 0.10, -h * 0.18);
            ctx.lineTo(-w * 0.02, -h * 0.06);
            ctx.lineTo(-w * 0.14, h * 0.02);
            ctx.stroke();

            ctx.restore();
        }

        function drawSymbolMusicShard(ctx, s, accent, deep) {
            ctx.save();
            const a = deep ? 'rgba(80,0,140,0.85)' : 'rgba(30,30,35,0.85)';
            // note stem
            ctx.strokeStyle = 'rgba(255,255,255,0.82)';
            ctx.lineWidth = s * 0.030;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(-s * 0.02, -s * 0.20);
            ctx.lineTo(s * 0.02, s * 0.16);
            ctx.stroke();

            // note head
            const g = ctx.createRadialGradient(-s * 0.05, s * 0.14, s * 0.01, 0, s * 0.12, s * 0.12);
            g.addColorStop(0, 'rgba(255,255,255,0.9)');
            g.addColorStop(1, a);
            ctx.fillStyle = g;
            ctx.beginPath();
            ctx.ellipse(-s * 0.06, s * 0.16, s * 0.10, s * 0.07, -0.3, 0, Math.PI * 2);
            ctx.fill();

            // shards
            ctx.fillStyle = accent;
            ctx.globalAlpha = 0.65;
            for (let i = 0; i < 6; i++) {
                ctx.save();
                ctx.rotate(-0.9 + i * 0.35);
                ctx.beginPath();
                ctx.moveTo(s * 0.16, -s * 0.02);
                ctx.lineTo(s * 0.26, s * 0.02);
                ctx.lineTo(s * 0.14, s * 0.06);
                ctx.closePath();
                ctx.fill();
                ctx.restore();
            }
            ctx.globalAlpha = 1;

            ctx.restore();
        }

        function drawSymbolBadge(ctx, s, accent) {
            ctx.save();
            const r = s * 0.22;

            // star
            ctx.fillStyle = drawMetal(ctx, -r, -r, r, r, 'rgba(255,255,255,0.65)', accent, 'rgba(0,0,0,0.7)');
            ctx.beginPath();
            for (let i = 0; i < 10; i++) {
                const ang = (Math.PI * 2 / 10) * i - Math.PI / 2;
                const rr = i % 2 === 0 ? r : r * 0.45;
                const x = Math.cos(ang) * rr;
                const y = Math.sin(ang) * rr;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.fill();

            // center gem
            const g = ctx.createRadialGradient(-r * 0.2, -r * 0.2, r * 0.05, 0, 0, r * 0.6);
            g.addColorStop(0, 'rgba(255,255,255,0.85)');
            g.addColorStop(1, 'rgba(0,0,0,0.65)');
            ctx.fillStyle = g;
            ctx.beginPath();
            ctx.arc(0, 0, r * 0.45, 0, Math.PI * 2);
            ctx.fill();

            ctx.strokeStyle = 'rgba(255,255,255,0.25)';
            ctx.lineWidth = s * 0.012;
            ctx.beginPath();
            ctx.arc(0, 0, r * 0.45, 0, Math.PI * 2);
            ctx.stroke();

            ctx.restore();
        }
        // =============================
        // [강화 재료 아이콘] (캔버스 드로잉)
        // =============================
        function _tierColorFromId(id) {
            const tier = (id || '').split('_')[0];
            switch (tier) {
                case 'common':    return {a:'#b7b7b7', b:'#5a5a5a'};
                case 'uncommon':  return {a:'#66ff9a', b:'#1f7a3f'};
                case 'rare':      return {a:'#74a7ff', b:'#224a9a'};
                case 'epic':      return {a:'#c97bff', b:'#5a2a8c'};
                case 'unique':    return {a:'#ffdf7a', b:'#9a6a12'};
                case 'legendary': return {a:'#ffb066', b:'#a24a12'};
                case 'demonic':   return {a:'#ff5b5b', b:'#7a1010'};
                case 'angelic':   return {a:'#e7f3ff', b:'#7aa6d9'};
                default:          return {a:'#d0d0d0', b:'#666'};
            }
        }

        function drawSymbolClothScrap(ctx, s, accent, id) {
            const c = _tierColorFromId(id);
            ctx.save();
            const w = s * 0.52, h = s * 0.38;
            const x = -w/2, y = -h/2;

            // base fabric
            const g = ctx.createLinearGradient(x, y, x+w, y+h);
            g.addColorStop(0, c.a);
            g.addColorStop(1, c.b);
            ctx.fillStyle = g;
            ctx.strokeStyle = 'rgba(0,0,0,0.35)';
            ctx.lineWidth = Math.max(1, s*0.02);

            ctx.beginPath();
            ctx.moveTo(x + s*0.05, y + s*0.03);
            ctx.lineTo(x + w - s*0.02, y + s*0.06);
            ctx.lineTo(x + w - s*0.08, y + h - s*0.03);
            ctx.lineTo(x + s*0.02, y + h - s*0.06);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            // folds
            ctx.globalAlpha = 0.35;
            ctx.strokeStyle = 'rgba(255,255,255,0.65)';
            ctx.lineWidth = Math.max(1, s*0.012);
            ctx.beginPath();
            ctx.moveTo(x + w*0.15, y + h*0.25);
            ctx.quadraticCurveTo(x + w*0.45, y + h*0.05, x + w*0.8, y + h*0.22);
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(x + w*0.2, y + h*0.7);
            ctx.quadraticCurveTo(x + w*0.55, y + h*0.85, x + w*0.82, y + h*0.62);
            ctx.stroke();
            ctx.globalAlpha = 1;

            // stitches
            ctx.strokeStyle = 'rgba(20,20,20,0.55)';
            ctx.lineWidth = Math.max(1, s*0.008);
            for (let i=0;i<8;i++){
                const px = x + w*0.18 + i*(w*0.08);
                const py = y + h*0.52 + (i%2? s*0.01 : -s*0.01);
                ctx.beginPath();
                ctx.moveTo(px, py);
                ctx.lineTo(px + w*0.05, py + s*0.01);
                ctx.stroke();
            }

            // frayed threads
            ctx.strokeStyle = 'rgba(255,255,255,0.55)';
            ctx.lineWidth = Math.max(1, s*0.006);
            for (let i=0;i<6;i++){
                const px = x + w*0.05 + i*(w*0.15);
                ctx.beginPath();
                ctx.moveTo(px, y + h - s*0.02);
                ctx.lineTo(px - s*0.03, y + h + s*0.06);
                ctx.stroke();
            }
            ctx.restore();
        }

        function drawSymbolMetalScrap(ctx, s, accent, id) {
            const c = _tierColorFromId(id);
            ctx.save();

            const shard = (ox, oy, sc) => {
                const w = s*0.22*sc, h = s*0.26*sc;
                const x = ox - w/2, y = oy - h/2;
                const g = ctx.createLinearGradient(x, y, x+w, y+h);
                g.addColorStop(0, 'rgba(255,255,255,0.65)');
                g.addColorStop(0.35, c.a);
                g.addColorStop(1, c.b);
                ctx.fillStyle = g;
                ctx.strokeStyle = 'rgba(0,0,0,0.45)';
                ctx.lineWidth = Math.max(1, s*0.015);
                ctx.beginPath();
                ctx.moveTo(x + w*0.15, y);
                ctx.lineTo(x + w, y + h*0.2);
                ctx.lineTo(x + w*0.75, y + h);
                ctx.lineTo(x, y + h*0.75);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();

                // highlight edge
                ctx.globalAlpha = 0.35;
                ctx.strokeStyle = 'rgba(255,255,255,0.85)';
                ctx.lineWidth = Math.max(1, s*0.01);
                ctx.beginPath();
                ctx.moveTo(x + w*0.18, y + h*0.1);
                ctx.lineTo(x + w*0.82, y + h*0.25);
                ctx.stroke();
                ctx.globalAlpha = 1;

                // rivet
                ctx.fillStyle = 'rgba(0,0,0,0.35)';
                ctx.beginPath();
                ctx.arc(x + w*0.72, y + h*0.62, s*0.018*sc, 0, Math.PI*2);
                ctx.fill();
            };

            shard(-s*0.13, s*0.02, 1.05);
            shard(s*0.08, -s*0.06, 0.95);
            shard(s*0.18, s*0.11, 0.85);

            ctx.restore();
        }

        function drawSymbolHardener(ctx, s, accent, id) {
            const c = _tierColorFromId(id);
            ctx.save();

            // bottle
            const bw = s*0.24, bh = s*0.34;
            const bx = -bw/2, by = -bh/2 - s*0.02;

            // glass body
            ctx.fillStyle = 'rgba(255,255,255,0.18)';
            ctx.strokeStyle = 'rgba(0,0,0,0.45)';
            ctx.lineWidth = Math.max(1, s*0.015);

            ctx.beginPath();
            ctx.moveTo(bx + bw*0.25, by);
            ctx.lineTo(bx + bw*0.75, by);
            ctx.lineTo(bx + bw*0.88, by + bh*0.25);
            ctx.lineTo(bx + bw*0.82, by + bh);
            ctx.lineTo(bx + bw*0.18, by + bh);
            ctx.lineTo(bx + bw*0.12, by + bh*0.25);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            // liquid
            const lg = ctx.createLinearGradient(0, by+bh*0.25, 0, by+bh);
            lg.addColorStop(0, c.a);
            lg.addColorStop(1, c.b);
            ctx.globalAlpha = 0.85;
            ctx.fillStyle = lg;
            ctx.beginPath();
            ctx.moveTo(bx + bw*0.18, by + bh*0.52);
            ctx.quadraticCurveTo(0, by + bh*0.60, bx + bw*0.82, by + bh*0.50);
            ctx.lineTo(bx + bw*0.78, by + bh*0.98);
            ctx.lineTo(bx + bw*0.22, by + bh*0.98);
            ctx.closePath();
            ctx.fill();
            ctx.globalAlpha = 1;

            // cork
            ctx.fillStyle = 'rgba(40,25,10,0.9)';
            ctx.beginPath();
            ctx.roundRect(bx + bw*0.28, by - s*0.07, bw*0.44, s*0.07, s*0.02);
            ctx.fill();

            // sparkle crystals
            ctx.globalAlpha = 0.65;
            ctx.fillStyle = 'rgba(255,255,255,0.85)';
            for (const p of [[-s*0.18, s*0.16],[s*0.22, s*0.12],[s*0.05, s*0.22]]) {
                ctx.save();
                ctx.translate(p[0], p[1]);
                ctx.rotate(Math.PI/4);
                ctx.beginPath();
                ctx.rect(-s*0.03, -s*0.03, s*0.06, s*0.06);
                ctx.fill();
                ctx.restore();
            }
            ctx.globalAlpha = 1;

            ctx.restore();
        }



        function drawSymbolNameRelic(ctx, s, accent, name = '') {
            drawSymbolBadge(ctx, s, accent);
            ctx.save();
            const txt = (name || '').toUpperCase();
            const hasBlood = /피|혈|BLOOD/.test(txt);
            const hasDark = /암흑|어둠|다크|DARK/.test(txt);
            const hasMusic = /음|선율|노트|NOTE|MUSIC/.test(txt);
            const hasOrb = /구슬|오브|ORB/.test(txt);

            if (hasBlood) {
                ctx.fillStyle = 'rgba(180,0,0,0.70)';
                ctx.beginPath();
                ctx.moveTo(0, -s*0.10); ctx.bezierCurveTo(s*0.12, -s*0.20, s*0.16, -s*0.02, 0, s*0.16);
                ctx.bezierCurveTo(-s*0.16, -s*0.02, -s*0.12, -s*0.20, 0, -s*0.10);
                ctx.fill();
            } else if (hasMusic) {
                ctx.strokeStyle = 'rgba(230,230,255,0.85)';
                ctx.lineWidth = s * 0.03;
                ctx.beginPath();
                ctx.moveTo(-s*0.05, -s*0.12); ctx.lineTo(-s*0.05, s*0.12);
                ctx.lineTo(s*0.10, s*0.08);
                ctx.stroke();
                ctx.beginPath(); ctx.arc(-s*0.08, s*0.14, s*0.05, 0, Math.PI*2); ctx.fillStyle='rgba(220,220,255,0.85)'; ctx.fill();
            } else if (hasOrb) {
                const g = ctx.createRadialGradient(0, 0, s*0.03, 0, 0, s*0.16);
                g.addColorStop(0, 'rgba(255,255,255,0.95)');
                g.addColorStop(1, accent);
                ctx.fillStyle = g;
                ctx.beginPath(); ctx.arc(0, 0, s*0.16, 0, Math.PI*2); ctx.fill();
            } else if (hasDark) {
                ctx.fillStyle = 'rgba(40,0,70,0.9)';
                ctx.beginPath(); ctx.arc(0, 0, s*0.16, 0, Math.PI*2); ctx.fill();
                ctx.strokeStyle = 'rgba(190,120,255,0.85)';
                ctx.lineWidth = s*0.02;
                ctx.beginPath(); ctx.arc(0, 0, s*0.10, 0, Math.PI*2); ctx.stroke();
            } else {
                ctx.fillStyle = 'rgba(255,255,255,0.9)';
                ctx.font = `900 ${Math.floor(s*0.12)}px var(--ui-font-clean)`;
                ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                ctx.fillText((name || '?').slice(0,1), 0, 0);
            }
            ctx.restore();
        }

        function drawSymbolSamuraiMask(ctx, s, accent) {
            ctx.save();
            // mask base
            ctx.fillStyle = drawMetal(ctx, -s*0.22, -s*0.22, s*0.22, s*0.22, 'rgba(60,60,70,0.95)', 'rgba(15,15,20,0.95)', 'rgba(0,0,0,0.95)');
            ctx.beginPath();
            ctx.moveTo(0, -s * 0.22);
            ctx.quadraticCurveTo(s * 0.20, -s * 0.12, s * 0.18, s * 0.06);
            ctx.quadraticCurveTo(s * 0.12, s * 0.22, 0, s * 0.26);
            ctx.quadraticCurveTo(-s * 0.12, s * 0.22, -s * 0.18, s * 0.06);
            ctx.quadraticCurveTo(-s * 0.20, -s * 0.12, 0, -s * 0.22);
            ctx.closePath();
            ctx.fill();

            // horns
            ctx.strokeStyle = accent;
            ctx.lineWidth = s * 0.022;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(-s * 0.10, -s * 0.18);
            ctx.quadraticCurveTo(-s * 0.22, -s * 0.26, -s * 0.18, -s * 0.08);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(s * 0.10, -s * 0.18);
            ctx.quadraticCurveTo(s * 0.22, -s * 0.26, s * 0.18, -s * 0.08);
            ctx.stroke();

            // eyes
            ctx.fillStyle = 'rgba(255,60,60,0.75)';
            ctx.beginPath();
            ctx.ellipse(-s * 0.08, -s * 0.03, s * 0.06, s * 0.035, 0.1, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(s * 0.08, -s * 0.03, s * 0.06, s * 0.035, -0.1, 0, Math.PI * 2);
            ctx.fill();

            // teeth grill
            ctx.strokeStyle = 'rgba(255,255,255,0.20)';
            ctx.lineWidth = s * 0.010;
            for (let i = -3; i <= 3; i++) {
                ctx.beginPath();
                ctx.moveTo(i * s * 0.035, s * 0.06);
                ctx.lineTo(i * s * 0.030, s * 0.18);
                ctx.stroke();
            }

            ctx.restore();
        }

        function drawSymbolInfectedOrb(ctx, s, accent) {
            ctx.save();
            const r = s * 0.23;

            const g = ctx.createRadialGradient(-r * 0.25, -r * 0.25, r * 0.03, 0, 0, r);
            g.addColorStop(0, 'rgba(255,255,255,0.70)');
            g.addColorStop(0.45, 'rgba(120,255,160,0.18)');
            g.addColorStop(1, 'rgba(10,20,15,0.85)');
            ctx.fillStyle = g;
            ctx.beginPath();
            ctx.arc(0, 0, r, 0, Math.PI * 2);
            ctx.fill();

            // veins
            ctx.strokeStyle = 'rgba(120,255,160,0.55)';
            ctx.lineWidth = s * 0.010;
            for (let i = 0; i < 5; i++) {
                const a = -1.6 + i * 0.75;
                ctx.beginPath();
                ctx.moveTo(Math.cos(a) * r * 0.2, Math.sin(a) * r * 0.2);
                ctx.quadraticCurveTo(Math.cos(a) * r * 0.8, Math.sin(a) * r * 0.35, Math.cos(a + 0.4) * r * 0.9, Math.sin(a + 0.4) * r * 0.85);
                ctx.stroke();
            }

            // highlight
            ctx.globalAlpha = 0.25;
            ctx.fillStyle = accent;
            ctx.beginPath();
            ctx.arc(-r * 0.25, -r * 0.25, r * 0.35, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();
        }

        function drawSymbolGasBottle(ctx, s, accent) {
            ctx.save();
            // bottle
            ctx.fillStyle = drawMetal(ctx, -s*0.16, -s*0.22, s*0.16, s*0.22, 'rgba(220,220,230,0.22)', 'rgba(0,0,0,0.55)', 'rgba(0,0,0,0.75)');
            pathRoundRect(ctx, -s * 0.16, -s * 0.18, s * 0.32, s * 0.46, s * 0.10);
            ctx.fill();

            // neck
            ctx.fillStyle = 'rgba(255,255,255,0.10)';
            pathRoundRect(ctx, -s * 0.08, -s * 0.26, s * 0.16, s * 0.10, s * 0.05);
            ctx.fill();

            // condensed gas swirl
            ctx.globalAlpha = 0.85;
            const g = ctx.createRadialGradient(0, s * 0.05, s * 0.02, 0, s * 0.12, s * 0.22);
            g.addColorStop(0, 'rgba(120,255,120,0.55)');
            g.addColorStop(1, 'rgba(0,80,0,0.05)');
            ctx.fillStyle = g;
            ctx.beginPath();
            ctx.arc(0, s * 0.10, s * 0.16, 0, Math.PI * 2);
            ctx.fill();

            // hazard mark
            ctx.globalAlpha = 0.95;
            ctx.strokeStyle = accent;
            ctx.lineWidth = s * 0.016;
            ctx.beginPath();
            ctx.moveTo(0, -s * 0.02);
            ctx.lineTo(s * 0.07, s * 0.11);
            ctx.lineTo(-s * 0.07, s * 0.11);
            ctx.closePath();
            ctx.stroke();

            ctx.restore();
        }

        function drawSymbolVirus(ctx, s, accent) {
            ctx.save();
            const r = s * 0.18;

            // core
            const g = ctx.createRadialGradient(-r*0.3, -r*0.3, r*0.1, 0, 0, r);
            g.addColorStop(0, 'rgba(255,255,255,0.8)');
            g.addColorStop(0.45, 'rgba(160,0,200,0.35)');
            g.addColorStop(1, 'rgba(0,0,0,0.75)');
            ctx.fillStyle = g;
            ctx.beginPath();
            ctx.arc(0, 0, r, 0, Math.PI * 2);
            ctx.fill();

            // spikes
            ctx.strokeStyle = accent;
            ctx.lineWidth = s * 0.012;
            for (let i = 0; i < 12; i++) {
                const a = (Math.PI * 2 / 12) * i;
                const x1 = Math.cos(a) * r * 0.9;
                const y1 = Math.sin(a) * r * 0.9;
                const x2 = Math.cos(a) * r * 1.55;
                const y2 = Math.sin(a) * r * 1.55;
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();

                ctx.fillStyle = 'rgba(255,255,255,0.35)';
                ctx.beginPath();
                ctx.arc(x2, y2, s * 0.020, 0, Math.PI * 2);
                ctx.fill();
            }

            // toxic glow
            ctx.globalAlpha = 0.18;
            ctx.fillStyle = 'rgba(120,255,160,1)';
            ctx.beginPath();
            ctx.arc(0, 0, r * 1.55, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();
        }

        function drawSymbolHilt(ctx, s, accent) {
            ctx.save();
            ctx.rotate(-0.35);

            // handle
            ctx.fillStyle = drawMetal(ctx, -s*0.08, -s*0.20, s*0.08, s*0.20, 'rgba(160,120,60,0.9)', 'rgba(90,60,30,0.9)', 'rgba(0,0,0,0.8)');
            pathRoundRect(ctx, -s*0.06, -s*0.02, s*0.12, s*0.28, s*0.06);
            ctx.fill();

            // guard
            ctx.strokeStyle = accent;
            ctx.lineWidth = s * 0.028;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(-s*0.14, -s*0.02);
            ctx.lineTo(s*0.14, -s*0.02);
            ctx.stroke();

            // pommel
            ctx.fillStyle = drawMetal(ctx, -s*0.05, s*0.25, s*0.05, s*0.35, 'rgba(255,255,255,0.55)', accent, 'rgba(0,0,0,0.65)');
            ctx.beginPath();
            ctx.arc(0, s*0.29, s*0.045, 0, Math.PI * 2);
            ctx.fill();

            // blood smear
            ctx.globalAlpha = 0.85;
            ctx.fillStyle = 'rgba(180,0,0,0.60)';
            ctx.beginPath();
            ctx.ellipse(s*0.03, s*0.07, s*0.05, s*0.14, 0.5, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(-s*0.02, s*0.13, s*0.04, s*0.10, -0.4, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();
        }


        // ----- Extra loot symbols (추가 전리품 아이콘) -----
        //  - 기존 배지 기본 아이콘에서 벗어나, 아이템별로 한눈에 구분되는 RPG풍 캔버스 아트로 추가
        function drawSymbolCurseVial(ctx, s, accent) {
            ctx.save();
            ctx.rotate(-0.18);

            const bw = s * 0.28, bh = s * 0.46;
            const bx = -bw / 2, by = -bh / 2 + s * 0.04;

            // glass body
            ctx.fillStyle = drawMetal(ctx, bx, by, bx + bw, by + bh,
                'rgba(220,240,255,0.22)', 'rgba(0,0,0,0.58)', 'rgba(0,0,0,0.78)');
            ctx.strokeStyle = 'rgba(255,255,255,0.18)';
            ctx.lineWidth = s * 0.012;
            pathRoundRect(ctx, bx, by, bw, bh, s * 0.12);
            ctx.fill();
            ctx.stroke();

            // neck
            const nw = s * 0.16, nh = s * 0.14;
            const nx = -nw / 2, ny = by - nh * 0.55;
            ctx.fillStyle = 'rgba(255,255,255,0.10)';
            ctx.lineWidth = s * 0.010;
            pathRoundRect(ctx, nx, ny, nw, nh, s * 0.06);
            ctx.fill();
            ctx.stroke();

            // cork
            ctx.fillStyle = drawMetal(ctx, nx, ny - nh * 0.45, nx + nw, ny,
                'rgba(170,120,60,0.95)', 'rgba(100,60,30,0.95)', 'rgba(0,0,0,0.82)');
            pathRoundRect(ctx, -nw * 0.35, ny - nh * 0.45, nw * 0.70, nh * 0.45, s * 0.05);
            ctx.fill();

            // liquid (purple curse)
            ctx.save();
            pathRoundRect(ctx, bx, by, bw, bh, s * 0.12);
            ctx.clip();
            const lg = ctx.createLinearGradient(0, by, 0, by + bh);
            lg.addColorStop(0, 'rgba(170,60,220,0.00)');
            lg.addColorStop(0.45, 'rgba(170,60,220,0.28)');
            lg.addColorStop(1, 'rgba(30,0,50,0.86)');
            ctx.fillStyle = lg;
            ctx.fillRect(bx, by + bh * 0.18, bw, bh);

            // swirl
            ctx.globalAlpha = 0.70;
            ctx.strokeStyle = 'rgba(220,200,255,0.25)';
            ctx.lineWidth = s * 0.010;
            ctx.beginPath();
            ctx.moveTo(-bw * 0.35, by + bh * 0.35);
            ctx.bezierCurveTo(-bw * 0.05, by + bh * 0.22, bw * 0.05, by + bh * 0.55, bw * 0.35, by + bh * 0.40);
            ctx.stroke();

            // bubbles
            ctx.globalAlpha = 0.55;
            ctx.fillStyle = 'rgba(255,255,255,0.20)';
            for (let i = 0; i < 10; i++) {
                const x = bx + bw * (0.18 + (i % 5) * 0.16) + ((i % 2) ? s * 0.006 : 0);
                const y = by + bh * (0.35 + Math.floor(i / 5) * 0.18) + ((i % 3) ? s * 0.008 : 0);
                ctx.beginPath();
                ctx.arc(x, y, s * (0.006 + (i % 3) * 0.003), 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.restore();

            // label
            ctx.fillStyle = 'rgba(0,0,0,0.35)';
            ctx.strokeStyle = accent;
            ctx.lineWidth = s * 0.010;
            pathRoundRect(ctx, -bw * 0.32, by + bh * 0.05, bw * 0.64, bh * 0.18, s * 0.05);
            ctx.fill();
            ctx.stroke();

            // rune
            ctx.strokeStyle = 'rgba(255,255,255,0.55)';
            ctx.lineWidth = s * 0.010;
            ctx.beginPath();
            ctx.arc(0, by + bh * 0.14, s * 0.055, 0, Math.PI * 2);
            ctx.stroke();
            ctx.strokeStyle = accent;
            ctx.lineWidth = s * 0.012;
            ctx.beginPath();
            ctx.moveTo(-s * 0.02, by + bh * 0.11);
            ctx.lineTo(s * 0.02, by + bh * 0.17);
            ctx.stroke();

            // curse glow
            ctx.globalAlpha = 0.18;
            ctx.fillStyle = 'rgba(170,60,220,1)';
            ctx.beginPath();
            ctx.arc(0, by + bh * 0.10, s * 0.34, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1;

            ctx.restore();
        }

        function drawSymbolCloakFragment(ctx, s, accent) {
            ctx.save();
            ctx.rotate(0.12);

            const g = ctx.createLinearGradient(-s * 0.25, -s * 0.25, s * 0.25, s * 0.25);
            g.addColorStop(0, 'rgba(60,70,120,0.85)');
            g.addColorStop(0.5, 'rgba(20,20,35,0.95)');
            g.addColorStop(1, 'rgba(0,0,0,0.95)');

            ctx.fillStyle = g;
            ctx.strokeStyle = 'rgba(0,0,0,0.70)';
            ctx.lineWidth = s * 0.012;

            // torn cloth silhouette
            ctx.beginPath();
            ctx.moveTo(-s * 0.22, -s * 0.18);
            ctx.lineTo(s * 0.20, -s * 0.20);
            ctx.quadraticCurveTo(s * 0.26, -s * 0.05, s * 0.18, s * 0.02);
            ctx.lineTo(s * 0.24, s * 0.20);
            ctx.lineTo(s * 0.10, s * 0.24);
            ctx.lineTo(s * 0.02, s * 0.18);
            ctx.lineTo(-s * 0.08, s * 0.26);
            ctx.lineTo(-s * 0.20, s * 0.14);
            ctx.quadraticCurveTo(-s * 0.28, -s * 0.02, -s * 0.22, -s * 0.18);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            // fold highlight
            ctx.globalAlpha = 0.35;
            const hg = ctx.createLinearGradient(-s * 0.10, -s * 0.12, s * 0.18, s * 0.18);
            hg.addColorStop(0, 'rgba(255,255,255,0.18)');
            hg.addColorStop(1, 'rgba(255,255,255,0.00)');
            ctx.fillStyle = hg;
            ctx.beginPath();
            ctx.moveTo(-s * 0.14, -s * 0.12);
            ctx.lineTo(s * 0.10, -s * 0.14);
            ctx.lineTo(s * 0.06, s * 0.10);
            ctx.lineTo(-s * 0.12, s * 0.12);
            ctx.closePath();
            ctx.fill();
            ctx.globalAlpha = 1;

            // stitch line
            ctx.strokeStyle = 'rgba(255,255,255,0.16)';
            ctx.lineWidth = s * 0.006;
            ctx.setLineDash([s * 0.012, s * 0.014]);
            ctx.beginPath();
            ctx.moveTo(-s * 0.18, -s * 0.12);
            ctx.lineTo(s * 0.18, -s * 0.14);
            ctx.stroke();
            ctx.setLineDash([]);

            // faint accent thread
            ctx.strokeStyle = accent;
            ctx.globalAlpha = 0.55;
            ctx.lineWidth = s * 0.010;
            ctx.beginPath();
            ctx.moveTo(-s * 0.16, s * 0.02);
            ctx.quadraticCurveTo(0, s * 0.10, s * 0.16, s * 0.02);
            ctx.stroke();
            ctx.globalAlpha = 1;

            // shadow aura
            ctx.globalAlpha = 0.12;
            ctx.fillStyle = accent;
            ctx.beginPath();
            ctx.arc(0, 0, s * 0.34, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1;

            ctx.restore();
        }

        function drawSymbolEvidenceBag(ctx, s, accent) {
            ctx.save();
            ctx.rotate(-0.14);

            const w = s * 0.26, h = s * 0.50;
            const tipY = -h * 0.50;
            const baseY = h * 0.42;

            // pink condom silhouette
            ctx.beginPath();
            ctx.moveTo(0, tipY);
            ctx.bezierCurveTo(w * 0.82, tipY + h * 0.06, w * 0.92, h * 0.08, w * 0.78, h * 0.20);
            ctx.bezierCurveTo(w * 0.72, h * 0.26, w * 0.70, h * 0.34, w * 0.66, baseY);
            ctx.lineTo(-w * 0.66, baseY);
            ctx.bezierCurveTo(-w * 0.70, h * 0.34, -w * 0.72, h * 0.26, -w * 0.78, h * 0.20);
            ctx.bezierCurveTo(-w * 0.92, h * 0.08, -w * 0.82, tipY + h * 0.06, 0, tipY);
            ctx.closePath();

            const shell = ctx.createLinearGradient(-w, tipY, w, baseY);
            shell.addColorStop(0, 'rgba(255,180,220,0.78)');
            shell.addColorStop(0.52, 'rgba(255,85,170,0.62)');
            shell.addColorStop(1, 'rgba(120,10,70,0.88)');
            ctx.fillStyle = shell;
            ctx.strokeStyle = 'rgba(255,210,235,0.68)';
            ctx.lineWidth = s * 0.010;
            ctx.fill();
            ctx.stroke();

            // creamy fill inside condom
            ctx.save();
            ctx.clip();
            const cream = ctx.createLinearGradient(0, tipY + h * 0.04, 0, baseY);
            cream.addColorStop(0, 'rgba(255,255,255,0.92)');
            cream.addColorStop(0.45, 'rgba(255,250,240,0.94)');
            cream.addColorStop(1, 'rgba(240,230,210,0.96)');
            ctx.fillStyle = cream;
            ctx.fillRect(-w * 0.62, tipY + h * 0.05, w * 1.24, h * 0.86);

            // soft creamy blobs
            ctx.globalAlpha = 0.72;
            ctx.fillStyle = 'rgba(255,255,255,0.92)';
            for (let i = 0; i < 6; i++) {
                const xx = (-w * 0.40) + i * (w * 0.16);
                const yy = tipY + h * (0.24 + (i % 3) * 0.11);
                ctx.beginPath();
                ctx.ellipse(xx, yy, w * 0.13, h * 0.06, (i % 2 ? 0.2 : -0.15), 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.restore();

            // rolled rim
            ctx.fillStyle = 'rgba(255,95,185,0.95)';
            ctx.strokeStyle = 'rgba(255,220,240,0.55)';
            ctx.lineWidth = s * 0.010;
            pathRoundRect(ctx, -w * 0.74, baseY - h * 0.02, w * 1.48, h * 0.14, s * 0.08);
            ctx.fill();
            ctx.stroke();

            // aura
            ctx.globalAlpha = 0.12;
            ctx.fillStyle = accent;
            ctx.beginPath();
            ctx.arc(0, 0, s * 0.34, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1;

            ctx.restore();
        }

        function drawSymbolPoisonedHilt(ctx, s, accent) {
            ctx.save();
            ctx.rotate(-0.35);

            // blade stub
            const bladeGrad = ctx.createLinearGradient(0, -s * 0.34, 0, -s * 0.06);
            bladeGrad.addColorStop(0, 'rgba(255,255,255,0.85)');
            bladeGrad.addColorStop(1, 'rgba(120,150,190,0.45)');
            ctx.fillStyle = bladeGrad;
            ctx.strokeStyle = 'rgba(0,0,0,0.55)';
            ctx.lineWidth = s * 0.010;
            ctx.beginPath();
            ctx.moveTo(0, -s * 0.30);
            ctx.lineTo(s * 0.045, -s * 0.18);
            ctx.lineTo(s * 0.018, -s * 0.02);
            ctx.lineTo(-s * 0.018, -s * 0.02);
            ctx.lineTo(-s * 0.045, -s * 0.18);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            // handle
            ctx.fillStyle = drawMetal(ctx, -s * 0.08, -s * 0.20, s * 0.08, s * 0.20,
                'rgba(160,120,60,0.92)', 'rgba(90,60,30,0.92)', 'rgba(0,0,0,0.82)');
            pathRoundRect(ctx, -s * 0.06, -s * 0.02, s * 0.12, s * 0.28, s * 0.06);
            ctx.fill();

            // guard
            ctx.strokeStyle = accent;
            ctx.lineWidth = s * 0.030;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(-s * 0.14, -s * 0.02);
            ctx.lineTo(s * 0.14, -s * 0.02);
            ctx.stroke();

            // poison smear
            ctx.globalAlpha = 0.90;
            const pg = ctx.createRadialGradient(s * 0.04, s * 0.06, s * 0.02, s * 0.02, s * 0.08, s * 0.20);
            pg.addColorStop(0, 'rgba(170,255,170,0.75)');
            pg.addColorStop(1, 'rgba(0,120,0,0.00)');
            ctx.fillStyle = pg;
            ctx.beginPath();
            ctx.ellipse(s * 0.04, s * 0.08, s * 0.10, s * 0.18, 0.6, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1;

            // drip
            ctx.fillStyle = 'rgba(120,255,160,0.55)';
            ctx.beginPath();
            ctx.moveTo(-s * 0.02, s * 0.14);
            ctx.quadraticCurveTo(-s * 0.05, s * 0.22, -s * 0.01, s * 0.24);
            ctx.quadraticCurveTo(s * 0.03, s * 0.22, 0, s * 0.14);
            ctx.closePath();
            ctx.fill();

            // glow
            ctx.globalAlpha = 0.12;
            ctx.fillStyle = 'rgba(120,255,160,1)';
            ctx.beginPath();
            ctx.arc(0, s * 0.08, s * 0.36, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1;

            ctx.restore();
        }

        function drawSymbolEbonyPowder(ctx, s, accent) {
            ctx.save();
            ctx.rotate(0.16);

            // pouch base
            const g = ctx.createLinearGradient(-s * 0.20, -s * 0.10, s * 0.20, s * 0.22);
            g.addColorStop(0, 'rgba(255,255,255,0.18)');
            g.addColorStop(0.35, 'rgba(40,40,50,0.85)');
            g.addColorStop(1, 'rgba(0,0,0,0.92)');
            ctx.fillStyle = g;
            ctx.strokeStyle = 'rgba(0,0,0,0.70)';
            ctx.lineWidth = s * 0.012;

            ctx.beginPath();
            ctx.moveTo(-s * 0.18, -s * 0.12);
            ctx.quadraticCurveTo(0, -s * 0.22, s * 0.18, -s * 0.12);
            ctx.quadraticCurveTo(s * 0.24, s * 0.10, 0, s * 0.22);
            ctx.quadraticCurveTo(-s * 0.24, s * 0.10, -s * 0.18, -s * 0.12);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            // tie
            ctx.strokeStyle = accent;
            ctx.lineWidth = s * 0.018;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(-s * 0.12, -s * 0.10);
            ctx.lineTo(s * 0.12, -s * 0.10);
            ctx.stroke();

            // powder spill
            ctx.save();
            ctx.globalAlpha = 0.90;
            const spill = ctx.createRadialGradient(0, s * 0.10, s * 0.02, 0, s * 0.12, s * 0.24);
            spill.addColorStop(0, 'rgba(30,30,40,0.75)');
            spill.addColorStop(1, 'rgba(0,0,0,0.00)');
            ctx.fillStyle = spill;
            ctx.beginPath();
            ctx.ellipse(0, s * 0.12, s * 0.26, s * 0.18, 0, 0, Math.PI * 2);
            ctx.fill();

            // spark dust specks
            ctx.globalAlpha = 0.65;
            ctx.fillStyle = 'rgba(255,255,255,0.25)';
            for (let i = 0; i < 14; i++) {
                const x = (-s * 0.14) + (i % 7) * (s * 0.05) + (i % 2 ? s * 0.012 : 0);
                const y = (s * 0.02) + Math.floor(i / 7) * (s * 0.06);
                ctx.beginPath();
                ctx.arc(x, y, s * (0.007 + (i % 3) * 0.003), 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.restore();

            // subtle swirl
            ctx.globalAlpha = 0.55;
            ctx.strokeStyle = 'rgba(120,120,150,0.28)';
            ctx.lineWidth = s * 0.010;
            ctx.beginPath();
            ctx.moveTo(-s * 0.16, s * 0.02);
            ctx.bezierCurveTo(-s * 0.06, s * 0.12, s * 0.06, s * 0.02, s * 0.16, s * 0.12);
            ctx.stroke();
            ctx.globalAlpha = 1;

            ctx.restore();
        }

        function drawSymbolPerfume(ctx, s, accent) {
            ctx.save();
            ctx.rotate(-0.10);

            const bw = s * 0.30, bh = s * 0.40;
            const bx = -bw / 2, by = -bh / 2 + s * 0.06;

            // bottle body
            const bg = ctx.createLinearGradient(bx, by, bx + bw, by + bh);
            bg.addColorStop(0, 'rgba(255,255,255,0.35)');
            bg.addColorStop(0.25, 'rgba(220,120,200,0.22)');
            bg.addColorStop(1, 'rgba(0,0,0,0.78)');
            ctx.fillStyle = bg;
            ctx.strokeStyle = 'rgba(255,255,255,0.18)';
            ctx.lineWidth = s * 0.012;
            pathRoundRect(ctx, bx, by, bw, bh, s * 0.12);
            ctx.fill();
            ctx.stroke();

            // pink gas cloud inside bottle
            ctx.save();
            pathRoundRect(ctx, bx, by, bw, bh, s * 0.12);
            ctx.clip();
            const cloud = ctx.createRadialGradient(0, by + bh * 0.52, s * 0.03, 0, by + bh * 0.58, s * 0.34);
            cloud.addColorStop(0, 'rgba(255,205,240,0.92)');
            cloud.addColorStop(0.42, 'rgba(255,120,210,0.78)');
            cloud.addColorStop(1, 'rgba(155,20,120,0.26)');
            ctx.fillStyle = cloud;
            ctx.fillRect(bx - s * 0.02, by + bh * 0.08, bw + s * 0.04, bh * 0.96);

            ctx.globalAlpha = 0.85;
            ctx.fillStyle = 'rgba(255,160,225,0.82)';
            const puffs = [
                [-0.08, 0.58, 0.14, 0.11],
                [ 0.03, 0.56, 0.16, 0.12],
                [ 0.11, 0.64, 0.12, 0.10],
                [-0.10, 0.68, 0.13, 0.10],
                [ 0.00, 0.71, 0.17, 0.12],
            ];
            puffs.forEach(([ox, oy, rx, ry], idx) => {
                ctx.beginPath();
                ctx.ellipse(ox * s, by + bh * oy, rx * s, ry * s, idx % 2 ? 0.35 : -0.25, 0, Math.PI * 2);
                ctx.fill();
            });

            // shimmer highlight
            ctx.globalAlpha = 0.35;
            ctx.fillStyle = 'rgba(255,255,255,0.35)';
            ctx.beginPath();
            ctx.ellipse(-bw * 0.15, by + bh * 0.05, s * 0.06, s * 0.18, 0.2, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();

            // neck
            ctx.fillStyle = 'rgba(255,255,255,0.10)';
            pathRoundRect(ctx, -s * 0.07, by - s * 0.12, s * 0.14, s * 0.12, s * 0.05);
            ctx.fill();

            // cap
            ctx.fillStyle = drawMetal(ctx, -s * 0.08, by - s * 0.20, s * 0.08, by - s * 0.08,
                'rgba(255,255,255,0.55)', accent, 'rgba(0,0,0,0.65)');
            pathRoundRect(ctx, -s * 0.07, by - s * 0.22, s * 0.14, s * 0.10, s * 0.05);
            ctx.fill();

            // mist swirl
            ctx.globalAlpha = 0.70;
            ctx.strokeStyle = 'rgba(255,255,255,0.22)';
            ctx.lineWidth = s * 0.010;
            ctx.beginPath();
            ctx.moveTo(-s * 0.18, by - s * 0.14);
            ctx.bezierCurveTo(-s * 0.10, by - s * 0.22, s * 0.10, by - s * 0.12, s * 0.18, by - s * 0.24);
            ctx.stroke();
            ctx.globalAlpha = 1;

            // glow aura
            ctx.globalAlpha = 0.14;
            ctx.fillStyle = 'rgba(255,120,200,1)';
            ctx.beginPath();
            ctx.arc(0, by + bh * 0.08, s * 0.36, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1;

            ctx.restore();
        }

        function drawSymbolOathBlooddrop(ctx, s, accent) {
            ctx.save();
            const r = s * 0.23;

            // droplet shape
            ctx.beginPath();
            ctx.moveTo(0, -r * 1.15);
            ctx.bezierCurveTo(r * 0.55, -r * 0.55, r * 0.75, -r * 0.05, 0, r * 1.15);
            ctx.bezierCurveTo(-r * 0.75, -r * 0.05, -r * 0.55, -r * 0.55, 0, -r * 1.15);
            ctx.closePath();

            const dg = ctx.createRadialGradient(-r * 0.25, -r * 0.55, r * 0.05, 0, 0, r * 1.25);
            dg.addColorStop(0, 'rgba(255,255,255,0.75)');
            dg.addColorStop(0.25, 'rgba(220,30,30,0.70)');
            dg.addColorStop(1, 'rgba(0,0,0,0.85)');
            ctx.fillStyle = dg;
            ctx.fill();
            ctx.strokeStyle = 'rgba(0,0,0,0.65)';
            ctx.lineWidth = s * 0.012;
            ctx.stroke();

            // oath ring
            ctx.strokeStyle = accent;
            ctx.lineWidth = s * 0.020;
            ctx.globalAlpha = 0.85;
            ctx.beginPath();
            ctx.arc(0, r * 0.55, r * 0.60, -0.25, Math.PI + 0.25);
            ctx.stroke();
            ctx.globalAlpha = 1;

            // glint
            ctx.strokeStyle = 'rgba(255,255,255,0.35)';
            ctx.lineWidth = s * 0.010;
            ctx.beginPath();
            ctx.moveTo(-r * 0.20, -r * 0.35);
            ctx.lineTo(r * 0.05, -r * 0.60);
            ctx.stroke();

            // aura
            ctx.globalAlpha = 0.12;
            ctx.fillStyle = accent;
            ctx.beginPath();
            ctx.arc(0, 0, s * 0.34, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1;

            ctx.restore();
        }

        function drawSymbolBrokenLens(ctx, s, accent) {
            ctx.save();
            const r = s * 0.24;

            // outer ring
            ctx.strokeStyle = drawMetal(ctx, -r, -r, r, r,
                'rgba(255,255,255,0.60)', accent, 'rgba(0,0,0,0.70)');
            ctx.lineWidth = s * 0.045;
            ctx.beginPath();
            ctx.arc(0, 0, r, 0, Math.PI * 2);
            ctx.stroke();

            // lens
            const lg = ctx.createRadialGradient(-r * 0.25, -r * 0.25, r * 0.05, 0, 0, r * 0.95);
            lg.addColorStop(0, 'rgba(255,255,255,0.60)');
            lg.addColorStop(0.35, 'rgba(80,180,255,0.18)');
            lg.addColorStop(1, 'rgba(0,0,0,0.80)');
            ctx.fillStyle = lg;
            ctx.beginPath();
            ctx.arc(0, 0, r * 0.86, 0, Math.PI * 2);
            ctx.fill();

            // crosshair
            ctx.globalAlpha = 0.55;
            ctx.strokeStyle = accent;
            ctx.lineWidth = s * 0.010;
            ctx.beginPath();
            ctx.moveTo(-r * 0.82, 0);
            ctx.lineTo(r * 0.82, 0);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(0, -r * 0.82);
            ctx.lineTo(0, r * 0.82);
            ctx.stroke();
            ctx.globalAlpha = 1;

            // cracks
            ctx.strokeStyle = 'rgba(255,255,255,0.25)';
            ctx.lineWidth = s * 0.010;
            ctx.beginPath();
            ctx.moveTo(-r * 0.60, -r * 0.10);
            ctx.lineTo(-r * 0.15, -r * 0.25);
            ctx.lineTo(r * 0.20, -r * 0.55);
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(-r * 0.10, r * 0.10);
            ctx.lineTo(r * 0.20, r * 0.05);
            ctx.lineTo(r * 0.55, r * 0.35);
            ctx.stroke();

            // missing shard
            ctx.fillStyle = 'rgba(0,0,0,0.55)';
            ctx.beginPath();
            ctx.moveTo(r * 0.70, -r * 0.10);
            ctx.lineTo(r * 1.05, -r * 0.22);
            ctx.lineTo(r * 0.98, r * 0.08);
            ctx.closePath();
            ctx.fill();

            // glint
            ctx.globalAlpha = 0.22;
            ctx.fillStyle = 'rgba(255,255,255,0.65)';
            ctx.beginPath();
            ctx.arc(-r * 0.25, -r * 0.25, r * 0.35, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1;

            ctx.restore();
        }

        function drawSymbolArcaneEchoDust(ctx, s, accent) {
            ctx.save();

            // base mound
            const base = ctx.createRadialGradient(-s * 0.10, s * 0.10, s * 0.05, 0, s * 0.12, s * 0.28);
            base.addColorStop(0, 'rgba(255,255,255,0.35)');
            base.addColorStop(0.35, 'rgba(120,190,255,0.18)');
            base.addColorStop(1, 'rgba(0,0,0,0.78)');
            ctx.fillStyle = base;
            ctx.beginPath();
            ctx.ellipse(0, s * 0.10, s * 0.24, s * 0.16, 0, 0, Math.PI * 2);
            ctx.fill();

            // crystals
            ctx.strokeStyle = 'rgba(255,255,255,0.20)';
            ctx.lineWidth = s * 0.008;
            const shards = [
                [-0.14, 0.02, 0.06, 0.18],
                [-0.02, -0.10, 0.05, 0.22],
                [0.12, -0.04, 0.06, 0.16],
                [0.02, 0.00, 0.04, 0.14],
            ];
            for (let i = 0; i < shards.length; i++) {
                const [xx, yy, ww, hh] = shards[i];
                const x = xx * s, y = yy * s, w = ww * s, h = hh * s;
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(-0.4 + i * 0.25);

                const cg = ctx.createLinearGradient(0, -h, 0, h);
                cg.addColorStop(0, 'rgba(255,255,255,0.60)');
                cg.addColorStop(0.4, 'rgba(140,220,255,0.18)');
                cg.addColorStop(1, 'rgba(0,0,0,0.65)');
                ctx.fillStyle = cg;

                ctx.beginPath();
                ctx.moveTo(0, -h * 0.65);
                ctx.lineTo(w * 0.55, 0);
                ctx.lineTo(0, h * 0.65);
                ctx.lineTo(-w * 0.55, 0);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                ctx.restore();
            }

            // echo wave
            ctx.globalAlpha = 0.55;
            ctx.strokeStyle = accent;
            ctx.lineWidth = s * 0.010;
            for (let i = 0; i < 3; i++) {
                ctx.beginPath();
                ctx.arc(0, s * 0.04, s * (0.12 + i * 0.07), Math.PI * 1.05, Math.PI * 1.95);
                ctx.stroke();
            }
            ctx.globalAlpha = 1;

            // sparkle dots
            ctx.globalAlpha = 0.65;
            ctx.fillStyle = 'rgba(255,255,255,0.35)';
            for (let i = 0; i < 10; i++) {
                const x = (-0.18 + (i % 5) * 0.09) * s;
                const y = (-0.18 + Math.floor(i / 5) * 0.10) * s;
                ctx.beginPath();
                ctx.arc(x, y, s * (0.006 + (i % 3) * 0.003), 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1;

            ctx.restore();
        }

        function drawSymbolTornLetter(ctx, s, accent) {
            ctx.save();
            ctx.rotate(0.12);

            const w = s * 0.46, h = s * 0.34;
            const x = -w / 2, y = -h / 2;

            const pg = ctx.createLinearGradient(x, y, x + w, y + h);
            pg.addColorStop(0, 'rgba(255,245,220,0.90)');
            pg.addColorStop(0.55, 'rgba(210,180,130,0.85)');
            pg.addColorStop(1, 'rgba(90,60,30,0.75)');

            // paper
            ctx.fillStyle = pg;
            ctx.strokeStyle = 'rgba(0,0,0,0.65)';
            ctx.lineWidth = s * 0.012;

            ctx.beginPath();
            ctx.moveTo(x + s * 0.04, y);
            ctx.lineTo(x + w - s * 0.06, y + s * 0.02);
            ctx.lineTo(x + w, y + h * 0.55);
            ctx.lineTo(x + w - s * 0.06, y + h - s * 0.02);
            ctx.lineTo(x + w * 0.35, y + h);
            // torn edge
            ctx.lineTo(x + w * 0.28, y + h - s * 0.03);
            ctx.lineTo(x + w * 0.22, y + h + s * 0.01);
            ctx.lineTo(x + w * 0.16, y + h - s * 0.02);
            ctx.lineTo(x + w * 0.10, y + h + s * 0.02);
            ctx.lineTo(x + s * 0.02, y + h * 0.70);
            ctx.lineTo(x, y + h * 0.25);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            // fold highlight
            ctx.globalAlpha = 0.25;
            ctx.fillStyle = 'rgba(255,255,255,0.55)';
            ctx.beginPath();
            ctx.moveTo(x + w * 0.25, y + h * 0.05);
            ctx.lineTo(x + w * 0.48, y + h * 0.08);
            ctx.lineTo(x + w * 0.40, y + h * 0.50);
            ctx.lineTo(x + w * 0.22, y + h * 0.44);
            ctx.closePath();
            ctx.fill();
            ctx.globalAlpha = 1;

            // text lines
            ctx.strokeStyle = 'rgba(0,0,0,0.25)';
            ctx.lineWidth = s * 0.008;
            for (let i = 0; i < 5; i++) {
                const yy = y + h * 0.18 + i * h * 0.12;
                ctx.beginPath();
                ctx.moveTo(x + w * 0.12, yy);
                ctx.lineTo(x + w * 0.82, yy);
                ctx.stroke();
            }

            // wax seal
            const wx = x + w * 0.68;
            const wy = y + h * 0.70;
            const wr = s * 0.08;
            const wg = ctx.createRadialGradient(wx - wr * 0.3, wy - wr * 0.3, wr * 0.2, wx, wy, wr);
            wg.addColorStop(0, 'rgba(255,255,255,0.55)');
            wg.addColorStop(0.35, 'rgba(180,0,0,0.75)');
            wg.addColorStop(1, 'rgba(0,0,0,0.85)');
            ctx.fillStyle = wg;
            ctx.beginPath();
            ctx.arc(wx, wy, wr, 0, Math.PI * 2);
            ctx.fill();

            ctx.strokeStyle = accent;
            ctx.globalAlpha = 0.65;
            ctx.lineWidth = s * 0.010;
            ctx.beginPath();
            ctx.arc(wx, wy, wr * 0.72, 0, Math.PI * 2);
            ctx.stroke();
            ctx.globalAlpha = 1;

            // imprint
            ctx.strokeStyle = 'rgba(255,255,255,0.25)';
            ctx.lineWidth = s * 0.012;
            ctx.beginPath();
            ctx.moveTo(wx - wr * 0.25, wy);
            ctx.lineTo(wx + wr * 0.25, wy);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(wx, wy - wr * 0.25);
            ctx.lineTo(wx, wy + wr * 0.25);
            ctx.stroke();

            ctx.restore();
        }

        function drawSymbolOathWindShard(ctx, s, accent) {
            ctx.save();
            ctx.rotate(-0.10);

            // wind swirl
            ctx.globalAlpha = 0.85;
            ctx.strokeStyle = 'rgba(255,255,255,0.20)';
            ctx.lineWidth = s * 0.020;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(-s * 0.26, s * 0.06);
            ctx.bezierCurveTo(-s * 0.10, -s * 0.20, s * 0.18, -s * 0.12, s * 0.18, s * 0.02);
            ctx.bezierCurveTo(s * 0.18, s * 0.16, -s * 0.08, s * 0.18, -s * 0.22, s * 0.28);
            ctx.stroke();

            ctx.strokeStyle = accent;
            ctx.globalAlpha = 0.55;
            ctx.lineWidth = s * 0.012;
            ctx.beginPath();
            ctx.moveTo(-s * 0.24, s * 0.02);
            ctx.bezierCurveTo(-s * 0.06, -s * 0.26, s * 0.26, -s * 0.16, s * 0.24, s * 0.06);
            ctx.stroke();

            // shard pieces
            ctx.globalAlpha = 0.85;
            for (let i = 0; i < 3; i++) {
                ctx.save();
                ctx.rotate(-0.8 + i * 0.55);

                const h = s * (0.18 + i * 0.03);
                const w = s * (0.07 + i * 0.01);

                const cg = ctx.createLinearGradient(0, -h, 0, h);
                cg.addColorStop(0, 'rgba(255,255,255,0.55)');
                cg.addColorStop(0.5, 'rgba(180,230,255,0.15)');
                cg.addColorStop(1, 'rgba(0,0,0,0.65)');
                ctx.fillStyle = cg;

                ctx.strokeStyle = 'rgba(255,255,255,0.12)';
                ctx.lineWidth = s * 0.008;

                ctx.beginPath();
                ctx.moveTo(0, -h * 0.65);
                ctx.lineTo(w * 0.55, 0);
                ctx.lineTo(0, h * 0.65);
                ctx.lineTo(-w * 0.55, 0);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();

                ctx.restore();
            }
            ctx.globalAlpha = 1;

            // aura
            ctx.globalAlpha = 0.10;
            ctx.fillStyle = accent;
            ctx.beginPath();
            ctx.arc(0, 0, s * 0.34, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1;

            ctx.restore();
        }

        function drawSymbolDarkSediment(ctx, s, accent) {
            ctx.save();
            ctx.rotate(0.14);

            const bw = s * 0.28, bh = s * 0.46;
            const bx = -bw / 2, by = -bh / 2 + s * 0.04;

            // glass
            ctx.fillStyle = drawMetal(ctx, bx, by, bx + bw, by + bh,
                'rgba(220,240,255,0.18)', 'rgba(0,0,0,0.60)', 'rgba(0,0,0,0.85)');
            ctx.strokeStyle = 'rgba(255,255,255,0.16)';
            ctx.lineWidth = s * 0.012;
            pathRoundRect(ctx, bx, by, bw, bh, s * 0.12);
            ctx.fill();
            ctx.stroke();

            // neck
            ctx.fillStyle = 'rgba(255,255,255,0.08)';
            pathRoundRect(ctx, -s * 0.07, by - s * 0.12, s * 0.14, s * 0.12, s * 0.05);
            ctx.fill();

            // stopper ring
            ctx.strokeStyle = accent;
            ctx.globalAlpha = 0.70;
            ctx.lineWidth = s * 0.018;
            ctx.beginPath();
            ctx.arc(0, by - s * 0.06, s * 0.08, 0, Math.PI * 2);
            ctx.stroke();
            ctx.globalAlpha = 1;

            // sediment
            ctx.save();
            pathRoundRect(ctx, bx, by, bw, bh, s * 0.12);
            ctx.clip();
            const sg = ctx.createLinearGradient(0, by + bh * 0.45, 0, by + bh);
            sg.addColorStop(0, 'rgba(0,0,0,0.00)');
            sg.addColorStop(0.25, 'rgba(0,0,0,0.35)');
            sg.addColorStop(1, 'rgba(0,0,0,0.90)');
            ctx.fillStyle = sg;
            ctx.fillRect(bx, by + bh * 0.45, bw, bh);

            // gritty particles
            ctx.globalAlpha = 0.75;
            ctx.fillStyle = 'rgba(255,255,255,0.10)';
            for (let i = 0; i < 10; i++) {
                const x = bx + bw * (0.10 + (i % 6) * 0.15);
                const y = by + bh * (0.55 + Math.floor(i / 6) * 0.13) + (i % 2 ? s * 0.008 : 0);
                ctx.beginPath();
                ctx.arc(x, y, s * (0.006 + (i % 3) * 0.003), 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.restore();

            // ominous swirl
            ctx.globalAlpha = 0.55;
            ctx.strokeStyle = 'rgba(120,120,140,0.25)';
            ctx.lineWidth = s * 0.010;
            ctx.beginPath();
            ctx.moveTo(-bw * 0.32, by + bh * 0.22);
            ctx.bezierCurveTo(-bw * 0.10, by + bh * 0.12, bw * 0.10, by + bh * 0.32, bw * 0.32, by + bh * 0.20);
            ctx.stroke();
            ctx.globalAlpha = 1;

            // aura
            ctx.globalAlpha = 0.10;
            ctx.fillStyle = accent;
            ctx.beginPath();
            ctx.arc(0, by + bh * 0.10, s * 0.34, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1;

            ctx.restore();
        }

        function drawSymbolCallSignNoise(ctx, s, accent) {
            ctx.save();
            ctx.rotate(-0.08);

            const w = s * 0.44, h = s * 0.26;

            // radio base
            ctx.fillStyle = drawMetal(ctx, -w / 2, -h / 2, w / 2, h / 2,
                'rgba(255,255,255,0.25)', 'rgba(30,30,40,0.85)', 'rgba(0,0,0,0.85)');
            ctx.strokeStyle = 'rgba(0,0,0,0.65)';
            ctx.lineWidth = s * 0.012;
            pathRoundRect(ctx, -w / 2, s * 0.06, w, h, s * 0.08);
            ctx.fill();
            ctx.stroke();

            // screen
            const sg = ctx.createLinearGradient(-w / 2, 0, w / 2, 0);
            sg.addColorStop(0, 'rgba(120,255,180,0.15)');
            sg.addColorStop(1, 'rgba(0,0,0,0.55)');
            ctx.fillStyle = sg;
            pathRoundRect(ctx, -w * 0.32, s * 0.10, w * 0.48, h * 0.56, s * 0.05);
            ctx.fill();

            // knobs
            ctx.fillStyle = accent;
            ctx.globalAlpha = 0.65;
            ctx.beginPath();
            ctx.arc(w * 0.18, s * 0.14, s * 0.028, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(w * 0.18, s * 0.22, s * 0.028, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1;

            // antenna
            ctx.strokeStyle = 'rgba(255,255,255,0.35)';
            ctx.lineWidth = s * 0.012;
            ctx.beginPath();
            ctx.moveTo(-w * 0.40, s * 0.08);
            ctx.lineTo(-w * 0.26, -s * 0.22);
            ctx.stroke();
            ctx.fillStyle = 'rgba(255,255,255,0.35)';
            ctx.beginPath();
            ctx.arc(-w * 0.26, -s * 0.22, s * 0.018, 0, Math.PI * 2);
            ctx.fill();

            // waves
            ctx.strokeStyle = accent;
            ctx.globalAlpha = 0.65;
            ctx.lineWidth = s * 0.010;
            for (let i = 0; i < 3; i++) {
                const rr = s * (0.10 + i * 0.06);
                ctx.beginPath();
                ctx.arc(-w * 0.26, -s * 0.22, rr, -0.15, Math.PI * 0.65);
                ctx.stroke();
            }
            ctx.globalAlpha = 1;

            // static dots
            ctx.globalAlpha = 0.35;
            ctx.fillStyle = 'rgba(255,255,255,0.55)';
            for (let i = 0; i < 10; i++) {
                const x = (-w * 0.30 + (i % 6) * w * 0.10) + (i % 2 ? s * 0.010 : 0);
                const y = (s * 0.12 + Math.floor(i / 6) * h * 0.18);
                ctx.beginPath();
                ctx.arc(x, y, s * (0.004 + (i % 3) * 0.002), 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1;

            // aura
            ctx.globalAlpha = 0.10;
            ctx.fillStyle = accent;
            ctx.beginPath();
            ctx.arc(0, 0, s * 0.34, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1;

            ctx.restore();
        }

        function drawSymbolGreedInkTrace(ctx, s, accent) {
            ctx.save();
            ctx.rotate(0.08);

            // ink blot
            const blotG = ctx.createRadialGradient(-s * 0.06, -s * 0.02, s * 0.02, 0, 0, s * 0.28);
            blotG.addColorStop(0, 'rgba(255,255,255,0.20)');
            blotG.addColorStop(0.25, 'rgba(30,30,40,0.90)');
            blotG.addColorStop(1, 'rgba(0,0,0,0.92)');
            ctx.fillStyle = blotG;
            ctx.beginPath();
            ctx.moveTo(-s * 0.18, -s * 0.04);
            ctx.quadraticCurveTo(-s * 0.28, s * 0.02, -s * 0.18, s * 0.08);
            ctx.quadraticCurveTo(-s * 0.12, s * 0.18, -s * 0.02, s * 0.16);
            ctx.quadraticCurveTo(s * 0.10, s * 0.22, s * 0.16, s * 0.10);
            ctx.quadraticCurveTo(s * 0.30, s * 0.06, s * 0.18, -s * 0.06);
            ctx.quadraticCurveTo(s * 0.12, -s * 0.22, -s * 0.06, -s * 0.18);
            ctx.quadraticCurveTo(-s * 0.14, -s * 0.16, -s * 0.18, -s * 0.04);
            ctx.closePath();
            ctx.fill();

            // drips
            ctx.globalAlpha = 0.85;
            ctx.fillStyle = 'rgba(0,0,0,0.75)';
            for (let i = 0; i < 3; i++) {
                const x = (-0.06 + i * 0.08) * s;
                const y = (0.18 + i * 0.02) * s;
                ctx.beginPath();
                ctx.ellipse(x, y, s * 0.025, s * 0.05, 0.2, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1;

            // quill
            ctx.save();
            ctx.rotate(-0.65);

            ctx.strokeStyle = accent;
            ctx.lineWidth = s * 0.014;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(-s * 0.06, -s * 0.22);
            ctx.lineTo(s * 0.18, s * 0.10);
            ctx.stroke();

            ctx.fillStyle = drawMetal(ctx, -s * 0.10, -s * 0.28, s * 0.10, s * 0.28,
                'rgba(255,255,255,0.55)', accent, 'rgba(0,0,0,0.75)');
            ctx.beginPath();
            ctx.moveTo(-s * 0.10, -s * 0.18);
            ctx.quadraticCurveTo(-s * 0.02, -s * 0.24, s * 0.06, -s * 0.16);
            ctx.quadraticCurveTo(s * 0.02, -s * 0.02, -s * 0.08, -s * 0.06);
            ctx.closePath();
            ctx.fill();
            ctx.restore();

            // glint
            ctx.globalAlpha = 0.22;
            ctx.fillStyle = accent;
            ctx.beginPath();
            ctx.arc(s * 0.10, -s * 0.10, s * 0.22, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1;

            ctx.restore();
        }

        function drawSymbolDissonanceMeter(ctx, s, accent) {
            ctx.save();
            ctx.rotate(-0.10);

            // body (metronome)
            const g = ctx.createLinearGradient(0, -s * 0.22, 0, s * 0.26);
            g.addColorStop(0, 'rgba(255,255,255,0.35)');
            g.addColorStop(0.45, 'rgba(60,60,80,0.90)');
            g.addColorStop(1, 'rgba(0,0,0,0.92)');
            ctx.fillStyle = g;
            ctx.strokeStyle = 'rgba(0,0,0,0.70)';
            ctx.lineWidth = s * 0.012;

            ctx.beginPath();
            ctx.moveTo(0, -s * 0.26);
            ctx.lineTo(s * 0.20, s * 0.26);
            ctx.lineTo(-s * 0.20, s * 0.26);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            // window
            ctx.fillStyle = 'rgba(255,255,255,0.08)';
            pathRoundRect(ctx, -s * 0.09, -s * 0.06, s * 0.18, s * 0.20, s * 0.05);
            ctx.fill();

            // swinging arm (off beat)
            ctx.strokeStyle = accent;
            ctx.lineWidth = s * 0.014;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(0, -s * 0.18);
            ctx.lineTo(s * 0.14, s * 0.02);
            ctx.stroke();
            ctx.fillStyle = accent;
            ctx.globalAlpha = 0.75;
            ctx.beginPath();
            ctx.arc(s * 0.14, s * 0.02, s * 0.020, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1;

            // ticks
            ctx.strokeStyle = 'rgba(255,255,255,0.20)';
            ctx.lineWidth = s * 0.008;
            for (let i = 0; i < 5; i++) {
                const yy = -s * 0.02 + i * s * 0.04;
                ctx.beginPath();
                ctx.moveTo(-s * 0.04, yy);
                ctx.lineTo(s * 0.04, yy);
                ctx.stroke();
            }

            // small note
            ctx.save();
            ctx.translate(s * 0.18, -s * 0.02);
            ctx.rotate(0.25);
            ctx.strokeStyle = 'rgba(255,255,255,0.35)';
            ctx.lineWidth = s * 0.010;
            ctx.beginPath();
            ctx.moveTo(0, -s * 0.04);
            ctx.lineTo(0, s * 0.10);
            ctx.stroke();

            ctx.fillStyle = accent;
            ctx.globalAlpha = 0.65;
            ctx.beginPath();
            ctx.ellipse(-s * 0.03, s * 0.12, s * 0.05, s * 0.035, -0.3, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();

            // aura
            ctx.globalAlpha = 0.10;
            ctx.fillStyle = accent;
            ctx.beginPath();
            ctx.arc(0, 0, s * 0.34, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1;

            ctx.restore();
        }

        function drawSymbolRankSealWax(ctx, s, accent) {
            ctx.save();
            ctx.rotate(0.08);

            const r = s * 0.22;

            // wax base
            const wg = ctx.createRadialGradient(-r * 0.25, -r * 0.25, r * 0.05, 0, 0, r);
            wg.addColorStop(0, 'rgba(255,255,255,0.55)');
            wg.addColorStop(0.30, 'rgba(180,0,0,0.72)');
            wg.addColorStop(1, 'rgba(0,0,0,0.85)');
            ctx.fillStyle = wg;
            ctx.beginPath();
            ctx.arc(0, s * 0.04, r, 0, Math.PI * 2);
            ctx.fill();

            // wax edge ridges
            ctx.strokeStyle = 'rgba(255,255,255,0.18)';
            ctx.lineWidth = s * 0.012;
            for (let i = 0; i < 10; i++) {
                const a = (Math.PI * 2 / 10) * i;
                ctx.beginPath();
                ctx.moveTo(Math.cos(a) * r * 0.65, s * 0.04 + Math.sin(a) * r * 0.65);
                ctx.lineTo(Math.cos(a) * r * 0.90, s * 0.04 + Math.sin(a) * r * 0.90);
                ctx.stroke();
            }

            // imprint crown
            ctx.strokeStyle = accent;
            ctx.globalAlpha = 0.75;
            ctx.lineWidth = s * 0.014;
            ctx.lineJoin = 'round';
            ctx.beginPath();
            ctx.moveTo(-r * 0.40, s * 0.06);
            ctx.lineTo(-r * 0.20, -r * 0.10 + s * 0.04);
            ctx.lineTo(0, s * 0.00);
            ctx.lineTo(r * 0.20, -r * 0.10 + s * 0.04);
            ctx.lineTo(r * 0.40, s * 0.06);
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(-r * 0.40, s * 0.06);
            ctx.lineTo(r * 0.40, s * 0.06);
            ctx.stroke();
            ctx.globalAlpha = 1;

            // ribbon tails
            ctx.fillStyle = drawMetal(ctx, -r * 0.40, s * 0.18, r * 0.40, s * 0.40,
                'rgba(255,255,255,0.25)', accent, 'rgba(0,0,0,0.75)');
            ctx.globalAlpha = 0.55;
            ctx.beginPath();
            ctx.moveTo(-r * 0.15, s * 0.18);
            ctx.lineTo(-r * 0.32, s * 0.40);
            ctx.lineTo(-r * 0.06, s * 0.34);
            ctx.closePath();
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(r * 0.15, s * 0.18);
            ctx.lineTo(r * 0.32, s * 0.40);
            ctx.lineTo(r * 0.06, s * 0.34);
            ctx.closePath();
            ctx.fill();
            ctx.globalAlpha = 1;

            // shine
            ctx.globalAlpha = 0.22;
            ctx.fillStyle = 'rgba(255,255,255,0.55)';
            ctx.beginPath();
            ctx.arc(-r * 0.22, s * 0.04 - r * 0.22, r * 0.45, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1;

            ctx.restore();
        }

        function drawSymbolAbyssOrb(ctx, s, accent) {
            ctx.save();
            const r = s * 0.24;

            // outer ring
            ctx.strokeStyle = drawMetal(ctx, -r, -r, r, r,
                'rgba(255,255,255,0.40)', accent, 'rgba(0,0,0,0.80)');
            ctx.lineWidth = s * 0.040;
            ctx.beginPath();
            ctx.arc(0, 0, r, 0, Math.PI * 2);
            ctx.stroke();

            // void sphere
            const vg = ctx.createRadialGradient(-r * 0.25, -r * 0.25, r * 0.05, 0, 0, r * 0.92);
            vg.addColorStop(0, 'rgba(255,255,255,0.35)');
            vg.addColorStop(0.25, 'rgba(140,0,220,0.22)');
            vg.addColorStop(1, 'rgba(0,0,0,0.92)');
            ctx.fillStyle = vg;
            ctx.beginPath();
            ctx.arc(0, 0, r * 0.86, 0, Math.PI * 2);
            ctx.fill();

            // swirling arcs
            ctx.globalAlpha = 0.70;
            ctx.strokeStyle = 'rgba(255,255,255,0.15)';
            ctx.lineWidth = s * 0.012;
            for (let i = 0; i < 3; i++) {
                ctx.beginPath();
                ctx.arc(0, 0, r * (0.30 + i * 0.18), -0.4 + i * 0.3, Math.PI * 1.4 + i * 0.25);
                ctx.stroke();
            }

            // star specks
            ctx.globalAlpha = 0.55;
            ctx.fillStyle = 'rgba(255,255,255,0.35)';
            for (let i = 0; i < 10; i++) {
                const a = i * 0.62;
                const rr = r * 0.10 + (i % 5) * r * 0.12;
                ctx.beginPath();
                ctx.arc(Math.cos(a) * rr, Math.sin(a) * rr, s * (0.004 + (i % 3) * 0.002), 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1;

            // abyss glow
            ctx.globalAlpha = 0.14;
            ctx.fillStyle = accent;
            ctx.beginPath();
            ctx.arc(0, 0, r * 1.65, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1;

            ctx.restore();
        }

        function drawSymbolConfessionThread(ctx, s, accent) {
            ctx.save();
            ctx.rotate(-0.18);

            const w = s * 0.26, h = s * 0.34;

            // spool metal
            const g = ctx.createLinearGradient(-w, -h, w, h);
            g.addColorStop(0, 'rgba(255,255,255,0.25)');
            g.addColorStop(0.45, 'rgba(30,30,40,0.90)');
            g.addColorStop(1, 'rgba(0,0,0,0.92)');
            ctx.fillStyle = g;
            ctx.strokeStyle = 'rgba(0,0,0,0.70)';
            ctx.lineWidth = s * 0.012;

            // top disc
            ctx.beginPath();
            ctx.ellipse(0, -h * 0.32, w * 0.55, h * 0.18, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();

            // bottom disc
            ctx.beginPath();
            ctx.ellipse(0, h * 0.32, w * 0.55, h * 0.18, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();

            // core
            ctx.fillStyle = 'rgba(0,0,0,0.55)';
            pathRoundRect(ctx, -w * 0.35, -h * 0.30, w * 0.70, h * 0.60, s * 0.06);
            ctx.fill();

            // thread wraps
            ctx.strokeStyle = accent;
            ctx.globalAlpha = 0.45;
            ctx.lineWidth = s * 0.008;
            for (let i = -5; i <= 5; i++) {
                const yy = i * s * 0.018;
                ctx.beginPath();
                ctx.moveTo(-w * 0.32, yy);
                ctx.lineTo(w * 0.32, yy);
                ctx.stroke();
            }
            ctx.globalAlpha = 1;

            // loose thread
            ctx.strokeStyle = 'rgba(255,255,255,0.18)';
            ctx.lineWidth = s * 0.010;
            ctx.beginPath();
            ctx.moveTo(w * 0.20, -h * 0.10);
            ctx.bezierCurveTo(w * 0.55, -h * 0.05, w * 0.55, h * 0.20, w * 0.10, h * 0.28);
            ctx.stroke();

            // needle
            ctx.strokeStyle = 'rgba(255,255,255,0.35)';
            ctx.lineWidth = s * 0.012;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(w * 0.46, h * 0.08);
            ctx.lineTo(w * 0.14, h * 0.30);
            ctx.stroke();
            ctx.fillStyle = 'rgba(255,255,255,0.35)';
            ctx.beginPath();
            ctx.arc(w * 0.46, h * 0.08, s * 0.012, 0, Math.PI * 2);
            ctx.fill();

            // aura
            ctx.globalAlpha = 0.10;
            ctx.fillStyle = accent;
            ctx.beginPath();
            ctx.arc(0, 0, s * 0.34, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1;

            ctx.restore();
        }

        function drawSymbolVeilStrand(ctx, s, accent) {
            ctx.save();
            ctx.rotate(0.10);

            // main strand
            const g = ctx.createLinearGradient(-s * 0.22, -s * 0.22, s * 0.22, s * 0.22);
            g.addColorStop(0, 'rgba(255,255,255,0.18)');
            g.addColorStop(0.35, 'rgba(20,20,28,0.90)');
            g.addColorStop(1, 'rgba(0,0,0,0.92)');

            ctx.strokeStyle = g;
            ctx.lineWidth = s * 0.030;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(-s * 0.26, -s * 0.08);
            ctx.bezierCurveTo(-s * 0.10, -s * 0.22, s * 0.10, -s * 0.02, s * 0.24, -s * 0.18);
            ctx.bezierCurveTo(s * 0.10, s * 0.02, -s * 0.06, s * 0.20, -s * 0.22, s * 0.18);
            ctx.stroke();

            // inner highlight
            ctx.strokeStyle = 'rgba(255,255,255,0.18)';
            ctx.lineWidth = s * 0.012;
            ctx.beginPath();
            ctx.moveTo(-s * 0.24, -s * 0.06);
            ctx.bezierCurveTo(-s * 0.10, -s * 0.18, s * 0.12, -s * 0.02, s * 0.22, -s * 0.14);
            ctx.stroke();

            // bead
            ctx.fillStyle = drawMetal(ctx, -s * 0.06, s * 0.14, s * 0.06, s * 0.26,
                'rgba(255,255,255,0.55)', accent, 'rgba(0,0,0,0.70)');
            ctx.beginPath();
            ctx.arc(-s * 0.18, s * 0.18, s * 0.045, 0, Math.PI * 2);
            ctx.fill();

            // aura
            ctx.globalAlpha = 0.10;
            ctx.fillStyle = accent;
            ctx.beginPath();
            ctx.arc(0, 0, s * 0.34, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1;

            ctx.restore();
        }

        function drawSymbolAbyssPhrase(ctx, s, accent) {
            ctx.save();
            ctx.rotate(-0.10);

            // staff lines
            ctx.strokeStyle = 'rgba(255,255,255,0.15)';
            ctx.lineWidth = s * 0.008;
            for (let i = 0; i < 5; i++) {
                const yy = (-0.10 + i * 0.05) * s;
                ctx.beginPath();
                ctx.moveTo(-s * 0.26, yy);
                ctx.lineTo(s * 0.18, yy);
                ctx.stroke();
            }

            function note(x, y, up = true) {
                ctx.save();
                ctx.translate(x, y);

                ctx.fillStyle = drawMetal(ctx, -s * 0.06, -s * 0.06, s * 0.06, s * 0.06,
                    'rgba(255,255,255,0.70)', accent, 'rgba(0,0,0,0.75)');
                ctx.beginPath();
                ctx.ellipse(0, 0, s * 0.045, s * 0.032, -0.35, 0, Math.PI * 2);
                ctx.fill();

                ctx.strokeStyle = 'rgba(255,255,255,0.20)';
                ctx.lineWidth = s * 0.008;
                ctx.beginPath();
                ctx.ellipse(0, 0, s * 0.045, s * 0.032, -0.35, 0, Math.PI * 2);
                ctx.stroke();

                ctx.strokeStyle = accent;
                ctx.lineWidth = s * 0.012;
                ctx.lineCap = 'round';
                ctx.beginPath();
                if (up) {
                    ctx.moveTo(s * 0.040, -s * 0.005);
                    ctx.lineTo(s * 0.040, -s * 0.14);
                } else {
                    ctx.moveTo(-s * 0.040, s * 0.005);
                    ctx.lineTo(-s * 0.040, s * 0.14);
                }
                ctx.stroke();

                ctx.restore();
            }

            note(-s * 0.12, -s * 0.05, true);
            note(-s * 0.02, 0, true);
            note(s * 0.08, -s * 0.03, false);

            // phrase arc
            ctx.globalAlpha = 0.55;
            ctx.strokeStyle = accent;
            ctx.lineWidth = s * 0.010;
            ctx.beginPath();
            ctx.moveTo(-s * 0.18, s * 0.10);
            ctx.bezierCurveTo(-s * 0.02, s * 0.04, s * 0.08, s * 0.12, s * 0.18, s * 0.04);
            ctx.stroke();
            ctx.globalAlpha = 1;

            // abyss hole
            const rr = s * 0.15;
            const hg = ctx.createRadialGradient(s * 0.22 - rr * 0.2, s * 0.16 - rr * 0.2, rr * 0.05, s * 0.22, s * 0.16, rr);
            hg.addColorStop(0, 'rgba(255,255,255,0.35)');
            hg.addColorStop(0.25, 'rgba(120,0,200,0.18)');
            hg.addColorStop(1, 'rgba(0,0,0,0.95)');
            ctx.fillStyle = hg;
            ctx.beginPath();
            ctx.arc(s * 0.22, s * 0.16, rr, 0, Math.PI * 2);
            ctx.fill();

            // pull swirl
            ctx.globalAlpha = 0.65;
            ctx.strokeStyle = 'rgba(255,255,255,0.12)';
            ctx.lineWidth = s * 0.010;
            ctx.beginPath();
            ctx.arc(s * 0.22, s * 0.16, rr * 0.70, -0.3, Math.PI * 1.6);
            ctx.stroke();
            ctx.globalAlpha = 1;

            // aura
            ctx.globalAlpha = 0.10;
            ctx.fillStyle = accent;
            ctx.beginPath();
            ctx.arc(0, 0, s * 0.34, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1;

            ctx.restore();
        }

        function drawSymbolResidualSpore(ctx, s, accent) {
            ctx.save();
            ctx.rotate(0.08);

            // haze
            ctx.globalAlpha = 0.35;
            const haze = ctx.createRadialGradient(-s * 0.06, s * 0.06, s * 0.02, 0, 0, s * 0.32);
            haze.addColorStop(0, 'rgba(120,255,180,0.18)');
            haze.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = haze;
            ctx.beginPath();
            ctx.arc(0, 0, s * 0.30, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1;

            const spores = [
                [-0.12, 0.05, 0.09],
                [0.00, -0.06, 0.11],
                [0.14, 0.02, 0.08],
                [-0.02, 0.12, 0.07],
            ];
            for (let i = 0; i < spores.length; i++) {
                const [xx, yy, rr] = spores[i];
                const r = s * rr;

                const g = ctx.createRadialGradient(xx * s - r * 0.3, yy * s - r * 0.3, r * 0.15, xx * s, yy * s, r);
                g.addColorStop(0, 'rgba(255,255,255,0.65)');
                g.addColorStop(0.35, 'rgba(80,220,140,0.25)');
                g.addColorStop(1, 'rgba(0,0,0,0.85)');

                ctx.fillStyle = g;
                ctx.beginPath();
                ctx.arc(xx * s, yy * s, r, 0, Math.PI * 2);
                ctx.fill();

                ctx.strokeStyle = accent;
                ctx.globalAlpha = 0.40;
                ctx.lineWidth = s * 0.010;
                ctx.beginPath();
                ctx.arc(xx * s, yy * s, r * 0.82, 0, Math.PI * 2);
                ctx.stroke();
                ctx.globalAlpha = 1;

                // tiny stem
                ctx.strokeStyle = 'rgba(255,255,255,0.12)';
                ctx.lineWidth = s * 0.008;
                ctx.beginPath();
                ctx.moveTo(xx * s, yy * s + r * 0.80);
                ctx.lineTo(xx * s - r * 0.10, yy * s + r * 1.15);
                ctx.stroke();
            }

            // dust specks
            ctx.globalAlpha = 0.55;
            ctx.fillStyle = 'rgba(255,255,255,0.25)';
            for (let i = 0; i < 14; i++) {
                const a = i * 0.45;
                const rr = s * (0.06 + (i % 7) * 0.02);
                ctx.beginPath();
                ctx.arc(Math.cos(a) * rr, Math.sin(a) * rr, s * (0.004 + (i % 3) * 0.002), 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1;

            // aura
            ctx.globalAlpha = 0.10;
            ctx.fillStyle = accent;
            ctx.beginPath();
            ctx.arc(0, 0, s * 0.34, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1;

            ctx.restore();
        }

        function drawSymbolAncestorMark(ctx, s, accent) {
            ctx.save();
            const r = s * 0.24;

            // dark plate
            const g = ctx.createRadialGradient(-r * 0.25, -r * 0.25, r * 0.05, 0, 0, r);
            g.addColorStop(0, 'rgba(255,255,255,0.30)');
            g.addColorStop(0.35, 'rgba(40,10,10,0.45)');
            g.addColorStop(1, 'rgba(0,0,0,0.92)');
            ctx.fillStyle = g;
            ctx.beginPath();
            ctx.arc(0, 0, r, 0, Math.PI * 2);
            ctx.fill();

            // outer ring
            ctx.strokeStyle = accent;
            ctx.globalAlpha = 0.75;
            ctx.lineWidth = s * 0.018;
            ctx.beginPath();
            ctx.arc(0, 0, r * 0.92, 0, Math.PI * 2);
            ctx.stroke();
            ctx.globalAlpha = 1;

            // runic ticks
            ctx.strokeStyle = 'rgba(255,255,255,0.18)';
            ctx.lineWidth = s * 0.010;
            for (let i = 0; i < 12; i++) {
                const a = (Math.PI * 2 / 12) * i;
                const x1 = Math.cos(a) * r * 0.62;
                const y1 = Math.sin(a) * r * 0.62;
                const x2 = Math.cos(a) * r * 0.78;
                const y2 = Math.sin(a) * r * 0.78;
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();
            }

            // twin crescents (pair)
            ctx.strokeStyle = accent;
            ctx.globalAlpha = 0.65;
            ctx.lineWidth = s * 0.020;
            ctx.beginPath();
            ctx.arc(-r * 0.18, 0, r * 0.45, -0.7, 0.7);
            ctx.stroke();
            ctx.beginPath();
            ctx.arc(r * 0.18, 0, r * 0.45, Math.PI - 0.7, Math.PI + 0.7);
            ctx.stroke();
            ctx.globalAlpha = 1;

            // center sigil
            ctx.strokeStyle = 'rgba(255,255,255,0.22)';
            ctx.lineWidth = s * 0.012;
            ctx.beginPath();
            ctx.moveTo(0, -r * 0.42);
            ctx.lineTo(r * 0.22, 0);
            ctx.lineTo(0, r * 0.42);
            ctx.lineTo(-r * 0.22, 0);
            ctx.closePath();
            ctx.stroke();

            // glow
            ctx.globalAlpha = 0.12;
            ctx.fillStyle = accent;
            ctx.beginPath();
            ctx.arc(0, 0, r * 1.65, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1;

            ctx.restore();
        }


        function drawWeaponIcon(ctx, s) {
            ctx.save();
            drawOrnateFrame(ctx, s, '#ffffff');
            drawSparkles(ctx, s, 'weapon', '#ffffff');

            ctx.translate(s*0.5, s*0.56);
            ctx.rotate(-0.35);

            // blade
            const bladeGrad = ctx.createLinearGradient(0, -s*0.35, 0, s*0.28);
            bladeGrad.addColorStop(0, 'rgba(255,255,255,0.95)');
            bladeGrad.addColorStop(0.45, 'rgba(230,240,255,0.85)');
            bladeGrad.addColorStop(1, 'rgba(160,180,210,0.60)');
            ctx.fillStyle = bladeGrad;
            ctx.strokeStyle = 'rgba(0,0,0,0.55)';
            ctx.lineWidth = s*0.010;
            ctx.beginPath();
            ctx.moveTo(0, -s*0.34);
            ctx.lineTo(s*0.04, -s*0.24);
            ctx.lineTo(s*0.018, s*0.14);
            ctx.lineTo(-s*0.018, s*0.14);
            ctx.lineTo(-s*0.04, -s*0.24);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            // fuller
            ctx.strokeStyle = 'rgba(120,150,190,0.35)';
            ctx.lineWidth = s*0.008;
            ctx.beginPath();
            ctx.moveTo(0, -s*0.26);
            ctx.lineTo(0, s*0.08);
            ctx.stroke();

            // guard
            ctx.strokeStyle = '#d4af37';
            ctx.lineWidth = s*0.028;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(-s*0.14, s*0.14);
            ctx.lineTo(s*0.14, s*0.14);
            ctx.stroke();

            // handle
            ctx.fillStyle = drawMetal(ctx, -s*0.06, s*0.14, s*0.06, s*0.34, 'rgba(255,255,255,0.55)', 'rgba(160,160,170,0.75)', 'rgba(0,0,0,0.7)');
            pathRoundRect(ctx, -s*0.04, s*0.14, s*0.08, s*0.22, s*0.04);
            ctx.fill();

            // pommel gem
            ctx.fillStyle = '#ffffff';
            ctx.globalAlpha = 0.8;
            ctx.beginPath();
            ctx.arc(0, s*0.36, s*0.035, 0, Math.PI*2);
            ctx.fill();
            ctx.globalAlpha = 1;

            // shine
            ctx.strokeStyle = 'rgba(255,255,255,0.75)';
            ctx.lineWidth = s*0.010;
            ctx.beginPath();
            ctx.moveTo(s*0.03, -s*0.30);
            ctx.lineTo(s*0.05, -s*0.12);
            ctx.stroke();

            ctx.restore();
        }

        function drawArmorIcon(ctx, s) {
            ctx.save();
            drawOrnateFrame(ctx, s, '#ffffff');
            drawSparkles(ctx, s, 'armor', '#ffffff');

            ctx.translate(s*0.5, s*0.58);

            // chestplate silhouette
            const g = ctx.createLinearGradient(0, -s*0.28, 0, s*0.28);
            g.addColorStop(0, 'rgba(255,255,255,0.90)');
            g.addColorStop(0.45, 'rgba(235,240,255,0.85)');
            g.addColorStop(1, 'rgba(120,140,170,0.65)');
            ctx.fillStyle = g;
            ctx.strokeStyle = 'rgba(0,0,0,0.55)';
            ctx.lineWidth = s*0.010;

            ctx.beginPath();
            ctx.moveTo(0, -s*0.26);
            ctx.quadraticCurveTo(s*0.18, -s*0.22, s*0.20, -s*0.06);
            ctx.quadraticCurveTo(s*0.22, s*0.18, 0, s*0.26);
            ctx.quadraticCurveTo(-s*0.22, s*0.18, -s*0.20, -s*0.06);
            ctx.quadraticCurveTo(-s*0.18, -s*0.22, 0, -s*0.26);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            // pauldrons
            ctx.fillStyle = 'rgba(255,255,255,0.70)';
            ctx.beginPath();
            ctx.ellipse(-s*0.22, -s*0.10, s*0.12, s*0.09, -0.2, 0, Math.PI*2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(s*0.22, -s*0.10, s*0.12, s*0.09, 0.2, 0, Math.PI*2);
            ctx.fill();

            // center ridge
            ctx.strokeStyle = 'rgba(120,150,190,0.35)';
            ctx.lineWidth = s*0.010;
            ctx.beginPath();
            ctx.moveTo(0, -s*0.22);
            ctx.lineTo(0, s*0.20);
            ctx.stroke();

            // holy emblem
            ctx.strokeStyle = '#d4af37';
            ctx.lineWidth = s*0.018;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(0, -s*0.04);
            ctx.lineTo(0, s*0.12);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(-s*0.06, s*0.04);
            ctx.lineTo(s*0.06, s*0.04);
            ctx.stroke();

            ctx.restore();
        }

        function makeIconDataURL(drawFn, size = 128) {
            const c = document.createElement('canvas');
            c.width = c.height = size;
            const g = c.getContext('2d');

            // 하이DPI 느낌: 내부에서 살짝 오버샘플링
            g.clearRect(0, 0, size, size);
            drawFn(g, size);

            return c.toDataURL('image/png');
        }

        function initLootArt() {
            // 전리품 아이콘
            for (const id in LOOT_DEFS) {
                LOOT_ICON[id] = makeIconDataURL((g, s) => drawLootIcon(g, s, id), 128);
            }
            // 장비 아이콘 (첨부 이미지 느낌으로 고급화) — 파일이 없으면 기존 캔버스 아이콘으로 대체
            WEAPON_ICON_URL = WEAPON_ICON_FILE;
            ARMOR_ICON_URL  = ARMOR_ICON_FILE;

            if (weaponIconEl) {
                weaponIconEl.src = WEAPON_ICON_URL;
                weaponIconEl.onerror = () => {
                    WEAPON_ICON_URL = makeIconDataURL((g, s) => drawWeaponIcon(g, s), 160);
                    weaponIconEl.src = WEAPON_ICON_URL;
                };
            }
            if (armorIconEl) {
                armorIconEl.src = ARMOR_ICON_URL;
                armorIconEl.onerror = () => {
                    ARMOR_ICON_URL = makeIconDataURL((g, s) => drawArmorIcon(g, s), 160);
                    armorIconEl.src = ARMOR_ICON_URL;
                };
            }
        }

        
        // =========================================================
        // [NEW] 유물(Relics) 시스템
        //  - O : 유물 UI 열기/닫기
        //  - 전리품을 슬롯에 투입해 유물을 해금
        //  - 해금된 유물의 '능력치'는 항상 적용
        //  - 유물의 '특수 효과'는 장착한 유물(최대 3개)만 적용
        // =========================================================

        const RELIC_STORAGE_KEY = 'gbvs_relics_v1';
        const RELIC_EQUIP_SLOTS = 3;
        const RELIC_ICON_BASE = './relic_icons/';

        // [유물 박아넣기.jpg] 참고 배치(12 슬롯)
        const RELIC_SLOT_LAYOUT = [
            { left: '25%', top: '7%'  },
            { left: '50%', top: '7%'  },
            { left: '75%', top: '7%'  },

            { left: '37%', top: 'calc(23% - 14px)' },
            { left: '63%', top: 'calc(23% - 14px)' },

            { left: '22%', top: '38%' },
            { left: '78%', top: '38%' },

            { left: '22%', top: '62%' },
            { left: '78%', top: '62%' },

            { left: '42%', top: '86%' },
            { left: '58%', top: '86%' },

            { left: '50%', top: '94%' },
        ];

        function RSTAT(type, value) { return { type, value }; }
        function RREQ(lootId, qty) { return { lootId, qty }; }

        // 유물 정의(최소 10개 이상 유지, 확장 가능)
        //  - requirements는 슬롯(최대 12)과 1:1 매칭됩니다.
        const RELIC_DEFS = [
            {
                id: 'illusion_badge',
                name: '칠흑 장막 브로치',
                iconFile: 'relic_black_veil_brooch.png',
                passive: [ RSTAT('evasion', 0.03), RSTAT('hp', 40), RSTAT('critResist', 3) ],
                special: '회피 성공 시 3초에 1번, 0.5초간 무적',
                requirements: [
                    RREQ('kai_grimoire', 18), RREQ('cassias_badge', 18), RREQ('arcane_echo_dust', 9), RREQ('broken_aim_lens', 9),
                    RREQ('greed_ink_trace', 9), RREQ('curse_vial', 30), RREQ('dark_cloak_fragment', 30), RREQ('ebony_powder', 30),
                    RREQ('rank_seal_wax', 9), RREQ('black_veil_strand', 6), RREQ('abyss_orb', 6), RREQ('abyss_phrase', 6),
                ],
            },
            {
                id: 'pocket_watch',
                name: '불협의 메트로놈',
                iconFile: 'relic_dissonance_metronome.png',
                passive: [ RSTAT('skillCooldownReduction', 0.015), RSTAT('moveSpeed', 0.15), RSTAT('luck', 1) ],
                special: '15초마다 1번, 모든 액티브 스킬 쿨타임을 1초 추가로 감소',
                requirements: [
                    RREQ('dissonance_meter', 9), RREQ('call_sign_noise', 9), RREQ('broken_aim_lens', 9), RREQ('masakuni_mask', 12),
                    RREQ('kaito_orb', 12), RREQ('questa_bottle', 12), RREQ('tetora_note', 12), RREQ('poisoned_hilt', 30),
                    RREQ('used_condom', 30), RREQ('dark_virus', 6), RREQ('abyss_residual_spore', 3), RREQ('true_ancestor_mark', 3),
                ],
            },
            {
                id: 'end_prophecy',
                name: '심연의 소절 석판',
                iconFile: 'relic_abyss_phrase_tablet.png',
                passive: [ RSTAT('atk', 2), RSTAT('critChance', 2), RSTAT('critDamage', 0.05) ],
                special: '일반 적 처치시, 고대의 두루마리 드랍 확률 1% 증가.',
                requirements: [
                    RREQ('kai_grimoire', 18), RREQ('dark_virus', 6), RREQ('abyss_phrase', 6), RREQ('abyss_residual_spore', 3),
                    RREQ('true_ancestor_mark', 3), RREQ('curse_vial', 30), RREQ('ebony_powder', 30), RREQ('rank_seal_wax', 9),
                    RREQ('black_confession_thread', 6), RREQ('abyss_orb', 6), RREQ('blood_hilt', 9), RREQ('oath_blooddrop', 9),
                ],
            },
            {
                id: 'panshin_box',
                name: '장막의 병',
                iconFile: 'relic_veil_vial.png',
                passive: [ RSTAT('xpGain', 0.06), RSTAT('regen', 6), RSTAT('luck', 1) ],
                special: '엘리트/로열/보스 처치 시 8초에 1번, 보너스 아이템 1개 생성',
                requirements: [
                    RREQ('luca_diary', 18), RREQ('jacques_note', 18), RREQ('arcane_echo_dust', 9), RREQ('torn_letter', 9),
                    RREQ('greed_ink_trace', 9), RREQ('used_condom', 30), RREQ('aphrodisiac_perfume', 30), RREQ('black_veil_strand', 6),
                    RREQ('black_confession_thread', 6), RREQ('dark_sediment', 9), RREQ('abyss_phrase', 6), RREQ('abyss_orb', 6),
                ],
            },
            {
                id: 'soren_eye',
                name: '심안의 가면',
                iconFile: 'relic_minds_eye_mask.png',
                passive: [ RSTAT('accuracy', 0.03), RSTAT('range', 2), RSTAT('critChance', 1) ],
                special: '치명타 적중 시, 5초에 1번 3초간 명중 10% 증가',
                requirements: [
                    RREQ('broken_aim_lens', 9), RREQ('ozma_orb', 18), RREQ('call_sign_noise', 9), RREQ('dissonance_meter', 9),
                    RREQ('taro_chain', 18), RREQ('poisoned_hilt', 30), RREQ('ebony_powder', 30), RREQ('arcane_echo_dust', 9),
                    RREQ('rank_seal_wax', 9), RREQ('abyss_orb', 6), RREQ('abyss_phrase', 6), RREQ('true_ancestor_mark', 3),
                ],
            },
            {
                id: 'ancestor_amulet',
                name: '사냥꾼의 침전물 표본',
                iconFile: 'relic_hunter_sediment_sample.png',
                passive: [ RSTAT('hp', 70), RSTAT('regen', 6), RSTAT('critResist', 6) ],
                special: '사악한 마음/사악한 빛 디버프 적용 시 10초에 1번 무효화 + 정의 보호막 +1',
                requirements: [
                    RREQ('true_ancestor_mark', 3), RREQ('abyss_residual_spore', 3), RREQ('abyss_phrase', 6), RREQ('abyss_orb', 6),
                    RREQ('black_confession_thread', 6), RREQ('black_veil_strand', 6), RREQ('oath_blooddrop', 9), RREQ('blood_hilt', 9),
                    RREQ('dark_virus', 6), RREQ('curse_vial', 30), RREQ('dark_cloak_fragment', 30), RREQ('arcane_echo_dust', 9),
                ],
            },
            {
                id: 'tribe_horn',
                name: '절단된 사슬 수갑',
                iconFile: 'relic_cut_chain_manacles.png',
                passive: [ RSTAT('atkSpeed', 0.06), RSTAT('stunChance', 0.01), RSTAT('moveSpeed', 0.10) ],
                special: '적을 기절시키면 3초에 1번, 상태이상 보호막 +1',
                requirements: [
                    RREQ('ryuon_emblem', 18), RREQ('gawain_flag', 18), RREQ('hiro_radio', 18), RREQ('aki_potion', 18),
                    RREQ('poisoned_hilt', 30), RREQ('used_condom', 30), RREQ('torn_letter', 9), RREQ('oath_wind_shard', 9),
                    RREQ('call_sign_noise', 9), RREQ('rank_seal_wax', 9), RREQ('masakuni_mask', 12), RREQ('kaito_orb', 12),
                ],
            },
            {
                id: 'christel_goblet',
                name: '잔향의 수정 성배',
                iconFile: 'relic_aftertone_crystal_goblet.png',
                passive: [ RSTAT('hp', 50), RSTAT('regen', 10), RSTAT('defense', 1) ],
                special: '체력 회복 아이템 획득 시, 5초에 1번 디버프 스택 3개 추가 정화',
                requirements: [
                    RREQ('aphrodisiac_perfume', 30), RREQ('used_condom', 30), RREQ('ebony_powder', 30), RREQ('luca_diary', 18),
                    RREQ('ozma_orb', 18), RREQ('greed_ink_trace', 9), RREQ('arcane_echo_dust', 9), RREQ('torn_letter', 9),
                    RREQ('black_confession_thread', 6), RREQ('black_veil_strand', 6), RREQ('abyss_residual_spore', 3), RREQ('dark_virus', 6),
                ],
            },
            {
                id: 'wraith_totem',
                name: '포자 배양관',
                iconFile: 'relic_spore_incubator.png',
                passive: [ RSTAT('defense', 2), RSTAT('xpGain', 0.05), RSTAT('critResist', 4) ],
                special: '7초마다 1번(디버프가 있을 때만), 디버프 스택 1개 자동 정화',
                requirements: [
                    RREQ('dark_cloak_fragment', 30), RREQ('ebony_powder', 30), RREQ('curse_vial', 30), RREQ('jacques_note', 18),
                    RREQ('cassias_badge', 18), RREQ('dark_sediment', 9), RREQ('dissonance_meter', 9), RREQ('abyss_orb', 6),
                    RREQ('abyss_phrase', 6), RREQ('black_veil_strand', 6), RREQ('true_ancestor_mark', 3), RREQ('dark_virus', 6),
                ],
            },

            // --- 추가 유물(10개 이상 유지) ---
            {
                id: 'perfume_case',
                name: '유혹 차단 향수 케이스',
                iconFile: 'relic_perfume_case.png',
                passive: [ RSTAT('evasion', 0.03), RSTAT('critResist', 8), RSTAT('moveSpeed', 0.10) ],
                special: '키스 계열 디버프 지속시간 -25% · 2초에 1번, 추가 키스 스택 1회 무효화',
                requirements: [
                    RREQ('aphrodisiac_perfume', 30), RREQ('used_condom', 30), RREQ('luca_diary', 18), RREQ('jacques_note', 18),
                    RREQ('greed_ink_trace', 9), RREQ('torn_letter', 9), RREQ('rank_seal_wax', 9), RREQ('black_confession_thread', 6),
                    RREQ('black_veil_strand', 6), RREQ('abyss_phrase', 6), RREQ('dissonance_meter', 9), RREQ('dark_sediment', 9),
                ],
            },
            {
                id: 'barrier_core',
                name: '성기사의 바람깃발',
                iconFile: 'relic_paladin_wind_banner.png',
                passive: [ RSTAT('defense', 3), RSTAT('hp', 60), RSTAT('skillCooldownReduction', 0.01) ],
                special: '보호막이 피해를 흡수하면 4초에 1번, 보호막 +5% (5초)',
                requirements: [
                    RREQ('dark_virus', 6), RREQ('oath_blooddrop', 9), RREQ('blood_hilt', 9), RREQ('abyss_orb', 6),
                    RREQ('black_veil_strand', 6), RREQ('dark_sediment', 9), RREQ('curse_vial', 30), RREQ('dark_cloak_fragment', 30),
                    RREQ('poisoned_hilt', 30), RREQ('rank_seal_wax', 9), RREQ('true_ancestor_mark', 3), RREQ('abyss_residual_spore', 3),
                ],
            },
            {
                id: 'stellar_compass',
                name: '호출부호 수신기',
                iconFile: 'relic_callsign_receiver.png',
                passive: [ RSTAT('xpGain', 0.08), RSTAT('luck', 2), RSTAT('moveSpeed', 0.10) ],
                special: '레벨업 시 15%확률로 리로드 기회 +1',
                requirements: [
                    RREQ('call_sign_noise', 9), RREQ('broken_aim_lens', 9), RREQ('dissonance_meter', 9), RREQ('rank_seal_wax', 9),
                    RREQ('kai_grimoire', 18), RREQ('hiro_radio', 18), RREQ('tetora_note', 12), RREQ('questa_bottle', 12),
                    RREQ('masakuni_mask', 12), RREQ('kaito_orb', 12), RREQ('abyss_orb', 6), RREQ('abyss_phrase', 6),
                ],
            },
            {
                id: 'inquisition_record',
                name: '봉인된 저주 앰플',
                iconFile: 'relic_sealed_curse_ampoule.png',
                passive: [ RSTAT('critResist', 6), RSTAT('defense', 1), RSTAT('skillCooldownReduction', 0.01) ],
                special: '저주 폭발 피해를 무시할 확률이 생긴다. 25% 확률',
                requirements: [
                    RREQ('torn_letter', 9), RREQ('greed_ink_trace', 9), RREQ('rank_seal_wax', 9), RREQ('jacques_note', 18),
                    RREQ('cassias_badge', 18), RREQ('curse_vial', 30), RREQ('ebony_powder', 30), RREQ('dark_cloak_fragment', 30),
                    RREQ('black_confession_thread', 6), RREQ('black_veil_strand', 6), RREQ('abyss_phrase', 6), RREQ('dark_virus', 6),
                ],
            },
            {
                id: 'chaos_ink',
                name: '탐욕의 잉크 인장',
                iconFile: 'relic_greed_ink_seal.png',
                passive: [ RSTAT('critChance', 1), RSTAT('critDamage', 0.05), RSTAT('luck', 1) ],
                special: '리로드 사용시 15%확률로 리로드 기회를 소모하지 않는다',
                requirements: [
                    RREQ('greed_ink_trace', 9), RREQ('arcane_echo_dust', 9), RREQ('dissonance_meter', 9), RREQ('call_sign_noise', 9),
                    RREQ('ebony_powder', 30), RREQ('curse_vial', 30), RREQ('used_condom', 30), RREQ('ozma_orb', 18),
                    RREQ('hiro_radio', 18), RREQ('abyss_orb', 6), RREQ('black_veil_strand', 6), RREQ('true_ancestor_mark', 3),
                ],
            },
            {
                id: 'abyss_hourglass',
                name: '진조의 낙인 성유물',
                iconFile: 'relic_true_ancestor_mark_reliquary.png',
                passive: [ RSTAT('skillCooldownReduction', 0.02), RSTAT('moveSpeed', 0.10), RSTAT('evasion', 0.02) ],
                special: '30초마다 1번, 노바 보호막(최대 체력 10%, 10초) 자동 획득',
                requirements: [
                    RREQ('abyss_orb', 6), RREQ('abyss_phrase', 6), RREQ('abyss_residual_spore', 3), RREQ('true_ancestor_mark', 3),
                    RREQ('dark_virus', 6), RREQ('dissonance_meter', 9), RREQ('dark_sediment', 9), RREQ('rank_seal_wax', 9),
                    RREQ('kai_grimoire', 18), RREQ('masakuni_mask', 12), RREQ('tetora_note', 12), RREQ('broken_aim_lens', 9),
                ],
            },
            {
                id: 'confession_spool',
                name: '고해실의 실타래',
                iconFile: 'relic_confessional_spool.png',
                passive: [ RSTAT('defense', 1), RSTAT('critResist', 5), RSTAT('regen', 6) ],
                special: '상태이상 정화 아이템으로 디버프 정화 성공 시, 3초에 1번 상태이상 보호막 +2',
                requirements: [
                    RREQ('black_confession_thread', 6), RREQ('black_veil_strand', 6), RREQ('abyss_orb', 6), RREQ('abyss_phrase', 6),
                    RREQ('dark_sediment', 9), RREQ('greed_ink_trace', 9), RREQ('torn_letter', 9), RREQ('jacques_note', 18),
                    RREQ('luca_diary', 18), RREQ('curse_vial', 30), RREQ('dark_cloak_fragment', 30), RREQ('abyss_residual_spore', 3),
                ],
            },
            {
                id: 'red_oath_ring',
                name: '붉은 맹세의 성서',
                iconFile: 'relic_crimson_oath_scripture.png',
                passive: [ RSTAT('atk', 1), RSTAT('critChance', 3), RSTAT('critResist', 3) ],
                special: '플레이어가 적에게 치명타 피해(크리티컬 피해)를 받을시 10초에 1번, 5초간 치명타 저항 10% 증가, 최대 체력 2% 회복.',
                requirements: [
                    RREQ('oath_blooddrop', 9), RREQ('blood_hilt', 9), RREQ('oath_wind_shard', 9), RREQ('rank_seal_wax', 9),
                    RREQ('ryuon_emblem', 18), RREQ('taro_chain', 18), RREQ('masakuni_mask', 12), RREQ('kaito_orb', 12),
                    RREQ('abyss_phrase', 6), RREQ('abyss_orb', 6), RREQ('dark_virus', 6), RREQ('true_ancestor_mark', 3),
                ],
            },
            {
                id: 'sacred_blood_lens',
                name: '조준 교정 렌즈',
                iconFile: 'relic_aim_calibration_lens.png',
                passive: [ RSTAT('accuracy', 0.04), RSTAT('atk', 1), RSTAT('range', 1) ],
                special: '플레이어가 적에게 치명타 피해를 입힐시 5초에 1번, 최대 체력 1% 회복',
                requirements: [
                    RREQ('broken_aim_lens', 9), RREQ('blood_hilt', 9), RREQ('oath_blooddrop', 9), RREQ('arcane_echo_dust', 9),
                    RREQ('call_sign_noise', 9), RREQ('dark_sediment', 9), RREQ('curse_vial', 30), RREQ('poisoned_hilt', 30),
                    RREQ('ozma_orb', 18), RREQ('tetora_note', 12), RREQ('abyss_residual_spore', 3), RREQ('true_ancestor_mark', 3),
                ],
            },
        ];


// [밸런스] 로열/보스 전리품은 희소성이 높으므로 유물 요구 수량을 상한으로 제한합니다.
function capRelicRequirementQty(lootId, qty) {
    const def = (typeof LOOT_DEFS !== 'undefined') ? LOOT_DEFS[lootId] : null;
    if (!def) return qty;
    const cat = def.category;
    const rar = def.rarity;
    if (cat === LOOT_CATEGORY.ROYAL) {
        return Math.min(qty, (rar === 'rare') ? 2 : 5);
    }
    if (cat === LOOT_CATEGORY.BOSS) {
        return Math.min(qty, (rar === 'rare') ? 1 : 2);
    }
    return qty;
}

for (const relicDef of RELIC_DEFS) {
    if (!relicDef || !Array.isArray(relicDef.requirements)) continue;
    for (const req of relicDef.requirements) {
        if (!req) continue;
        req.qty = capRelicRequirementQty(req.lootId, req.qty);
    }
}

        const RELIC_ICON = {};
        let relicState = { byId: {}, equipped: [] };
        let isRelicPanelOpen = false;

        // UI refs
        let relicPanelEl, closeRelicPanelBtnEl, relicCollectionViewEl, relicDetailViewEl;
        let relicGridEl, relicEquipSlotsEl, relicBackBtnEl, relicDetailTitleEl, relicBoardEl;
        let relicEquipBtnEl, relicInvToggleBtnEl, relicInventoryWrapEl, relicInventoryGridEl;
        let relicEffectDescEl, relicStatsDescEl;

        let currentRelicId = null;
        let selectedRelicSlotIdx = null;

        // ---------------------------
        // Storage
        // ---------------------------
        function getRelicDef(id) {
            return RELIC_DEFS.find(r => r.id === id);
        }

        function ensureRelicEntry(id) {
            if (!relicState.byId) relicState.byId = {};
            if (!relicState.byId[id]) {
                const def = getRelicDef(id);
                const n = def ? def.requirements.length : 0;
                relicState.byId[id] = { unlocked: false, filled: new Array(n).fill(0) };
            } else {
                const def = getRelicDef(id);
                const n = def ? def.requirements.length : 0;
                if (!Array.isArray(relicState.byId[id].filled)) relicState.byId[id].filled = new Array(n).fill(0);
                if (relicState.byId[id].filled.length < n) {
                    relicState.byId[id].filled = relicState.byId[id].filled.concat(new Array(n - relicState.byId[id].filled.length).fill(0));
                } else if (relicState.byId[id].filled.length > n) {
                    relicState.byId[id].filled = relicState.byId[id].filled.slice(0, n);
                }
                relicState.byId[id].unlocked = !!relicState.byId[id].unlocked;
            }
            return relicState.byId[id];
        }

        function loadRelicsFromStorage() {
            try {
                const raw = localStorage.getItem(RELIC_STORAGE_KEY);
                if (!raw) return;
                const parsed = JSON.parse(raw);
                if (!parsed || typeof parsed !== 'object') return;

                relicState.byId = parsed.byId && typeof parsed.byId === 'object' ? parsed.byId : {};
                relicState.equipped = Array.isArray(parsed.equipped) ? parsed.equipped : [];

                // sanitize (unknown ids / limit)
                relicState.equipped = relicState.equipped.filter(id => !!getRelicDef(id));
                relicState.equipped = relicState.equipped.slice(0, RELIC_EQUIP_SLOTS);

                // ensure entries for all defs
                for (const def of RELIC_DEFS) ensureRelicEntry(def.id);

                // equipped must be unlocked
                relicState.equipped = relicState.equipped.filter(id => ensureRelicEntry(id).unlocked);

            } catch (e) {
                console.warn('Relic load failed:', e);
            }
        }

        function saveRelicsToStorage() {
            try {
                localStorage.setItem(RELIC_STORAGE_KEY, JSON.stringify(relicState));
            } catch (e) {
                console.warn('Relic save failed:', e);
            }
        }

        function isRelicUnlocked(id) {
            return ensureRelicEntry(id).unlocked;
        }
        function isRelicEquipped(id) {
            return relicState.equipped.includes(id);
        }

        // ---------------------------
        // Art (fallback placeholder + optional local file)
        // ---------------------------
        function makeRelicPlaceholder(name) {
            const c = document.createElement('canvas');
            c.width = 128; c.height = 128;
            const ctx = c.getContext('2d');
            const g = ctx.createLinearGradient(0, 0, 128, 128);
            g.addColorStop(0, 'rgba(0,191,255,0.35)');
            g.addColorStop(1, 'rgba(255, 64, 160,0.25)');
            ctx.fillStyle = g;
            ctx.fillRect(0,0,128,128);

            ctx.fillStyle = 'rgba(0,0,0,0.35)';
            ctx.fillRect(8,8,112,112);

            ctx.fillStyle = 'rgba(255,255,255,0.85)';
            ctx.font = 'bold 28px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            const t = (name || '?').trim();
            ctx.fillText(t.length ? t[0] : '?', 64, 64);

            return c.toDataURL('image/png');
        }

        function initRelicArt() {
            for (const def of RELIC_DEFS) {
                // default placeholder
                RELIC_ICON[def.id] = makeRelicPlaceholder(def.name);
                if (!def.iconFile) continue;

                const file = String(def.iconFile || '').trim();
                if (!file) continue;

                // Candidates:
                //  1) Same folder as the running HTML: ./<file>
                //  2) A subfolder next to the HTML: ./relic_icons/<file>  (configurable via RELIC_ICON_BASE)
                //
                // If iconFile is already a path (contains '/' or starts with http/data/./../), we use it as-is.
                const isPathLike =
                    file.startsWith('data:') ||
                    file.startsWith('http://') ||
                    file.startsWith('https://') ||
                    file.startsWith('/') ||
                    file.startsWith('./') ||
                    file.startsWith('../') ||
                    file.includes('/');

                const candidates = isPathLike ? [file] : [`${RELIC_ICON_BASE}${file}`, `./${file}`];

                const img = new Image();
                let i = 0;

                img.onload = () => {
                    // Use the resolved successful src
                    RELIC_ICON[def.id] = candidates[i];

                    // refresh UI if open
                    if (isRelicPanelOpen) {
                        updateRelicCollectionUI();
                        if (currentRelicId === def.id) renderRelicDetail(def.id);
                    }
                };

                img.onerror = () => {
                    i++;
                    if (i < candidates.length) {
                        img.src = candidates[i];
                    } else {
                        // keep placeholder; optionally log:
                        // console.warn('Relic icon load failed:', file);
                    }
                };

                img.src = candidates[i];
            }
        }

        // ---------------------------
        // UI
        // ---------------------------
        function initRelicPanelUI() {
            relicPanelEl = document.getElementById('relicPanel');
            closeRelicPanelBtnEl = document.getElementById('closeRelicPanelBtn');
            relicCollectionViewEl = document.getElementById('relicCollectionView');
            relicDetailViewEl = document.getElementById('relicDetailView');
            relicGridEl = document.getElementById('relicGrid');
            relicEquipSlotsEl = document.getElementById('relicEquipSlots');
            relicBackBtnEl = document.getElementById('relicBackBtn');
            relicDetailTitleEl = document.getElementById('relicDetailTitle');
            relicBoardEl = document.getElementById('relicBoard');
            relicEquipBtnEl = document.getElementById('relicEquipBtn');
            relicInvToggleBtnEl = document.getElementById('relicInvToggleBtn');
            relicInventoryWrapEl = document.getElementById('relicInventoryWrap');
            relicInventoryGridEl = document.getElementById('relicInventoryGrid');
            relicEffectDescEl = document.getElementById('relicEffectDesc');
            relicStatsDescEl = document.getElementById('relicStatsDesc');

            if (closeRelicPanelBtnEl) closeRelicPanelBtnEl.addEventListener('click', () => closeRelicPanel(true));
            if (relicBackBtnEl) relicBackBtnEl.addEventListener('click', () => showRelicCollectionView());
            if (relicInvToggleBtnEl) relicInvToggleBtnEl.addEventListener('click', () => {
                const now = relicInventoryWrapEl.style.display !== 'none';
                relicInventoryWrapEl.style.display = now ? 'none' : 'block';
                if (!now) renderRelicInventoryGrid();
            });

            if (relicEquipBtnEl) relicEquipBtnEl.addEventListener('click', () => {
                if (!currentRelicId) return;
                toggleRelicEquip(currentRelicId);
            });

            updateRelicCollectionUI();
        }

        function openRelicPanel() {
            if (isRelicPanelOpen) return;
            if (!isGameRunning) return;
            if (isLevelUpPaused) return;

            // 다른 패널 닫기
            if (typeof closeGearPanel === 'function' && isGearPanelOpen) closeGearPanel(false);
            if (typeof closeEquipPanel === 'function' && isEquipPanelOpen) closeEquipPanel(false);

            isRelicPanelOpen = true;
            relicPanelEl.style.display = 'flex';
            showRelicCollectionView();
        }

        function closeRelicPanel(resume = true) {
            if (!isRelicPanelOpen) return;
            isRelicPanelOpen = false;
            relicPanelEl.style.display = 'none';
            currentRelicId = null;
            selectedRelicSlotIdx = null;

            if (resume && isGameRunning && !isLevelUpPaused) {
                requestAnimationFrame(animate);
            }
        }

        function toggleRelicPanel() {
            if (isRelicPanelOpen) closeRelicPanel(true);
            else openRelicPanel();
        }

        function showRelicCollectionView() {
            currentRelicId = null;
            selectedRelicSlotIdx = null;
            relicDetailViewEl.style.display = 'none';
            relicCollectionViewEl.style.display = 'block';
            updateRelicCollectionUI();
        }

        function showRelicDetailView(relicId) {
            currentRelicId = relicId;
            selectedRelicSlotIdx = 0;
            relicCollectionViewEl.style.display = 'none';
            relicDetailViewEl.style.display = 'block';
            relicInventoryWrapEl.style.display = 'none';
            renderRelicDetail(relicId);
        }

        function formatRelicStatLine(type, value) {
            const pct = (v) => (Math.round(v * 1000) / 10).toFixed(1) + '%';
            switch (type) {
                case 'atk': return ['공격', `+${value}`];
                case 'hp': return ['체력', `+${value}`];
                case 'defense': return ['방어', `+${value}`];
                case 'accuracy': return ['명중', `+${pct(value)}`];
                case 'evasion': return ['회피', `+${pct(value)}`];
                case 'stunChance': return ['기절 확률', `+${pct(value)}`];
                case 'critChance': return ['치명타 확률', `+${value}%`];
                case 'critResist': return ['치명타 저항', `+${value}%`];
                case 'critDamage': return ['치명타 피해', `+${pct(value)}`];
                case 'atkSpeed': return ['공격 속도', `+${pct(value)}`];
                case 'range': return ['사거리', `+${value}`];
                case 'xpGain': return ['경험치 획득', `+${pct(value)}`];
                case 'regen': return ['재생', `+${value}`];
                case 'moveSpeed': return ['이동 속도', `+${value}`];
                case 'luck': return ['행운', `+${value}`];
                case 'skillCooldownReduction': return ['쿨타임 회복', `+${pct(value)}`];
                default: return [type, String(value)];
            }
        }

        function updateRelicCollectionUI() {
            if (!relicGridEl) return;

            // equip slots
            renderRelicEquipSlots();

            relicGridEl.innerHTML = '';
            for (const def of RELIC_DEFS) {
                const st = ensureRelicEntry(def.id);
                const totalNeed = def.requirements.reduce((a, r) => a + r.qty, 0);
                const totalFilled = def.requirements.reduce((a, r, i) => a + Math.min(st.filled[i] || 0, r.qty), 0);

                const card = document.createElement('div');
                card.className = 'relic-card ' + (st.unlocked ? '' : 'locked ') + (isRelicEquipped(def.id) ? 'equipped' : '');
                card.title = st.unlocked ? '클릭: 상세/장착' : '클릭: 전리품 투입';
                card.addEventListener('click', () => showRelicDetailView(def.id));

                const thumb = document.createElement('div');
                thumb.className = 'relic-thumb';
                const img = document.createElement('img');
                img.src = RELIC_ICON[def.id] || makeRelicPlaceholder(def.name);
                thumb.appendChild(img);

                const meta = document.createElement('div');
                meta.className = 'relic-meta';
                const name = document.createElement('div');
                name.className = 'relic-name';
                name.textContent = def.name;

                const prog = document.createElement('div');
                prog.className = 'relic-progress';
                prog.textContent = st.unlocked ? '해금 완료' : `${totalFilled}/${totalNeed}`;

                const tags = document.createElement('div');
                tags.className = 'relic-tags';

                const t1 = document.createElement('div');
                t1.className = 'relic-tag ' + (st.unlocked ? 'on' : 'lock');
                t1.textContent = st.unlocked ? '활성' : '잠김';

                tags.appendChild(t1);

                if (isRelicEquipped(def.id)) {
                    const t2 = document.createElement('div');
                    t2.className = 'relic-tag on';
                    t2.textContent = '장착';
                    tags.appendChild(t2);
                }

                meta.appendChild(name);
                meta.appendChild(prog);
                meta.appendChild(tags);

                card.appendChild(thumb);
                card.appendChild(meta);
                relicGridEl.appendChild(card);
            }
        }

        function renderRelicEquipSlots() {
            if (!relicEquipSlotsEl) return;
            relicEquipSlotsEl.innerHTML = '';

            for (let i = 0; i < RELIC_EQUIP_SLOTS; i++) {
                const slot = document.createElement('div');
                const id = relicState.equipped[i] || null;
                slot.className = 'relic-equip-slot ' + (id ? '' : 'empty');

                if (id) {
                    const def = getRelicDef(id);
                    const img = document.createElement('img');
                    img.src = RELIC_ICON[id] || makeRelicPlaceholder(def?.name);
                    slot.appendChild(img);
                    slot.title = `클릭: 해제 (${def?.name || id})`;
                    slot.addEventListener('click', () => {
                        toggleRelicEquip(id);
                    });
                } else {
                    slot.title = '빈 슬롯';
                }
                relicEquipSlotsEl.appendChild(slot);
            }
        }

        function renderRelicDetail(relicId) {
            const def = getRelicDef(relicId);
            if (!def) return;
            const st = ensureRelicEntry(relicId);

            relicDetailTitleEl.textContent = def.name;

            // equip button state
            if (!st.unlocked) {
                relicEquipBtnEl.textContent = '잠김';
                relicEquipBtnEl.disabled = true;
            } else {
                relicEquipBtnEl.disabled = false;
                relicEquipBtnEl.textContent = isRelicEquipped(relicId) ? '해제' : '장착';
            }

            // effect / stats
            relicEffectDescEl.textContent = def.special || '';
            relicStatsDescEl.innerHTML = '';
            for (const mod of def.passive || []) {
                const [k, v] = formatRelicStatLine(mod.type, mod.value);
                const row = document.createElement('div');
                row.className = 'stat-line';
                const l = document.createElement('div'); l.textContent = k;
                const r = document.createElement('div'); r.textContent = v;
                row.appendChild(l); row.appendChild(r);
                relicStatsDescEl.appendChild(row);
            }

            // board
            relicBoardEl.innerHTML = '';
            const center = document.createElement('div');
            center.className = 'relic-center';
            const cimg = document.createElement('img');
            cimg.src = RELIC_ICON[relicId] || makeRelicPlaceholder(def.name);
            center.appendChild(cimg);
            relicBoardEl.appendChild(center);

            const slotCount = Math.min(RELIC_SLOT_LAYOUT.length, def.requirements.length);
            for (let i = 0; i < slotCount; i++) {
                const pos = RELIC_SLOT_LAYOUT[i];
                const req = def.requirements[i];
                const filled = ensureRelicEntry(relicId).filled[i] || 0;
                const complete = filled >= req.qty;

                const slot = document.createElement('div');
                slot.className = 'relic-slot ' + (complete ? 'complete ' : '') + (selectedRelicSlotIdx === i ? 'selected' : '');
                slot.style.left = pos.left;
                slot.style.top = pos.top;

                const icon = document.createElement('img');
                icon.src = LOOT_ICON[req.lootId] || '';
                slot.appendChild(icon);

                const cnt = document.createElement('div');
                cnt.className = 'rs-count';
                cnt.textContent = `${Math.min(filled, req.qty)}/${req.qty}`;
                slot.appendChild(cnt);

                const defLoot = LOOT_DEFS[req.lootId];
                const have = getLootCount(req.lootId);
                slot.title = `${defLoot ? defLoot.name : req.lootId}\n보유: ${have}\n필요: ${req.qty}\n\n[회수] 같은 슬롯 재클릭: 1개 / Shift 또는 우클릭: 전부`;

                slot.addEventListener('click', (ev) => {
                    // [NEW] 박아넣은 전리품 회수: 같은 슬롯을 다시 클릭하면 1개(Shift: 전부) 회수
                    if (selectedRelicSlotIdx === i) {
                        const stNow = ensureRelicEntry(relicId);
                        const cur = (stNow.filled[i] || 0);
                        if (cur > 0) {
                            const amt = ev.shiftKey ? 999999 : 1;
                            withdrawLootFromRelicSlot(relicId, i, amt);
                            return;
                        }
                    }
                    selectedRelicSlotIdx = i;
                    renderRelicDetail(relicId);
                });
                slot.addEventListener('contextmenu', (ev) => {
                    ev.preventDefault();
                    withdrawLootFromRelicSlot(relicId, i, 999999);
                });
relicBoardEl.appendChild(slot);
            }

            // unlock check UI refresh
            updateRelicCollectionUI();
        }

        function toggleRelicEquip(relicId) {
            const st = ensureRelicEntry(relicId);
            if (!st.unlocked) {
                showPickupEffect(player.x, player.y - 80, '아직 해금되지 않은 유물입니다.', false, true, 'damage-text');
                return;
            }

            const idx = relicState.equipped.indexOf(relicId);
            if (idx >= 0) {
                relicState.equipped.splice(idx, 1);
                saveRelicsToStorage();
                updateRelicCollectionUI();
                if (currentRelicId === relicId) renderRelicDetail(relicId);
                showPickupEffect(player.x, player.y - 80, `유물 해제: ${getRelicDef(relicId)?.name || relicId}`, false, true, 'heal-text');
                return;
            }

            if (relicState.equipped.length >= RELIC_EQUIP_SLOTS) {
                showPickupEffect(player.x, player.y - 80, `장착 슬롯이 가득 찼습니다. (최대 ${RELIC_EQUIP_SLOTS}개)`, false, true, 'damage-text');
                return;
            }

            relicState.equipped.push(relicId);
            saveRelicsToStorage();
            updateRelicCollectionUI();
            if (currentRelicId === relicId) renderRelicDetail(relicId);
            showPickupEffect(player.x, player.y - 80, `유물 장착: ${getRelicDef(relicId)?.name || relicId}`, false, true, 'heal-text');
        }

        // ---------------------------
        // Inventory → Relic deposit
        // ---------------------------
        function renderRelicInventoryGrid() {
            if (!relicInventoryGridEl || !currentRelicId) return;

            relicInventoryGridEl.innerHTML = '';
            for (let i = 0; i < inventorySlots.length; i++) {
                const slotData = inventorySlots[i];
                const el = document.createElement('div');
                el.className = 'relic-inv-slot ' + (slotData ? '' : 'empty');

                if (slotData) {
                    const img = document.createElement('img');
                    img.src = LOOT_ICON[slotData.id] || '';
                    el.appendChild(img);

                    const c = document.createElement('div');
                    c.className = 'inv-count';
                    c.textContent = slotData.qty;
                    el.appendChild(c);

                    const ld = LOOT_DEFS[slotData.id];
                    el.title = ld ? ld.name : slotData.id;

                    // left click: +1 / shift or right click: max
                    el.addEventListener('click', (ev) => {
                        if (selectedRelicSlotIdx == null) return;
                        const amt = ev.shiftKey ? 999999 : 1;
                        depositLootToSelectedSlot(slotData.id, amt);
                    });
                    el.addEventListener('contextmenu', (ev) => {
                        ev.preventDefault();
                        if (selectedRelicSlotIdx == null) return;
                        depositLootToSelectedSlot(slotData.id, 999999);
                    });
                }

                relicInventoryGridEl.appendChild(el);
            }
        }

        function depositLootToSelectedSlot(lootId, amount) {
            if (!currentRelicId) return;
            const def = getRelicDef(currentRelicId);
            const st = ensureRelicEntry(currentRelicId);
            if (!def) return;
            if (selectedRelicSlotIdx == null) return;

            const req = def.requirements[selectedRelicSlotIdx];
            if (!req) return;

            if (lootId !== req.lootId) {
                const needName = LOOT_DEFS[req.lootId]?.name || req.lootId;
                showPickupEffect(player.x, player.y - 80, `이 슬롯은 "${needName}"만 투입할 수 있습니다.`, false, true, 'damage-text');
                return;
            }

            const have = getLootCount(lootId);
            const needRemain = Math.max(0, req.qty - (st.filled[selectedRelicSlotIdx] || 0));
            const take = Math.min(have, needRemain, Math.max(1, Math.floor(amount)));

            if (take <= 0) {
                showPickupEffect(player.x, player.y - 80, '더 이상 투입할 수 없습니다.', false, true, 'damage-text');
                return;
            }

            if (!consumeLoot(lootId, take)) {
                showPickupEffect(player.x, player.y - 80, '전리품이 부족합니다.', false, true, 'damage-text');
                return;
            }

            st.filled[selectedRelicSlotIdx] = (st.filled[selectedRelicSlotIdx] || 0) + take;
            saveRelicsToStorage();

            // UI refresh
            renderRelicInventoryGrid();
            renderRelicDetail(currentRelicId);
            updateInventoryUI();

            // unlock check
            maybeUnlockRelic(currentRelicId);
        }

        function withdrawLootFromRelicSlot(relicId, slotIndex, amount) {
            if (!relicId) return;
            const def = getRelicDef(relicId);
            const st = ensureRelicEntry(relicId);
            if (!def) return;

            if (st.unlocked) {
                showPickupEffect(player.x, player.y - 80, '해금된 유물에서는 전리품을 회수할 수 없습니다.', false, true, 'damage-text');
                return;
            }

            const req = def.requirements[slotIndex];
            if (!req) return;

            const filled = (st.filled[slotIndex] || 0);
            const take = Math.min(filled, Math.max(1, Math.floor(amount || 1)));

            if (take <= 0) {
                showPickupEffect(player.x, player.y - 80, '회수할 전리품이 없습니다.', false, true, 'weak-text');
                return;
            }

            // 인벤 공간 체크(가득 차면 회수 불가)
            if (!addLootToInventory(req.lootId, take)) {
                showPickupEffect(player.x, player.y - 80, '인벤토리가 가득 찼습니다.', false, true, 'damage-text');
                return;
            }

            st.filled[slotIndex] = Math.max(0, filled - take);
            saveRelicsToStorage();

            const lootName = (LOOT_DEFS[req.lootId] && LOOT_DEFS[req.lootId].name) ? LOOT_DEFS[req.lootId].name : req.lootId;
            showPickupEffect(player.x, player.y - 80, `회수: ${lootName} x${take}`, false, true, 'heal-text');

            // UI refresh
            renderRelicInventoryGrid();
            renderRelicDetail(relicId);
            updateInventoryUI();
            updateRelicCollectionUI();
        }


        function maybeUnlockRelic(relicId) {
            const def = getRelicDef(relicId);
            const st = ensureRelicEntry(relicId);
            if (!def || st.unlocked) return;

            for (let i = 0; i < def.requirements.length; i++) {
                if ((st.filled[i] || 0) < def.requirements[i].qty) return;
            }

            st.unlocked = true;
            saveRelicsToStorage();

            // 능력치 즉시 반영(현재 런)
            applyRelicPassiveBonusesForRelicId(relicId);

            showPickupEffect(player.x, player.y - 90, `유물 해금: ${def.name}`, false, true, 'heal-text');
            updateRelicCollectionUI();
            if (currentRelicId === relicId) renderRelicDetail(relicId);
        }

        // ---------------------------
        // Passive stat application (always-on after unlock)
        // ---------------------------
        function applyRelicStatDelta(type, value) {
            switch (type) {
                case 'atk':
                    player.weapon.baseDamage += value;
                    player.weapon.damage = player.weapon.baseDamage;
                    break;
                case 'hp':
                    player.baseMaxHealth += value;
                    updateMaxHealth();
                    break;
                case 'defense':
                    player.defense += value;
                    break;
                case 'accuracy':
                    player.bonusAccuracy += value;
                    break;
                case 'evasion':
                    player.bonusEvasion += value;
                    break;
                case 'stunChance':
                    player.bonusStunChance += value;
                    break;
                case 'critChance':
                    player.baseCritChance += value;
                    player.critChance = player.baseCritChance;
                    break;
                case 'critResist':
                    player.baseCritResist += value;
                    player.critResist = player.baseCritResist;
                    break;
                case 'critDamage':
                    player.baseCritDamageMultiplier += value;
                    player.critDamageMultiplier = player.baseCritDamageMultiplier;
                    break;
                case 'atkSpeed':
                    player.bonusAttackSpeed += value;
                    player.weapon.baseAutoAttackInterval = Math.max(8, Math.floor(player.weapon.originalAutoAttackInterval / (1 + player.bonusAttackSpeed)));
                    player.weapon.autoAttackInterval = player.weapon.baseAutoAttackInterval;
                    break;
                case 'range':
                    player.weapon.baseLength += value;
                    player.weapon.length = player.weapon.baseLength;
                    break;
                case 'xpGain':
                    player.bonusXpGain += value;
                    break;
                case 'regen':
                    player.baseRegen += value;
                    break;
                case 'moveSpeed':
                    player.baseSpeed += value;
                    player.speed = player.baseSpeed;
                    break;
                case 'luck':
                    luck += value;
                    break;
                case 'skillCooldownReduction':
                    player.permanentSkillCooldownReduction = clamp(player.permanentSkillCooldownReduction + value, 0, 0.75);
                    player.bonusSkillCooldownReduction = player.permanentSkillCooldownReduction; // compatibility
                    break;
                default:
                    break;
            }
        }

        function applyRelicPassiveBonusesFromUnlocked() {
            for (const def of RELIC_DEFS) {
                const st = ensureRelicEntry(def.id);
                if (!st.unlocked) continue;
                for (const mod of def.passive || []) {
                    applyRelicStatDelta(mod.type, mod.value);
                }
            }
        }

        function applyRelicPassiveBonusesForRelicId(relicId) {
            const def = getRelicDef(relicId);
            if (!def) return;
            for (const mod of def.passive || []) {
                applyRelicStatDelta(mod.type, mod.value);
            }
        }

        // ---------------------------
        // Runtime special effects (equipped only)
        // ---------------------------
        function initRelicRuntimeForRun() {
            // cooldowns / timers
            player.relicIllusionBadgeCD = 0;
            player.relicPanshinBoxCD = 0;
            player.relicSorenEyeCD = 0;
            player.relicSorenEyeBuffTimer = 0;
            player.relicSorenEyeBuffValue = 0.10;

            player.relicAncestorAmuletCD = 0;
            player.relicTribeHornCD = 0;

            player.relicChristelGobletCD = 0;

            player.relicWraithTotemTimer = (typeof isRelicEquipped === 'function' && isRelicEquipped('wraith_totem')) ? 60 : 0;
            player.relicPerfumeCaseCD = 0;

            player.relicBarrierCoreCD = 0;

            player.relicPocketWatchTimer = (typeof isRelicEquipped === 'function' && isRelicEquipped('pocket_watch')) ? 900 : 0;
            player.relicAbyssHourglassTimer = (typeof isRelicEquipped === 'function' && isRelicEquipped('abyss_hourglass')) ? 1800 : 0;

            player.relicRedOathRingCD = 0;
            player.relicRedOathRingBuffTimer = 0;
            player.relicRedOathRingBuffValue = 10;

            player.relicSacredBloodLensCD = 0;
            player.relicConfessionSpoolCD = 0;
        }

        function updateRelicRuntime() {
            // cooldowns tick down
            const dec = (k) => { if (player[k] > 0) player[k]--; };

            dec('relicIllusionBadgeCD');
            dec('relicPanshinBoxCD');
            dec('relicSorenEyeCD');
            dec('relicAncestorAmuletCD');
            dec('relicTribeHornCD');
            dec('relicChristelGobletCD');
            dec('relicPerfumeCaseCD');
            dec('relicBarrierCoreCD');
            dec('relicRedOathRingCD');
            dec('relicSacredBloodLensCD');
            dec('relicConfessionSpoolCD');

            // timers
            if (player.relicPocketWatchTimer > 0) player.relicPocketWatchTimer--;
            if (player.relicWraithTotemTimer > 0) player.relicWraithTotemTimer--;
            if (player.relicAbyssHourglassTimer > 0) player.relicAbyssHourglassTimer--;

            // buff timers: 소렌의 눈
            if (player.relicSorenEyeBuffTimer > 0) {
                player.relicSorenEyeBuffTimer--;
                if (player.relicSorenEyeBuffTimer === 0) {
                    player.bonusAccuracy -= player.relicSorenEyeBuffValue;
                }
            }

            // buff timers: 붉은 서약 반지
            if (player.relicRedOathRingBuffTimer > 0) {
                player.relicRedOathRingBuffTimer--;
                if (player.relicRedOathRingBuffTimer === 0) {
                    player.baseCritResist -= player.relicRedOathRingBuffValue;
                    player.critResist = player.baseCritResist;
                }
            }

            // periodic: 포켓워치
            if (isRelicEquipped('pocket_watch')) {
                if (player.relicPocketWatchTimer <= 0) {
                    // trigger
                    const reduce = 60;
                    goddessSkill.cooldown = Math.max(0, goddessSkill.cooldown - reduce);
                    sacredFaithSkill.cooldown = Math.max(0, sacredFaithSkill.cooldown - reduce);
                    limitFocusSkill.cooldown = Math.max(0, limitFocusSkill.cooldown - reduce);
                    novaSkill.cooldown = Math.max(0, novaSkill.cooldown - reduce);
                    divineDashSkill.cooldown = Math.max(0, divineDashSkill.cooldown - reduce);

                    player.relicPocketWatchTimer = 900;
                    showPickupEffect(player.x, player.y - 70, '불협의 메트로놈: 쿨타임 -1s', false, true, 'heal-text');
                }
            } else {
                player.relicPocketWatchTimer = 0;
            }

            // periodic: 망령 토템
            if (isRelicEquipped('wraith_totem')) {
                if (player.relicWraithTotemTimer <= 0) {
                    const removed = cleanseRandomDebuffStacks(1);
                    if (removed > 0) {
                        player.relicWraithTotemTimer = 420; // 7s
                        showPickupEffect(player.x, player.y - 70, '포자 배양관: 디버프 정화', false, true, 'heal-text');
                    } else {
                        // 디버프가 없으면 1초 후 재확인
                        player.relicWraithTotemTimer = 60;
                    }
                }
            } else {
                player.relicWraithTotemTimer = 0;
            }

            // periodic: 심연의 모래시계
            if (isRelicEquipped('abyss_hourglass')) {
                if (player.relicAbyssHourglassTimer <= 0) {
                    // 보호막(노바) 10% / 10s
                    player.novaBarrierValue = Math.max(player.novaBarrierValue, Math.floor(player.maxHealth * 0.10));
                    player.novaBarrierTimer = Math.max(player.novaBarrierTimer, 600);
                    player.relicAbyssHourglassTimer = 1800; // 30s
                    showPickupEffect(player.x, player.y - 70, '진조의 낙인 성유물: 보호막', false, true, 'heal-text');
                }
            } else {
                player.relicAbyssHourglassTimer = 0;
            }
        }

        // 랜덤 디버프 정화(여러 시스템에서 재사용)
        function cleanseRandomDebuffStacks(count) {
            let removed = 0;
            if (count <= 0) return 0;

            // 정화 대상(일부만)
            const keys = [
                'poisonTimers','poopPoisonTimers','maliceTimers','kissTimers','semenTimers','oralTimers',
                'byururutTimers','fractureTimers','blindTimers','paralysisTimers',
                'curseTimers','gnawingLifeTimers','darkScentTimers','darkSmellTimers','darkSeedTimers','darkKissTimers','darkReceiverTimers',
                'fatalScarTimers','corruptedBloodTimers','shadingTimers','darknessTimers','confusionTimers',
                'evilMindTimers','evilLightTimers'
            ].filter(k => Array.isArray(player[k]) && player[k].length > 0);

            for (let i = 0; i < count; i++) {
                const avail = keys.filter(k => player[k] && player[k].length > 0);
                if (!avail.length) break;
                const key = avail[Math.floor(Math.random() * avail.length)];
                player[key].pop();
                removed++;
            }
            if (removed > 0) updateStatusUI();
            if (removed > 0) player._lastCleanseFrame = frameCount;
            return removed;
        }

        // 이벤트 훅들
        function relicOnPlayerDodged(attacker) {
            if (!isRelicEquipped('illusion_badge')) return;
            if (player.relicIllusionBadgeCD > 0) return;
            player.invincibleTimer = Math.max(player.invincibleTimer, 30); // 0.5s
            player.relicIllusionBadgeCD = 180; // 3s
            showPickupEffect(player.x, player.y - 70, '칠흑 장막 브로치: 무적!', false, true, 'heal-text');
        }

        function relicOnEnemyKilled(enemy) {
            if (!Array.isArray(player._gearKillFrames)) player._gearKillFrames = [];
            player._gearKillFrames.push(frameCount);

            // 판신의 마법 상자: 보너스 아이템
            if (isRelicEquipped('panshin_box')) {
                if (player.relicPanshinBoxCD <= 0 && (enemy.isElite || enemy.isRoyal || enemy.isBoss)) {
                    const types = ['health','shield','justice','berserk','magnet'];
                    const t = types[Math.floor(Math.random() * types.length)];
                    spawnDroppedItem(enemy.x, enemy.y, t);
                    player.relicPanshinBoxCD = 480; // 8s
                    showPickupEffect(enemy.x, enemy.y - 60, '장막의 병!', false, true, 'heal-text');
                }
            }
        }

        function relicOnEnemyStunned(enemy) {
            if (!isRelicEquipped('tribe_horn')) return;
            if (player.relicTribeHornCD > 0) return;
            player.shieldStacks += 1;
            player.relicTribeHornCD = 180; // 3s
            updateStatusUI();
            showPickupEffect(player.x, player.y - 70, '절단된 사슬 수갑: 보호막 +1', false, true, 'heal-text');
        }

        function relicOnPlayerDealtCrit() {
            if (!Array.isArray(player._gearCritFrames)) player._gearCritFrames = [];
            player._gearCritFrames.push(frameCount);

            // 소렌의 눈
            if (isRelicEquipped('soren_eye')) {
                if (player.relicSorenEyeCD <= 0) {
                    player.relicSorenEyeCD = 300; // 5s
                    if (player.relicSorenEyeBuffTimer <= 0) {
                        player.bonusAccuracy += player.relicSorenEyeBuffValue;
                    }
                    player.relicSorenEyeBuffTimer = 180; // 3s
                    showPickupEffect(player.x, player.y - 70, '심안의 가면: 집중!', false, true, 'heal-text');
                }
            }
            // 성혈의 렌즈
            if (isRelicEquipped('sacred_blood_lens')) {
                if (player.relicSacredBloodLensCD <= 0) {
                    player.relicSacredBloodLensCD = 300; // 5s
                    const heal = Math.max(1, Math.floor(player.maxHealth * 0.01));
                    player.health = Math.min(player.maxHealth, player.health + heal);
                    showPickupEffect(player.x, player.y - 70, `조준 교정 렌즈: +${heal}`, false, true, 'heal-text');
                    updateHealthUI();
                }
            }
        }

        function relicOnPlayerTookCriticalHit() {
            if (!isRelicEquipped('red_oath_ring')) return;
            if (player.relicRedOathRingCD > 0) return;

            player.relicRedOathRingCD = 600; // 10s

            // critResist buff
            if (player.relicRedOathRingBuffTimer <= 0) {
                player.baseCritResist += player.relicRedOathRingBuffValue;
                player.critResist = player.baseCritResist;
            }
            player.relicRedOathRingBuffTimer = 300; // 5s

            // heal 2%
            const heal = Math.max(1, Math.floor(player.maxHealth * 0.02));
            player.health = Math.min(player.maxHealth, player.health + heal);
            updateHealthUI();

            showPickupEffect(player.x, player.y - 70, '붉은 맹세의 성서: 버팀!', false, true, 'heal-text');
        }

        function relicOnBarrierAbsorbed() {
            if (!isRelicEquipped('barrier_core')) return;
            if (player.relicBarrierCoreCD > 0) return;

            player.relicBarrierCoreCD = 240; // 4s
            player.novaBarrierValue = Math.max(player.novaBarrierValue, 0) + Math.floor(player.maxHealth * 0.05);
            player.novaBarrierTimer = Math.max(player.novaBarrierTimer, 300);
            showPickupEffect(player.x, player.y - 70, '성기사의 바람깃발: 보호막 강화', false, true, 'heal-text');
        }

        function relicOnHealthItemPicked() {
            if (!isRelicEquipped('christel_goblet')) return;
            if (player.relicChristelGobletCD > 0) return;

            const removed = cleanseRandomDebuffStacks(3);
            if (removed > 0) {
                player.relicChristelGobletCD = 300; // 5s
                showPickupEffect(player.x, player.y - 70, '잔향의 수정 성배: 정화!', false, true, 'heal-text');
            }
        }

        function relicOnCleansePicked(totalCleansed) {
            if (!isRelicEquipped('confession_spool')) return;
            if (totalCleansed <= 0) return;
            if (player.relicConfessionSpoolCD > 0) return;
            player.shieldStacks += 2;
            player.relicConfessionSpoolCD = 180; // 3s
            updateStatusUI();
            showPickupEffect(player.x, player.y - 70, '고해실의 실타래: 보호막 +2', false, true, 'heal-text');
        }

        // addStatus에서 사용할 상태이상 조정(향수/조상)
        function relicModifyStatusDuration(name, duration) {
            let d = duration;

            // 향수 케이스(키스 계열) - 장착 시
            if (isRelicEquipped('perfume_case')) {
                const kissTypes = ['kiss','darkKiss','trueAncestorKiss'];
                if (kissTypes.includes(name)) {
                    d = Math.floor(d * 0.75);
                }
            }
            return d;
        }

        function relicShouldCancelStatus(name) {
            // 조상 애뮬릿: 악의 디버프 무효화 + 정의 보호막
            if (isRelicEquipped('ancestor_amulet')) {
                if ((name === 'evilMind' || name === 'evilLight') && player.relicAncestorAmuletCD <= 0) {
                    player.relicAncestorAmuletCD = 600; // 10s
                    player.justiceShield += 1;
                    updateStatusUI();
                    showPickupEffect(player.x, player.y - 70, '사냥꾼의 침전물 표본: 악의 차단!', false, true, 'heal-text');
                    return true;
                }
            }

            // 향수 케이스: 이미 키스가 걸린 상태에서 추가 스택 1회 무효화(2초 내쿨)
            if (isRelicEquipped('perfume_case')) {
                const kissTypes = ['kiss','darkKiss','trueAncestorKiss'];
                if (kissTypes.includes(name) && player.relicPerfumeCaseCD <= 0) {
                    const map = { kiss:'kissTimers', darkKiss:'darkKissTimers', trueAncestorKiss:'trueAncestorKissTimers' };
                    const arrKey = map[name];
                    const arr = player[arrKey];
                    if (Array.isArray(arr) && arr.length > 0) {
                        player.relicPerfumeCaseCD = 120; // 2s
                        showPickupEffect(player.x, player.y - 70, '유혹 차단 향수 케이스: 차단!', false, true, 'heal-text');
                        return true;
                    }
                }
            }

            return false;
        }


// ---------------------------
        // 초기화(페이지 로드 시 1회)
        // ---------------------------
        initGearPanelUI();
        initInventoryUI();
        initSynthesisFxCanvas();
        initEnhanceUI();
        initLootArt();
        // [NEW] 장비 인벤토리/장착 시스템 로드
        loadGearFromStorage();
        initEquipPanelUI();
        updateEquipPanelUI();

        // [NEW] 유물 시스템 로드
        loadRelicsFromStorage();
        initRelicArt();
        initRelicPanelUI();

        updateInventoryUI();
        updateEnhanceUI();

        let performanceState = {
            mode: 'normal',
            enemySpawnMultiplier: 1,
            enemyHardCap: 180,
            projectileStride: 1,
            effectsStride: 1,
            particleStride: 1,
            maxFloatingTexts: 40,
            allowDomEffects: true
        };

        function updatePerformanceState() {
            const loadScore =
                (enemies.length * 2) +
                floatingTexts.length +
                gases.length +
                darkGases.length +
                darkGreenGases.length +
                poops.length +
                bigPoops.length +
                darkBigPoops.length +
                darkSemens.length +
                homingSemens.length +
                whiteshots.length +
                ghosts.length +
                deathClouds.length +
                items.length +
                mindSkulls.length +
                pandemoniums.length +
                hollowNight.length +
                darkHearts.length +
                darkWaves.length +
                pheromoneMarkers.length +
                pleasureZones.length +
                movingGases.length +
                explosions.length +
                phantomSwords.length +
                blackMoons.length +
                deathMetalNotes.length +
                darknessSpotlights.length;

            if (loadScore > 1400) {
                performanceState.mode = 'high';
                performanceState.enemySpawnMultiplier = 2.2;
                performanceState.enemyHardCap = 140;
                performanceState.projectileStride = 2;
                performanceState.effectsStride = 2;
                performanceState.particleStride = 3;
                performanceState.maxFloatingTexts = 25;
                performanceState.allowDomEffects = false;
            } else if (loadScore > 900) {
                performanceState.mode = 'medium';
                performanceState.enemySpawnMultiplier = 1.5;
                performanceState.enemyHardCap = 170;
                performanceState.projectileStride = 1;
                performanceState.effectsStride = 2;
                performanceState.particleStride = 2;
                performanceState.maxFloatingTexts = 35;
                performanceState.allowDomEffects = true;
            } else {
                performanceState.mode = 'normal';
                performanceState.enemySpawnMultiplier = 1;
                performanceState.enemyHardCap = 180;
                performanceState.projectileStride = 1;
                performanceState.effectsStride = 1;
                performanceState.particleStride = 1;
                performanceState.maxFloatingTexts = 40;
                performanceState.allowDomEffects = true;
            }
        }

        startBtn.addEventListener('click', () => {
            startGame();
        });
        gameOverStatsBtn.addEventListener('click', () => {
            updateStatsContent(); // 현재(사망 시점) 스탯 정보 갱신
            document.getElementById('statsInfoBox').style.display = 'block'; // 스탯창 열기
        });
        function startGame() {
            isGameRunning = true;
            score = 0;
            gameOverStatsBtn.style.display = 'none';
            killCount = 0;
            frameCount = 0;
            activeAkiCount = 0; 
            killVal.innerText = 0;
            
            // [신규] 인벤토리/강화 레벨은 localStorage로 유지 (사망/재시작 후에도)
            // (세션성: 강화 재료 슬롯/예약 상태만 리셋)
            resetEnhancePanelSession(false);
            
            player.baseMaxHealth = 400; 
            player.maxHealth = 400; 
            player.health = player.maxHealth;
            player.x = canvas.width / 2;
            player.y = canvas.height / 2;
            
            // [수정 위치 1] 플레이어 기본 방어력 설정
            player.defense = 2; // 이 숫자를 올리면 시작 방어력이 높아집니다.
            player.baseRegen = 2;
            player.regen = 2;
            
            // [버그픽스] 게임 재시작 시 치명타 스탯(확률/배율/저항)이 누적되어 초기화되지 않던 문제 수정
            // 기본값은 플레이어 초기 스탯과 동일하게 강제 초기화합니다.
            player.baseCritChance = 25;
            player.baseCritResist = 15;
            player.baseCritDamageMultiplier = 1.5;

            player.critChance = player.baseCritChance;
            player.critResist = player.baseCritResist;
            player.critDamageMultiplier = player.baseCritDamageMultiplier;
            player.corruptedOathStacks = 0;
            player.dangerousJudgmentStacks = 0;
            player.deepDarknessStacks = 0;
            player.corruptedJusticeStacks = 0;
            player.deathBrandTimers = [];
            player.poisonTimers = [];
            player.poopPoisonTimers = [];
            player.maliceTimers = []; 
            player.kissTimers = [];
            player.semenTimers = [];
            player.oralTimers = [];
            player.byururutTimers = [];
            player.evilMindTimers = [];
            player.curseTimers = [];
            player.gnawingLifeTimers = [];
            player.fishyTimers = []; 
            player.darkScentTimers = [];
            player.darkSmellTimers = [];
            player.darkSeedTimers = [];
            player.darkKissTimers = [];
            player.darkReceiverTimers = [];
            player.evilLightTimers = []; 
            player.darkEcstasyTimers = [];
            player.bleedingTimers = [];
            player.shadingTimers = [];
            player.blasphemyTimers = []; // 신성 모독 타이머
            player.inPinkGas = false; // 최음 가스 안에 있는지 여부
            player.blindTimers = [];
            player.paralysisTimers = [];
            player.geoptalCount = 0;
            player.hasHypersensitivity = false;
            player.bonusAccuracy = 0;
            player.bonusEvasion = 0;
            player.bonusXpGain = 0;
            player.bonusSkillCooldownReduction = 0;

            player.permanentSkillCooldownReduction = 0;
            player.bonusStunChance = 0;

            player.majestyActive = false;
            player.trueAncestorKissTimers = [];
            player.fatalScarTimers = [];
            player.corruptedBloodTimers = [];
            player.darknessTimers = [];
            player.confusionTimers = [];
            player.pheromoneOverloadTimer = 0;
            player.pheromoneOverloadCritCount = 0;
            player.darknessOverwhelmActive = false;
            pheromoneOverloadStatus.style.display = 'none';
            darknessOverwhelmStatus.style.display = 'none';
            player.fractureTimers = [];
            fractureStatus.style.display = 'none';
            shadowGrips = [];
            // player.paralysisStacks = 0; // [삭제]
            player.rootTimer = 0;
            player.skillSealTimer = 0;
            
            player.stunTimer = 0;
            player.evilMindGasTimer = 0;
            player.semenCooldown = 0;
            player.oralCooldown = 0;
            player.darkReceiverCooldown = 0;
            player.byururutCooldown = 0;
            player.deathCloudTimer = 0;
            player.bodyHitCooldown = 0; 
            player.shieldStacks = 0; 
            player.justiceShield = 0;
            player.novaBarrierValue = 0;
            player.novaBarrierTimer = 0;
            player.slowedByCloud = false;
            player.invincibleTimer = 0;
            player.berserkTimer = 0;
            player.defenseBroken = false;
            
            player.goddessSkill.cooldown = 0; 
            updateGoddessSkillUI();

            player.sacredFaithSkill.cooldown = 0;
            player.sacredFaithSkill.activeTimer = 0;
            updateSacredFaithUI();
          
            player.limitFocusSkill.cooldown = 0;
            player.limitFocusSkill.activeTimer = 0;
            updateLimitFocusUI();

            player.novaSkill.cooldown = 0;
            updateNovaUI();

            player.divineDashSkill.cooldown = 0;
            player.dashTimer = 0;
            updateDivineDashUI();

            xp = 0;
            maxXp = 10;
            level = 1;
            luck = 0;
            rerollCount = 0;
            isLevelUpPaused = false;
            document.getElementById('level-text').innerText = 'Lv.1';
            document.getElementById('xp-bar').style.width = '0%';
            document.getElementById('levelUpModal').style.display = 'none';

            player.baseSpeed = 5.125;
            player.speed = player.baseSpeed; 
            player.weapon.isAttacking = false;
            player.weapon.cooldown = 0;
            player.weapon.autoTimer = 0;
            player.weapon.buffTimer = 0;
            player.weapon.baseDamage = 24;
            player.weapon.damage = 24;
            player.weapon.baseLength = 280; 
            player.weapon.length = 280;
            player.weapon.color = 'black';
            player.weapon.originalAutoAttackInterval = 29; // 원본값 복구
            player.weapon.baseAutoAttackInterval = 29;     // 베이스 복구
            player.weapon.autoAttackInterval = 29;         // 현재값 복구
            player.bonusAttackSpeed = 0;                   // 보너스 수치 초기화
            
            poopOverlay.style.opacity = 0;
            mindOverlay.style.opacity = 0;
            darknessOverlay.style.opacity = 0; 
            sacredFaithOverlay.style.opacity = 0;
            bloodOverlay.style.opacity = 0;
            visionOverlay.style.opacity = 0;
            skillSealOverlay.style.display = 'none';
            goddessSealOverlay.style.display = 'none';
            sacredFaithSealOverlay.style.display = 'none';
            novaSealOverlay.style.display = 'none';
            divineDashSealOverlay.style.display = 'none';

            enemies = [];
            gases = [];
            darkGases = [];
            darkGreenGases = [];
            poops = []; 
            bigPoops = [];
            darkBigPoops = [];
            darkSemens = [];
            homingSemens = [];
            poopStains = []; 
            whiteshots = [];
            fartSmogs = []; // [신규] 오즈마: 방구 스모그
            ghosts = [];
            deathClouds = []; 
            items = [];
            mindSkulls = [];
            stickyCreamPuddles = [];
            pandemoniums = []; 
            hollowNight = [];
            darkHearts = [];
            darkWaves = [];
            pheromoneMarkers = [];
            pleasureZones = []; 
            shockwaves = [];
            groundCracks = [];
            dragShots = [];
            evilArrows = [];
            poisonousShots = [];
            jammingWaves = [];
            neuroNeedles = [];
            bloodBats = [];
            bloodPuddles = [];
            excaliburSlashes = [];
            slashTrails = [];
            blinkMines = [];
            chaosOrbs = [];
            pinkGases = [];
            darkNotes = [];
            pianissimoSnipes = [];
            cursedCatastrophes = [];
            soulHarvestSlashes = [];
            prismSweeps = [];
            occlusionSpools = [];
            movingGases = [];
            explosions = [];
            blackMoons = [];
            maliceBallistics = [];
            antiPassingTentacles = [];
            darknessSpotlights = [];
            tetoraRequiemActive = false;
            tetoraRhapsodyActive = false;

            document.getElementById('blasphemyStatus').style.display = 'none';
            document.getElementById('blasphemyIcon').src = blasphemyIconSrc;

            player.despairTimer = 0;
            player.baptismStacks = 0;
            player.netherGrabbedBy = null;
            darkMatters = [];
            confessionalTotems = [];
            despairStatus.style.display = 'none';
            baptismStatus.style.display = 'none';

            startTime = Date.now();
            lastScoreTime = Date.now();
            overlay.style.display = 'none';
            updateHealthUI();
            updateStatusUI();
            
            bgmAudio.currentTime = 0;
            bgmAudio.play().catch(e => console.log("Audio play failed:", e));
            
            clearTimeout(itemSpawnTimeout);

            // [NEW] 열려있는 패널 강제 닫기
            if (typeof closeGearPanel === 'function' && isGearPanelOpen) closeGearPanel(false);
            if (typeof closeEquipPanel === 'function' && isEquipPanelOpen) closeEquipPanel(false);
            if (typeof closeRelicPanel === 'function' && isRelicPanelOpen) closeRelicPanel(false);
            score = 0;
            enemyTimer = 0;
            royalSpawnTimer = 0;
            lastScoreTime = Date.now();

            // [NEW] 저장된 강화 레벨 보너스 재적용
            applyEnhanceBonusesFromLevels();
            // [NEW] 저장된 장비(Equipment) 보너스 재적용
            applyEquippedGearBonuses(true);

            // [NEW] 해금된 유물 능력치(항상 적용) 반영 + 런타임(특수효과) 초기화
            applyRelicPassiveBonusesFromUnlocked();
            initRelicRuntimeForRun();

            // [NEW] 시작 시 최대 체력으로 회복(지속 보너스/유물/장비 반영 후)
            player.health = player.maxHealth;
            updateHealthUI();

            for (let i = 0; i < 2; i++) { spawnEnemy(true); }
            animate();
            // (삭제) 맵 자연 스폰 아이템 비활성화
}
        
        function addStatus(name, duration, maxStacks) {
            // [NEW] 유물 특수 효과: 상태이상 무효화(장착 시)
            if (typeof relicShouldCancelStatus === 'function' && relicShouldCancelStatus(name)) {
                return false;
            }

            if (name === 'evilMind' && checkShieldBlockStatus('evil')) {
                return false;
            }

            if (hasEquippedNamedGear('현실 도피의 인장')) {
                if (Math.random() < 0.03) {
                    showDamageText(player.x, player.y, 'IGNORE', false, false, 'weak-text');
                    return false;
                }
                if (Math.random() < 0.01) duration += 600;
            }

            // [NEW] 엔젤릭 고정 옵션: 디버프 회피 확률
            if (name === 'poison' && (player.poisonAvoidChance || 0) > 0 && Math.random() < (player.poisonAvoidChance || 0)) {
                showDamageText(player.x, player.y, "RESIST", false, false, "weak-text");
                return false;
            }
            if (name === 'darkness' && (player.darknessAvoidChance || 0) > 0 && Math.random() < (player.darknessAvoidChance || 0)) {
                showDamageText(player.x, player.y, "RESIST", false, false, "weak-text");
                return false;
            }
            if (name === 'evilMind' && (player.evilMindAvoidChance || 0) > 0 && Math.random() < (player.evilMindAvoidChance || 0)) {
                showDamageText(player.x, player.y, "RESIST", false, false, "weak-text");
                return false;
            }

            let finalDuration = duration;
            if (['poison', 'poopPoison', 'malice', 'kiss', 'semen', 'oral', 'byururut', 'fishy'].includes(name)) finalDuration += 600;
            if (['darkScent', 'darkSmell', 'darkSeed', 'darkKiss', 'darkReceiver'].includes(name)) finalDuration += 600;
            if (['evilMind', 'curse'].includes(name)) finalDuration += 900; 
            if (name === 'gnawingLife') finalDuration = 1800; 
            if (name === 'blind') finalDuration = 900; // 실명 15초
            if (name === 'paralysis') finalDuration = 900; // [수정] 마비 15초 (900프레임) 설정
            if (name === 'malice') finalDuration = 1800;

            if (name === 'deathBrand') finalDuration = 600;
            if (name === 'bleeding') finalDuration = 600; // 기본 지속시간
            if (name === 'shading') finalDuration = 600;   // 10초
            // [신규] 아서 디버프 지속시간
            if (['trueAncestorKiss', 'fatalScar', 'corruptedBlood'].includes(name)) finalDuration = 1800; // 30초


            if (name === 'darkScent') finalDuration = Math.max(1, Math.floor(finalDuration * (player.darkScentDurationMultiplier || 1)));
            if (name === 'darkSmell') finalDuration = Math.max(1, Math.floor(finalDuration * (player.darkSmellDurationMultiplier || 1)));
            if (name === 'poison') finalDuration = Math.max(1, Math.floor(finalDuration * (player.gasPoisonDurationMultiplier || 1)));
            if (name === 'bleeding') finalDuration = Math.max(1, Math.floor(finalDuration * (player.bleedDurationMultiplier || 1)));
            if (name === 'malice') finalDuration = Math.max(1, Math.floor(finalDuration * (player.maliceDurationMultiplier || 1)));


            if (name !== 'kiss' && player.kissTimers.length > 0) {
                finalDuration += (player.kissTimers.length * 30);
            }

            // [NEW] 장비 특수옵션: 디버프 지속시간 감소
            if (name === 'bleeding') {
                const r = (player.reduceBleedDuration || 0);
                if (r > 0) finalDuration = Math.max(1, Math.floor(finalDuration * (1 - r)));
            }
            if (name === 'darkness') {
                finalDuration += (player.darknessDurationBonus || 0);
                const r = (player.reduceDarknessDuration || 0);
                if (r > 0) finalDuration = Math.max(1, Math.floor(finalDuration * (1 - r)));
            }

            // [NEW] 유물 특수 효과: 지속시간 조정(장착 시)
            if (typeof relicModifyStatusDuration === 'function') {
                finalDuration = relicModifyStatusDuration(name, finalDuration);
            }

            const timers = player[name + 'Timers'];
            if (name === 'darkEcstasy' || name === 'gnawingLife') {
                const cap = (name === 'gnawingLife') ? 15 : 5;
                if (timers.length < cap) timers.push(finalDuration); 
                else timers[0] = finalDuration; 
            } else if (name === 'evilLight' || name === 'byururut') {
                timers.push(finalDuration);
            } else {
                timers.push(finalDuration);
                if (timers.length > maxStacks) {
                    timers.shift(); 
                }
            }
            
            if (name === 'evilMind' || name === 'evilLight') updateMaxHealth();
            updateStatusUI();
            return true;
        }
        
        function checkShieldBlockStatus(type = 'normal', statusName = null) {
            if (type === 'normal') {
                const statusShieldCost = {
                    kiss: 2,
                    poison: 1,
                    poopPoison: 1,
                    fishy: 1,
                    darkness: 10,
                    malice: 2,
                    byururut: 2,
                    semen: 2,
                    oral: 2,
                    blind: 5
                };
                const shieldCost = statusShieldCost[statusName] || 1;
                if (player.shieldStacks >= shieldCost) {
                    player.shieldStacks -= shieldCost;
                    updateStatusUI();
                    showPickupEffect(player.x, player.y - 30, `상태이상 방어! (-${shieldCost})`, false);
                    return true;
                }
            } else if (type === 'evil') {
                if (player.justiceShield > 0) {
                    player.justiceShield--;
                    updateStatusUI();
                    showPickupEffect(player.x, player.y - 30, "정의의 방어!", false);
                    return true;
                }
            }
            return false;
        }

        function gameOver() {
            isGameRunning = false;
            cancelAnimationFrame(animationId);
            clearTimeout(itemSpawnTimeout);
            
            bgmAudio.pause();
            cainAudio.pause();
            touyaAudio.pause();
            pandemoniumAudio.pause();
            arthurAudio.pause();
            
            document.querySelector('.title').innerHTML = "어둠에 먹혔다..♡";
            document.querySelector('.subtitle').innerHTML = `버틴 시간: ${score}초 | 처치: ${killCount}명`;
            startBtn.innerText = "다시 도전";
            gameOverStatsBtn.style.display = 'inline-block';
            overlay.style.display = 'flex';
        }
        
     function getColorFromClass(className, defaultColor) {
    const colorMap = {
        'crit-text': '#ff3333',
        'weak-text': '#cccccc',
        'gnawing-life-text': '#6B8E23',
        'heal-text': '#7FFF00',
        'block-text': '#FFFF00',
        'sticky-text': '#fffdd0',
        'sticky-large-text': '#fffdd0',
        'unwashed-text': '#F0F8FF',
        'condensed-milk-text': '#FFFDD0',
        'dirty-pink-text': '#d45d7d',
        'dirty-brown-text': '#8B4513',
        'pink-text': '#FF69B4',
        'deep-pink-text': '#FF1493',
        'evil-purple-text': '#8A2BE2',
        'shadow-text': '#2F4F4F',
        'poop-text': '#5c4033',
        'evil-summon-text': '#9400D3',
        'wicked-large-text': '#3d004d',
        'boss-warning-text': '#ff0000',
        'mind-break-text': '#800080',
        'pregnancy-text': '#8A2BE2',
        'evil-shout-text': '#8A2BE2',
        'choke-text': '#2F4F4F',
        'fishy-text': '#7FFFD4',
        'hollow-night-text': '#9370DB',
        'malice-text': '#8A2BE2',
        'corrupted-text': '#8B0000',
        'sniper-text': '#FFFFFF',
        'ozma-text': '#FF00FF',
        'gawain-text': '#9370DB',
        'aki-text': '#1a1a1a',
        'hiro-text': '#9932CC',
        'arthur-text': '#DC143C',
        'goddess-text': '#FFD700',
        'crit-damage-text': '#FFFF00',
        'player-crit-text': '#FF0000',
        'enemy-curse-text': '#8A2BE2',
        'enemy-purifying-poison-text': '#ADFF2F'
    };

    if (colorMap[className]) return colorMap[className];
    
    // 포함된 단어로 대략적인 색상 유추
    if (className.includes('pink')) return '#FF69B4';
    if (className.includes('poop')) return '#8B4513';
    
    return defaultColor;
} 

       function showDamageText(x, y, text, isCrit, isRear, customClass) {
    if (floatingTexts.length >= performanceState.maxFloatingTexts) return;
    let color = '#ffcc00'; // 기본 노랑
    let size = 24;
    let borderColor = '#000000'; // 기본 테두리 검정
    
    if (isCrit) {
        color = '#FFFF00'; // 크리티컬 노랑
        size = 32;
        text += "!";
        borderColor = '#8B0000'; // 크리티컬은 붉은 테두리 느낌
    } else if (isRear) {
        color = '#cccccc'; // 후방 회색
        size = 18;
    }
    
    // 커스텀 클래스가 있으면 색상 덮어쓰기
    if (customClass) {
        color = getColorFromClass(customClass, color);

        // 플레이어가 '피격 크리티컬'을 맞았을 때만 크게/더 눈에 띄게
        if (customClass === 'player-crit-text') {
            size = Math.max(size, 48);
            borderColor = '#FFFF00';
        }
    }

    floatingTexts.push({
        x: x,
        y: y,
        text: text,
        life: 100,       
        maxLife: 100,
        vy: -1.5,       
        color: color,
        size: size,
        borderColor: borderColor,
        isCrit: isCrit
    });
}
        function showPickupEffect(x, y, text, isGood, isBig = false, customClass = '') {
    if (floatingTexts.length >= performanceState.maxFloatingTexts) return;
    let color = isGood ? '#00ff00' : '#ff4d4d';
    let size = isBig ? 40 : 30;
    
    // 커스텀 클래스가 있으면 색상 덮어쓰기
    if (customClass) {
        color = getColorFromClass(customClass, color);
    }
    
    floatingTexts.push({
        x: x,
        y: y,
        text: text,
        life: 100,
        maxLife: 100,
        vy: -1.0,
        color: color,
        size: size,
        borderColor: '#000000'
    });
}
        
        function showVillainSpeech(x, y, text) {
            if (!performanceState.allowDomEffects) return;
            const el = document.createElement('div');
            el.className = 'villain-speech';
            el.style.left = x + 'px';
            el.style.top = y + 'px';
            el.innerText = text;
            document.body.appendChild(el);
            setTimeout(() => el.remove(), 1500);
        }

        function spawnGhost(x, y, radius, rotation, img, isElite) {
            ghosts.push({ x: x, y: y, radius: radius, rotation: rotation, img: img, life: 15, maxLife: 15, isElite: isElite });
        }
        function updateGhosts() {
            for (let i = ghosts.length - 1; i >= 0; i--) {
                const g = ghosts[i]; g.life--; if (g.life <= 0) ghosts.splice(i, 1);
            }
        }

       function spawnBoss() {
            let x, y;
            if (Math.random() < 0.5) {
                x = Math.random() < 0.5 ? -100 : canvas.width + 100;
                y = Math.random() * canvas.height;
            } else {
                x = Math.random() * canvas.width;
                y = Math.random() < 0.5 ? -100 : canvas.height + 100;
            }

            if (Math.random() < 0.5) {
                spawnArthur(x, y);
                return;
            }

            let bossType = Math.floor(Math.random() * 5);
            let hp = 850; // 360 * 2.5
            let defense = 5; // 카인 기본 방어 

            hp = getEnemySpawnHp(hp);
if (bossType === 4) {
                 for (let k = 0; k < 3; k++) addStatus('darkReceiver', 900, 20);
                 showPickupEffect(player.x, player.y, "넌 내 좆집이다!", false, false, "evil-shout-text");
            }

            cainAudio.currentTime = 0;
            cainAudio.play().catch(()=>{});

            const initialSummonTimer = 2340; 
            const bossRadius = 100;
            const boss = {
                x: x, y: y, radius: bossRadius, baseRadius: bossRadius, 
                baseSpeed: 1.3, 
                speed: 0, vx: 0, vy: 0,
                
                // [수정] 카인: 명중 10%, 회피 10%
                accuracy: 0.10, evasion: 0.10,

                critChance: 25, critResist: 15,
                
                darkGasTimer: 0, darkBigPoopTimer: 0, darkSemenScatterTimer: 0, darkTargetSemenTimer: 0, darkNormalSemenTimer: 0,
                summonTimer: 0, consumeTimer: 0, regenTimer: 0, mindBreakTimer: Math.random() * 480, tanetsukeTimer: 0, tanetsukeTeleportTimer: 0, darkGasExtraTimer: 0,
                demonSummonTimer: initialSummonTimer, hollowNightTimer: 0, 
                angle: 0, isElite: true, isBoss: true, isZako: false, maxHp: hp, hp: hp, defense: defense,
                hitFlash: 0, erectionStacks: 0, erectionTimer: 0, passiveErectionTimer: 0, contactStackTimer: 0, 
                bossType: bossType, buffType: -1, alpha: 1.0, dashTimer: 0, dashVx: 0, dashVy: 0,
                stunTimer: 0, gasExplosionTimer: 900, devilsProtectionTimer: 840, protectionTarget: null, evilDigestTimer: 960, isEvilDigestActive: false, evilDigestDuration: 0, devilsProtectionDuration: 0
            };
            enemies.push(boss);
            
            let bossName = "";
            if (bossType === 0) bossName = "방구킹 카인 (블랙 미스트)";
            else if (bossType === 1) bossName = "방구킹 카인 (다크 테러리스트)";
            else if (bossType === 2) bossName = "방구킹 카인 (테러블 자멘)";
            else if (bossType === 3) bossName = "방구킹 카인 (호러블 네크로맨서)";
            else if (bossType === 4) bossName = "방구킹 카인 (타네츠케 데빌)";

            showPickupEffect(player.x, player.y - 100, `WARNING: ${bossName}!!`, false, false, "boss-warning-text");
        }
        
        function spawnArthur(x, y) {
            let hp = 790; // 330 * 2.5
            let defense = 5; // 아서 기본 방어
            hp = getEnemySpawnHp(hp);
arthurAudio.currentTime = 0;
            arthurAudio.play().catch(()=>{});
            const boss = {
                x: x, y: y, radius: 100, baseRadius: 100,
                baseSpeed: 1.0, speed: 0, vx: 0, vy: 0,
                
                // [수정] 아서: 명중 5%, 회피 5% (유지)
                accuracy: 0.05, evasion: 0.05,

                critChance: 25, critResist: 15,
                
                isElite: true, isBoss: true, isArthur: true,
                maxHp: hp, hp: hp, defense: defense,
                hitFlash: 0, erectionStacks: 0, alpha: 1.0,
                
                bloodDrainTimer: 0,
                excaliburTimer: 0,
                bloodSwarmTimer: 0,
                arthurSummonTimer: 0, 
                initialSummonTimer: 420,
                stunTimer: 0
            };
            enemies.push(boss);
            
            player.majestyActive = true;
            updateStatusUI();
            bloodOverlay.style.opacity = 1;
            setTimeout(() => { 
                if(isGameRunning) bloodOverlay.style.opacity = 0; 
            }, 4000);

            showPickupEffect(player.x, player.y - 100, "WARNING: 타락한 킹 아서!!", false, false, "arthur-text");
            showPickupEffect(player.x, player.y - 50, "군주의 위엄 (쿨감 감소)", false, true, "majesty-border");
        }
        
      

        // [신규] 박쥐 투사체 생성
       function spawnBloodBat(x, y, owner, accuracy = 0) {
    bloodBats.push({
        x: x, y: y,
        owner: owner,
        speed: 3,
        radius: 60,
        life: 300,
        angle: Math.atan2(player.y - y, player.x - x),
        accuracy: accuracy // [추가]
    });
}
        
      function spawnBloodPuddle(x, y, owner, accuracy = 0) {
    bloodPuddles.push({
        x: x, y: y,
        radius: 290,
        owner: owner,
        life: 480,
        tickTimer: 0,
        accuracy: accuracy // [추가]
    });
}

        // ... (이하 기존 함수들 그대로 유지) ...

        function spawnArchdemons(x, y) {
            spawnArchdemonUnit(0, canvas.height / 2, 0, '대악마 아키토');
            spawnArchdemonUnit(canvas.width, canvas.height / 2, 2, '대악마 토우야');
        }

       function spawnArchdemonUnit(x, y, bossType, name) {
            const radius = 85;
            let baseHp = 425; // 170 * 2.5
            let baseDefense = 3;

            const currentHp = getEnemySpawnHp(baseHp);
            const currentDefense = (name.includes('아키토') || name.includes('토우야')) ? 3 : 0;
// [수정] 대악마 스탯 설정
            let accuracy = 0;
            let evasion = 0;
            if (name.includes('아키토')) {
                accuracy = 0.10; evasion = 0.05; // 아키토: 명중 10%, 회피 5%
            } else if (name.includes('토우야')) {
                accuracy = 0.05; evasion = 0.10; // 토우야: 명중 5%, 회피 10%
            }

            const unit = {
                x: x, y: y, radius: radius, baseRadius: radius,
                baseSpeed: 1.04, speed: 0, vx: 0, vy: 0,
                
                // [추가]
                accuracy: accuracy,
                evasion: evasion,
                // [신규] 상태이상 저항(기절 확률과 상쇄)
                baseStatusResist: 0,
                statusResist: 0,

                critChance: 25, critResist: 15,
                
                darkGasTimer: 0, darkBigPoopTimer: 0, darkSemenScatterTimer: 0, darkTargetSemenTimer: 0, darkNormalSemenTimer: 0,
                mindBreakTimer: 0, tanetsukeTimer: 0, tanetsukeTeleportTimer: 0, darkGasExtraTimer: 0,
                pandemoniumTimer: 0, evilLightTimer: 0, appliedEvilLightCount: 0,
                darkServiceCooldown: 0, darkServicePulseTimer: 0, darkServiceEcstasyTimer: 0,
                angle: 0, isElite: true, isBoss: true, isArchdemon: true, archdemonName: name, bossType: bossType, 
                isZako: false, maxHp: currentHp, hp: currentHp, defense: currentDefense,
                hitFlash: 0, erectionStacks: 0, erectionTimer: 0, passiveErectionTimer: 0, contactStackTimer: 0,
                buffType: -1, eliteType: -1, alpha: 1.0, dashTimer: 0, dashVx: 0, dashVy: 0,
                stunTimer: 0
            };
            enemies.push(unit);
            
            if (name.includes('토우야')) {
                setTimeout(() => triggerEvilLight(unit), 500);
                touyaAudio.currentTime = 0;
                touyaAudio.play().catch(()=>{});
            } else if (name.includes('아키토')) {
                setTimeout(() => {
                    pandemoniumAudio.currentTime = 0;
                    pandemoniumAudio.play().catch(()=>{});
                }, 3000);
            }
        }
        
        function spawnMinionRapist(x, y) {
             if (enemies.length >= performanceState.enemyHardCap) return;
             const traitRoll = Math.random();
             let isStealth = false;
             let isAmbush = false;
             if (traitRoll < 0.33) isStealth = true;
             else if (traitRoll < 0.66) isAmbush = true;
             
             let hp = 163; // 65 * 2.5
             let defense = 0;
             
             if (isAmbush) { hp = 163; defense = 1; }
             else if (isStealth) { hp = 138; defense = 1; }
             
             hp = getEnemySpawnHp(hp);
             let baseSpeed = 1.3;
             
             const enemy = {
                x: x, y: y, radius: 45, baseRadius: 45, 
                baseSpeed: baseSpeed, speed: 0, vx: 0, vy: 0,
                accuracy: 0, evasion: 0.05,
                critChance: 25, critResist: 15,
                
                gasTimer: 0, gasInterval: 9999,
                bigPoopTimer: 0, scatterTimer: 0, whiteShotTimer: 0, summonTimer: 0, 
                regenTimer: 0, homingPoopTimer: 0, angle: 0, isElite: false, isZako: false, 
                maxHp: hp, hp: hp, defense: defense,
                hitFlash: 0, erectionStacks: 0, erectionTimer: 0, passiveErectionTimer: 0, contactStackTimer: 0, 
                buffType: -1, eliteType: -1, stealthTimer: 0, alpha: 1.0, dashTimer: 0, dashVx: 0, dashVy: 0,
                normalType: 'rapist', isAttached: false, attachTimer: 0, isStealth: isStealth, isAmbush: isAmbush,
                ambushState: 'approach', ambushTimer: 0,
                stunTimer: 0
            };
            enemy.speed = enemy.baseSpeed;
            enemies.push(enemy);
        }

        function spawnEnemy(isElite, forcedEliteName = null, fixedX = null, fixedY = null) {
            if (!isElite && enemies.length >= performanceState.enemyHardCap) return;
            let x, y;
            let normalType = 'summoner';
            let isStealth = false;
            let isAmbush = false;
            let isAgent = false;
            let agentType = "";
            
            // ... (기존 타입 결정 로직 유지) ...
            if (!isElite) {
                if (Math.random() < 0.2) {
                    isAgent = true;
                    const rand = Math.random();
                    if (rand < 0.33) agentType = 'curse';
                    else if (rand < 0.66) agentType = 'pain';
                    else agentType = 'blind';
                } else {
                    if (Math.random() < 0.5) {
                        normalType = 'rapist';
                        const traitRoll = Math.random();
                        if (traitRoll < 0.33) isStealth = true;
                        else if (traitRoll < 0.66) isAmbush = true;
                    }
                }
            }
            
            let eliteType = -1;
            let buffType = -1;
            let hp = 163; // 65 * 2.5
            let defense = 0; 
            let radius; 
            let isRyuon = false;
            let isLuca = false; 
            let isOzma = false; 
            let isTaro = false;
            let isGawain = false; 
            let isAki = false;
            let isHiro = false;
            let isKai = false;
            let isJacques = false;
            let isCassias = false;

            // [수정] 명중률, 회피율 변수 초기화
            let accuracy = 0;
            let evasion = 0;

                        if (isElite) {
                // [추가] 강제 엘리트 소환 지원 (아서 소환 등)
                if (forcedEliteName) {
                    const n = forcedEliteName;

                    // ※ 이름은 기존 아서 소환에서 쓰던 'Ryuon', 'Gawain' 등을 그대로 사용
                    if (n === 'Aki') {
                        isAki = true; hp = 290; defense = 2; radius = 70; // 130 * 2.5
                        accuracy = 0.05; evasion = 0.08;
                    } else if (n === 'Gawain') {
                        isGawain = true; hp = 350; defense = 2; radius = 70; // 160 * 2.5
                        accuracy = 0.01; evasion = 0.04;
                    } else if (n === 'Taro') {
                        isTaro = true; hp = 300; defense = 2; radius = 70; // 140 * 2.5
                        accuracy = 0.05; evasion = 0.10;
                    } else if (n === 'Ozma') {
                        isOzma = true; hp = 275; defense = 1; radius = 70; // 120 * 2.5
                        accuracy = 0.03; evasion = 0.02;
                    } else if (n === 'Luca') {
                        isLuca = true; hp = 290; defense = 2; radius = 70; // 130 * 2.5
                        accuracy = 0.05; evasion = 0.08;
                    } else if (n === 'Ryuon') {
                        isRyuon = true; hp = 375; defense = 3; radius = 70; // 170 * 2.5
                        accuracy = 0.01; evasion = 0.04;
                    } else if (n === 'Hiro') {
                        isHiro = true; hp = 320; defense = 2; radius = 70; // 140 * 2.5
                        accuracy = 0.05; evasion = 0.05;
                    } else if (n === 'Kai') {
                        isKai = true; hp = 230; defense = 1; radius = 70; // 100 * 2.5
                        accuracy = 0.03; evasion = 0.02;
                    } else if (n === 'Jacques') {
                        isJacques = true; hp = 275; defense = 1; radius = 70; // 120 * 2.5
                        accuracy = 0.03; evasion = 0.02;
                    } else {
                        // 카시아스 (통합)
                        isCassias = true;
                        hp = 335; defense = 2; radius = 70; // 150 * 2.5
                        accuracy = 0.03; evasion = 0.03;
                    }
                } else {
                    const rand = Math.random();
                    // 확률 분포에 따라 엘리트 결정
                    if (rand < 0.10) {
                        isAki = true; hp = 290; defense = 2; radius = 70; // 130 * 2.5
                        accuracy = 0.05; evasion = 0.08; // 아키: 명중 5%, 회피 8% (상향)
                    } else if (rand < 0.20) {
                        isGawain = true; hp = 350; defense = 2; radius = 70; // 160 * 2.5
                        accuracy = 0.01; evasion = 0.04; // 가웨인: 명중 1%, 회피 4% (하향)
                    } else if (rand < 0.30) {
                        isTaro = true; hp = 300; defense = 2; radius = 70; // 140 * 2.5
                        accuracy = 0.05; evasion = 0.10; // 타로: 명중 5%, 회피 10%
                    } else if (rand < 0.40) {
                        isOzma = true; hp = 275; defense = 1; radius = 70; // 120 * 2.5
                        accuracy = 0.03; evasion = 0.02; // 오즈마: 명중 3%, 회피 2%
                    } else if (rand < 0.50) {
                        isLuca = true; hp = 290; defense = 2; radius = 70; // 130 * 2.5
                        accuracy = 0.05; evasion = 0.08; // 루카: 명중 5%, 회피 8%
                    } else if (rand < 0.60) {
                        isRyuon = true; hp = 375; defense = 3; radius = 70; // 170 * 2.5
                        accuracy = 0.01; evasion = 0.04; // 류온: 명중 1%, 회피 4%
                    } else if (rand < 0.70) {
                        isHiro = true; hp = 320; defense = 2; radius = 70; // 140 * 2.5
                        accuracy = 0.05; evasion = 0.05; // 히로: 명중 5%, 회피 5%
                    } else if (rand < 0.80) {
                        isKai = true; hp = 230; defense = 1; radius = 70; // 100 * 2.5
                        accuracy = 0.03; evasion = 0.02; // 카이: 명중 3%, 회피 2%
                    } else if (rand < 0.90) { 
                        isJacques = true; hp = 275; defense = 1; radius = 70; // 120 * 2.5
                        accuracy = 0.03; evasion = 0.02; // 자크: 명중 3%, 회피 2%
                    } else {
                        // 카시아스 (통합)
                        isCassias = true;
                        hp = 335; defense = 2; radius = 70; // 150 * 2.5
                        accuracy = 0.03; evasion = 0.03; // 카시아스: 명중 3%, 회피 3%
                    }
                }
            } else {
                // 자코들은 기본 0
                if (isAgent) { hp = 113; defense = 1; radius = 35; accuracy = 0; evasion = 0.05;}
                else if (normalType === 'rapist') {
                     accuracy = 0;
                     evasion = 0.05;
                     if (isAmbush) { hp = 163; defense = 1; } 
                     else if (isStealth) { hp = 138; defense = 1; } 
                     else { hp = 163; defense = 1; } 
                     radius = 45;
                } else if (normalType === 'summoner') {
                     accuracy = 0.05;
                     evasion = 0;
                     eliteType = Math.floor(Math.random() * 3);
                     hp = 150; defense = 0; radius = 45; // 60 * 2.5 
                }
            }

            // ... (위치 결정 및 HP 계산 로직 유지) ...
            if (fixedX !== null && fixedX !== undefined && fixedY !== null && fixedY !== undefined) {
                x = fixedX;
                y = fixedY;
            } else if (Math.random() < 0.5) {
                x = Math.random() < 0.5 ? 0 - radius : canvas.width + radius;
                y = Math.random() * canvas.height;
            } else {
                x = Math.random() * canvas.width;
                y = Math.random() < 0.5 ? 0 - radius : canvas.height + radius;
            }

            hp = getEnemySpawnHp(hp);
let baseSpeed = 0.6 + (Math.random() * 0.6);
            
            // ... (속도 보정 로직 유지) ...
            if (!isElite && normalType === 'rapist') baseSpeed *= 1.3;
            if (isRyuon) { baseSpeed *= 1.0; }
            if (isLuca) { baseSpeed = 1.5; } 
            if (isOzma) { baseSpeed = 1.5; } 
            if (isTaro) { baseSpeed = 1.0; } 
            if (isGawain) { baseSpeed = 1.0; } 
            if (isAgent) { baseSpeed *= 1.0; } 
            if (isAki) { baseSpeed *= 1.5; } 
            if (isHiro) { baseSpeed *= 1.5; }
            if (isKai) { baseSpeed = 1.5; }
            if (isJacques) { baseSpeed = 1.5; }

            const enemy = {
                x: x, y: y, radius: radius, baseRadius: radius, 
                baseSpeed: baseSpeed, speed: 0, vx: 0, vy: 0,
                
                // [추가] 명중, 회피 속성 적용
                accuracy: accuracy,
                evasion: evasion,

                critChance: 25, critResist: 15,
                gasTimer: 0, gasInterval: 120,
                bigPoopTimer: isElite ? Math.random() * 300 : 0, 
                scatterTimer: 0, whiteShotTimer: 0, summonTimer: 0, 
                regenTimer: 0, homingPoopTimer: 0, 
                angle: 0, isElite: isElite, isZako: false, maxHp: hp, hp: hp, defense: defense,
                hitFlash: 0, erectionStacks: 0, erectionTimer: 0, passiveErectionTimer: 0,
                contactStackTimer: 0, 
                buffType: buffType, eliteType: eliteType, stealthTimer: 0, alpha: 1.0, dashTimer: 0, dashVx: 0, dashVy: 0,
                darkDenizenSummonTimer: 0, hasSummonedDenizen: false, darkHeartTimer: 0, homingSemenTimer: 0,
                normalType: normalType, isAttached: false, attachTimer: 0,
                isStealth: isStealth, isAmbush: isAmbush, ambushState: 'approach', ambushTimer: 0,
                darkWaveTimer: 0, chargeState: 'idle', chargeTimer: 0, chargeCount: 0, 
                isRyuon: isRyuon, isLuca: isLuca, isOzma: isOzma, isTaro: isTaro, isGawain: isGawain, 
                isAki: isAki, isHiro: isHiro, isKai: isKai, isJacques: isJacques,
                isCassias: isCassias,
                dragShotTimer: 0, evilArrowTimer: 0, poisonousShotTimer: 0, akiSummonTimer: 0, evilKagerouTimer: 0,
                gawainSanctuaryTimer: 300, gawainSanctuaryActive: 0, gawainSwordTimer: 0, gawainJumpState: 'idle', gawainJumpTimer: 0, gawainJumpQueued: false,
                cruelChargeTimer: 120, isCruelChargeCharging: false, cruelChargeWindup: 0, isCruelCharging: false, cruelChargeDuration: 0, cruelChargeAngle: 0, cruelChargeVictim: false,
                aimTimer: 0, pheromoneTimer: 0, healPulseTimer: 0, pleasureZoneTimer: 0, darkBlessingTimer: 0, hasShield: false, 
                poopShotTimer: 0, backstabTimer: 0, sonicBoomTimer: 0, deathGripTimer: 0, deathGripActive: false, deathGripDuration: 0,
                isTransparent: false, transparentTimer: 0, speedBoostTimer: 0, sonicState: 'idle', sonicHitCooldown: 0,
                isAgent: isAgent, agentType: agentType, agentDeathTimer: 900,
                stunTimer: 0, abyssalResonanceTimer: 0, jacquesAdrenalineTimer: 0, pianissimoTimer: 240,
                jacquesGasTimer: 0, jacquesHymnTimer: 0, shadowSwapTimer: 0,
                shadowSwapCharging: false, shadowSwapChargeTimer: 0, shadowSwapChargeMax: 240,
                shadowSwapShield: 0, shadowSwapShieldMax: 0,
                chaosOrbTimer: 0, shadowCloakTimer: 0, isInvisible: false, invisibleDuration: 0, soulLinkCooldown: 540, soulLinkTarget: null, soulLinkHealTimer: 0, voidGrimoireTimer: 300, voidGrimoireCooldown: 1020,
                jammingTimer: 0, needleTimer: 0, hiroSummonTimer: 0, blackHolyBloodTimer: 720,
                antiPassingTimer: 0, antiPassingCharging: false, antiPassingChargeTimer: 0, antiPassingChargeMax: 360,
                antiPassingShield: 0, antiPassingShieldMax: 0, antiPassingTentacleSpawnTimer: 0,
            };
            enemy.speed = enemy.baseSpeed;
            enemies.push(enemy);

            // ... (등장 이펙트 로직 유지) ...
            if (isRyuon) { player.corruptedOathStacks++; showPickupEffect(player.x, player.y - 40, "맹세가 타락했다..", false, true); updateStatusUI(); }
            if (isLuca) { player.dangerousJudgmentStacks++; showPickupEffect(player.x, player.y - 40, "판단력이 흐려진다..", false, true); updateStatusUI(); }
            if (isOzma) { player.deepDarknessStacks++; showPickupEffect(player.x, player.y - 40, "어둠이 짙어진다..", false, true); updateStatusUI(); }
            if (isGawain) { player.corruptedJusticeStacks++; showPickupEffect(player.x, player.y - 40, "정의가 왜곡된다..", false, true); updateStatusUI(); }
            if (isAki) { activeAkiCount++; showPickupEffect(player.x, player.y - 40, "기세 등등한 어둠..", false, true); }
            if (isKai) { showPickupEffect(player.x, player.y - 40, "욕심쟁이♥", false, true, "evil-purple-text"); spawnFakeItem(enemy.accuracy); spawnFakeItem(enemy.accuracy, enemy); }
            if (isJacques) { showPickupEffect(enemy.x, enemy.y - 40, "타락한 선율..", false, true, "evil-purple-text"); }
            if (isHiro) { 
                const hiroCount = enemies.filter(e => e.isHiro).length;
                let sealDuration = 600; if (hiroCount >= 2) sealDuration = 1200;
                player.skillSealTimer = sealDuration;
                showPickupEffect(player.x, player.y - 40, "당황스럽지♥?", false, true, "hiro-text");
                skillSealOverlay.style.display = 'flex'; updateStatusUI();
            }

            if (!isElite && !isAgent && !isGawain && !isAki && !isHiro) {
                const zakoTypes = [null, 'terrorist', 'plague'];
                const randomZako = zakoTypes[Math.floor(Math.random() * 3)];
                const offsetX = (Math.random() - 0.5) * 100;
                const offsetY = (Math.random() - 0.5) * 100;
                spawnZako(x + offsetX, y + offsetY, randomZako);
            }
        }

        function spawnDragShot(x, y, angle, accuracy = 0, owner = null) {
    dragShots.push({
        x: x, y: y,
        vx: Math.cos(angle) * 5,
        vy: Math.sin(angle) * 5,
        radius: 60,
        angle: angle,
        startX: x, startY: y,
        life: 240,
        accuracy: accuracy, // [신규]
        owner: owner,
        seed: (_akiProjectileUid++ * 10007),
    });
}

function spawnEvilArrow(x, y, angle, accuracy = 0, owner = null) {
    // [SFX] Evil Arrow
    if (typeof playAkiEvilArrowSfx === 'function') playAkiEvilArrowSfx();

    evilArrows.push({
        x: x, y: y,
        vx: Math.cos(angle) * 7,
        vy: Math.sin(angle) * 7,
        radius: 45,
        angle: angle,
        life: 300,
        accuracy: accuracy, // [신규]
        owner: owner,
        seed: (_akiProjectileUid++ * 10007),
    });
}


function spawnPoisonousShot(x, y, angle, accuracy = 0, owner = null) {
    // [SFX] Poisonous Shot
    if (typeof playAkiPoisonousShotSfx === 'function') playAkiPoisonousShotSfx();

    // [Aki] Poisonous Shot: villain + gas + poop projectile (same size level as Evil Arrow)
    poisonousShots.push({
        x: x, y: y,
        vx: Math.cos(angle) * 7,
        vy: Math.sin(angle) * 7,
        radius: 45,
        angle: angle,
        life: 300, // 5초(60fps 기준)
        accuracy: accuracy,
        owner: owner,
        seed: (_akiProjectileUid++ * 10007),
    });
}


function spawnShadowGrip(x, y, owner) {
            const angle = Math.atan2(player.y - y, player.x - x);
            shadowGrips.push({
                x: x, y: y,
                vx: Math.cos(angle) * 8, // 빠른 속도
                vy: Math.sin(angle) * 8,
                radius: 48,
                angle: angle,
                owner: owner,
                life: 300, // 5초 후 소멸
                accuracy: owner.accuracy
            });
            showPickupEffect(x, y - 50, "그림자 품으로♥", false, true, "evil-purple-text");
        }

       function spawnBlackMoon(x, y, accuracy = 0, owner = null) {
    // [신규] 크레이터(달 무늬) 데이터 생성
    const craters = [];
    for (let i = 0; i < 7; i++) {
        // 달 내부 랜덤 위치
        const angle = Math.random() * Math.PI * 2;
        const dist = Math.random() * 45; // 반지름 60 안쪽
        craters.push({
            dx: Math.cos(angle) * dist,
            dy: Math.sin(angle) * dist,
            r: 4 + Math.random() * 8 // 크기 랜덤
        });
    }

    blackMoons.push({
        x: x,
        y: y,
        radius: 60,          // 흑월의 피격 범위
        pullRange: 430,      // 흡인(끌어당김) 범위
        life: 480,           // 지속시간 8초
        maxLife: 480,
        accuracy: accuracy,// 명중률 전달
        owner: owner,
        angle: 0,            // 회전 애니메이션용
        craters: craters     // [추가] 크레이터 정보 저장
    });

    // 등장 이펙트
    showPickupEffect(x, y - 80, "흑월(Black Moon)", false, true, "masakuni-text");
    shockwaves.push({ x: x, y: y, radius: 10, speed: 5, alpha: 1.0, fade: 0.02 });
}

function updateBlackMoons() {
    for (let i = blackMoons.length - 1; i >= 0; i--) {
        const moon = blackMoons[i];
        moon.life--;
        moon.angle += 0.02; 

        if (moon.life <= 0) {
            blackMoons.splice(i, 1);
            continue;
        }

        const dx = player.x - moon.x;
        const dy = player.y - moon.y;
        const distSq = dx * dx + dy * dy; // 거리 제곱

        // 2. 플레이어 흡인 로직 (끌어당김)
        // 거리제곱 < 당기기범위제곱
        if (distSq < moon.pullRange * moon.pullRange) {
            // 거리가 가까울수록 더 강하게 끌어당김 (정확한 거리 계산이 필요하므로 여기서만 sqrt 사용하거나, 근사치 사용)
            // 최적화를 위해 distSq를 이용하되, 물리적으로 정확할 필요는 없으므로 sqrt는 최소화
            const dist = Math.sqrt(distSq); 
            if (dist > 0) {
                const pullPower = (1 - (dist / moon.pullRange)) * 1.9;
                player.x -= (dx / dist) * pullPower * 3.0; 
                player.y -= (dy / dist) * pullPower * 3.0;
            }
        }

        // 3. 충돌 처리 (플레이어 타격)
        // 거리제곱 < (반지름합)^2
        const hitRadius = moon.radius + player.radius;
        if (distSq < hitRadius * hitRadius) {
            if (player.invincibleTimer <= 0) {
                let dmg = 30 + Math.floor(score * 0.25);
                // [마사쿠니 패시브: 심안] 흑월도 다음 공격 치명타(1.5배) 적용
                if (moon.owner && moon.owner.nextAttackCrit) {
                    dmg *= 1.5;
                    moon.owner.nextAttackCrit = false;
                    showPickupEffect(player.x, player.y, "심안 치명타!!", false, true, "masakuni-text");
                }
                takeDamage(dmg, 'direct', moon.accuracy, moon);
                for(let k=0; k<5; k++) {
                   addStatus('bleeding', 600, 20);
                }
                
                showPickupEffect(player.x, player.y, "어둠의 달..", false, true, "bleeding-border");
                blackMoons.splice(i, 1);
                
                explosions.push({ 
                    x: moon.x, y: moon.y, 
                    radius: 80, life: 30, 
                    accuracy: moon.accuracy,
                    owner: moon.owner,
                    damage: 0, hasHit: true 
               });
            }
        }
    }
}
     function spawnJammingWave(x, y, angle, accuracy = 0, owner = null) {
    jammingWaves.push({
        x: x, y: y,
        vx: Math.cos(angle) * 8, 
        vy: Math.sin(angle) * 8,
        radius: 40,
        life: 300,
        angle: angle,
        accuracy: accuracy, // [추가]
        owner: owner,
    });
}

       function spawnNeuroNeedle(x, y, angle, accuracy = 0, owner = null) {
    neuroNeedles.push({
        x: x, y: y,
        vx: Math.cos(angle) * 9, 
        vy: Math.sin(angle) * 9,
        radius: 8,
        life: 300,
        angle: angle,
        accuracy: accuracy, // [추가]
        owner: owner,
    });
}
        function spawnBlackHolyBlood(x, y, accuracy, owner = null) {
        blackHolyBloods.push({
            x: x, y: y,
            radius: 55, // 투사체 크기
            speed: 3.3, // 투사체 속도
            angle: Math.atan2(player.y - y, player.x - x), // 초기 각도
            life: 300, // 지속 시간 6초
            homingPower: 0.07, // 유도 성능
            accuracy: accuracy,// 명중률
            owner: owner,
            wobbleOffset: Math.random() * 100 // 시각적 이펙트용 랜덤값
        });
        showPickupEffect(x, y - 40, "감염 시켜주마♥", false, true, "corrupted-text");
    }

        function spawnAntiPassingTentacle(owner) {
            if (!owner) return;

            const nearR = 90 + Math.random() * 160;
            const ang = Math.random() * Math.PI * 2;
            const tx = player.x + Math.cos(ang) * nearR;
            const ty = player.y + Math.sin(ang) * nearR;

            antiPassingTentacles.push({
                x: tx,
                y: ty,
                radius: 65,
                life: 210,
                maxLife: 210,
                hitDelay: 75,
                riseDuration: 15,
                hitApplied: false,
                gasSpawned: false,
                frame: 0,
                riseProgress: 0,
                baseAngle: Math.random() * Math.PI * 2,
                segCount: 7,
                owner: owner,
                accuracy: owner.accuracy || 0,
                gasBursts: Array.from({ length: 8 }, () => ({
                    angle: Math.random() * Math.PI * 2,
                    dist: 8 + Math.random() * 36,
                    size: 8 + Math.random() * 20,
                    drift: 0.3 + Math.random() * 1.0,
                }))
            });
        }

        function spawnDarkDenizen(x, y, denizenType) {
            const radius = 55; 
            let hp = 225; // 90 * 2.5
            let defense = 2; // 루이/라이 기본 방어
            let accuracy = 0;
            let evasion = 0;
            if (denizenType === 'louie') {
        // 루이: 명중 5%, 회피 0%
        accuracy = 0.05;
        evasion = 0;
    } else if (denizenType === 'rai') {
        // 라이: 명중 0%, 회피 5%
        accuracy = 0;
        evasion = 0.05;
    }
            hp = getEnemySpawnHp(hp);
const enemy = {
                x: x, y: y, radius: radius, baseRadius: radius,
                baseSpeed: 1.5, speed: 0, vx: 0, vy: 0,
                accuracy: accuracy,
                evasion: evasion,
                critChance: 25, critResist: 15,
                
                gasTimer: 0, gasInterval: 120, 
                bigPoopTimer: 0, scatterTimer: 0, whiteShotTimer: 0,
                angle: 0, isElite: false, isZako: false, isSummoned: true, isDarkDenizen: true, 
                denizenType: denizenType, 
                maxHp: hp, hp: hp, defense: defense,
                hitFlash: 0, erectionStacks: 0, erectionTimer: 0, passiveErectionTimer: 0, contactStackTimer: 0,
                eliteType: -1, buffType: -1, alpha: 1.0, dashTimer: 0, dashVx: 0, dashVy: 0,
                darkHeartTimer: 0, attachTimer: 0, isAttached: false, readyStacks: 0, readyTimer: 0,
                stunTimer: 0
            };
            enemies.push(enemy);
        }
        
        function spawnMonolith(x, y, accuracy = 0, owner = null) {
    let hp = 150; // 75 * 2.5
    hp = getEnemySpawnHp(hp);
    const monolith = {
        x: x, y: y,
        radius: 35,       // 비석 크기
        baseRadius: 35,
        baseSpeed: 0,     // 움직이지 않음
        speed: 0, vx: 0, vy: 0,
        
        hp: hp, maxHp: hp,
        defense: 3,  
        
        isZako: false, isElite: false, isBoss: false,
        isMonolith: true,
        accuracy: accuracy,
        
        gasTimer: 0,      // 가스 패턴용 타이머
        
        // 필수 초기화 변수들 (에러 방지)
        critChance: 0, critResist: 100,
        isSuperArmor: true,
        hitFlash: 0, alpha: 1.0, 
        erectionStacks: 0, buffType: -1, eliteType: -1,
        stunTimer: 0, collisionTimer: 0
    };
    
    enemies.push(monolith);
    
    // 등장 이펙트
    showPickupEffect(x, y - 50, "혼돈의 비석!", false, true, "wicked-large-text");
    // 주변을 밀어내기 위한 충격파
    shockwaves.push({ x: x, y: y, radius: 10, speed: 8, alpha: 0.8, fade: 0.05 });
}
        

        function spawnVoidGrimoire(x, y, accuracy = 0, owner = null) {
    let hp = 150; // 75 * 2.5
    hp = getEnemySpawnHp(hp);

    const margin = 140;
    const gx = Math.max(margin, Math.min(canvas.width - margin, x));
    const gy = Math.max(margin, Math.min(canvas.height - margin, y));

    const grimoire = {
        x: gx, y: gy,
        radius: 35,
        baseRadius: 35,
        baseSpeed: 0,
        speed: 0, vx: 0, vy: 0,
        hp: hp, maxHp: hp,
        defense: 3,
        isZako: false, isElite: false, isBoss: false,
        isVoidGrimoire: true,
        accuracy: accuracy,
        owner: owner,
        gasTimer: 0,
        playerGasTimer: 0,
        allyBuffRange: 190,
        critChance: 0, critResist: 100,
        isSuperArmor: true,
        hitFlash: 0, alpha: 1.0,
        erectionStacks: 0, buffType: -1, eliteType: -1,
        stunTimer: 0, collisionTimer: 0
    };

    enemies.push(grimoire);
    showPickupEffect(gx, gy - 55, "공허의 금서!", false, true, "evil-purple-text");
    shockwaves.push({ x: gx, y: gy, radius: 8, speed: 7, alpha: 0.85, fade: 0.05 });
}

        function spawnAkiClone(x, y, maxHp, accuracy, owner = null) {
            const hp = Math.floor(maxHp * 0.5); // 본체 체력의 50%
            const clone = {
                x: x, y: y, radius: 70, baseRadius: 70,
                baseSpeed: 1.5 * 1.5, // 아키와 동일한 기본 속도 (기본 1.5배)
                speed: 0, vx: 0, vy: 0,
                accuracy: accuracy, evasion: 0.1, // 분신도 회피율 가짐
                critChance: 25, critResist: 15,
                
                angle: 0, isElite: false, isZako: false, isBoss: false,
                isAkiClone: true, // 분신 식별 플래그
                
                maxHp: hp, hp: hp, defense: 2,
                hitFlash: 0, erectionStacks: 0, alpha: 1.0,
                
                erectionBuffTimer: 0, // 주변 아군 발기 버프 타이머
                passiveErectionTimer: 0,

                // 필수 초기화 변수들
                gasTimer: 0, gasInterval: 180, buffType: -1, eliteType: -1,
                dashTimer: 0, dashVx: 0, dashVy: 0, stunTimer: 0
            };
            enemies.push(clone);
            showPickupEffect(x, y - 60, "카게로우♥", false, true, "pink-text");
        }
        function spawnMasakuni() {
            // 위치: 화면 밖 랜덤
            let x, y;
            if (Math.random() < 0.5) {
                x = Math.random() < 0.5 ? -100 : canvas.width + 100;
                y = Math.random() * canvas.height;
            } else {
                x = Math.random() * canvas.width;
                y = Math.random() < 0.5 ? -100 : canvas.height + 100;
            }

            let hp = 600; // 280 * 2.5
            let defense = 3; // 마사쿠니 기본 방어
            hp = getEnemySpawnHp(hp);
const enemy = {
                x: x, y: y, radius: 90, baseRadius: 90,
                baseSpeed: 0, // 기본 이동 속도는 0 (대쉬로만 이동)
                speed: 0, vx: 0, vy: 0,
                
                // 마사쿠니 스탯
                accuracy: 0.08, 
                evasion: 0.15,  
                critChance: 25, 
                critResist: 15,

                isElite: false, isBoss: false, isZako: false, isRoyal: true,
                isMasakuni: true,
                
                maxHp: hp, hp: hp, defense: defense,
                hitFlash: 0, alpha: 1.0,
                erectionStacks: 0, passiveErectionTimer: 0,
                
                // [패시브] 심안
                nextAttackCrit: false,

                // [이동 패턴] 가스 추진 대쉬 (평상시 이동)
                moveDashTimer: 0,       // 대쉬 쿨타임 체크용
                moveDashDuration: 0,    // 대쉬 지속 시간
                moveDashCooldown: 90,  // 대쉬 간격

                // [스킬 1] 일섬 (가웨인 돌진 기반)
                flashState: 'idle', 
                flashTimer: 0, 
                flashCooldown: 660,
                flashAngle: 0,
                hasHitFlash: false, // 돌진 중 플레이어 타격 여부 (다단히트 방지)

                // [스킬 2] 흑월
                blackMoonState: 'idle', blackMoonTimer: 0, blackMoonCooldown: 600, 

                // [스킬 3] 환영검
                phantomSwordCooldown: 900, 
                phantomSwordsActive: false,

                // 필수 초기화 변수
                gasTimer: 0, gasInterval: 9999, buffType: -1, eliteType: -1, 
                dashTimer: 0, dashVx: 0, dashVy: 0, stunTimer: 0
            };
            
            enemies.push(enemy);
            showPickupEffect(player.x, player.y - 100, "WARNING: 검은 민족 마사쿠니!", false, true, "masakuni-text");
        }

        function spawnKaito() {
            // 위치: 화면 밖 랜덤
            let x, y;
            if (Math.random() < 0.5) {
                x = Math.random() < 0.5 ? -100 : canvas.width + 100;
                y = Math.random() * canvas.height;
            } else {
                x = Math.random() * canvas.width;
                y = Math.random() < 0.5 ? -100 : canvas.height + 100;
            }

            let hp = 550; // 260 * 2.5
            let defense = 2; // 카이토 기본 방어
            hp = getEnemySpawnHp(hp);
const enemy = {
                x: x, y: y, radius: 80, baseRadius: 80,
                baseSpeed: 2.5,
                speed: 2.5, vx: 0, vy: 0,
                
                // 카이토 스탯
                accuracy: 0.10, 
                evasion: 0.15,  
                critChance: 25, 
                critResist: 15,

                isElite: false, isBoss: false, isZako: false, isRoyal: true,
                isKaito: true,
                
                maxHp: hp, hp: hp, defense: defense,
                hitFlash: 0, alpha: 1.0,
                erectionStacks: 0, passiveErectionTimer: 0,
                
                // 스킬 쿨타임 및 타이머
                voidWarpTimer: 0, voidWarpCooldown: 180, // 3초
                darkMatterTimer: 0, darkMatterCooldown: 720, // 12초
                confessionalTimer: 0, confessionalCooldown: 960, // 16초
                netherGrabTimer: 0, netherGrabCooldown: 960, // 16초
                
                netherGrabActive: false,
                netherGrabDuration: 0,

                kaitoStealthTimer: 0,
                isKaitoStealth: false,

                // 필수 초기화 변수
                gasTimer: 0, gasInterval: 9999, buffType: -1, eliteType: -1, 
                dashTimer: 0, dashVx: 0, dashVy: 0, stunTimer: 0
            };
            enemies.push(enemy);
            showPickupEffect(player.x, player.y - 100, "WARNING: 검은 민족 카이토!", false, true, "masakuni-text"); // 텍스트 스타일 재활용
        }

        function spawnQuesta() {
    // 위치: 화면 밖 랜덤
    let x, y;
    if (Math.random() < 0.5) {
        x = Math.random() < 0.5 ? -100 : canvas.width + 100;
        y = Math.random() * canvas.height;
    } else {
        x = Math.random() * canvas.width;
        y = Math.random() < 0.5 ? -100 : canvas.height + 100;
    }

    let hp = 625; // 290 * 2.5
    let defense = 3; // 퀘스타 기본 방어
    hp = getEnemySpawnHp(hp);
const enemy = {
        x: x, y: y, radius: 80, baseRadius: 80,
        baseSpeed: 0, // 기본 이동은 0, 로직으로 제어
        speed: 0, vx: 0, vy: 0,

        // --- [추가됨: 덮치기 패턴용 상태 변수] ---
        state: 'idle',         // idle(접근), warmup(준비), dashing(돌진), cooldown(휴식)
        actionTimer: 0,        // 각 상태별 지속 시간 체크용
        dashDir: {x: 0, y: 0}, // 돌진 시 방향 고정용 벡터
        // ------------------------------------
        
        // 퀘스타 스탯
        accuracy: 0.05, 
        evasion: 0.20,
        baseEvasion: 0.20, // 기본 회피율 저장
        critChance: 25, 
        critResist: 15,

        isElite: false, isBoss: false, isZako: false, isRoyal: true,
        isQuesta: true,
        
        maxHp: hp, hp: hp, defense: defense,
        hitFlash: 0, alpha: 1.0,
        erectionStacks: 0, passiveErectionTimer: 0,

        // [스킬 1] 그림자 손아귀 (10초)
        shadowGripTimer: 0, shadowGripCooldown: 600,

        // [스킬 2] 다크 플리커 (6초)
        flickerTimer: 0, flickerCooldown: 360,
        isFlickering: false, flickerCount: 0, flickerStepTimer: 0, flickerHitCooldown: 0,

        // [스킬 3] 칠흑의 장막 (10초)
        veilTimer: 600, veilCooldown: 600,
        isVeiled: false, veilDuration: 0,

        // [스킬 4] 본 크러셔 (17초)
        boneCrusherTimer: 0, boneCrusherCooldown: 1020,
        boneCrusherState: 'idle', // idle, charging, rushing
        boneCrusherChargeTimer: 0,
        
        // 이동 패턴용 (기존 변수 유지 혹은 state 로직이 대체하지만 호환성을 위해 남김)
        moveDelay: 0,

        // 필수 초기화
        gasTimer: 0, gasInterval: 9999, buffType: -1, eliteType: -1, 
        dashTimer: 0, dashVx: 0, dashVy: 0, stunTimer: 0
    };
    enemies.push(enemy);
    showPickupEffect(player.x, player.y - 100, "WARNING: 검은 민족 퀘스타!", false, true, "masakuni-text");
}

        function spawnTetora() {
            // 위치: 화면 밖 랜덤
            let x, y;
            if (Math.random() < 0.5) {
                x = Math.random() < 0.5 ? -100 : canvas.width + 100;
                y = Math.random() * canvas.height;
            } else {
                x = Math.random() * canvas.width;
                y = Math.random() < 0.5 ? -100 : canvas.height + 100;
            }

            let hp = 475; // 230 * 2.5
            let defense = 2; // 테토라 기본 방어
            // 스코어 비례 강화
            hp = getEnemySpawnHp(hp);
// 등장 시 진혼곡/광시곡 중 하나 랜덤 즉시 발동
            const startWithRequiem = Math.random() < 0.5;

            const enemy = {
                x: x, y: y, radius: 80, baseRadius: 80,
                baseSpeed: 1.5,
                speed: 1.5, vx: 0, vy: 0,

                // 테토라 스탯
                accuracy: 0.15,
                evasion: 0.15,
                critChance: 25,
                critResist: 15,

                isElite: false, isBoss: false, isZako: false, isRoyal: true,
                isTetora: true, // 식별 플래그

                maxHp: hp, hp: hp, defense: defense,
                hitFlash: 0, alpha: 1.0,
                erectionStacks: 0, passiveErectionTimer: 0,

                // [패시브] 불협화음 계산용
                allyCount: 0, 

                // [스킬] 노래 (진혼곡/광시곡)
                // 16초 지속(960프레임), 16초 쿨타임
                currentSong: startWithRequiem ? 'requiem' : 'rhapsody',
                songTimer: 960,       // 지속 시간 타이머
                songCooldown: 960,    // 쿨타임 (지속시간 끝나면 쿨타임 시작 or 지속시간 포함 쿨타임인지에 따라 로직 조정. 여기선 지속 끝난 후 쿨타임으로 구현하거나 스위칭 형태로 구현)
                // 요구사항: 쿨타임 16초, 지속 16초. 즉 무한 유지 가능한지 여부가 중요하나, "쿨타임 16초"가 사용 후 16초라면 텀이 빔.
                // 여기서는 "지속시간 동안 사용 불가"이므로, 효과 종료 후 쿨타임이 도는 방식으로 구현하거나, 
                // 등장 시 바로 사용하고 쿨타임이 같이 돈다면 무한 유지가 됨. 로직 상 '지속 시간'을 우선시합니다.
                
                // [스킬] 데스메탈 크레센도 (12초 쿨타임)
                crescendoTimer: 0, 
                crescendoCooldown: 720,

                // [스킬] 다크니스 스포트라이트 (14초 쿨타임)
                spotlightTimer: 0,
                spotlightCooldown: 840,

                // 필수 초기화 변수
                gasTimer: 0, gasInterval: 9999, buffType: -1, eliteType: -1, 
                dashTimer: 0, dashVx: 0, dashVy: 0, stunTimer: 0
            };
            enemies.push(enemy);
            showPickupEffect(player.x, player.y - 100, "WARNING: 검은 민족 테토라!", false, true, "masakuni-text");
        }

        function spawnZako(x, y, type = null) {
            const zakoCount = enemies.filter(e => e.isZako).length;
            if (zakoCount >= 30) return;
            const radius = 30; 
            let hp = 45; // 18 * 2.5
            hp = getEnemySpawnHp(hp);
            let defense = 0;

            let state = 'idle';
            let isAmbush = false;
            
            if (type === 'terrorist') {
                state = 'wandering';
            } else if (type === 'plague') {
                state = 'wandering';
                isAmbush = false;
            }

            const enemy = {
                x: x, y: y, radius: radius, baseRadius: radius,
                baseSpeed: (0.6 + (Math.random() * 0.6)) * 0.5, speed: 0, vx: 0, vy: 0,
                accuracy: 0.01, evasion: 0.01,
                critChance: 25, critResist: 15,
                
                gasTimer: Math.random() * 300, gasInterval: 300, whiteShotTimer: 0, angle: 0,
                isElite: false, isZako: true, maxHp: hp, hp: hp, defense: defense, 
                hitFlash: 0, erectionStacks: 0, erectionTimer: 0, passiveErectionTimer: 0,
                contactStackTimer: 0, 
                buffType: -1, eliteType: -1, alpha: 1.0, 
                state: state, 
                pounceTimer: 0, cooldownTimer: 0,
                zakoType: type, 
                isAmbush: isAmbush,
                ambushState: null,
                wanderTimer: 0,
                wanderAngle: Math.random() * Math.PI * 2,
                ambushTimer: 0,
                readyStacks: 0,
                readyTimer: 0,
                enraged: false, 
                enrageTimer: 0,
                hasShield: false,
                stunTimer: 0
            };
            enemy.speed = 0; 
            enemies.push(enemy);
        }

       function spawnDarkBigPoop(x, y, isScatter = false, angle = 0, isHoming = false, accuracy = 0, owner = null) {
            let vx = 0, vy = 0;
            if (isHoming) {
                const targetAngle = Math.atan2(player.y - y, player.x - x);
                const speed = 3.0; 
                vx = Math.cos(targetAngle) * speed;
                vy = Math.sin(targetAngle) * speed;
            } else if (isScatter) {
                const speed = 4;
                vx = Math.cos(angle) * speed;
                vy = Math.sin(angle) * speed;
            } else {
                const targetAngle = Math.atan2(player.y - y, player.x - x);
                const speed = 3;
                vx = Math.cos(targetAngle) * speed;
                vy = Math.sin(targetAngle) * speed;
            }

            darkBigPoops.push({
                x: x, y: y, vx: vx, vy: vy,
                radius: 45, life: isHoming ? 600 : 600, isScatter: isScatter, isHoming: isHoming,
                accuracy: accuracy, // [신규]
                owner: owner,
            });
        }

       function spawnDarkSemen(x, y, isHoming = false, angle = 0, sizeMult = 1.0, accuracy = 0, owner = null, irregularHoming = false) {
            let vx = 0, vy = 0;
            let speed = 3.5;

            // [수정] 토우야 다크 서비스 펄스(불규칙 유도) 검은 정액: 크기 2배, 속도 1.5배
            if (irregularHoming && isHoming) {
                speed *= 1.5;
                sizeMult *= 2;
            }

            let finalAngle = angle;
            if (isHoming) finalAngle = Math.atan2(player.y - y, player.x - x);

            vx = Math.cos(finalAngle) * speed;
            vy = Math.sin(finalAngle) * speed;

            const proj = {
                x: x, y: y, vx: vx, vy: vy,
                radius: 15 * sizeMult, life: isHoming ? 360 : 400, isHoming: isHoming,
                accuracy: accuracy, // [신규]
                owner: owner,
                stickyTrailTimer: 0,
            };

            // [신규] 불규칙 유도 궤적(토우야 다크 서비스 펄스 전용 등)
            if (irregularHoming && isHoming) {
                proj.irregularHoming = true;
                proj.irregularAmp = 0.65; // 라디안(약 37도) 내에서 불규칙하게 흔들림
                proj.irregularOffset = (Math.random() * 2 - 1) * proj.irregularAmp;
                proj.irregularTargetOffset = (Math.random() * 2 - 1) * proj.irregularAmp;
                proj.irregularTimer = 0;
                proj.irregularInterval = 6 + Math.floor(Math.random() * 14); // 6~19프레임마다 목표 오프셋 갱신
                proj.speed = speed; // 유도 업데이트에서 속도 유지
                proj.irregularSeed = Math.random() * 1000;
            }

            darkSemens.push(proj);
        }


        function spawnPandemonium(x, y, accuracy = 0, owner = null) {
    const angle = Math.atan2(player.y - y, player.x - x);
    const speed = 2.1;
    pandemoniums.push({
        x: x, y: y, 
        vx: Math.cos(angle) * speed, 
        vy: Math.sin(angle) * speed,
        radius: 52.5, 
        life: 300,
        speed: speed,
        accuracy: accuracy, // [추가]
        owner: owner,
    });
}

        function spawnDarkHeart(x, y, accuracy = 0, owner = null) {
    const angle = Math.atan2(player.y - y, player.x - x);
    const speed = 2.78;
    darkHearts.push({
        x: x, y: y, 
        vx: Math.cos(angle) * speed, 
        vy: Math.sin(angle) * speed,
        radius: 52.5, 
        life: 345,
        speed: speed,
        isHoming: true,
        accuracy: accuracy, // [추가]
        owner: owner,
    });
}
        
        function spawnChaosOrb(x, y, accuracy = 0, owner = null) {
    const angle = Math.atan2(player.y - y, player.x - x);
    const speed = 2.5;
    chaosOrbs.push({
        x: x, y: y,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        radius: 52.5,
        life: 300,
        speed: speed,
        accuracy: accuracy, // [추가]
        owner: owner,
    });
}

        function spawnFakeItem(accuracy = 0, owner = null) {
            const margin = 50;
            const x = margin + Math.random() * (canvas.width - margin * 2);
            const y = margin + Math.random() * (canvas.height - margin * 2);
            // type을 'fakeHealth'로 지정하여 구분
           items.push({ x: x, y: y, radius: 15, type: 'fakeHealth', life: 2100, accuracy: accuracy , owner: owner});
}

       function spawnDarkWave(x, y, angle, accuracy = 0, owner = null) {
            const speed = 5.5;
            const newRadius = 45 * 1.25;
            const newLength = 120 * 1.25;
            darkWaves.push({
                x: x, y: y, 
                vx: Math.cos(angle) * speed, 
                vy: Math.sin(angle) * speed,
                rotation: angle,
                radius: newRadius, 
                length: newLength, 
                life: 300,
                bounceCount: 0,
                maxBounces: 3,
                accuracy: accuracy, // [신규]
                owner: owner,
            });
        }
        
        // [신규] 소울 하비스트 시각 효과 생성
    function spawnSoulHarvestSlash(targetX, targetY) {
        soulHarvestSlashes.push({
            x: targetX,
            y: targetY,
            life: 45,
            scale: 1.0,
            angle: Math.random() * Math.PI * 2
        });
    }
        // [신규] 가이코츠 카타스트로피(커스드 카타스트로피) 생성
   function spawnCursedCatastrophe(x, y, accuracy, owner = null) {
    const angle = Math.atan2(player.y - y, player.x - x); // 각도 미리 계산
    const speed = 3.5; // 초기 속도

    cursedCatastrophes.push({
        x: x, y: y,
        // [수정] vx, vy에 초기 속도 적용
        vx: Math.cos(angle) * speed, 
        vy: Math.sin(angle) * speed,
        
        speed: speed, // (참고: 업데이트 로직에서 p.speed를 직접 쓰지 않고 vx, vy에서 역산한다면 이 값은 참조용이 됩니다)
        maxSpeed: 4.3,
        angle: angle,
        radius: 160,
        life: 480,
        accuracy: accuracy,
        owner: owner,
    });
    showPickupEffect(x, y - 50, "불알의 낙인♥", false, true, "wicked-large-text");
}

        // [신규] 아키토의 소울 하비스트 로직 (이름 변경: aki -> akito)
    function castSoulHarvest(akito) {
        // 1. 플레이어의 디버프 목록 확인
        const debuffKeys = [
            'poisonTimers', 'poopPoisonTimers', 'maliceTimers', 'kissTimers',
            'semenTimers', 'oralTimers', 'byururutTimers'
        ];
        
        let removedCount = 0;
        let stacksToRemove = 10; // 최대 10중첩 제거

        // 제거 가능한 디버프 수집 및 제거
        for (let key of debuffKeys) {
            if (stacksToRemove <= 0) break;
            if (player[key] && player[key].length > 0) {
                while (player[key].length > 0 && stacksToRemove > 0) {
                    player[key].shift(); // 스택 하나 제거
                    removedCount++;
                    stacksToRemove--;
                }
            }
        }
        
        updateStatusUI(); // UI 갱신

        // 2. 효과 적용
        if (removedCount > 0) {
            let damage = removedCount * 2.5;
            damage += Math.floor(score * 0.12); 
            
            // 데미지 입히기 (명중률 적용 - akito 변수 사용)
            takeDamage(damage, 'direct', akito.accuracy, akito);
            showPickupEffect(player.x, player.y, `영혼 수확 -${damage}`, false, true, "evil-purple-text");

            // 아키토 회복: 치료한 중첩 수 * 3% (akito 변수 사용)
            let healAmount = akito.maxHp * (removedCount * 0.03);
            akito.hp = Math.min(akito.maxHp, akito.hp + healAmount);
            showDamageText(akito.x, akito.y, `+${Math.floor(healAmount)}`, false, false, "heal-text");
        } else {
            // 치료할 디버프가 없다면 '좀먹는 생명' 3중첩 부여
            for(let i=0; i<3; i++) addStatus('gnawingLife', 1800, 10);
            showPickupEffect(player.x, player.y, "먹을게 없군..", false, true, "gnawing-life-border");
        }

        // 3. 시각 효과 (은색 낫)
        spawnSoulHarvestSlash(player.x, player.y);
    }

        function spawnPheromoneMarker(x, y, angle, accuracy = 0, owner = null) {
    const speed = 3.2;
    pheromoneMarkers.push({
        x: x, y: y,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        radius: 15 * 1.25, 
        life: 360,
        accuracy: accuracy, // [추가]
        owner: owner,
    });
}
        
       function spawnPleasureZone(x, y, accuracy = 0, owner = null) {
    pleasureZones.push({
        x: x, y: y,
        radius: 240,
        life: 300,
        stackTimer: 0,
        accuracy: accuracy, // [추가]
        owner: owner,
    });
}

       function findDarkServiceTeleportTarget(touya) {
    if (!touya || touya.hp <= 0) return null;

    const aliveAllies = enemies.filter(e => e !== touya && e.hp > 0);
    if (aliveAllies.length === 0) return null;

    const getNearest = (list) => {
        if (list.length === 0) return null;
        let nearest = list[0];
        let bestDist = Math.hypot(touya.x - nearest.x, touya.y - nearest.y);
        for (let i = 1; i < list.length; i++) {
            const ally = list[i];
            const dist = Math.hypot(touya.x - ally.x, touya.y - ally.y);
            if (dist < bestDist) {
                nearest = ally;
                bestDist = dist;
            }
        }
        return nearest;
    };

    const cainTargets = aliveAllies.filter(e => (e.isBoss && !e.isArthur && !e.isArchdemon) || (e.archdemonName && e.archdemonName.includes('카인')));
    const akitoTargets = aliveAllies.filter(e => e.isArchdemon && e.archdemonName && e.archdemonName.includes('아키토'));

    return getNearest(cainTargets) || getNearest(akitoTargets) || getNearest(aliveAllies);
}

       function castDarkService(touya) {
    if (!touya || touya.hp <= 0) return;

    const target = findDarkServiceTeleportTarget(touya);
    if (!target) return;

    const angle = Math.random() * Math.PI * 2;
    const sideDistance = target.radius + touya.radius + 20;
    touya.x = Math.max(touya.radius, Math.min(canvas.width - touya.radius, target.x + Math.cos(angle) * sideDistance));
    touya.y = Math.max(touya.radius, Math.min(canvas.height - touya.radius, target.y + Math.sin(angle) * sideDistance));

    showPickupEffect(touya.x, touya.y - 70, "빨아줄게♥", false, true, "evil-purple-text");

    touya.darkServicePulseTimer = 60;
}

       function triggerDarkServicePulse(touya) {
    if (!touya || touya.hp <= 0) return;

    const pulseRadius = 260;
    let affectedCount = 0;

    for (let ally of enemies) {
        if (ally === touya || ally.hp <= 0) continue;

        const dist = Math.hypot(ally.x - touya.x, ally.y - touya.y);
        if (dist > pulseRadius + ally.radius) continue;

        ally.erectionStacks = Math.min((ally.erectionStacks || 0) + 2, 20);
        ally.darkServiceEcstasyTimer = 180;
        ally.enraged = true;
        ally.enrageTimer = Math.max(ally.enrageTimer || 0, 180);

        const healAmount = Math.max(1, Math.floor(ally.maxHp * 0.03 * (ally.hpRecoveryRate || 1)));
        ally.hp = Math.min(ally.maxHp, ally.hp + healAmount);
        showDamageText(ally.x, ally.y - 15, `+${healAmount}`, false, false, 'heal-text');
        showPickupEffect(ally.x, ally.y - 45, "기모찌..", false, true, "pink-text");

        affectedCount++;
    }
    // [신규] 펄스 발동 시: 유도 검정 정액 3발(불규칙 궤적) 발사
    for (let k = 0; k < 3; k++) {
        const offR = 10 + Math.random() * 8;
        const offA = Math.random() * Math.PI * 2;
        const sx = touya.x + Math.cos(offA) * offR;
        const sy = touya.y + Math.sin(offA) * offR;
        spawnDarkSemen(sx, sy, true, 0, 1.25, touya.accuracy || 0, touya, true);
    }


    if (affectedCount > 0) {
        showPickupEffect(touya.x, touya.y - 100, "빨아줄게♥", false, true, "evil-purple-text");
    }
}

       function updatePleasureZones() {
    let inZone = false;
    for (let i = pleasureZones.length - 1; i >= 0; i--) {
        const zone = pleasureZones[i];
        zone.life--;
        
        if (zone.life <= 0) {
            pleasureZones.splice(i, 1);
            continue;
        }
        
        // [최적화] 플레이어 충돌 판정 (제곱 거리 사용)
        const dx = player.x - zone.x;
        const dy = player.y - zone.y;
        const distSq = dx * dx + dy * dy;
        const zoneRadiusSq = zone.radius * zone.radius;

        if (distSq < zoneRadiusSq) {
            player.slowedByCloud = true;
            player.defenseBroken = true; 
            inZone = true;

            let dmgPerFrame = (3 + Math.floor(score * 0.04)) / 60;
            takeDamage(dmgPerFrame, 'direct', zone.accuracy, zone);
            zone.stackTimer = (zone.stackTimer || 0) + 1;
            if (zone.stackTimer >= 30) {
                 if (!checkShieldBlockStatus('normal', 'kiss')) {
                     addStatus('kiss', 900, 30);
                 }
                 zone.stackTimer = 0;
            }
        } else {
            zone.stackTimer = 0;
        }
        
        // 적들이 쾌락의 장판 위에 있을 때 발기 수치 증가
        for (let e of enemies) {
            // [최적화] 적 충돌 판정 (제곱 거리 사용)
            const edx = e.x - zone.x;
            const edy = e.y - zone.y;
            const eDistSq = edx * edx + edy * edy;
            const hitRadius = zone.radius + e.radius;

            if (eDistSq < hitRadius * hitRadius) {
                 e.passiveErectionTimer += 1.5;
                 // 자코(쫄병)가 장판 위에 있으면 분노 상태가 됨
                 if (e.isZako && !e.enraged) {
                    e.enraged = true;
                    e.enrageTimer = 60; 
                }
            }
        }
    }
    
    if (!inZone) player.defenseBroken = false;
}

        function spawnPinkGas(x, y) {
            const puffs = [];
            const puffCount = 100; // 구름 조각 개수
            for (let i = 0; i < puffCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                const dist = Math.random() * 450; // 중심에서 퍼지는 거리
                puffs.push({
                    dx: Math.cos(angle) * dist,
                    dy: Math.sin(angle) * dist,
                    r: 60 + Math.random() * 50, // 조각의 크기 (40~80)
                    scale: 0.1 // 등장 애니메이션용 스케일
            });
        }

           pinkGases.push({
                x: x, y: y,
                radius: 450, 
                life: 480,   
                alpha: 0, // 서서히 나타나도록 0부터 시작
                maxAlpha: 0.4,
                puffs: puffs 
            });
        }
        
   
        function updatePinkGases() {
    player.inPinkGas = false; // 매 프레임 초기화
    
    for (let i = pinkGases.length - 1; i >= 0; i--) {
        const g = pinkGases[i];
        g.life--;
        if (g.life <= 0) { pinkGases.splice(i, 1); continue; }

        // [최적화] 플레이어 체크 (제곱 거리)
        const dx = player.x - g.x;
        const dy = player.y - g.y;
        const distSq = dx * dx + dy * dy;
        const radiusSq = g.radius * g.radius;

        if (distSq < radiusSq) {
            player.inPinkGas = true; // 가스 안에 있음
        }

        // 적 버프 체크 (영구 적용이므로 한 번만 적용하도록 플래그 사용)
        enemies.forEach(e => {
            // [최적화] 적 거리 체크 (제곱 거리)
            const edx = e.x - g.x;
            const edy = e.y - g.y;
            const eDistSq = edx * edx + edy * edy;
            const hitRadius = g.radius + e.radius;

            if (eDistSq < hitRadius * hitRadius) {
                if (!e.hasPinkGasBuff) {
                    e.hasPinkGasBuff = true;
                    e.hpRecoveryRate = (e.hpRecoveryRate || 1) * 1.5; // 회복량 1.5배 플래그
                    e.baseSpeed *= 1.2;
                    e.speed *= 1.2;
                    showDamageText(e.x, e.y, "UP!", false, false, "heal-text");
                }
            }
        });
    }
}
      


        // ==========================================================
        // [신규] 퀘스타 '새디즘' 활성화 연출: 갈색 방구 가스 (핑크가스 스타일)
        // - 게임플레이 효과 없음(시각 연출만)
        // - sadismGasTimer가 켜져 있는 동안 10프레임마다 계속 뿜어져나옴
        // - sadismGasTimer가 꺼지거나(해제), 퀘스타가 사망하면 즉시 소멸
        // ==========================================================
        const SADISM_BROWN_GAS_RADIUS = 340; // 새디즘 방구 가스 퍼짐 반경(요청: 더 넓게)

        function spawnSadismBrownGas(x, y, owner) {
            if (!owner) return;

            // 과도한 누적 방지(성능)
            const hardCap = Math.max(18, Math.floor(((performanceState && performanceState.maxParticles) ? performanceState.maxParticles : 6000) / 350));
            if (sadismBrownGases.length >= hardCap) return;

            const puffs = [];
            const stride = (performanceState && performanceState.particleStride) ? performanceState.particleStride : 1;
            const puffCount = Math.max(40, Math.floor(80 / stride)); // 성능 상태에 따라 가볍게 조절
            for (let i = 0; i < puffCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                const dist = Math.random() * SADISM_BROWN_GAS_RADIUS; // 중심에서 퍼지는 거리(확장)
                puffs.push({
                    dx: Math.cos(angle) * dist,
                    dy: Math.sin(angle) * dist,
                    r: 55 + Math.random() * 45,
                    scale: 0.1
                });
            }

            sadismBrownGases.push({
                x: x, y: y,
                owner: owner,
                radius: SADISM_BROWN_GAS_RADIUS,
                life: 240,
                maxLife: 240,
                alpha: 0,
                maxAlpha: 0.35,
                puffs: puffs
            });
        }

        function clearSadismBrownGasesFor(owner) {
            if (!owner || sadismBrownGases.length === 0) return;
            for (let i = sadismBrownGases.length - 1; i >= 0; i--) {
                if (sadismBrownGases[i].owner === owner) {
                    sadismBrownGases.splice(i, 1);
                }
            }
        }

        function updateSadismBrownGases() {
            let inSadismGas = false;

            for (let i = sadismBrownGases.length - 1; i >= 0; i--) {
                const g = sadismBrownGases[i];

                // [요청] 퀘스타 사망/새디즘 해제 시에도, 이미 생성된 가스는 자연 소멸
                if (!g.owner) {
                    sadismBrownGases.splice(i, 1);
                    continue;
                }

                // [신규] 새디즘 가스 접촉 판정(제곱 거리)
                const dx = player.x - g.x;
                const dy = player.y - g.y;
                const distSq = dx * dx + dy * dy;
                const hitR = player.radius + g.radius;
                if (distSq < hitR * hitR) {
                    inSadismGas = true;
                }

                // 시각적인 자연 소멸
                g.life--;
                if (g.life <= 0) {
                    sadismBrownGases.splice(i, 1);
                }
            }

            // [신규] 새디즘 가스에 닿으면 30프레임마다 '가스 중독' 1중첩
            if (inSadismGas && (frameCount % 30 === 0) && player.invincibleTimer <= 0) {
                if (!checkShieldBlockStatus('normal', 'poison')) {
                    addStatus('poison', 900, 50);
                }
                // 텍스트는 과도한 출력 방지(1.5초에 1번)
                player._sadismGasMsgCD = player._sadismGasMsgCD || 0;
                if (player._sadismGasMsgCD <= 0) {
                    showPickupEffect(player.x, player.y, "퀘스타 방구냄새..", false, true);
                    player._sadismGasMsgCD = 90;
                }
            }
            if (player._sadismGasMsgCD > 0) player._sadismGasMsgCD--;
        }

        function updateSadismGasEmitters() {
            const stride = (performanceState && performanceState.particleStride) ? performanceState.particleStride : 1;
            const interval = 60 * stride; // 요청: 60프레임마다 (렉 완화)

            for (let i = 0; i < enemies.length; i++) {
                const e = enemies[i];
                if (!e || !e.isQuesta) continue;

                // 사망 시: 즉시 "분사 중단"만 하고, 남아있던 가스는 자연 소멸
                if (e.hp <= 0) {
                    e.sadismGasTimer = 0;
                    e.sadismGasActive = false;
                    e.sadismGasSpawnTick = 0;
                    continue;
                }

                // 새디즘 연출 활성 상태
                if ((e.sadismGasTimer || 0) > 0) {
                    e.sadismGasTimer--;
                    e.sadismGasActive = true;

                    e.sadismGasSpawnTick = (e.sadismGasSpawnTick || 0) + 1;
                    if (e.sadismGasSpawnTick >= interval) {
                        e.sadismGasSpawnTick = 0;

                        // 퀘스타 주변에서 "뿜어져나오는" 느낌으로 약간 랜덤 오프셋
                        const ox = (Math.random() - 0.5) * 40;
                        const oy = (Math.random() - 0.5) * 40;
                        spawnSadismBrownGas(e.x + ox, e.y + oy, e);
                    }

                    // 타이머가 끝나면: 즉시 분사 중단(이미 뿜은 가스는 자연 소멸)
                    if ((e.sadismGasTimer || 0) <= 0) {
                        e.sadismGasActive = false;
                        e.sadismGasSpawnTick = 0;
                    }
                } else {
                    // 비활성화로 전환되면: 분사만 중단(남아있던 가스는 자연 소멸)
                    if (e.sadismGasActive) {
                        e.sadismGasActive = false;
                    }
                    e.sadismGasSpawnTick = 0;
                }
            }
        }

// ==========================================================
// [OPT] Occlusion Spool / Questa Veil / Cursed Catastrophe 캐시
// - 색감은 기존 유지, 연산만 줄임
// ==========================================================
const __optCaches = {
    occlusionDisc: new Map(),
    questaVeil: new Map(),
    cursedCat: new Map(),
    tadHead: null
};

function __hash01(n) {
    const x = Math.sin(n) * 10000;
    return x - Math.floor(x);
}

// ---- Occlusion Spool: 바닥 그라데이션 디스크 텍스처 캐시 ----
function getOcclusionSpoolDiscTex(radius) {
    const r = Math.max(10, Math.floor(radius));
    const key = r;
    const cached = __optCaches.occlusionDisc.get(key);
    if (cached) return cached;

    const c = document.createElement('canvas');
    c.width = c.height = r * 2;
    const cctx = c.getContext('2d');
    cctx.translate(r, r);

    const grad = cctx.createRadialGradient(0, 0, r * 0.2, 0, 0, r);
    // [조정] 더 진한 보라색(오클루전 스풀) - 색감 강화
    grad.addColorStop(0.0, "rgba(45, 0, 90, 0.90)");   // 중심(딥 퍼플)
    grad.addColorStop(0.55, "rgba(110, 0, 200, 0.40)"); // 중간(보라빛)
    grad.addColorStop(1.0, "rgba(0, 0, 0, 0)");         // 외곽(투명)

    cctx.fillStyle = grad;
    cctx.beginPath();
    cctx.arc(0, 0, r, 0, Math.PI * 2);
    cctx.fill();

    __optCaches.occlusionDisc.set(key, c);
    // 간단한 메모리 제한
    if (__optCaches.occlusionDisc.size > 40) __optCaches.occlusionDisc.clear();
    return c;
}

// ---- Questa Veil: 칠흑의 장막 스프라이트 캐시(12fps) ----
function getQuestaVeilSprite(size, timeKey) {
    const sizeKey = Math.max(32, Math.round(size / 4) * 4);
    const key = sizeKey + ":" + timeKey;

    const cached = __optCaches.questaVeil.get(key);
    if (cached) return cached;

    // 기존 로직 기준 최대 반경 추정: ((size/2)+35)*1.5
    const maxR = ((sizeKey / 2) + 35) * 1.5 + 12;
    const csz = Math.max(96, Math.ceil(maxR * 2));
    const c = document.createElement('canvas');
    c.width = c.height = csz;
    const cctx = c.getContext('2d');
    cctx.translate(csz / 2, csz / 2);

    // 기존 색감 유지
    cctx.shadowColor = "#4B0082";
    cctx.shadowBlur = 25;
    cctx.lineJoin = "round";

    const nowApprox = timeKey * 83; // 12fps 버킷
    const time = nowApprox / 30;

    for (let layer = 0; layer < 3; layer++) {
        cctx.strokeStyle = "black";
        // lineWidth 랜덤은 해시로 결정(색감/느낌 유지 + Math.random 제거)
        const lw = 8 + __hash01(timeKey * 13.7 + layer * 7.3) * 4;
        cctx.lineWidth = lw;

        cctx.beginPath();
        const segments = 16;
        for (let k = 0; k <= segments; k++) {
            const angle = (k / segments) * Math.PI * 2 + time + (layer * Math.PI / 3);

            const h = __hash01(timeKey * 0.91 + layer * 11.1 + k * 17.3);
            const noise = 10 + h * 25;
            const r = ((sizeKey / 2) + noise) * 1.5;

            const lx = Math.cos(angle) * r;
            const ly = Math.sin(angle) * r;
            if (k === 0) cctx.moveTo(lx, ly);
            else cctx.lineTo(lx, ly);
        }
        cctx.closePath();
        cctx.stroke();
    }

    cctx.shadowBlur = 0;

    const out = { canvas: c, size: csz };
    __optCaches.questaVeil.set(key, out);
    if (__optCaches.questaVeil.size > 60) __optCaches.questaVeil.clear();
    return out;
}

function drawQuestaVeilCached(ctx, size) {
    const stride = (performanceState && performanceState.particleStride) ? performanceState.particleStride : 1;
    const timeKey = Math.floor(Date.now() / (83 * stride));
    const spr = getQuestaVeilSprite(size, timeKey);
    ctx.drawImage(spr.canvas, -spr.size / 2, -spr.size / 2);
}

// ---- Cursed Catastrophe: 전체 스프라이트 캐시(12fps) ----
function getTadpoleHeadTex() {
    if (__optCaches.tadHead) return __optCaches.tadHead;

    const c = document.createElement('canvas');
    c.width = c.height = 64;
    const cctx = c.getContext('2d');
    cctx.translate(32, 32);

    // [수정] 검정색 정자 머리(타원형) 텍스처
    // - 기본 형태는 +X 방향을 "앞"으로 둠(그릴 때 rotate로 방향 맞춤)
    const g = cctx.createRadialGradient(12, -10, 2, 0, 0, 34);
    g.addColorStop(0, '#222');
    g.addColorStop(0.35, '#080808');
    g.addColorStop(1, '#000');

    // 메인 헤드(앞쪽이 더 넓은 타원)
    cctx.fillStyle = g;
    cctx.beginPath();
    cctx.ellipse(6, 0, 22, 16, 0, 0, Math.PI * 2);
    cctx.fill();

    // 뒤쪽(꼬리 연결부) 조금 더 좁게
    cctx.fillStyle = '#000';
    cctx.beginPath();
    cctx.ellipse(-12, 0, 14, 12, 0, 0, Math.PI * 2);
    cctx.fill();

    // 아주 얇은 외곽선(검정)
    cctx.strokeStyle = 'rgba(0, 0, 0, 0.95)';
    cctx.lineWidth = 2;
    cctx.beginPath();
    cctx.ellipse(6, 0, 22, 16, 0, 0, Math.PI * 2);
    cctx.stroke();

    __optCaches.tadHead = c;
    return c;
}

function getCursedCatastropheSprite(outerR, timeKey, stride) {
    const rKey = Math.max(15, Math.round(outerR));
    const key = rKey + ":" + timeKey + ":" + stride;
    const cached = __optCaches.cursedCat.get(key);
    if (cached) return cached;

    const coreR = rKey * 0.5;

    // 원본 기준 바깥 반경 ~ 1.2 * outerR, 여유 추가
    const sprR = Math.ceil(rKey * 1.35 + 20);
    const csz = sprR * 2;

    const c = document.createElement('canvas');
    c.width = c.height = csz;
    const cctx = c.getContext('2d');
    cctx.translate(sprR, sprR);

    // 시간 버킷(원본 Date.now 기반)
    const nowApprox = timeKey * 83 * stride;
    const time = nowApprox / 150;
    const timeTad = nowApprox / 500;

    // (1) 코어
    cctx.beginPath();
    cctx.arc(0, 0, coreR, 0, Math.PI * 2);
    cctx.fillStyle = "#1a0505";
    cctx.fill();

    // (1-1) 올챙이(헤드 스프라이트 + 꼬리)
    const headTex = getTadpoleHeadTex();

    // 원본의 개수/비용을 stride로 조절
    const baseCount = Math.max(8, Math.min(22, Math.floor(coreR * 1.2)));
    const tadpoleCount = Math.max(6, Math.floor(baseCount / stride));

    // 코어 클립
    cctx.save();
    cctx.beginPath();
    cctx.arc(0, 0, coreR, 0, Math.PI * 2);
    cctx.clip();

    for (let j = 0; j < tadpoleCount; j++) {
        const t = timeTad * 2 + j * 113.7;
        const rMax = coreR * 0.75;
        const dist = (Math.sin(t * 0.3) * 0.5 + 0.5) * rMax;
        const angle = t * 0.5 + (j * (Math.PI * 2 / 13));

        const tx = Math.cos(angle) * dist;
        const ty = Math.sin(angle) * dist;

        // 머리(텍스처) - [수정] 크기 소폭 감소 + 검정색 정자 형태
        const headBase = Math.max(2, coreR * 0.15);
        let headSize = headBase + Math.sin(t * 3) * Math.max(0.3, coreR * 0.02);
        headSize *= 0.85;

        // 정자 "앞" 방향 (머리가 바라보는 방향)
        const moveDir = angle + Math.PI / 2;

        cctx.save();
        cctx.translate(tx, ty);
        cctx.rotate(moveDir);
        const scale = headSize / 30; // 텍스처 기준(30)
        cctx.scale(scale, scale);
        cctx.drawImage(headTex, -32, -32);
        cctx.restore();

        // 꼬리 - [수정] 머리 뒤쪽에서 시작해 정자 느낌 강화
        const backOff = headSize * 0.45;
        const startX = tx - Math.cos(moveDir) * backOff;
        const startY = ty - Math.sin(moveDir) * backOff;

        const wiggle = Math.sin(t * 15) * (coreR * 0.35);
        const tailLen = Math.max(10, coreR * 1.10);
        const tailBaseAngle = moveDir + Math.PI;

        const tailEndX = startX + Math.cos(tailBaseAngle) * tailLen + Math.cos(tailBaseAngle + Math.PI / 2) * wiggle;
        const tailEndY = startY + Math.sin(tailBaseAngle) * tailLen + Math.sin(tailBaseAngle + Math.PI / 2) * wiggle;
        const cpX = (startX + tailEndX) / 2 + Math.cos(tailBaseAngle + Math.PI / 2) * (wiggle * 0.5);
        const cpY = (startY + tailEndY) / 2 + Math.sin(tailBaseAngle + Math.PI / 2) * (wiggle * 0.5);

        cctx.beginPath();
        cctx.moveTo(startX, startY);
        cctx.strokeStyle = "#000";
        cctx.lineWidth = Math.max(1.2, coreR * 0.085);
        cctx.lineCap = "round";
        cctx.quadraticCurveTo(cpX, cpY, tailEndX, tailEndY);
        cctx.stroke();
    }

    cctx.restore(); // clip 해제

    // (2) 잔털(비용 큰 부분: stride로 개수 줄임)
    const hairBaseCount = Math.min(28, Math.max(16, Math.floor(coreR / 6)));
    const hairCount = Math.max(10, Math.floor(hairBaseCount / stride));
    const baseRadius = coreR;

    cctx.strokeStyle = "#2b2b2b";
    cctx.lineWidth = Math.max(1.5, coreR * 0.02);

    for (let j = 0; j < hairCount; j++) {
        const angle = (j / hairCount) * Math.PI * 2;
        const wiggle = Math.sin(time * 2 + j * 132) * 0.5;

        const sx = Math.cos(angle) * baseRadius;
        const sy = Math.sin(angle) * baseRadius;

        const hairLen = baseRadius + Math.sin(j * 55) * (baseRadius * 0.35);
        const ex = Math.cos(angle + wiggle * 0.2) * (baseRadius + hairLen);
        const ey = Math.sin(angle + wiggle * 0.2) * (baseRadius + hairLen);

        const cp1Mod = (j % 2 === 0) ? 1 : -1;
        const cp1x = Math.cos(angle + 0.5 * cp1Mod + wiggle) * (baseRadius + hairLen * 0.4);
        const cp1y = Math.sin(angle + 0.5 * cp1Mod + wiggle) * (baseRadius + hairLen * 0.4);

        const cp2Mod = (j % 3 === 0) ? -1 : 1;
        const cp2x = Math.cos(angle - 0.5 * cp2Mod - wiggle) * (baseRadius + hairLen * 0.8);
        const cp2y = Math.sin(angle - 0.5 * cp2Mod - wiggle) * (baseRadius + hairLen * 0.8);

        cctx.beginPath();
        cctx.moveTo(sx, sy);
        cctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, ex, ey);
        cctx.stroke();
    }

    // (3) 오라(기존 유지)
    cctx.shadowBlur = Math.min(40, Math.max(10, coreR * 0.25));
    cctx.shadowColor = "#8b0000";
    cctx.strokeStyle = "rgba(139, 0, 0, 0.3)";
    cctx.lineWidth = Math.max(2, coreR * 0.03);
    cctx.beginPath();
    cctx.arc(0, 0, coreR * 1.05, 0, Math.PI * 2);
    cctx.stroke();
    cctx.shadowBlur = 0;

    const out = { canvas: c, w: csz, h: csz };
    __optCaches.cursedCat.set(key, out);
    if (__optCaches.cursedCat.size > 90) __optCaches.cursedCat.clear();
    return out;
}



        // [신규] 어둠의 음표 생성
        function spawnDarkNote(x, y, owner) {
            darkNotes.push({
                x: x, y: y,
                owner: owner, // 발사한 주체
                speed: 4,
                life: 300,
                target: null // 유도 대상
            });
        }

       function updateDarkNotes() {
    for (let i = darkNotes.length - 1; i >= 0; i--) {
        const note = darkNotes[i];
        note.life--;
        if (note.life <= 0) { darkNotes.splice(i, 1); continue; }

        // 타겟 찾기 (가장 가까운 아군) - 여기서는 거리 비교만 하므로 sqrt 생략 가능
        if (!note.target || note.target.hp <= 0) {
            let minDistSq = 9999 * 9999; // 제곱 거리로 초기화
            let newTarget = null;
            enemies.forEach(e => {
                if (e !== note.owner && e.hp > 0) {
                    const dx = e.x - note.x;
                    const dy = e.y - note.y;
                    const dSq = dx * dx + dy * dy;
                    if (dSq < minDistSq) { 
                        minDistSq = dSq; 
                        newTarget = e; 
                    }
                }
            });
            note.target = newTarget;
        }

        // 이동
        if (note.target) {
            const angle = Math.atan2(note.target.y - note.y, note.target.x - note.x);
            note.x += Math.cos(angle) * note.speed;
            note.y += Math.sin(angle) * note.speed;

            // [최적화] 충돌 (아군 힐) - 제곱 거리 사용
            const dx = note.target.x - note.x;
            const dy = note.target.y - note.y;
            const distSq = dx * dx + dy * dy;
            const hitRadiusSq = note.target.radius * note.target.radius;

            if (distSq < hitRadiusSq) {
                note.target.erectionStacks = Math.min((note.target.erectionStacks || 0) + 2, 20);
                let heal = Math.floor(note.target.maxHp * 0.15);
                heal = Math.floor(heal * (note.target.hpRecoveryRate || 1));
                note.target.hp = Math.min(note.target.maxHp, note.target.hp + heal);
                
                showDamageText(note.target.x, note.target.y, "+" + heal, false, false, "heal-text");
                showPickupEffect(note.target.x, note.target.y, "UP!!", false, false, "pink-text");
                
                darkNotes.splice(i, 1);
                continue;
            }
        } else {
            // 타겟 없으면 직진하거나 사라짐
            note.y += note.speed;
        }
    }
}

       function spawnDarkMatter(x, y, owner) {
            const angle = Math.atan2(player.y - y, player.x - x);
            darkMatters.push({
                x: x, y: y,
                vx: Math.cos(angle) * 2.9, // 느린 속도
                vy: Math.sin(angle) * 2.9,
                angle: angle,
                radius: 100,
                owner: owner,
                life: 900, // 15초
                gasTrailTimer: 0,
                accuracy: owner.accuracy
            });
            showPickupEffect(x, y - 60, "다크 매터!", false, true, "evil-purple-text");
        }

        function spawnConfessionalTotem(x, y, accuracy, owner = null) {
            confessionalTotems.push({
                x: x, y: y,
                radius: 40, // 토템 자체 크기
                range: 300, // 효과 범위
                life: 720, // 12초
                damageTimer: 0,
                accuracy: accuracy,
                owner: owner,
            });
            showPickupEffect(x, y - 60, "컨페셔너..", false, true, "corrupted-text");
        }

  function updatePheromoneMarkers() {
    for (let i = pheromoneMarkers.length - 1; i >= 0; i--) {
        const marker = pheromoneMarkers[i];
        
        // [유도 로직 최적화]
        const dx = player.x - marker.x;
        const dy = player.y - marker.y;
        
        // 유도 계산을 위해 거리가 필요하지만, 매 프레임 정확할 필요가 없다면
        // 일정 거리 이내일 때만 정밀 유도하거나 할 수 있습니다. 
        // 여기서는 기존 로직 유지하되 안전장치 추가
        const distSq = dx * dx + dy * dy;
        
        if (distSq > 0) {
            const dist = Math.sqrt(distSq); // 유도 벡터 정규화를 위해 필요
            const homingStrength = 0.06;
            const currentSpeed = Math.sqrt(marker.vx * marker.vx + marker.vy * marker.vy);
            
            marker.vx += (dx / dist) * homingStrength * currentSpeed;
            marker.vy += (dy / dist) * homingStrength * currentSpeed;
            
            // 속도 재정규화
            const newSpeedSq = marker.vx * marker.vx + marker.vy * marker.vy;
            const newSpeed = Math.sqrt(newSpeedSq);
            marker.vx = (marker.vx / newSpeed) * currentSpeed;
            marker.vy = (marker.vy / newSpeed) * currentSpeed;
        }

        marker.x += marker.vx;
        marker.y += marker.vy;
        marker.life--;

        if (marker.life <= 0 || marker.x < -100 || marker.x > canvas.width + 100 || marker.y < -100 || marker.y > canvas.height + 100) {
            pheromoneMarkers.splice(i, 1);
            continue;
        }

        // ★ [최적화] 충돌 체크 (제곱 거리 사용)
        const hitRadius = player.radius + marker.radius;
        if (distSq < hitRadius * hitRadius) {
            if (player.invincibleTimer <= 0) {
                let dmg = 18 + Math.floor(score * 0.19);
                takeDamage(dmg, 'direct', marker.accuracy, marker);
                showPickupEffect(player.x, player.y, "수컷의 냄새♥", false, true, "pink-text");
                
                enemies.forEach(e => {
                    if (e.isZako) {
                        e.enraged = true;
                        e.enrageTimer = 600; 
                    }
                });
                pheromoneMarkers.splice(i, 1);
            }
        }
    }
}
        
        function updateExcaliburSlashes() {
    for (let i = excaliburSlashes.length - 1; i >= 0; i--) {
        const s = excaliburSlashes[i];
        s.x += s.vx;
        s.y += s.vy;
        s.life--;

        if (s.life <= 0 || s.x < -200 || s.x > canvas.width + 200 || s.y < -200 || s.y > canvas.height + 200) {
            excaliburSlashes.splice(i, 1);
            continue;
        }

        if (frameCount % 2 === 0) {
            slashTrails.push({
                x: s.x + (Math.random()-0.5)*40,
                y: s.y + (Math.random()-0.5)*40,
                radius: 20 + Math.random() * 10,
                life: 40,
                maxLife: 40,
                dx: (Math.random() - 0.5) * 2,
                dy: (Math.random() - 0.5) * 2
            });
        }

        // ★ [최적화] 제곱 거리 비교
        const dx = player.x - s.x;
        const dy = player.y - s.y;
        const distSq = dx * dx + dy * dy;
        const hitRadius = player.radius + s.radius;

        if (!s.hasHit && distSq < hitRadius * hitRadius) {
            if (player.invincibleTimer <= 0) {
                let dmg = 28 + Math.floor(score * 0.24);
                takeDamage(dmg, 'direct', s.accuracy, s);
                for(let k=0; k<2; k++) addStatus('fatalScar', 1800, 10);
                showPickupEffect(player.x, player.y, "페이탈 스칼!", false, true, "fatal-scar-border");
                
                s.hasHit = true;
            }
        }
    }
}
        // [신규] 연기 궤적 업데이트
function updateSlashTrails() {
    for (let i = slashTrails.length - 1; i >= 0; i--) {
        const t = slashTrails[i];
        t.x += t.dx;
        t.y += t.dy;
        t.radius *= 0.95; // 점점 작아짐
        t.life--;
        if (t.life <= 0) slashTrails.splice(i, 1);
    }
}

function updateFloatingTexts() {
    const MAX_FLOATING_TEXTS = performanceState.maxFloatingTexts; // 최대 개수 (성능에 따라 조절)

    // [최적화] 제한 개수를 넘으면 한 번에 여러 개 정리 (여유분 5개까지 포함해서 삭제)
    // 매 프레임 splice를 호출하는 것을 방지합니다.
    if (floatingTexts.length > MAX_FLOATING_TEXTS) {
        const removeCount = (floatingTexts.length - MAX_FLOATING_TEXTS) + 5;
        floatingTexts.splice(0, removeCount);
    }

    // 텍스트가 너무 많으면 수명 감소 속도를 가속 (렉 방지)
    const decayRate = (floatingTexts.length > 30) ? 2 : 1;

    for (let i = floatingTexts.length - 1; i >= 0; i--) {
        let ft = floatingTexts[i];
        
        ft.y += ft.vy; 
        ft.vy *= 0.95;

        ft.life -= decayRate;
        
        // 수명이 다하면 제거
        if (ft.life <= 0) {
            floatingTexts.splice(i, 1);
        }
    }
}

    function drawFloatingTexts() {
    ctx.save();
    
    // 공통 스타일 미리 설정 (루프 밖)
    ctx.shadowBlur = 0;
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.lineWidth = 3;

    let lastFont = ""; // [최적화] 마지막으로 설정한 폰트 기억

    for (let i = 0; i < floatingTexts.length; i++) {
        const ft = floatingTexts[i];
        
        // 투명도 계산
        const alpha = Math.max(0, ft.life / ft.maxLife);
        
        // [최적화] 거의 보이지 않는 텍스트는 그리기 연산 스킵
        if (alpha < 0.05) continue; 

        ctx.globalAlpha = alpha;
        
        // [최적화] 폰트 문자열 생성 비용은 어쩔 수 없지만, 
        // ctx.font 대입(무거운 연산)은 값이 다를 때만 수행
        const currentFont = `bold ${ft.size}px 'Black Han Sans', sans-serif`;
        
        if (lastFont !== currentFont) {
            ctx.font = currentFont;
            lastFont = currentFont;
        }
        
        // 좌표 소수점 제거 (렌더링 선명도 향상 및 미세한 성능 이득)
        const drawX = Math.floor(ft.x);
        const drawY = Math.floor(ft.y);

        // 테두리
        ctx.strokeStyle = ft.borderColor;
        ctx.strokeText(ft.text, drawX, drawY);
        
        // 글자
        ctx.fillStyle = ft.color;
        ctx.fillText(ft.text, drawX, drawY);
    }

    ctx.restore();
}

        function spawnHollowNight(x, y, accuracy = 0, owner = null) {
    // [최적화] 중첩 하드캡 (오라가 여러 개 겹치면 급격히 무거워짐)
    if (hollowNight.length >= 2) hollowNight.shift();
    hollowNight.push({
        x: x, y: y,
        radius: 144, 
        life: 1200, 
        angle: 0,
        cooldown: 0,
        accuracy: accuracy, // [추가]
        owner: owner,
    });
    showPickupEffect(x, y - 80, "할로우 나이트!", false, false, "hollow-night-text");
}
        
        function triggerEvilLight(sourceEnemy) {
            darknessOverlay.style.opacity = 1;
            setTimeout(() => { darknessOverlay.style.opacity = 0; }, 500);

            updateMaxHealth();
            showPickupEffect(player.x, player.y - 40, "사악한 빛..", false);
            
            showPickupEffect(player.x, player.y, "이 세상에 어둠을..", false, true, "wicked-large-text");
            
            addStatus('evilLight', 999999, 9999);
            
            if (sourceEnemy) {
                sourceEnemy.appliedEvilLightCount = (sourceEnemy.appliedEvilLightCount || 0) + 1;
            }

            if (player.shieldStacks > 0) {
                player.shieldStacks = Math.floor(player.shieldStacks / 2);
            }
            if (player.justiceShield > 0) {
                player.justiceShield = Math.floor(player.justiceShield / 2);
            }
            updateStatusUI();
        }

        function spawnWhiteShot(x, y, isElite, isZako, extraStacks = 0, isLucaShot = false, accuracy = 0, owner = null) {
            const angle = Math.atan2(player.y - y, player.x - x);
            const speed = 1.5; 
            let radius = 30;
            if (isElite) radius = 45; if (isZako) radius = 16;
            whiteshots.push({ 
                x: x, y: y, 
                vx: Math.cos(angle) * speed, 
                vy: Math.sin(angle) * speed, 
                radius: radius, 
                life: 400, 
                isZako: isZako, 
                isElite: isElite, 
                extraStacks: extraStacks,
                isLucaShot: isLucaShot,
                accuracy: accuracy, // [신규]
                owner: owner,
            });
        }


        // [신규] 오즈마: 방구 스모그 (갈색 방구 구름 투사체)
        function spawnFartSmog(x, y, accuracy = 0, owner = null) {
            // [SFX] 오즈마 '방구 스모그' 발사 사운드
            if (isGameRunning) playOzmaFartSmogSfx();

            const angle = Math.atan2(player.y - y, player.x - x);
            const speed = 4;

            // 크기를 키우면 히트박스도 같이 커지도록 radius에 배율을 적용
            const baseRadius = 55;
            const sizeMult = (typeof FART_SMOG_SIZE_MULT !== 'undefined') ? FART_SMOG_SIZE_MULT : 1.0;
            const radius = baseRadius * sizeMult;

            fartSmogs.push({
                x: x, y: y,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed,
                radius: radius,          // 충돌 판정용
                sizeMult: sizeMult,      // 디버그/추후 조정용
                life: 420, // 화면 밖으로 나가면 더 빨리 제거됨
                accuracy: accuracy,
                owner: owner,
                trailTimer: 0,
            });
        }
function spawnPoop(startX, startY, isEliteOrOptions, isZako = false, isGreen = false, accuracy = 0, owner = null) {
            const options = (typeof isEliteOrOptions === 'object' && isEliteOrOptions !== null)
                ? isEliteOrOptions
                : { isElite: !!isEliteOrOptions, isZako, isGreen, accuracy, owner, sizeMult: 1 };

            const angle = Math.atan2(player.y - startY, player.x - startX);

            // ------------------------------------------------------------
            // [PATCH] Poop 개체별 이동속도 랜덤/가변 지원
            //  - 기본: baseSpeed(=2) * speedMult(기본 1)
            //  - speedMin/speedMax가 있으면 개체마다 랜덤 배율 적용 (권장)
            //  - speedJitter(예: 0.25)만 있으면 ±jitter 범위로 흔들림
            // ------------------------------------------------------------
            const baseSpeed = 2;
            const speedMult = (options.speedMult != null) ? options.speedMult : 1;

            let randMult = 1;
            if (options.speedMin != null && options.speedMax != null) {
                randMult = options.speedMin + Math.random() * (options.speedMax - options.speedMin);
            } else if (options.speedJitter != null) {
                const j = options.speedJitter;
                randMult = 1 + ((Math.random() * 2 - 1) * j);
            } else if (options.speedRand != null) {
                randMult = options.speedRand;
            }

            const speed = baseSpeed * speedMult * randMult;

            let radius = 18;
            if (options.isElite) radius = 36;
            if (options.isZako) radius = 9;
            if (options.isGreen) radius = 10;
            radius *= (options.sizeMult || 1);

            poops.push({
                x: startX, y: startY,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed,
                radius: radius,
                rotation: Math.random() * Math.PI * 2,
                isElite: !!options.isElite,
                isZako: !!options.isZako,
                isGreen: !!options.isGreen,
                life: 600,
                accuracy: options.accuracy || 0,
                owner: options.owner || null,
            });
        }function spawnHomingBigPoop(x, y, accuracy = 0, owner = null) {
    bigPoops.push({ x: x, y: y, radius: 52.5, life: 360, isHoming: true, vx: 0, vy: 0, accuracy: accuracy, owner: owner });
}
       function spawnHomingSemen(x, y, accuracy = 0, owner = null) {
    homingSemens.push({ x: x, y: y, radius: 52.5, life: 360, isHoming: true, vx: 0, vy: 0, accuracy: accuracy, owner: owner });
}
        function spawnGas(x, y, isElite, isZako, extraStacks = 0, sizeMult = 1, accuracy = 0, owner = null, startFullyGrown = false) {
            let radius = 50;
            let maxRadius = 150; 
            if (isElite) { radius = 70; maxRadius = 210; } 
            if (isZako) { radius = 35; maxRadius = 120; } 
            radius *= sizeMult;
            maxRadius *= sizeMult;
            if (startFullyGrown) radius = maxRadius;
            gases.push({ 
                x: x, y: y, radius: radius, maxRadius: maxRadius, 
                alpha: 0.8, growth: startFullyGrown ? 0 : (0.5 * sizeMult), life: 300,
                isElite: isElite, isZako: isZako, extraStacks: extraStacks,
                accuracy: accuracy, // [신규]
                owner: owner,
            });
        }
       function spawnDarkGas(x, y, sizeMult = 1.0, damageMult = 1.0, accuracy = 0, explosionDamage = 0, owner = null, startFullyGrown = false) {
    let radius = 20 * sizeMult;
    let maxRadius = 140 * sizeMult;
    if (startFullyGrown) radius = maxRadius;
    
    darkGases.push({ 
        x: x, 
        y: y, 
        radius: radius, 
        maxRadius: maxRadius, 
        alpha: 0.8, 
        growth: startFullyGrown ? 0 : (0.5 * sizeMult),
        life: 300,
        damageMult: damageMult,
        accuracy: accuracy,// [신규]
        owner: owner,
        
        // [추가] 가스가 다 커졌을 때 터질 데미지와 폭발 여부 저장
        pendingDamage: explosionDamage,
        hasExploded: false
    });
}

// [NEW] DarkGas trail variant (purely visual, lightweight)
function spawnDarkGasTrail(x, y, sizeMult = 0.6, owner = null, damageMult = 0.85, accuracy = 0) {
    // Mini real DarkGas for Evil Arrow trail: deals damage + applies darkScent, but kept short/small for performance.
    // Soft cap to prevent runaway perf drops when many effects exist.
    if (darkGases.length > 240) return;

    const radius = 11 * sizeMult;
    const maxRadius = 78 * sizeMult;

    darkGases.push({
        x: x,
        y: y,
        radius: radius,
        maxRadius: maxRadius,
        alpha: 0.72,
        growth: 0.75 * sizeMult,
        life: 150,
        lifeMax: 150,

        // Gameplay effects (real darkgas)
        damageMult: damageMult,
        accuracy: accuracy,
        owner: owner,

        pendingDamage: 0,
        hasExploded: true,

        // Draw optimizations
        simpleDraw: true,
        isEvilTrail: true
    });
}


function spawnDarkGreenGas(x, y, sizeMult = 0.55, owner = null, damageMult = 1.0, accuracy = 0) {
    if (darkGreenGases.length > 260) return;

    darkGreenGases.push({
        x: x,
        y: y,
        radius: 45 * sizeMult,
        maxRadius: 210 * sizeMult,
        alpha: 0.8,
        growth: 0.8 * sizeMult,
        life: 360,
        damageMult: damageMult,
        accuracy: accuracy,
        owner: owner,
        pendingDamage: 0,
        hasExploded: true
    });
}

      function spawnExcaliburSlash(x, y, angle, accuracy = 0, owner = null) {
    excaliburSlashes.push({
        x: x, y: y,
        vx: Math.cos(angle) * 8, 
        vy: Math.sin(angle) * 8,
        angle: angle,
        radius: 90,
        life: 180,
        hasHit: false,
        accuracy: accuracy, // [추가]
        owner: owner,
    });
}
       function spawnBigPoop(x, y, accuracy = 0, owner = null) {
    bigPoops.push({ x: x, y: y, radius: 60, life: 480, accuracy: accuracy, owner: owner });
}
        function spawnPoopStain(x, y) {
            let puffs = [];
            for(let i=0; i<8; i++) { 
                puffs.push({
                    dx: (Math.random() - 0.5) * 60,
                    dy: (Math.random() - 0.5) * 60,
                    r: 20 + Math.random() * 20
                });
            }
            poopStains.push({ x: x, y: y, radius: 45, life: 420, puffs: puffs }); 
        }

       function spawnDeathCloud(x, y, isElite, isBoss, accuracy = 0, owner = null) {
            let r = 125;
            if (isElite) r = 175; if (isBoss) r = 275; 
            deathClouds.push({ x: x, y: y, radius: r, life: 240, accuracy: accuracy , owner: owner});
        }

       function spawnPianissimoSnipe(x, y, angle, accuracy = 0, owner = null) {
        pianissimoSnipes.push({
        x: x,
        y: y,
        state: 'charging', // charging(생성중) -> firing(발사)
        chargeTimer: 0,
        chargeMax: 360,    // 6초 동안 서서히 진해짐
        alpha: 0,          // 투명도 0에서 시작
        vx: 0,
        vy: 0,
        radius: 30,        // 크기
        accuracy: accuracy,
        owner: owner,
        life: 300          // 발사 후 수명 5초
    });
}
       // [신규] 프리즘 스윕 생성
        function spawnPrismSweep(x, y, accuracy, owner = null) {
            // 하늘에서 생성되므로 y는 화면 위쪽이나 타겟 근처 위
            prismSweeps.push({
                x: x, y: y - 300, // 위에서 시작
                targetY: y,       // 목표 고도
                life: 1080,       // 18초
                laserTimer: 0,
                colors: ['black', 'purple', 'red'], // 3색
                accuracy: accuracy,
                owner: owner,
            });
            showPickupEffect(player.x, player.y - 100, "프리즘♥", false, true, "wicked-large-text");
        }

        // [신규] 프리즘 스윕 업데이트
        function updatePrismSweeps() {
            for (let i = prismSweeps.length - 1; i >= 0; i--) {
                const p = prismSweeps[i];
                p.life--;
                
                // 등장 애니메이션 (부드럽게 내려옴)
                if (p.y < p.targetY) p.y += 2;
                else if (p.y > p.targetY) p.y -= 2;
                // 레이저 발사 로직 (매 프레임 레이저 유도 및 판정)
                // 레이저는 플레이어 위치로 천천히 유도됨
                const dx = player.x - p.x;
                const dy = player.y - p.y;
                const dist = Math.hypot(dx, dy);
                
                // 프리즘 자체의 이동
                p.x += (dx / dist) * 4.3; 
                p.targetY += (dy / dist) * 4.3;

                // 레이저 발사 (60프레임마다 피격 판정)
                p.laserTimer++;
                if (p.laserTimer >= 60) {
                    p.laserTimer = 0;
                    // 플레이어가 프리즘 아래(레이저 범위)에 있는지 확인 (수직 박스 판정)
                    if (Math.abs(player.x - p.x) < 40) { // 레이저 폭
                        if (player.invincibleTimer <= 0) {
                            let dmg = 18 + Math.floor(score * 0.12);
                            takeDamage(dmg, 'direct', p.accuracy, p);
                            
                            const color = p.colors[Math.floor(Date.now() / 6000) % 3];
                            if (color === 'black') {
                                addStatus('blind', 900, 10);
                                showPickupEffect(player.x, player.y, "실명..", false, true, "darkness-border");
                            } else if (color === 'purple') {
                                addStatus('curse', 900, 10);
                                showPickupEffect(player.x, player.y, "저주..", false, true, "curse-border");
                            } else if (color === 'red') {
                                addStatus('bleeding', 1800, 20);
                                showPickupEffect(player.x, player.y, "출혈..", false, true, "bleeding-border");
                            }
                        }
                    }
                }           
                if (p.life <= 0) prismSweeps.splice(i, 1);
            }
        }

function spawnGasExplosionPattern(accuracy = 0, owner = null) {
    const corners = [
        {x: 50, y: 50}, 
        {x: canvas.width - 50, y: 50},
        {x: canvas.width - 50, y: canvas.height - 50},
        {x: 50, y: canvas.height - 50} 
    ];
    
    const centerX = canvas.width / 2;
    const centerY = canvas.height / 2;
    const speed = 4.0; 

    corners.forEach(pos => {
        const angle = Math.atan2(centerY - pos.y, centerX - pos.x);
        
        movingGases.push({
            x: pos.x,
            y: pos.y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            radius: 180, // 이동 중 크기
            life: 300,
            centerX: centerX,
            centerY: centerY,
            accuracy: accuracy,
            owner: owner,
        });
    });

    showPickupEffect(player.x, player.y - 100, "똥방구 모이는 중...♥", false, true, "wicked-large-text");
}

        // [신규] 오클루전 스풀 생성
        function spawnOcclusionSpool(accuracy, owner = null) {
            const margin = 100;
            const x = margin + Math.random() * (canvas.width - margin * 2);
            const y = margin + Math.random() * (canvas.height - margin * 2);
            
            occlusionSpools.push({
                x: x, y: y,
                radius: SADISM_BROWN_GAS_RADIUS, // 볼륨감 있는 번개 필드 크기
                life: 600,   // 10초
                tickTimer: 0,
                accuracy: accuracy,
                owner: owner,
            });
            showPickupEffect(x, y, "찌릿찌릿..", false, true, "evil-purple-text");
        }
       // [신규] 오클루전 스풀 업데이트
        function updateOcclusionSpools() {
            for (let i = occlusionSpools.length - 1; i >= 0; i--) {
                const s = occlusionSpools[i];
                s.life--;
                
                const dx = player.x - s.x;
                const dy = player.y - s.y;
                const distSq = dx * dx + dy * dy;
                const rSq = s.radius * s.radius;
                if (distSq < rSq) {
                    // 번개 접촉 시 효과
                    s.tickTimer++;
                    if (s.tickTimer >= 120) { // 120프레임(2초)마다
                        s.tickTimer = 0;
                        if (player.invincibleTimer <= 0) {
                            // 1. 기절 0.5초 (18프레임)
                            player.stunTimer = 30;
                            // 2. 데미지
                            let dmg = 9 + Math.floor(score * 0.17);
                            takeDamage(dmg, 'direct', s.accuracy, s);
                            // 3. 차광 디버프
                            addStatus('shading', 600, 1); 
                            showPickupEffect(player.x, player.y, "차광! (치명타 저항 감소)", false, true, "shading-border");
                        }
                    }
                } else {
                    s.tickTimer = 100; // 범위 밖이면 타이머 리셋하되, 재진입시 빨리 맞게 설정
                }

                if (s.life <= 0) occlusionSpools.splice(i, 1);
            }
        }
        
        // [신규] 플레이어 출혈 도트 데미지 처리 (게임 루프에서 호출)
        function updatePlayerBleeding() {
            if (player.bleedingTimers.length > 0) {
                // 프레임당 데미지: 0.005 * 중첩 수
                let dotDmg = 0.005 * player.bleedingTimers.length;
                if (player.health > 0) {
                    // 무적이면 출혈 도트 데미지 무시
                    if ((player.invincibleTimer || 0) <= 0) {
                        player.health -= dotDmg;
                        if (player.health <= 0) {
                            if (hasEquippedNamedGear('호위무신의 운검') && !player.angelicReviveUsed) {
                                player.angelicReviveUsed = true;
                                player.health = Math.max(1, Math.floor(player.maxHealth * 0.10));
                                player.invincibleTimer = Math.max(player.invincibleTimer || 0, 300);
                                updateHealthUI();
                                showPickupEffect(player.x, player.y - 40, '운검 발동: 불사!', false, true, 'goddess-text');
                            } else gameOver();
                        }
                    }
                }
            }
            // 타이머 감소
                        for (let i = player.bleedingTimers.length - 1; i >= 0; i--) {
                            player.bleedingTimers[i]--;
                            if (player.bleedingTimers[i] <= 0) player.bleedingTimers.splice(i, 1);
                        }
                        // 차광 타이머 감소
                        for (let i = player.shadingTimers.length - 1; i >= 0; i--) {
                            player.shadingTimers[i]--;
                            if (player.shadingTimers[i] <= 0) player.shadingTimers.splice(i, 1);
                        }
            
                        // 차광 효과: 공격자 기준 크리로 전환됨 (피격 취약은 takeDamage에서 defenderCritResist 감소로 처리)
                        // ※ 여기서 player.critChance를 덮어쓰지 않음
            }

       // [신규] 데스메탈 크레센도 투사체 생성
        function spawnDeathMetalNote(x, y, angle, owner) {
            deathMetalNotes.push({
                x: x, y: y,
                vx: Math.cos(angle) * 7.5,
                vy: Math.sin(angle) * 7.5,
                radius: 100,
                owner: owner,
                life: 420, // 7초 (벽에 닿을 때까지라 충분히 김)
                draggingPlayer: false // 플레이어 납치 여부
            });
            showPickupEffect(x, y - 40, "크레센도!", false, true, "evil-purple-text");
        }

        // [신규] 데스메탈 크레센도 업데이트
        function updateDeathMetalNotes() {
            for (let i = deathMetalNotes.length - 1; i >= 0; i--) {
                const note = deathMetalNotes[i];
                note.x += note.vx;
                note.y += note.vy;
                note.life--;

                // 벽 충돌 체크
                const hitWall = note.x < 0 || note.x > canvas.width || note.y < 0 || note.y > canvas.height;
                
                if (hitWall || note.life <= 0) {
                    if (note.draggingPlayer) {
                        // 벽 충돌 시 데미지 및 디버프
                        let dmg = 30 + Math.floor(score * 0.3);
                        takeDamage(dmg, 'direct', note.owner.accuracy, note.owner);
                        addStatus('confusion', 300, 1); // 정신착란 5초
                        showPickupEffect(player.x, player.y, "정신착란!", false, true, "confusion-border");
                    }
                    deathMetalNotes.splice(i, 1);
                    continue;
                }

                // 플레이어 충돌 체크 (납치)
                if (!note.draggingPlayer) {
                    const dx = player.x - note.x;
                    const dy = player.y - note.y;
                    const distSq = dx*dx + dy*dy;
                    if (distSq < (player.radius + note.radius)**2) {
                        if (player.invincibleTimer <= 0) {
                            note.draggingPlayer = true;
                            showPickupEffect(player.x, player.y, "잡힘!", false, true, "weak-text");
                        }
                    }
                }

                // 플레이어 드래그 처리
                if (note.draggingPlayer) {
                    player.x = note.x;
                    player.y = note.y;
                    player.stunTimer = 2; // 이동/공격 불가하게 기절 유지
                    // 끌려가는 동안 공격/자동공격 즉시 중단
                    if (player.weapon.isAttacking) { player.weapon.isAttacking = false; player.weapon.attackTimer = 0; }
                    player.weapon.autoTimer = 0;
                }
            }
        }

        function spawnDarknessSpotlight(x, y, owner) {
    // owner가 있으면 owner.radius를 사용하고, 없으면 기본값 80 사용
    const baseRadius = owner ? owner.radius : 80;
    
    darknessSpotlights.push({
        x: x,
        y: y,
        radius: baseRadius * 2.5, // [수정] 테토라 크기의 2.5배로 설정
        life: 720, 
        owner: owner,
        tickTimer: 0,
        angle: 0 
    });
}

        // [신규] 다크니스 스포트라이트 업데이트
        function updateDarknessSpotlights() {
            for (let i = darknessSpotlights.length - 1; i >= 0; i--) {
                const spot = darknessSpotlights[i];
                
                // [수정] 테토라(owner)에게 부착되어 함께 움직이도록 좌표 동기화
        if (spot.owner && spot.owner.hp > 0) {
            spot.x = spot.owner.x;
            spot.y = spot.owner.y;
            
            // [추가] 테토라가 커지면(발기 스택 등) 장판 크기도 같이 커지도록 동기화
            if (spot.owner.radius) {
                spot.radius = spot.owner.radius * 2.5;
            }
        } else {
                    // 주인이 죽으면 스포트라이트도 소멸
                    spot.life = 0;
                }

                spot.life--;
                spot.angle += 0.02; // 마법진 회전
                spot.tickTimer++;
                
                if (spot.life <= 0) {
                    darknessSpotlights.splice(i, 1);
                    continue;
                }

                // 180프레임마다 효과 발동
                if (spot.tickTimer >= 180) {
                    spot.tickTimer = 0;
                    // 아군(적)에게 발기 스택 부여
                    enemies.forEach(e => {
                        if (e === spot.owner) return;
                        const dx = e.x - spot.x;
                        const dy = e.y - spot.y;
                        if (dx*dx + dy*dy < spot.radius**2) {
                            e.erectionStacks = Math.min((e.erectionStacks || 0) + 1, 20);
                            showDamageText(e.x, e.y, "UP", false, false, "pink-text");
                        }
                    });
                }

                // 플레이어가 안에 있으면 치명타 저항 감소 (매 프레임 체크하면 너무 빠르니 60프레임마다)
                if (frameCount % 60 === 0) {
                    const dx = player.x - spot.x;
                    const dy = player.y - spot.y;
                    if (dx*dx + dy*dy < spot.radius**2) {
                        const hadShading = player.shadingTimers.length > 0;
                        addStatus('shading', 600, 1);
                        if (!hadShading) {
                            showPickupEffect(player.x, player.y, "차광! (치명타 저항 감소)", false, true, "shading-border");
                        }
                    }
                }
            }
        }

       function spawnMindSkull(x, y, accuracy = 0, owner = null) {
    const angle = Math.atan2(player.y - y, player.x - x);
    let speed = 2.5; 
    if (owner && owner.isBoss && owner.bossType === 3) {
        const randomSpeeds = [1.2, 1.8, 2.5, 3.5, 4.5];
        speed = randomSpeeds[Math.floor(Math.random() * randomSpeeds.length)];
    }
    // [OPT] Soft cap: 과도한 누적 시 프레임 드랍 방지
    if (mindSkulls.length > 160) return;

    mindSkulls.push({
        x: x, y: y,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        radius: 20,
        angle: angle,
        speed: speed,
        life: 400,
        isScatter: false,
        accuracy: accuracy, // [추가]
        owner: owner,
    });
}
       function spawnMindSkullScatter(x, y, accuracy = 0, owner = null) {
    // [OPT] Soft cap: 과도한 누적 시 프레임 드랍 방지
    if (mindSkulls.length > 160) return;
    const count = 8;
    const speed = 2.0;
    for (let i = 0; i < count; i++) {
        const angle = (Math.PI * 2 * i) / count;
        mindSkulls.push({
            x: x,
            y: y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            radius: 20,
            angle: angle,
            speed: speed,
            life: 400,
            isScatter: true,
            accuracy: accuracy, // [추가]
            owner: owner,
        });
    }
}

// =========================================================
// [OPT] 마인드 브레이크 해골 발사체: 프리렌더 스프라이트(프레임 드랍 완화)
//  - 기존: 매 프레임/매 투사체당 다수의 arc/gradient를 생성
//  - 변경: 한 번만 오프스크린 캔버스에 렌더링 후 drawImage로 재사용
// =========================================================
let mindSkullSpriteCanvas = null;
let mindSkullSpriteSize = 0;
let mindSkullSpriteOffsetY = 0;
const MIND_SKULL_SPRITE_BASE_R = 20; // spawnMindSkull 기본 radius

function ensureMindSkullSprite() {
    if (mindSkullSpriteCanvas) return;

    const dpr = window.devicePixelRatio || 1;
    const baseR = MIND_SKULL_SPRITE_BASE_R;
    const baseS = baseR * 2.2; // [FIX] 's' 중복 선언 방지

    // 여유 캔버스(트레일 포함) — baseR=20 기준으로 약 300px대
    mindSkullSpriteSize = Math.ceil(baseS * 7.0);
    mindSkullSpriteOffsetY = baseS * 1.2;

    const c = document.createElement('canvas');
    c.width = Math.ceil(mindSkullSpriteSize * dpr);
    c.height = Math.ceil(mindSkullSpriteSize * dpr);

    const sctx = c.getContext('2d');
    sctx.scale(dpr, dpr);

    // (0,0)을 "해골 중심"으로 만들기 위해, 캔버스 중앙에서 살짝 위로 이동
    sctx.translate(mindSkullSpriteSize / 2, mindSkullSpriteSize / 2 - mindSkullSpriteOffsetY);

    // 스프라이트는 '위(−Y)로 진행'하는 방향(=angle=PI/2, rot=0)으로 고정 렌더
    const skull = { radius: baseR, angle: Math.PI / 2 };

                sctx.save();
                            // 해골이 진행 방향을 보게 회전 (보정값 적용)
                const rot = skull.angle - Math.PI / 2;
                sctx.rotate(rot);
    
                const s = skull.radius * 2.2; // 전체 크기 스케일
                const now = 0.0; // [OPT] sprite는 정적 렌더
    
                // =========================================================
                // [참조 이미지풍] 검푸른 연기 트레일 + 보라색 코어 광선
                // =========================================================
    
                // 1) 검푸른 연기 트레일 (진행 반대 방향 = +Y 로 길게)
                sctx.globalCompositeOperation = 'source-over';
                for (let i = 0; i < 9; i++) {
                    const t = i / 8; // 0(해골 근처) -> 1(뒤쪽)
                    const backY = s * (0.15 + t * 2.9);
                    const wobble = Math.sin(now + t * 6.0 + (0 + 0) * 0.01) * s * (0.10 + t * 0.20);
                    const puffR = s * (0.40 + t * 0.60) * (1 + Math.sin(now * 1.3 + t * 7.0) * 0.05);
    
                    // 깊은 검정 연기
                    const a0 = 0.26 * (1 - t) + 0.06;
                    sctx.fillStyle = `rgba(4, 6, 12, ${a0})`;
                    sctx.beginPath();
                    sctx.arc(wobble, backY, puffR, 0, Math.PI * 2);
                    sctx.fill();
    
                    // 가장자리의 푸른 기운(볼륨감)
                    const a1 = a0 * 0.7;
                    sctx.fillStyle = `rgba(25, 35, 95, ${a1})`;
                    sctx.beginPath();
                    sctx.arc(wobble * 0.65, backY + puffR * 0.12, puffR * 0.75, 0, Math.PI * 2);
                    sctx.fill();
    
                    // 소용돌이 작은 조각
                    const a2 = a0 * 0.5;
                    sctx.fillStyle = `rgba(10, 10, 20, ${a2})`;
                    sctx.beginPath();
                    sctx.arc(wobble + puffR * 0.35, backY - puffR * 0.15, puffR * 0.35, 0, Math.PI * 2);
                    sctx.fill();
                }
    
                // 2) 보라색 코어/광선 (연기 안쪽에서 번쩍이는 느낌)
                sctx.globalCompositeOperation = 'lighter';
                sctx.lineCap = 'round';
                sctx.shadowColor = 'rgba(170, 90, 255, 0.9)';
                sctx.shadowBlur = 26;
    
                const wig = Math.sin(now * 2.2 + (0 - 0) * 0.01) * s * 0.20;
                sctx.strokeStyle = 'rgba(190, 110, 255, 0.55)';
                sctx.lineWidth = Math.max(2, s * 0.085);
                sctx.beginPath();
                sctx.moveTo(0, s * 0.18);
                sctx.quadraticCurveTo(wig, s * 1.25, -wig * 0.65, s * 3.05);
                sctx.stroke();
    
                // 코어 입자 (보라색 스파크)
                for (let i = 0; i < 6; i++) {
                    const t = i / 5;
                    const y = s * (0.25 + t * 2.75);
                    const x = Math.sin(now * 1.8 + i * 2.1) * s * (0.10 + t * 0.12);
                    const pr = s * (0.055 + t * 0.05);
                    sctx.fillStyle = `rgba(200, 140, 255, ${0.32 * (1 - t)})`;
                    sctx.beginPath();
                    sctx.arc(x, y, pr, 0, Math.PI * 2);
                    sctx.fill();
                }
    
                sctx.shadowBlur = 0;
                sctx.globalCompositeOperation = 'source-over';
    
                // =========================================================
                // 해골 본체 (회백색 뼈 + 보라 균열/안광)
                // =========================================================
    
                // [오라] 사악한 보라색 후광 (은은)
                sctx.shadowColor = 'rgba(120, 60, 255, 0.55)';
                sctx.shadowBlur = 18;
    
                // 3) 두개골 (Cranium)
                sctx.beginPath();
                sctx.moveTo(0, -s * 0.42); // 정수리
                // 왼쪽 두개골 라인
                sctx.bezierCurveTo(-s * 0.36, -s * 0.42, -s * 0.48, -s * 0.10, -s * 0.42, s * 0.12);
                // 왼쪽 광대뼈
                sctx.bezierCurveTo(-s * 0.48, s * 0.28, -s * 0.25, s * 0.32, -s * 0.21, s * 0.48);
                // 턱 (Jaw)
                sctx.lineTo(-s * 0.12, s * 0.70);
                sctx.quadraticCurveTo(0, s * 0.80, s * 0.12, s * 0.70);
                sctx.lineTo(s * 0.21, s * 0.48);
                // 오른쪽 광대뼈
                sctx.bezierCurveTo(s * 0.25, s * 0.32, s * 0.48, s * 0.28, s * 0.42, s * 0.12);
                // 오른쪽 두개골 라인
                sctx.bezierCurveTo(s * 0.48, -s * 0.10, s * 0.36, -s * 0.42, 0, -s * 0.42);
                sctx.closePath();
    
                // [채색] 회백색 뼈 질감 + 약한 보라 그림자
                const skullGrad = sctx.createRadialGradient(-s * 0.12, -s * 0.10, s * 0.08, 0, 0, s * 0.72);
                skullGrad.addColorStop(0, '#E6E6E6');      // 하이라이트 (뼈)
                skullGrad.addColorStop(0.45, '#AFAFB7');   // 중간 톤
                skullGrad.addColorStop(0.75, '#5A5566');   // 그림자
                skullGrad.addColorStop(1, '#1a1028');      // 깊은 그림자 (보랏빛)
                sctx.fillStyle = skullGrad;
                sctx.fill();
    
                // 외곽선
                sctx.lineWidth = 1.6;
                sctx.strokeStyle = 'rgba(35, 20, 55, 0.9)';
                sctx.stroke();
    
                // 그림자 효과 제거 (눈/코 내부는 선명하게)
                sctx.shadowBlur = 0;
    
                // 4) 눈 구멍 (Eye Sockets)
                sctx.fillStyle = '#000000';
    
                // 왼쪽 눈
                sctx.beginPath();
                sctx.moveTo(-s * 0.12, s * 0.06);
                sctx.bezierCurveTo(-s * 0.22, -s * 0.05, -s * 0.38, -s * 0.05, -s * 0.34, s * 0.17);
                sctx.bezierCurveTo(-s * 0.31, s * 0.28, -s * 0.15, s * 0.28, -s * 0.12, s * 0.06);
                sctx.fill();
    
                // 오른쪽 눈
                sctx.beginPath();
                sctx.moveTo(s * 0.12, s * 0.06);
                sctx.bezierCurveTo(s * 0.22, -s * 0.05, s * 0.38, -s * 0.05, s * 0.34, s * 0.17);
                sctx.bezierCurveTo(s * 0.31, s * 0.28, s * 0.15, s * 0.28, s * 0.12, s * 0.06);
                sctx.fill();
    
                // [안광] 보라색 코어 (참조 이미지 느낌)
                sctx.globalCompositeOperation = 'lighter';
                sctx.shadowColor = 'rgba(190, 120, 255, 1)';
                sctx.shadowBlur = 16;
                sctx.fillStyle = 'rgba(160, 80, 255, 0.85)';
                sctx.beginPath();
                sctx.arc(-s * 0.24, s * 0.12, s * 0.03, 0, Math.PI * 2);
                sctx.arc(s * 0.24, s * 0.12, s * 0.03, 0, Math.PI * 2);
                sctx.fill();
                sctx.shadowBlur = 0;
                sctx.globalCompositeOperation = 'source-over';
    
                // 5) 코 구멍 (Nasal Cavity)
                sctx.fillStyle = '#000000';
                sctx.beginPath();
                sctx.moveTo(0, s * 0.26);
                sctx.lineTo(-s * 0.07, s * 0.37);
                sctx.lineTo(0, s * 0.34);
                sctx.lineTo(s * 0.07, s * 0.37);
                sctx.fill();
    
                // 6) 입 안쪽 보라빛 (치아 뒤에서 새어나오는 광)
                sctx.globalCompositeOperation = 'lighter';
                sctx.shadowColor = 'rgba(190, 120, 255, 0.9)';
                sctx.shadowBlur = 22;
                const mouthGrad = sctx.createRadialGradient(0, s * 0.57, s * 0.02, 0, s * 0.57, s * 0.40);
                mouthGrad.addColorStop(0, 'rgba(205, 140, 255, 0.85)');
                mouthGrad.addColorStop(0.55, 'rgba(135, 60, 235, 0.32)');
                mouthGrad.addColorStop(1, 'rgba(0, 0, 0, 0)');
                sctx.fillStyle = mouthGrad;
                sctx.beginPath();
                sctx.ellipse(0, s * 0.58, s * 0.26, s * 0.14, 0, 0, Math.PI * 2);
                sctx.fill();
                sctx.shadowBlur = 0;
                sctx.globalCompositeOperation = 'source-over';
    
                // 7) 이빨 (Teeth)
                sctx.fillStyle = '#F2F2F2';
                sctx.beginPath();
                // 윗니 4개
                for (let i = -2; i <= 1; i++) {
                    const x = (i + 0.5) * (s * 0.085);
                    const y = s * 0.50;
                    sctx.rect(x, y, s * 0.065, s * 0.085);
                }
                sctx.fill();
    
                // 치아 사이 그림자 선
                sctx.strokeStyle = 'rgba(40, 20, 65, 0.75)';
                sctx.lineWidth = 1;
                sctx.beginPath();
                sctx.moveTo(-s * 0.17, s * 0.50);
                sctx.lineTo(s * 0.17, s * 0.50);
                for (let i = -1; i <= 1; i++) {
                    const x = i * (s * 0.085);
                    sctx.moveTo(x, s * 0.48);
                    sctx.lineTo(x, s * 0.61);
                }
                sctx.stroke();
    
                // 8) 보라빛 균열 (Crack) - 이마/광대에 은은한 발광
                sctx.globalCompositeOperation = 'lighter';
                sctx.shadowColor = 'rgba(170, 90, 255, 0.8)';
                sctx.shadowBlur = 10;
                sctx.strokeStyle = 'rgba(160, 80, 255, 0.45)';
                sctx.lineWidth = 1.2;
    
                // 이마 크랙
                sctx.beginPath();
                sctx.moveTo(s * 0.22, -s * 0.28);
                sctx.lineTo(s * 0.16, -s * 0.16);
                sctx.lineTo(s * 0.24, -s * 0.10);
                sctx.stroke();
    
                // 왼쪽 광대 크랙
                sctx.beginPath();
                sctx.moveTo(-s * 0.30, s * 0.18);
                sctx.lineTo(-s * 0.22, s * 0.26);
                sctx.lineTo(-s * 0.28, s * 0.34);
                sctx.stroke();
    
                sctx.shadowBlur = 0;
                sctx.globalCompositeOperation = 'source-over';
    
                sctx.restore();
            

    mindSkullSpriteCanvas = c;
}

function drawMindSkullFast(ctx, skull) {
    ensureMindSkullSprite();

    const scale = (skull.radius || MIND_SKULL_SPRITE_BASE_R) / MIND_SKULL_SPRITE_BASE_R;
    ctx.save();
    ctx.translate(skull.x, skull.y);
    ctx.rotate((skull.angle || 0) - Math.PI / 2);
    ctx.scale(scale, scale);

    // ensureMindSkullSprite()에서 (0,0)을 해골 중심으로 맞췄던 오프셋을 역으로 적용
    ctx.drawImage(
        mindSkullSpriteCanvas,
        -mindSkullSpriteSize / 2,
        -mindSkullSpriteSize / 2 + mindSkullSpriteOffsetY
    );

    ctx.restore();
}

        // (삭제) 맵 자연 스폰 아이템 로직 제거

        function spawnDroppedItem(x, y, type) { 
            const item = { x: x, y: y, radius: 15, type: type, life: 2100 }; 
            items.push(item); 
        }
       function updateCardSelection() {
            const cards = document.querySelectorAll('.upgrade-card');
            cards.forEach((card, index) => {
                if (index === selectedCardIndex) {
                    card.classList.add('selected');
                } else {
                    card.classList.remove('selected');
                }
            });
        }
        const cardContainerEl = document.getElementById('cardContainer');
        if (cardContainerEl) {
            const observer = new MutationObserver((mutations) => {
                mutations.forEach((mutation) => {
                    if (mutation.addedNodes.length > 0) {
                        // 카드가 추가되면 0번 인덱스 선택 및 하이라이트
                        selectedCardIndex = 0;
                        setTimeout(updateCardSelection, 10);
                    }
                });
            });
            observer.observe(cardContainerEl, { childList: true });
        }
       window.addEventListener('keydown', (e) => { 
            // 1. 레벨업 모달이 떠있을 때 (일시정지 상태) -> 카드 선택 모드
            if (isLevelUpPaused) {
                const cards = document.querySelectorAll('.upgrade-card');
                if (cards.length === 0) return;

                if (e.code === 'ArrowLeft') {
                    // 왼쪽 이동 (0번보다 작아지면 마지막 카드로)
                    selectedCardIndex = (selectedCardIndex - 1 + cards.length) % cards.length;
                    updateCardSelection();
                } else if (e.code === 'ArrowRight') {
                    // 오른쪽 이동
                    selectedCardIndex = (selectedCardIndex + 1) % cards.length;
                    updateCardSelection();
                } 
                else if (e.code === 'KeyR') {
                    // R로 카드 리로드(리롤)
                    if (e.repeat) return;
                    e.preventDefault();
                    const rerollBtn = document.getElementById('rerollCardBtn');
                    if (rerollBtn && rerollBtn.style.display !== 'none' && !rerollBtn.disabled) {
                        rerollBtn.click(); // showLevelUpUI() 내부 로직 재사용
                    }
                }
                else if (e.code === 'Space' || e.code === 'Enter') {
                    // 스페이스바 또는 엔터로 선택
                    if (cards[selectedCardIndex]) {
                        cards[selectedCardIndex].click(); // 클릭 이벤트 트리거
                    }
                }
                return; // 게임 조작 키 입력 방지
            }

            // [신규] 패널이 열려있을 때: 단축키만 처리하고 게임 입력은 막기
            if (isGearPanelOpen) {
                if (e.code === 'Escape' || e.code === 'KeyP') {
                    e.preventDefault();
                    closeGearPanel();
                } else if (e.code === 'KeyI') {
                    // P 패널 → I 패널로 전환
                    e.preventDefault();
                    closeGearPanel(false);
                    openEquipPanel();
                }
                return;
            }

            if (isEquipPanelOpen) {
                if (e.code === 'Escape' || e.code === 'KeyI') {
                    e.preventDefault();
                    closeEquipPanel();
                } else if (e.code === 'KeyP') {
                    // I 패널 → P 패널로 전환
                    e.preventDefault();
                    closeEquipPanel(false);
                    openGearPanel();
                }
                return;
            }

            if (isRelicPanelOpen) {
                if (e.code === 'Escape' || e.code === 'KeyO') {
                    e.preventDefault();
                    closeRelicPanel(true);
                } else if (e.code === 'KeyP') {
                    // O 패널 → P 패널로 전환
                    e.preventDefault();
                    closeRelicPanel(false);
                    openGearPanel();
                } else if (e.code === 'KeyI') {
                    // O 패널 → I 패널로 전환
                    e.preventDefault();
                    closeRelicPanel(false);
                    openEquipPanel();
                }
                return;
            }

            // [신규] 패널 토글 (게임 플레이 중)
            if (e.code === 'KeyP') { e.preventDefault(); toggleGearPanel(); return; }
            if (e.code === 'KeyI') { e.preventDefault(); toggleEquipPanel(); return; }
            if (e.code === 'KeyO') { e.preventDefault(); toggleRelicPanel(); return; }

            // 2. 평상시 게임 플레이 조작
            if (keys.hasOwnProperty(e.code)) keys[e.code] = true;
            if (e.code === 'KeyQ') activateGoddessProtection(); 
            if (e.code === 'KeyW') activateSacredFaith();
            if (e.code === 'KeyE') activateLimitFocus();
            if (e.code === 'KeyA') activateNova();
            if (e.code === 'Space') activateDivineDash();
        });

        window.addEventListener('keyup', (e) => { if (keys.hasOwnProperty(e.code)) keys[e.code] = false; });
        // [UI Scroll Fix] 모바일에서 인벤토리/강화 패널 스크롤이 막히는 문제 해결
        function isInGearPanel(target) {
            return !!(target && target.closest && target.closest('#gearPanel'));
        }

        function hasScrollableParentInGearPanel(target) {
            if (!target || !target.closest) return false;
            const root = target.closest('#gearPanel');
            if (!root) return false;

            let el = target;
            while (el && el !== root) {
                const st = window.getComputedStyle(el);
                const oy = st.overflowY;
                if ((oy === 'auto' || oy === 'scroll') && el.scrollHeight > el.clientHeight + 1) return true;
                el = el.parentElement;
            }

            // 모바일에서 modal-panel 자체가 스크롤되는 경우도 허용
            const modal = target.closest('.modal-panel');
            if (modal) {
                const st = window.getComputedStyle(modal);
                const oy = st.overflowY;
                if ((oy === 'auto' || oy === 'scroll') && modal.scrollHeight > modal.clientHeight + 1) return true;
            }
            return false;
        }

        window.addEventListener('touchstart', (e) => {
            // GearPanel 위에서는 게임 이동 제스처를 시작하지 않음
            if (isGearPanelOpen && isInGearPanel(e.target)) {
                isTouching = false;
                return;
            }
            isTouching = true;
            touchStart.x = e.touches[0].clientX;
            touchStart.y = e.touches[0].clientY;
            touchCurrent.x = touchStart.x;
            touchCurrent.y = touchStart.y;
        }, {passive: false});

        window.addEventListener('touchmove', (e) => {
            // GearPanel 내부의 스크롤 영역에서는 기본 스크롤을 허용
            if (isGearPanelOpen && hasScrollableParentInGearPanel(e.target)) {
                return;
            }

            // 게임 플레이 중: 페이지 스크롤 방지 + 이동 제스처 처리
            e.preventDefault();
            if (isTouching) {
                touchCurrent.x = e.touches[0].clientX;
                touchCurrent.y = e.touches[0].clientY;
            }
        }, {passive: false});

        window.addEventListener('touchend', () => { isTouching = false; });


        function tryTriggerDemonicScreamGauntlet() {
            if (!hasEquippedNamedGear('절규의 건틀릿')) return;
            if (Math.random() < 0.10) {
                addStatus('despair', 600, 1);
                showPickupEffect(player.x, player.y - 60, '절규의 건틀릿: 절망!', false, true, 'darkness-border');
            }
        }

        function activateGoddessProtection() {
            if (player.goddessSkill.cooldown > 0 || player.skillSealTimer > 0) return;
            if (player.despairTimer > 0) {
                if (Math.random() < 0.5) {
                    player.goddessSkill.cooldown = player.goddessSkill.maxCooldown; // 쿨타임 적용
                    updateGoddessSkillUI();
                    showPickupEffect(player.x, player.y - 60, "절망..", false, true, "weak-text");
                    return; // 스킬 발동 중단
                }
            }

            player.poisonTimers = [];
            player.poopPoisonTimers = [];
            player.maliceTimers = [];
            player.kissTimers = [];
            player.semenTimers = [];
            player.oralTimers = [];
            player.byururutTimers = [];
            player.blindTimers = []; 
            player.darknessTimers = [];

            player.fishyTimers = [];
            // [수정] 아서 전용 디버프 해제 불가
            // player.trueAncestorKissTimers = [];
            // player.fatalScarTimers = [];
            // player.corruptedBloodTimers = [];
            
            // const hadEvilMind = player.evilMindTimers.length > 0;
            // player.evilMindTimers = [];
            // if (hadEvilMind) updateMaxHealth();
            
            tryTriggerDemonicScreamGauntlet();
            player.goddessSkill.cooldown = player.goddessSkill.maxCooldown;
            const goddessHealRatio = Math.min(0.25, level * 0.001);
            let healAmount = player.maxHealth * goddessHealRatio;
            if (player.gnawingLifeTimers.length > 0) {
                const gnawingReduction = Math.min(0.95, player.gnawingLifeTimers.length * 0.02);
                healAmount *= (1 - gnawingReduction);
            }
            player.health = Math.min(player.maxHealth, player.health + healAmount);
            showDamageText(player.x, player.y, "+" + Math.floor(healAmount), false, false, "heal-text");

            const goddessJusticeGain = Math.floor(level / 25);
            if (goddessJusticeGain > 0) {
                player.justiceShield += goddessJusticeGain;
                showPickupEffect(player.x, player.y - 90, `정의의 가호 +${goddessJusticeGain}`, false, true, "justice-border");
            }

            showPickupEffect(player.x, player.y - 60, "성스러운 힘이여!", false, true, "goddess-text");
            updateStatusUI();
            updatePoopVisual();
        }

        function activateSacredFaith() {
            if (player.sacredFaithSkill.cooldown > 0 || player.skillSealTimer > 0) return;
            if (player.despairTimer > 0) {
                if (Math.random() < 0.5) {
                    // 쿨타임만 적용되고 효과는 발동 안 함
                    player.sacredFaithSkill.cooldown = player.sacredFaithSkill.maxCooldown;
                    updateSacredFaithUI();
                    showPickupEffect(player.x, player.y - 60, "절망..", false, true, "weak-text");
                    return;
                }
            }
            tryTriggerDemonicScreamGauntlet();
            player.sacredFaithSkill.cooldown = player.sacredFaithSkill.maxCooldown;
            player.sacredFaithSkill.activeTimer = player.sacredFaithSkill.duration;
            tryApplyAngelicActiveExtend(player.sacredFaithSkill, '성스러운 믿음');

            showPickupEffect(player.x, player.y - 60, "믿음이 충만해진다!", false, true, "goddess-text");
            
            sacredFaithOverlay.style.opacity = 0.5;
            setTimeout(() => { sacredFaithOverlay.style.opacity = 0; }, 500);

            updateSacredFaithUI();
        }

        function activateLimitFocus() {
            if (player.limitFocusSkill.cooldown > 0 || player.skillSealTimer > 0) return;
            if (player.despairTimer > 0) {
                if (Math.random() < 0.5) {
                    player.limitFocusSkill.cooldown = player.limitFocusSkill.maxCooldown;
                    updateLimitFocusUI();
                    showPickupEffect(player.x, player.y - 60, "절망..", false, true, "weak-text");
                    return;
                }
            }
            tryTriggerDemonicScreamGauntlet();
            player.limitFocusSkill.cooldown = player.limitFocusSkill.maxCooldown;
            player.limitFocusSkill.activeTimer = player.limitFocusSkill.duration;
            tryApplyAngelicActiveExtend(player.limitFocusSkill, '한계 집중');

            showPickupEffect(player.x, player.y - 60, "한계 집중!", false, true, "hyper-border"); // 이펙트
            
            // UI 즉시 갱신
            updateLimitFocusUI();
        }

        function activateNova() {
            if (player.novaSkill.cooldown > 0 || player.skillSealTimer > 0) return;
            if (player.despairTimer > 0) {
                if (Math.random() < 0.5) {
                    player.novaSkill.cooldown = player.novaSkill.maxCooldown;
                    updateNovaUI();
                    showPickupEffect(player.x, player.y - 60, "절망..", false, true, "weak-text");
                    return;
                }
            }
            tryTriggerDemonicScreamGauntlet();
            player.novaSkill.cooldown = player.novaSkill.maxCooldown;
            
            shockwaves.push({
                x: player.x,
                y: player.y,
                radius: 10,
                speed: 15,
                alpha: 1.0,
                fade: 0.05
            });
            showPickupEffect(player.x, player.y - 60, "꺼져라!!", false, true, "block-text");
            player.novaBarrierValue = Math.floor(player.maxHealth * 0.10);
            player.novaBarrierTimer = 600;

            enemies.forEach(e => {
                const dist = Math.hypot(e.x - player.x, e.y - player.y);
                
                if (dist < player.novaSkill.range || e.isAttached) {
                    
                    if (e.isAttached) {
                        e.isAttached = false;
                        e.attachTimer = 0; // 즉시 재부착 방지를 위한 쿨타임 (필요 시 값을 늘리세요)
                    }

                    // 밀어낼 방향 계산
                    // 적이 플레이어와 완전히 겹쳐있을 경우(붙잡힌 상태 등)를 대비해 각도 계산
                    let angle = Math.atan2(e.y - player.y, e.x - player.x);
                    
                    e.x += Math.cos(angle) * player.novaSkill.pushPower;
                    e.y += Math.sin(angle) * player.novaSkill.pushPower;
                    
                    // [요청 사항] 기절 2초 적용
                    let finalStunDuration = 120;
                    const reducedStunTarget = e.isElite || e.isRoyal || e.isArthur || (e.isBoss && !e.isArthur) || (e.isArchdemon && ((e.archdemonName || '').includes('아키토') || (e.archdemonName || '').includes('토우야')));
                    if (reducedStunTarget) {
                        finalStunDuration = 60;
                        showDamageText(e.x, e.y, "기절 저항", false, false, "weak-text");
                    }
                    let finalDamage = 30 + (level * 3);
                    // 기절 타이머 적용
                    if (e.stunTimer < finalStunDuration) e.stunTimer = finalStunDuration;
                    
                    e.hp -= finalDamage;
                    e.hitFlash = 5;
                    showDamageText(e.x, e.y, "PUSH!", true);
                }
            });
            updateNovaUI();
        }

        function updateGoddessSkillUI() {
            if (player.goddessSkill.cooldown > 0) {
                const percent = (player.goddessSkill.cooldown / player.goddessSkill.maxCooldown) * 100;
                goddessCooldownOverlay.style.height = percent + '%';
                goddessCooldownText.style.display = 'block';
                goddessCooldownText.innerText = Math.ceil(player.goddessSkill.cooldown / 60);
            } else {
                goddessCooldownOverlay.style.height = '0%';
                goddessCooldownText.style.display = 'none';
            }
            
            // 봉인 오버레이
            if (player.skillSealTimer > 0) {
                goddessSealOverlay.style.display = 'flex';
            } else {
                goddessSealOverlay.style.display = 'none';
            }
        }

        function updateSacredFaithUI() {
            if (player.sacredFaithSkill.cooldown > 0) {
                const percent = (player.sacredFaithSkill.cooldown / player.sacredFaithSkill.maxCooldown) * 100;
                sacredFaithCooldownOverlay.style.height = percent + '%';
                sacredFaithCooldownText.style.display = 'block';
                sacredFaithCooldownText.innerText = Math.ceil(player.sacredFaithSkill.cooldown / 60);
            } else {
                sacredFaithCooldownOverlay.style.height = '0%';
                sacredFaithCooldownText.style.display = 'none';
            }
            
             // 봉인 오버레이
            if (player.skillSealTimer > 0) {
                sacredFaithSealOverlay.style.display = 'flex';
            } else {
                sacredFaithSealOverlay.style.display = 'none';
            }
        }
        
        function updateNovaUI() {
            if (player.novaSkill.cooldown > 0) {
                const percent = (player.novaSkill.cooldown / player.novaSkill.maxCooldown) * 100;
                novaCooldownOverlay.style.height = percent + '%';
                novaCooldownText.style.display = 'block';
                novaCooldownText.innerText = Math.ceil(player.novaSkill.cooldown / 60);
            } else {
                novaCooldownOverlay.style.height = '0%';
                novaCooldownText.style.display = 'none';
            }
            
             // 봉인 오버레이
            if (player.skillSealTimer > 0) {
                novaSealOverlay.style.display = 'flex';
            } else {
                novaSealOverlay.style.display = 'none';
            }
        }

            function updateLimitFocusUI() {
            // 쿨타임 오버레이 처리
            if (player.limitFocusSkill.cooldown > 0) {
                const percent = (player.limitFocusSkill.cooldown / player.limitFocusSkill.maxCooldown) * 100;
                limitFocusCooldownOverlay.style.height = percent + '%';
                limitFocusCooldownText.style.display = 'block';
                limitFocusCooldownText.innerText = Math.ceil(player.limitFocusSkill.cooldown / 60);
            } else {
                limitFocusCooldownOverlay.style.height = '0%';
                limitFocusCooldownText.style.display = 'none';
            }
            
            // 지속시간 표시 (아이콘 테두리가 반짝이거나 활성 상태 표시)
            if (player.limitFocusSkill.activeTimer > 0) {
                 limitFocusImg.style.border = "3px solid #00FFFF"; // 활성화 시 청록색 테두리
            } else {
                 limitFocusImg.style.border = "none";
            }

            // 봉인 오버레이
            if (player.skillSealTimer > 0) {
                limitFocusSealOverlay.style.display = 'flex';
            } else {
                limitFocusSealOverlay.style.display = 'none';
            }
        }

       function activateDivineDash() {
    if (player.divineDashSkill.cooldown > 0 || player.skillSealTimer > 0 || player.dashTimer > 0 || player.stunTimer > 0 || player.rootTimer > 0) return;

    let reducedCooldown = 900 - (level * 6);
    if (reducedCooldown < 420) reducedCooldown = 420;

    if (player.despairTimer > 0) {
        if (Math.random() < 0.5) {
            player.divineDashSkill.cooldown = reducedCooldown; // 계산된 쿨타임 적용
            updateDivineDashUI();
            showPickupEffect(player.x, player.y - 60, "절망..", false, true, "weak-text");
            return;
        }
    }

    let dx = 0, dy = 0;
    if (keys.ArrowUp) dy = -1;
    if (keys.ArrowDown) dy = 1;
    if (keys.ArrowLeft) dx = -1;
    if (keys.ArrowRight) dx = 1;

    // 모바일 터치 대응
    if (isTouching) {
        const touchDx = touchCurrent.x - touchStart.x;
        const touchDy = touchCurrent.y - touchStart.y;
        const distance = Math.hypot(touchDx, touchDy);
        if (distance > 10) {
            dx = touchDx / distance;
            dy = touchDy / distance;
        }
    }

    // 이동 입력이 없으면 현재 캐릭터(무기)가 바라보는 방향으로 돌진
    if (dx === 0 && dy === 0) {
        dx = Math.cos(player.weapon.angle);
        dy = Math.sin(player.weapon.angle);
    } else {
        // 벡터 정규화 (대각선 속도 일정하게)
        const len = Math.hypot(dx, dy);
        if (len > 0) {
            dx /= len;
            dy /= len;
        }
    }

    // 돌진 상태 설정
    player.dashTimer = player.divineDashSkill.duration;
    player.dashVx = dx * player.divineDashSkill.speed;
    player.dashVy = dy * player.divineDashSkill.speed;

    tryTriggerDemonicScreamGauntlet();
    player.divineDashSkill.cooldown = reducedCooldown; 
    
    player.invincibleTimer = player.divineDashSkill.duration; // 돌진 시간 동안 무적
    const divineJusticeGain = Math.floor(level / 25);
    if (divineJusticeGain > 0) {
        player.justiceShield += divineJusticeGain;
        showPickupEffect(player.x, player.y - 90, `정의의 가호 +${divineJusticeGain}`, false, true, "justice-border");
    }
    showPickupEffect(player.x, player.y - 60, "천상의 도약!", false, true, "block-text");
    updateDivineDashUI();
}

        // [신규] 천상의 도약 UI 업데이트 함수
        function updateDivineDashUI() {
            if (player.divineDashSkill.cooldown > 0) {
                const percent = (player.divineDashSkill.cooldown / player.divineDashSkill.maxCooldown) * 100;
                divineDashCooldownOverlay.style.height = percent + '%';
                divineDashCooldownText.style.display = 'block';
                divineDashCooldownText.innerText = Math.ceil(player.divineDashSkill.cooldown / 60);
            } else {
                divineDashCooldownOverlay.style.height = '0%';
                divineDashCooldownText.style.display = 'none';
            }
            
            if (player.skillSealTimer > 0) {
                divineDashSealOverlay.style.display = 'flex';
            } else {
                divineDashSealOverlay.style.display = 'none';
            }
        }

        function performAttack() {
            if (player.weapon.isAttacking) return;
            if (player.stunTimer > 0) return;
            if (blackMoons.some(m => Math.hypot(player.x - m.x, player.y - m.y) < (m.pullRange || 0))) return;
            if (enemies.some(e => e && e.hp > 0 && e.isRyuon && e.chargeState === 'charging' && Math.hypot(player.x - e.x, player.y - e.y) < 340)) return;
            if (enemies.some(e => e && e.hp > 0 && e.isGawain && e.isCruelCharging && e.cruelChargeVictim)) return;
            if (deathMetalNotes.some(n => n && n.draggingPlayer)) return;
            player.weapon.isAttacking = true; player.weapon.attackTimer = 15;
            let angle = player.weapon.angle; if (player.vx !== 0 || player.vy !== 0) { angle = Math.atan2(player.vy, player.vx); }
            player.weapon.baseAngle = angle; 
            checkWeaponCollision(angle, false);
            checkWeaponCollision(angle + Math.PI, true);
        }

        function checkWeaponCollision(faceAngle, isRear = false) {
    const range = player.weapon.length + 30;
    let baseDamage = player.weapon.damage;
    if (isRear) {
        baseDamage = baseDamage * 0.75;
    }

    let finalDamage = baseDamage;
    if (player.limitFocusSkill.activeTimer > 0) {
        finalDamage *= (1.25 + (level * 0.00025));
    }
    if (player.baptismStacks > 0) {
        finalDamage *= (1 - (player.baptismStacks * 0.15));
    }
    if (player.darkSeedTimers.length > 0) {
        finalDamage *= (1 - (player.darkSeedTimers.length * 0.02));
    }
    
    const darkReceiverMultiplier = 1 + (player.darkReceiverTimers.length * 0.02);
    const attackArc = (Math.PI / 2) * 0.9375;

    let missChance = (player.blindTimers.length * 0.05) + (player.deepDarknessStacks * 0.1) - player.bonusAccuracy;
    if (player.limitFocusSkill.activeTimer > 0) {
        missChance -= (0.10 + (level * 0.001));
    }

    for (const enemy of enemies) {
        if (enemy.isAttached) continue;
        const dx = enemy.x - player.x; const dy = enemy.y - player.y; const dist = Math.hypot(dx, dy);
        const angleToEnemy = Math.atan2(dy, dx);
        let angleDiff = angleToEnemy - faceAngle; while (angleDiff <= -Math.PI) angleDiff += Math.PI*2;
        while (angleDiff > Math.PI) angleDiff -= Math.PI*2;
        
        const hitByWeapon = dist < range + enemy.radius && Math.abs(angleDiff) < attackArc;
        let hitByBody = false;
        if (!isRear) {
            hitByBody = dist < player.radius + enemy.radius + 15;
        }

        if (hitByWeapon || hitByBody) {
            // 기존 카이 은신 판정
            if (enemy.isKai && enemy.isInvisible) {
                showDamageText(enemy.x, enemy.y, "MISS (은신)", false, false, "weak-text");
                continue; 
            }

            // [추가됨] 검은 민족 카이토 은신 판정
            if (enemy.isKaito && enemy.isKaitoStealth) {
                showDamageText(enemy.x, enemy.y, "MISS (은신)", false, false, "weak-text");
                continue;
            }

            if (enemy.isQuesta && enemy.isFlickering) {
                finalDamage *= 0.75; // 받는 데미지 25% 감소 (즉, 75% 받음)
            }
            if (enemy.isMasakuni && enemy.moveDashDuration > 0) {
                 finalDamage *= 0.5; // 데미지 50% 감소
            }

            // [수정] 적 고유 회피율 적용
            let enemyEvasion = enemy.evasion || 0;

            // [신규] 생존 시간(초) 기반 적 회피 증가
            enemyEvasion += (score / ENEMY_SCORE_SCALING.stepSeconds) * ENEMY_SCORE_SCALING.evasionPerStep;

                    if (enemy.erectionStacks > 0) {
                        let evaPerStack = 0.005 + (score / 15000);
                        let stackBonus = enemy.erectionStacks * evaPerStack;
                        let timeBonus = (score / 10) * 0.003;
                        enemyEvasion += (stackBonus + timeBonus);
                    }

                    if (player.semenTimers.length > 0) {
                        enemyEvasion += (player.semenTimers.length * 0.005);
                    }
                    
                    if (enemy.gawainSanctuaryCount > 0) {
                        enemyEvasion += (0.05 * enemy.gawainSanctuaryCount);
                    }
                    
                    if (activeAkiCount > 0) {
                         enemyEvasion += (0.02 * activeAkiCount);
                    }

                    // [신규] 기절 중인 적은 회피가 50% 감소
                    if (enemy.stunTimer > 0) enemyEvasion *= 0.5;
                    
                   const forceHitByAngelic = !!player.angelicNextHitSure;
                   const missRoll = Math.random() < (missChance + enemyEvasion);
                   if (hitByWeapon && !forceHitByAngelic && missRoll) {
                           showDamageText(enemy.x, enemy.y, "MISS!", false, false, "crit-text");
                        player.angelicNextHitSure = hasEquippedNamedGear('찬란한 유산의 실키얀 글로브');
                        if (player.angelicNextHitSure) {
                            showPickupEffect(player.x, player.y - 44, '실키얀 글로브: 다음 공격 필중!', false, true, 'goddess-text');
                        }
                        if (enemy.isMasakuni) {
                            enemy.nextAttackCrit = true;
                            showDamageText(enemy.x, enemy.y - 40, "심안 발동!", false, false, "masakuni-text");
                        }

                    if (enemy.isQuesta) {
                            // 쉐도우 위빙: 회피 시 3.5배 다크가스
                            spawnDarkGas(enemy.x, enemy.y, 4, 1.0, enemy.accuracy, 0, enemy);
                            showPickupEffect(enemy.x, enemy.y - 40, "곁에서 뿌우욱♥", false, true, "shadow-text");
                        }

                        continue; 
                    }

                    if (forceHitByAngelic) {
                        player.angelicNextHitSure = false;
                        showPickupEffect(enemy.x, enemy.y - 36, '실키얀 글로브: 필중!', false, true, 'goddess-text');
                    }

                    if (enemy.hasShield) {
                        enemy.hasShield = false;
                        showDamageText(enemy.x, enemy.y, "BLOCKED!", false);
                        showPickupEffect(enemy.x, enemy.y - 40, "쉴드 방어!", false, false, "block-text");
                        continue;
                    }

                    // [신규] 악마의 보호: 데미지 분산 로직
                    if (enemy.isBoss && enemy.protectionTarget && enemy.protectionTarget.hp > 0) {
                        finalDamage *= 0.5;
                        let redirectDmg = (player.weapon.damage * 0.25);
                        enemy.protectionTarget.hp -= redirectDmg;
                        showDamageText(enemy.protectionTarget.x, enemy.protectionTarget.y, "대신 맞음! -" + Math.floor(redirectDmg), false, false, "weak-text");
                    }

                    if (enemy.isKai && enemy.soulLinkTarget && enemy.soulLinkTarget.hp > 0 && !enemy.shadowSwapCharging) {
                        showDamageText(enemy.x, enemy.y, "IMMUNE", false, false, "block-text");
                        continue; 
                    }

                    let totalDefense = (enemy.defense || 0);
                    
                    if (enemy.isTetora) {
                         const reduction = Math.min(0.25, enemy.allyCount * 0.025);
                         finalDamage *= (1 - reduction);
                    }

                    // [수정] 발기 상태일 때만
                    if (enemy.erectionStacks > 0) {
                        let defensePerStack = 0.3 + (score / 200);
                        let stackBonus = enemy.erectionStacks * defensePerStack;
                        let timeBonus = (score / 25);
                        totalDefense += (stackBonus + timeBonus);
                    }
                    
                    totalDefense *= darkReceiverMultiplier;

                    // [신규] 기절 중인 적은 방어가 50% 감소
                    if (enemy.stunTimer > 0) totalDefense *= 0.5;

                    let actualDamage = finalDamage - totalDefense;
                    actualDamage = Math.floor(actualDamage);
                    if (actualDamage < 1) actualDamage = 1;

                    if (enemy.isTaro && enemy.isTransparent) {
                        actualDamage *= 0.5;
                        showDamageText(enemy.x, enemy.y, "뎀감..", false); 
                    } else if (enemy.isStealth && enemy.alpha < 0.9) {
                        actualDamage *= 0.75;
                    }
                    
                    if (enemy.isAmbush && enemy.ambushState === 'ambush' && enemy.normalType === 'rapist') {
                         actualDamage *= 0.75;
                    }

                    if (enemy.isZako && enemy.state === 'pouncing') {
                        actualDamage *= 0.5;
                    }

                    let enemyCritResist = (enemy.critResist || 0);
                    const tetora = enemies.find(e => e.isTetora && e.hp > 0);
                    if (tetora && tetora.currentSong === 'requiem' && tetora.songTimer > 0 && enemy !== tetora) {
                       totalDefense *= 1.2; 
                       enemyCritResist *= 1.2; 
                    }
                    // [수정] 발기 상태일 때만
                    if (enemy.erectionStacks > 0) {
                        let resistPerStack = 0.5 + (score / 150);
                        let stackBonus = enemy.erectionStacks * resistPerStack;
                        let timeBonus = (score / 10); // 10점당 치명타 저항 확률 1
                        enemyCritResist += (stackBonus + timeBonus);
                    }
                    
                    let attackerCritChance = (player.critChance || 0);
                    if (player.limitFocusSkill.activeTimer > 0) {
                      enemyCritResist = (enemyCritResist * 0.7) - (level * 0.25);
                      attackerCritChance += (10 + (level * 0.1));
                    }

                    if (activeAkiCount > 0) {
                        enemyCritResist += (activeAkiCount * 5);
                    }

                    const critChance = Math.max(0, Math.min(100, attackerCritChance - enemyCritResist));
                    let isCrit = false;
                    
                    if (Math.random() * 100 < critChance) {
                        actualDamage *= (player.critDamageMultiplier || 1.5);
                        isCrit = true;
                                // [NEW] 유물 특수 효과: 공격 치명타 트리거
                                if (typeof relicOnPlayerDealtCrit === 'function') relicOnPlayerDealtCrit();
                        if (hasEquippedNamedGear('심연의 고리') && (player._demonicProc?.abyssLoopCd || 0) <= frameCount && Math.random() < 0.12) {
                            player._demonicProc.abyssLoopCd = frameCount + 600;
                            player._demonicProc.abyssLoopUntil = frameCount + 300;
                        }
                        if (hasEquippedNamedGear('붉은 계약 펜던트')) {
                            const heal = player.maxHealth * 0.01;
                            player.health = Math.min(player.maxHealth, player.health + heal);
                            updateHealthUI();
                        }
                        if (hasEquippedNamedGear('에너지 드레인 인장') && Math.random() < 0.10) {
                            for (const sk of getActiveSkillList()) sk.cooldown = Math.max(0, sk.cooldown - 60);
                            updateGoddessSkillUI(); updateSacredFaithUI(); updateNovaUI(); updateLimitFocusUI(); updateDivineDashUI();
                        }
                    }

                    // [NEW] 장비 특수옵션: 연속 치명타(2회) 시 4초 치확 버프 트리거
                    if (isCrit) {
                        player._gearCritStreak = (player._gearCritStreak || 0) + 1;
                        const dcVal = (player._gearSpecial && player._gearSpecial.doubleCritCritChance) ? player._gearSpecial.doubleCritCritChance : 0;
                        if (dcVal > 0 && player._gearCritStreak >= 2) {
                            player._gearCritStreak = 0;
                            player._gearDoubleCritTimer = 240; // 4초(60fps)
                        }
                    } else {
                        player._gearCritStreak = 0;
                    }

                    actualDamage = Math.floor(actualDamage);
                    if (actualDamage < 1) actualDamage = 1;

                    // [신규] 카이 그림자 스왑 차지 보호막: HP보다 먼저 깎임
                    if ((enemy.shadowSwapShield || 0) > 0) {
                        const blocked = Math.min(enemy.shadowSwapShield, actualDamage);
                        enemy.shadowSwapShield -= blocked;
                        actualDamage -= blocked;

                        showDamageText(enemy.x, enemy.y, "BLOCK " + blocked, false, false, "block-text");

                        // 보호막 파괴로 차지 취소(즉시)
                        if (enemy.shadowSwapShield <= 0 && enemy.shadowSwapCharging) {
                            const backlashDamage = Math.max(1, Math.floor(enemy.maxHp * 0.25));
                            enemy.hp -= backlashDamage;
                            showDamageText(enemy.x, enemy.y, backlashDamage, false, false, "weak-text");
                            enemy.shadowSwapCharging = false;
                            enemy.shadowSwapChargeTimer = 0;
                            enemy.shadowSwapShield = 0;
                            enemy.shadowSwapShieldMax = 0;
                            enemy.shadowSwapTimer = 0; // 쿨타임 재시작
                            showPickupEffect(enemy.x, enemy.y - 60, "보호막 파괴! 스왑 취소", false, true, "dirty-pink-text");
                        }
                    }

                    if ((enemy.antiPassingShield || 0) > 0) {
                        const blocked = Math.min(enemy.antiPassingShield, actualDamage);
                        enemy.antiPassingShield -= blocked;
                        actualDamage -= blocked;

                        showDamageText(enemy.x, enemy.y, "BLOCK " + blocked, false, false, "block-text");

                        if (enemy.antiPassingShield <= 0 && enemy.antiPassingCharging) {
                            const backlashDamage = Math.max(1, Math.floor(enemy.maxHp * 0.25));
                            enemy.hp -= backlashDamage;
                            showDamageText(enemy.x, enemy.y, backlashDamage, false, false, "weak-text");
                            enemy.antiPassingCharging = false;
                            enemy.antiPassingChargeTimer = 0;
                            enemy.antiPassingShield = 0;
                            enemy.antiPassingShieldMax = 0;
                            enemy.antiPassingTentacleSpawnTimer = 0;
                            enemy.antiPassingTimer = 0;
                            showPickupEffect(enemy.x, enemy.y - 60, "보호막 파괴! 안티 패싱 취소", false, true, "poop-text");
                        }
                    }

                    if (actualDamage > 0) {
                        if (hasEquippedNamedGear('악몽의 결정 단검') && Math.random() < 0.10) {
                            enemy.curseStacks = Math.min(10, (enemy.curseStacks || 0) + 1);
                            enemy.curseTimer = Math.max(enemy.curseTimer || 0, frameCount + 900);
                        }
                        if (hasEquippedNamedGear('심연의 독니검') && Math.random() < 0.03) {
                            enemy.purifyingPoisonUntil = Math.max(enemy.purifyingPoisonUntil || 0, frameCount + 600);
                        }
                        if (hasEquippedNamedGear('흑도 ‘무라사메・심연’') && Math.random() < 0.05) {
                            enemy.darknessUntil = Math.max(enemy.darknessUntil || 0, frameCount + 600);
                        }
                        enemy.hp -= actualDamage; 
                        enemy.hitFlash = 5; 
                        showDamageText(enemy.x, enemy.y, actualDamage, isCrit, isRear);
                    }


                    // [신규] 기절 확률: 적 상태이상 저항과 상쇄
                    const baseStunChance = player.bonusStunChance || 0;
                    const resist = enemy.statusResist || 0;
                    let effectiveStunChance = baseStunChance - resist;
                    if (effectiveStunChance > 0) {
                        effectiveStunChance = Math.max(0, Math.min(1, effectiveStunChance));
                        if (Math.random() < effectiveStunChance) {
                            // 무기 타격 기절: 발동 시 0.75초 고정
                            const stunFrames = Math.max(1, Math.floor(0.75 * 60)); // 45프레임
                            enemy.stunTimer = Math.max(enemy.stunTimer || 0, stunFrames);

                                // [NEW] 유물 특수 효과: 기절 트리거
                                if (typeof relicOnEnemyStunned === 'function') relicOnEnemyStunned(enemy);
                        }
                    }

                    let knockbackPower = 10;
                    if (enemy.isBoss) knockbackPower *= 0.1; 
                    else if (enemy.isElite) knockbackPower *= 0.3;

                    if (!enemy.isSuperArmor) { 
                        const pushAngle = Math.atan2(enemy.y - player.y, enemy.x - player.x);
                        enemy.x += Math.cos(pushAngle) * knockbackPower;
                        enemy.y += Math.sin(pushAngle) * knockbackPower;
                    } else {
                        showDamageText(enemy.x, enemy.y, "SUPER ARMOR", false, false, "block-text");
                    }
                } 
            }
        }

     function updateGeoptalHeal() {
    if (player.geoptalCount > 0 && frameCount % 120 === 0) {
        let baseHeal = 2 + Math.floor(score * 0.04);
        for (let e of enemies) {
            if (e.hp > 0) {
                let healAmount = (baseHeal * player.geoptalCount) * (e.hpRecoveryRate || 1);
                healAmount = Math.floor(healAmount);
                
                // [수정] 최대 체력을 넘지 않도록 제한
                e.hp = Math.min(e.maxHp, e.hp + healAmount); 
                
                showDamageText(e.x, e.y, "+" + healAmount, false, false, 'heal-text');
            }
        }
    }
}

        // [신규] 새디즘 판정에 사용: 상태이상까지 반영한 '최종 치명타 저항'
        const SADISM_CRITRESIST_THRESHOLD = 0;
        const SADISM_LIFESTEAL_RATIO = 0.3;  


        // [신규] 새디즘 활성화 연출(시각효과): 갈색 방구 가스 지속 타이머
        // - 새디즘 회복이 한 번이라도 발동하면 시작
        // - 새디즘이 다시 발동하면 타이머가 갱신됨
        // - 타이머가 끝나거나(해제), 퀘스타가 사망하면 분사만 중단(이미 나온 가스는 자연 소멸)
        const SADISM_GAS_DURATION_FRAMES = 360; // 60fps 기준 6초

        function activateSadismGas(owner) {
            if (!owner) return;
            owner.sadismGasTimer = SADISM_GAS_DURATION_FRAMES; // 발동 시 항상 갱신
            owner.sadismGasSpawnTick = owner.sadismGasSpawnTick || 0;
            owner.sadismGasActive = true;
        }

        function getEffectiveDefenderCritResist() {
            let defenderCritResist = player.critResist;

            // takeDamage()의 크리 판정과 동일한 '피격 취약' / 가스 / 낙인 / 버프 반영
            defenderCritResist -= (player.dangerousJudgmentStacks * 10);
            defenderCritResist -= (player.corruptedOathStacks * 10);

            if (player.fractureTimers.length > 0) {
                defenderCritResist -= (player.fractureTimers.length * 5);
            }
            if (player.inPinkGas) {
                defenderCritResist *= 0.5;
            }
            if (player.deathBrandTimers.length > 0) {
                defenderCritResist *= 0.5;
            }
            if (player.shadingTimers.length > 0) {
                defenderCritResist -= 15;
            }
            if (player.trueAncestorKissTimers.length > 0) {
                defenderCritResist -= (player.trueAncestorKissTimers.length * 3);
            }
            if (player.fatalScarTimers.length > 0) {
                defenderCritResist -= (player.fatalScarTimers.length * 3);
            }
            if (player.sacredFaithSkill && player.sacredFaithSkill.activeTimer > 0) {
                defenderCritResist += (15 + (level * 0.25));
            }
            return defenderCritResist;
        }


        
       function takeDamage(amount, type = 'direct', accuracy = 0, attacker = null) {
            if (player.invincibleTimer > 0) return;
            
            if (type === 'direct') {
                let effectiveAccuracy = accuracy;

                 let totalEvasion = 0.02 + (player.bonusEvasion || 0);
                // [수정] 플레이어 기절 중: **총 회피(기본 2% 포함) 50% 감소**
                if (player.stunTimer > 0) totalEvasion *= 0.5;

                let dodgeChance = totalEvasion - effectiveAccuracy;
                if (player._demonicNoDodge) dodgeChance = 0;
             if (player.deathBrandTimers.length > 0) {
                 dodgeChance *= 0.5;
            }
                if (Math.random() < dodgeChance) {
                    showDamageText(player.x, player.y, "DODGE", false, false, "weak-text");
                    if (hasEquippedNamedGear('창천의 푸르름') && frameCount >= (player.angelicSkyShieldCd || 0)) {
                        player.novaBarrierValue = (player.novaBarrierValue || 0) + (player.maxHealth * 0.10);
                        player.novaBarrierTimer = Math.max(player.novaBarrierTimer || 0, 300);
                        player.angelicSkyShieldCd = frameCount + 600;
                        showPickupEffect(player.x, player.y - 30, '창천의 푸르름: 실드 획득!', false, true, 'shield-border');
                    }

                    // [NEW] 유물 특수 효과: 회피 트리거
                    if (typeof relicOnPlayerDodged === 'function') relicOnPlayerDodged(attacker);
                    if (hasEquippedNamedGear('회피의 손끝')) player._demonicProc.evasionFingertipUntil = frameCount + 300;
                    if (hasEquippedNamedGear('파멸의 스텝')) player._demonicProc.doomStepUntil = frameCount + 120;

                    return;
                }
            }

            // [신규] 더럽혀진 피: 받는 데미지 증가 (도트딜 제외)
            let damageMultiplier = 1;
            if (type === 'direct' && player.corruptedBloodTimers.length > 0) {
                damageMultiplier += (player.corruptedBloodTimers.length * 0.025);
            }

            const curseMultiplier = 1;
            let currentDefense = player.defenseBroken ? 0 : player.defense;
            if (player.sacredFaithSkill.activeTimer > 0) {
                currentDefense *= (1.25 + (level * 0.0005));
            }
            // [신규] 플레이어 기절 중: 방어 50% 감소
            if (player.stunTimer > 0) currentDefense *= 0.5;
            let finalAmount = amount * curseMultiplier * damageMultiplier;

            let damageSource = attacker;
            if (damageSource && damageSource.attackPower == null && damageSource.owner) damageSource = damageSource.owner;
            const sourceAttackPower = (damageSource && damageSource.attackPower != null) ? damageSource.attackPower : 0;
            if (type === 'dot' || type === 'hazardDot') {
                finalAmount *= 1.5; // 모든 도트 데미지 1.5배
                if (sourceAttackPower > 0) finalAmount *= (1 + sourceAttackPower * 0.04);
            } else if (sourceAttackPower > 0) {
                finalAmount *= (1 + sourceAttackPower * 0.11);
            }
            
            let attackerCritChance = 0;
            if (attacker) {
                // attacker가 투사체/장판 등이고 critChance가 없으면 owner의 critChance를 사용
                let src = attacker;
                if (src.critChance == null && src.owner) src = src.owner;
                if (src && src.critChance == null && src.owner) src = src.owner;
                attackerCritChance = (src && src.critChance != null) ? src.critChance : 0;
            }
            let defenderCritResist = player.critResist;
            // 공격자 기준 크리: attackerCritChance - defenderCritResist
            // (타락한 맹세/차광/진조의 키스 등은 '피격 취약'이므로 defenderCritResist를 깎는다)
            defenderCritResist -= (player.dangerousJudgmentStacks * 10);
            defenderCritResist -= (player.corruptedOathStacks * 10);
            if (player.fractureTimers.length > 0) {
                defenderCritResist -= (player.fractureTimers.length * 5);
            }
            if (player.inPinkGas) {
                defenderCritResist *= 0.5;
            }
            // [신규] 죽음의 낙인: 치명타 저항 확률 50% 감소
            if (player.deathBrandTimers.length > 0) {
                defenderCritResist *= 0.5;
            }
            // [신규] 차광: (피격) 치명타 저항 확률 감소
            if (player.shadingTimers.length > 0) {
                defenderCritResist -= 15;
            }
            // [신규] 진조의 키스: (피격) 치명타 저항 확률 감소
            if (player.trueAncestorKissTimers.length > 0) {
                defenderCritResist -= (player.trueAncestorKissTimers.length * 3);
            }
             // [신규] 페이탈 스칼: 치명타 저항 확률 감소
            if (player.fatalScarTimers.length > 0) {
                defenderCritResist -= (player.fatalScarTimers.length * 3);
            }

            if (player.sacredFaithSkill.activeTimer > 0) {
                defenderCritResist += (15 + (level * 0.25));
            }
            let isCriticalHit = false;
if (type === 'direct') {
                const critChance = Math.max(0, Math.min(100, attackerCritChance - defenderCritResist));
        if (player.pheromoneOverloadTimer > 0 || Math.random() * 100 < critChance) {
            finalAmount *= 1.5;
            isCriticalHit = true;

            // [NEW] 유물 특수 효과: 피격 치명타 트리거
            if (typeof relicOnPlayerTookCriticalHit === 'function') relicOnPlayerTookCriticalHit();
        }

        // [신규] 페로몬 오버로드 해제 로직 (크리티컬 3회 피격 시)
        if (player.pheromoneOverloadTimer > 0 && isCriticalHit) {
            player.pheromoneOverloadCritCount = (player.pheromoneOverloadCritCount || 0) + 1;

            // UI 갱신(즉시)
            updatePheromoneOverloadUI();

            // 3회 이상 크리티컬을 받으면 즉시 해제
            if (player.pheromoneOverloadCritCount >= 3) {
                endPheromoneOverload();
                showPickupEffect(player.x, player.y - 80, "오버로드 해제!", false, true, "heal-text");
            }
        }

finalAmount -= currentDefense;

            // [NEW] 엔젤릭 고정 옵션: 피로 물든 자비의 인장(받는 피해 감소)
            if (player._angelicDamageReduction && player._angelicDamageReduction > 0) {
                finalAmount *= (1 - player._angelicDamageReduction);
            }

    }
            

            if (attacker && attacker.hp > 0) {
                if ((attacker.isArthur || (attacker.isBoss && !attacker.isArchdemon && !attacker.isArthur)) && player.damageTakenMulCainArthur) {
                    finalAmount *= player.damageTakenMulCainArthur;
                }
                if ((attacker.isElite || attacker.isRoyal) && player.damageTakenMulEliteRoyal) {
                    finalAmount *= player.damageTakenMulEliteRoyal;
                }
            }

            if (type === 'direct' && hasEquippedNamedGear('타락한 추락자의 장화')) {
                if ((player._demonicProc?.fallenBootsCd || 0) <= frameCount) {
                    player._demonicProc.fallenBootsCd = frameCount + 600;
                    player._demonicProc.fallenBoostUntil = frameCount + 120;
                }
            }

            if (type === 'direct' && hasEquippedNamedGear('혈흔의 흉갑')) {
                if (Math.random() < 0.05) {
                    player.health = Math.min(player.maxHealth, player.health + player.maxHealth * 0.02);
                    updateHealthUI();
                }
                if (Math.random() < 0.02) {
                    finalAmount += player.maxHealth * 0.01;
                }
            }
            if (finalAmount < 0) finalAmount = 0;
            if (type !== 'dot' && type !== 'hazardDot' && finalAmount > 0 && player.novaBarrierTimer > 0 && player.novaBarrierValue > 0) {
                const absorbed = Math.min(player.novaBarrierValue, finalAmount);
                player.novaBarrierValue -= absorbed;
                finalAmount -= absorbed;
                showDamageText(player.x, player.y - 30, `SHIELD ${Math.floor(absorbed)}`, false, false, "block-text");

                // [NEW] 유물 특수 효과: 보호막 흡수 트리거
                if (typeof relicOnBarrierAbsorbed === 'function') relicOnBarrierAbsorbed();
            }
            player.health -= finalAmount; if (player.health < 0) player.health = 0; updateHealthUI();
            // [NEW] 장비 특수옵션: '3초간 피격 없음' 조건 체크용
            // 상태이상 도트(type==='dot')만 무피격 판정에서 제외 (가스형 hazardDot은 피격으로 처리)

            if (type !== 'dot') player.lastDamageFrame = frameCount;
            // [신규] 적이 플레이어에게 '크리티컬'을 준 경우에만 (숫자) 데미지 텍스트 표시
            if (isCriticalHit) {
                const dmgText = Math.floor(finalAmount);
                if (dmgText > 0) {
                    showDamageText(player.x, player.y - (player.radius || 0) - 40, dmgText, true, false, "player-crit-text");
                }
            }

            
            let color = '101, 67, 33';
            if (player.poisonTimers.length > 0 || player.darkScentTimers.length > 0) color = '0, 100, 0';
            if (player.poopPoisonTimers.length > 0 || player.darkSmellTimers.length > 0) color = '139, 69, 19';
            if (player.kissTimers.length > 0 || player.darkKissTimers.length > 0) color = '255, 20, 147';
            if (player.curseTimers.length > 0) color = '75, 0, 130'; 
            if (player.evilLightTimers.length > 0) color = '50, 0, 50';
            if (player.maliceTimers.length > 0) color = '128, 0, 128'; 
            if (player.corruptedBloodTimers.length > 0) color = '139, 0, 0';

            // [최적화] 데미지 오버레이는 히트마다 setTimeout을 쌓지 않고,
            //           애니메이션 루프에서 1프레임 1회만 감쇠 처리
            const strongHit = finalAmount > 0.1;
            damageFlashColor = color;
            damageFlashAlpha = strongHit ? 0.6 : 0.3;
            const targetOpacity = strongHit ? (0.5 + (Math.random() * 0.3)) : 0.1;
            if (targetOpacity > damageFlashOpacity) damageFlashOpacity = targetOpacity;
            damageFlashDirty = true;
if (player.health <= 0) {
                if (hasEquippedNamedGear('호위무신의 운검') && !player.angelicReviveUsed) {
                    player.angelicReviveUsed = true;
                    player.health = Math.max(1, Math.floor(player.maxHealth * 0.10));
                    player.invincibleTimer = Math.max(player.invincibleTimer || 0, 300);
                    updateHealthUI();
                    showPickupEffect(player.x, player.y - 40, '운검 발동: 불사!', false, true, 'goddess-text');
                } else gameOver();
            }
        }

        function processStatusTimers(timers) {
             // [최적화] filter로 새 배열을 매번 만들지 않고, 제자리(in-place)로 만료 타이머 제거
             let expiredCount = 0;
             const prevLen = timers.length;
             let write = 0;

             for (let i = 0; i < prevLen; i++) {
                 const t = timers[i] - 1;
                 if (t > 0) {
                     timers[write++] = t;
                 } else {
                     expiredCount++;
                 }
             }

             if (write !== prevLen) timers.length = write;

             return {
                 active: timers,
                 changed: expiredCount > 0,
                 expired: expiredCount
             };
        }


        function removeOneCleanseableDebuffStack() {
            const keys = ['poisonTimers','poopPoisonTimers','maliceTimers','kissTimers','semenTimers','oralTimers','byururutTimers','darknessTimers','fishyTimers','blindTimers','curseTimers'];
            const active = keys.filter(k => Array.isArray(player[k]) && player[k].length > 0);
            if (!active.length) return false;
            const key = active[Math.floor(Math.random() * active.length)];
            player[key].sort((a,b)=>a-b);
            player[key].splice(0,1);
            updateStatusUI();
            updatePoopVisual();
            return true;
        }

        function getActiveSkillList() {
            const out = [];
            if (player.goddessSkill) out.push(player.goddessSkill);
            if (player.sacredFaithSkill) out.push(player.sacredFaithSkill);
            if (player.novaSkill) out.push(player.novaSkill);
            if (player.limitFocusSkill) out.push(player.limitFocusSkill);
            if (player.divineDashSkill) out.push(player.divineDashSkill);
            return out;
        }

        function tryApplyAngelicActiveExtend(skill, skillLabel = '액티브 스킬') {
            if (!skill || typeof skill !== 'object') return;
            if (!hasEquippedNamedGear('영명한 천상의 날개')) return;
            const now = frameCount || 0;
            if ((player.angelicActiveExtendCd || 0) > now) return;
            if (typeof skill.duration !== 'number' || typeof skill.activeTimer !== 'number') return;
            if (skill.duration <= 0 || skill.activeTimer <= 0) return;
            if (Math.random() >= 0.25) return;

            player.angelicActiveExtendCd = now + 600; // 10초 쿨타임
            skill.activeTimer = Math.max(skill.activeTimer, skill.duration * 2);
            showPickupEffect(player.x, player.y - 62, `${skillLabel} 지속시간 2배!`, false, true, 'goddess-text');
        }



        // [FIX] 이동속도 감속(슬로우) 총합을 계산 (0~0.9)
        function getTotalMoveSpeedSlowFactor() {
            let totalSlowFactor = 0;
            if (player.slowedByCloud) totalSlowFactor += 0.25;
            if (player.slowedByStickyCream) totalSlowFactor += 0.25;
            if (player.darknessOverwhelmActive) totalSlowFactor += 0.05;
            if (player.paralysisTimers && player.paralysisTimers.length > 0) {
                totalSlowFactor += (player.paralysisTimers.length * 0.025);
            }
            return Math.min(0.9, totalSlowFactor);
        }

        function updateDemonicNamedGearEffects() {
            if (!player._demonicProc) player._demonicProc = {};
            if (!player._demonicDynApplied) player._demonicDynApplied = { acc:0, eva:0, def:0, critResist:0, atk:0, critChance:0, critDamage:0, moveSpeed:0, luck:0, magicChance:0 };
            const proc = player._demonicProc;
            const now = frameCount || 0;
            const hpRatio = (player.maxHealth > 0) ? (player.health / player.maxHealth) : 1;
            const dyn = { acc:0, eva:0, def:0, critResist:0, atk:0, critChance:0, critDamage:0, moveSpeed:0, luck:0, magicChance:0 };

            const nearby250 = countNearbyAliveEnemies(250);
            const highRankCount = enemies.filter(e => e && e.hp > 0 && (e.isElite || e.isRoyal || e.isBoss || e.isArchdemon || e.isArthur)).length;
            const cainOrArthurAlive = enemies.some(e => e && e.hp > 0 && (e.isArthur || (e.isBoss && !e.isArchdemon && !e.isArthur)));
            const royalAlive = enemies.some(e => e && e.hp > 0 && e.isRoyal);
            const archdemonAlive = enemies.some(e => e && e.hp > 0 && e.isArchdemon && String(e.archdemonName || '').match(/아키토|토우야/));
            const hasEvilMind = (player.evilMindTimers || []).length > 0;
            const moveSlowed = getTotalMoveSpeedSlowFactor() > 0;

            if (hasEquippedNamedGear('속삭이는 데몬 후드')) { dyn.eva += 0.05; dyn.acc -= 0.03; }
            if (hasEquippedNamedGear('야행의 서약 펜던트')) { dyn.critChance -= 5; dyn.critDamage += 0.10; }
            if (hasEquippedNamedGear('흑도 ‘무라사메・심연’')) { dyn.critChance -= 5; }
            if (hasEquippedNamedGear('악의로 가득찬 니힐리즘 단검')) { dyn.critChance += 10; dyn.critResist -= 5; }
            if (hasEquippedNamedGear('타락한 피의 왕 인장')) dyn.critChance += 3;
            if (hasEquippedNamedGear('타락성의 흑요 투구')) dyn.atk -= ((player.weapon?.baseDamage || 0) * 0.03);
            if (hasEquippedNamedGear('심야의 흉터가면')) dyn.atk += ((player.weapon?.baseDamage || 0) * 0.03);
            if (hasEquippedNamedGear('붉은 계약 펜던트')) { dyn.def -= ((player.defense || 0) * 0.03); dyn.eva -= 0.04; }
            if (hasEquippedNamedGear('피의 거래 흉갑')) dyn.def -= ((player.defense || 0) * 0.04);
            if (hasEquippedNamedGear('잔영 건틀릿')) dyn.def -= ((player.defense || 0) * 0.10);
            if (hasEquippedNamedGear('대악마의 봉인')) { dyn.def -= ((player.defense || 0) * 0.02); if (archdemonAlive) dyn.atk += ((player.weapon?.baseDamage || 0) * 0.10); }
            if (hasEquippedNamedGear('역병의 왕 인장')) dyn.atk -= ((player.weapon?.baseDamage || 0) * 0.08);
            if (hasEquippedNamedGear('독가스 심장부적')) dyn.atk += ((player.weapon?.baseDamage || 0) * 0.02);
            if (hasEquippedNamedGear('악의의 인장')) dyn.atk += ((player.weapon?.baseDamage || 0) * 0.02);
            if (hasEquippedNamedGear('다크 돌연변이 인장')) dyn.atk += ((player.weapon?.baseDamage || 0) * 0.04);
            if (hasEquippedNamedGear('타락한 결속 건틀릿')) {
                const hasForbidden = enemies.some(e => e && e.hp > 0 && (e.isTaro || e.isCassias));
                if (hasForbidden) dyn.atk += ((player.weapon?.baseDamage || 0) * 0.10);
                else dyn.critChance -= 2;
            }
            if (hasEquippedNamedGear('파멸의 흑풍 장화')) dyn.moveSpeed += (player.justiceShield > 0) ? 0.05 : -0.03;
            if (hasEquippedNamedGear('심연 추적자의 각반')) dyn.moveSpeed += hasEvilMind ? 0.10 : -0.05;
            if (hasEquippedNamedGear('서늘한 악마의 가면') && moveSlowed) dyn.critChance += 3;
            if (hasEquippedNamedGear('타락한 추락자의 장화')) dyn.eva -= 0.03;
            if (hasEquippedNamedGear('추격 불가의 코트')) { dyn.atk += ((player.weapon?.baseDamage || 0) * 0.10); player._demonicNoDodge = true; }
            else player._demonicNoDodge = false;
            if (hasEquippedNamedGear('어둠 장막의 목걸이')) dyn.acc -= 0.05;
            if (hasEquippedNamedGear('악마의 계약을 찢는 손')) { dyn.luck += 10; dyn.magicChance -= 0.50; }
            if (hasEquippedNamedGear('붕괴한 성배 갑주') && hpRatio <= 0.40) { dyn.atk += ((player.weapon?.baseDamage || 0) * 0.05); dyn.def -= ((player.defense || 0) * 0.05); }
            if (hasEquippedNamedGear('도주자의 절단검') && hpRatio <= 0.40) { dyn.critChance += 5; dyn.critResist -= 8; }
            if (hasEquippedNamedGear('타락 성흔의 사슬') && royalAlive) { dyn.atk += ((player.weapon?.baseDamage || 0) * 0.08); dyn.def -= ((player.defense || 0) * 0.04); }
            if (hasEquippedNamedGear('폐허의 목걸이') && nearby250 >= 5) { dyn.atk += ((player.weapon?.baseDamage || 0) * 0.03); dyn.def -= ((player.defense || 0) * 0.02); }
            if (hasEquippedNamedGear('검은 계약 펜던트')) {
                const hardKinds = ['darkScentTimers','darkSmellTimers','darkSeedTimers','darkKissTimers','darkReceiverTimers','evilMindTimers','curseTimers','darknessTimers'];
                const activeKinds = hardKinds.filter(k => Array.isArray(player[k]) && player[k].length > 0).length;
                if (activeKinds >= 5) dyn.critChance += 5;
            }
            if (hasEquippedNamedGear('심연의 청구서') && now < 3600) { dyn.acc += 0.05; dyn.atk += ((player.weapon?.baseDamage || 0) * 0.03); dyn.def -= ((player.defense || 0) * 0.05); }


            if ((proc.evasionFingertipUntil || 0) > now) { dyn.atk += ((player.weapon?.baseDamage || 0) * 0.05); dyn.def -= ((player.defense || 0) * 0.03); }
            if ((proc.doomStepUntil || 0) > now) dyn.moveSpeed += 0.04;
            if ((proc.doomStepUntil || 0) <= now && (proc.doomStepUntil || 0) > 0 && (proc.doomStepPenaltyUntil || 0) <= now) {
                proc.doomStepPenaltyUntil = now + 60;
                proc.doomStepUntil = 0;
            }
            if ((proc.doomStepPenaltyUntil || 0) > now) dyn.moveSpeed -= 0.04;
            if ((proc.fallenBoostUntil || 0) > now) dyn.moveSpeed += 0.05;

            if (hasEquippedNamedGear('어둠의 질주의 주술 장화')) {
                if ((proc.darkSprintTick || 0) <= now) {
                    proc.darkSprintTick = now + 360;
                    proc.darkSprintPosUntil = now + 90;
                    proc.darkSprintNegUntil = now + 180;
                }
                if ((proc.darkSprintPosUntil || 0) > now) dyn.moveSpeed += 0.07;
                else if ((proc.darkSprintNegUntil || 0) > now) dyn.moveSpeed -= 0.04;
            }

            if (hasEquippedNamedGear('배신의 주사위 반지') && (proc.betrayalTick || 0) <= now) {
                proc.betrayalTick = now + 720;
                proc.betrayalUntil = now + 300;
                proc.betrayalAcc = (Math.random() < 0.75) ? 0.08 : -0.02;
            }
            if ((proc.betrayalUntil || 0) > now) dyn.acc += (proc.betrayalAcc || 0);

            if (hasEquippedNamedGear('심연의 고리') && (proc.abyssLoopUntil || 0) > now) dyn.critDamage += 0.20;

            if (hasEquippedNamedGear('심야 군주의 암반지')) {
                if ((proc.midnightRingTick || 0) <= now) {
                    proc.midnightRingTick = now + 1200;
                    player.invincibleTimer = Math.max(player.invincibleTimer || 0, 120);
                }
                dyn.eva -= 0.05;
            }
            if (hasEquippedNamedGear('어둠 장막의 목걸이') && (proc.darkVeilTick || 0) <= now) {
                proc.darkVeilTick = now + 600;
                player.invincibleTimer = Math.max(player.invincibleTimer || 0, 60);
            }

            if (cainOrArthurAlive && hasEquippedNamedGear('어둠의 서약 목걸이') && (proc.darkOathTick || 0) <= now) {
                proc.darkOathTick = now + 300;
                const dmg = Math.max(1, Math.floor(player.maxHealth * 0.03));
                takeDamage(dmg, 'dot', 0, null);
                for (const e of enemies) {
                    if (!e || e.hp <= 0) continue;
                    if (e.isArthur || (e.isBoss && !e.isArchdemon && !e.isArthur)) {
                        e.hp -= Math.max(1, Math.floor((e.maxHp || 100) * 0.03));
                    }
                }
            }

            for (const k of Object.keys(dyn)) {
                const prev = player._demonicDynApplied[k] || 0;
                const next = dyn[k] || 0;
                const delta = next - prev;
                if (!delta) continue;
                if (k === 'critDamage') {
                    player.baseCritDamageMultiplier += delta;
                    player.critDamageMultiplier = player.baseCritDamageMultiplier;
                } else {
                    applyGearStatDelta(k, delta);
                }
                player._demonicDynApplied[k] = next;
            }

            player.darkScentDurationMultiplier = hasEquippedNamedGear('다크 돌연변이 인장') ? 1.25 : (hasEquippedNamedGear('역병의 왕 인장') ? 0.75 : 1);
            player.darkSmellDurationMultiplier = player.darkScentDurationMultiplier;
            player.gasPoisonDurationMultiplier = hasEquippedNamedGear('독가스 심장부적') ? 1.25 : 1;
            player.bleedDurationMultiplier = hasEquippedNamedGear('타락한 피의 왕 인장') ? 1.5 : 1;
            player.darknessDurationBonus = (hasEquippedNamedGear('심야의 흉터가면') ? 300 : 0) + (hasEquippedNamedGear('타락성의 흑요 투구') ? -300 : 0);
            player.maliceDurationMultiplier = hasEquippedNamedGear('악의의 인장') ? 1.25 : 1;
            player.hpPotionHealMultiplier = hasEquippedNamedGear('암야의 몰락 면갑') ? 0.90 : 1;
            player.hpPotionDropBonus = hasEquippedNamedGear('암야의 몰락 면갑') ? 0.01 : 0;
            player.damageTakenMulCainArthur = hasEquippedNamedGear('타락한 왕의 판금') ? 0.75 : 1;
            player.damageTakenMulEliteRoyal = hasEquippedNamedGear('타락한 왕의 판금') ? 1.15 : 1;
        }

        function updateAngelicNamedGearEffects() {
            if (!player._angelicProc) player._angelicProc = {};
            if (!player._angelicDynApplied) player._angelicDynApplied = { acc:0, eva:0, def:0, critResist:0, atk:0 };
            const proc = player._angelicProc;
            const now = frameCount || 0;

            // 엘리트/로열/보스(및 특수 보스) 적 수 계산
            let highRankCount = 0;
            for (const en of enemies) {
                if (!en || en.hp <= 0) continue;
                if (en.isElite || en.isRoyal || en.isBoss || en.isArthur || en.isArchdemon || en.isAkito || en.isTouya || en.isCain) highRankCount++;
            }

            // --- 동적 스탯(프레임 누적 방지: 이전 적용분과 차이만큼만 반영) ---
            const dyn = { acc:0, eva:0, def:0, critResist:0, atk:0 };

            // [구원의 향] 60초마다 리로드(+1)
            if (hasEquippedNamedGear('구원의 향(香) 목걸이') && (proc.aromaTick || 0) <= now) {
                proc.aromaTick = now + 3600;
                rerollCount += 1;
                showPickupEffect(player.x, player.y - 20, '구원의 향: 리로드 +1', false, true, 'justice-border');
            }

            // [약속을 지키는 발걸음] 엘리트/로열/보스 적 1명당 회피 +2%
            if (hasEquippedNamedGear('약속을 지키는 발걸음')) dyn.eva += 0.02 * highRankCount;

            // [평온의 펜던트] 엘리트/로열/보스 적 1명당 명중 +2%
            if (hasEquippedNamedGear('평온의 펜던트')) dyn.acc += 0.02 * highRankCount;

            // [헤르메스 부츠] 엘리트/로열/보스 적 1명당 치저 +2%
            if (hasEquippedNamedGear('헤르메스의 크리스탈 제이드빛 부츠')) dyn.critResist += 2 * highRankCount;

            // [피로 물든 자비의 인장] 엘리트/로열/보스 적 1명당 받는 피해 -1% (툴팁: 방어 +1%)
            player._angelicDamageReduction = hasEquippedNamedGear('피로 물든 자비의 인장') ? clampVal(0.01 * highRankCount, 0, 0.60) : 0;

            // [찬가의 목걸이] 15초마다 5초 동안 공격력 +5%
            if (hasEquippedNamedGear('찬가의 목걸이')) {
                if ((proc.hymnTick || 0) <= now) {
                    proc.hymnTick = now + 900;
                    proc.hymnBuffUntil = now + 300;
                    showPickupEffect(player.x, player.y - 22, '찬가: 공격력 +5%', false, true, 'goddess-text');
                }
                const atkRatio = ((proc.hymnBuffUntil || 0) > now) ? 0.05 : 0;
                const prevAtkApplied = player._angelicDynApplied.atk || 0;
                const baseAtkNoDyn = (player.weapon && typeof player.weapon.baseDamage === 'number') ? (player.weapon.baseDamage - prevAtkApplied) : 0;
                dyn.atk = baseAtkNoDyn * atkRatio;
            } else {
                proc.hymnBuffUntil = 0;
            }

            // dyn 적용(이전 적용분과 차이만큼만)
            for (const k of Object.keys(dyn)) {
                const prev = player._angelicDynApplied[k] || 0;
                const next = dyn[k] || 0;
                const delta = next - prev;
                if (delta) applyGearStatDelta(k, delta);
                player._angelicDynApplied[k] = next;
            }

            // --- 디버프 지속시간 감소(기본값 + 추가값, 누적 버그 방지) ---
            if (!player._gearBaseReduce) {
                player._gearBaseReduce = {
                    reduceBleedDuration: player.reduceBleedDuration || 0,
                    reducePoisonDotDamage: player.reducePoisonDotDamage || 0,
                    reduceDarknessDuration: player.reduceDarknessDuration || 0,
                    reducePoopPoisonDotDamage: player.reducePoopPoisonDotDamage || 0,
                    reduceFishyDotDamage: player.reduceFishyDotDamage || 0
                };
            }
            const baseReduce = player._gearBaseReduce || {};
            const basePoison = (baseReduce.reducePoisonDotDamage != null) ? baseReduce.reducePoisonDotDamage : (player.reducePoisonDotDamage || 0);
            const baseDark   = (baseReduce.reduceDarknessDuration != null) ? baseReduce.reduceDarknessDuration : (player.reduceDarknessDuration || 0);

            // 순백의 외투: 어둠 지속시간 50% 감소 (유일한 추가)
            const bonusDark = hasEquippedNamedGear('가브리엘의 성스러운 순백의 외투') ? 0.50 : 0;

            player.reducePoisonDotDamage = clampVal(basePoison, 0, 0.95);
            player.reduceDarknessDuration = clampVal(baseDark + bonusDark, 0, 0.95);

            // --- 디버프 회피 확률(=상태이상 부여 시 확률로 무시) ---
            player.poisonAvoidChance   = hasEquippedNamedGear('수호천사의 신성한 방진면') ? 0.50 : 0;
            player.darknessAvoidChance = hasEquippedNamedGear('어둠 정화자의 눈부신 판금') ? 0.25 : 0;
            player.evilMindAvoidChance = hasEquippedNamedGear('성스러운 정화의 성환') ? 0.25 : 0;

            // 가득찬 마력의 백색 구두: 25초마다 랜덤 액티브 스킬 쿨타임 초기화
            if (hasEquippedNamedGear('가득찬 마력의 백색 구두') && (proc.cooldownResetTick || 0) <= now) {
                proc.cooldownResetTick = now + 1500;
                const cooling = getActiveSkillList().filter(sk => sk && typeof sk.cooldown === 'number' && sk.cooldown > 0);
                if (cooling.length) {
                    const pick = cooling[Math.floor(Math.random() * cooling.length)];
                    pick.cooldown = 0;
                    showPickupEffect(player.x, player.y - 28, '백색 구두: 스킬 쿨타임 초기화!', false, true, 'goddess-text');
                }
            }

            // 혼돈의 정화 반지: 5초마다 치료 가능한 상태이상 1중첩 정화
            if (hasEquippedNamedGear('혼돈의 정화 반지') && (proc.cleansePulseTick || 0) <= now) {
                proc.cleansePulseTick = now + 300;
                if (removeOneCleanseableDebuffStack()) {
                    showPickupEffect(player.x, player.y - 24, '혼돈의 정화 반지: 상태이상 정화', false, true, 'goddess-text');
                }
            }

            // --- 주기/상시 효과 ---
            const hpRatio = player.maxHealth > 0 ? (player.health / player.maxHealth) : 1;
            if (hasEquippedNamedGear('가브리엘의 영원한 자애의 반지') && hpRatio <= 0.35 && (proc.mercyCd || 0) <= now) {
                const heal = Math.max(1, Math.floor(player.maxHealth * 0.08));
                player.health = Math.min(player.maxHealth, player.health + heal);
                proc.mercyCd = now + 1200;
                updateHealthUI();
                showPickupEffect(player.x, player.y - 26, '자애의 반지: 치유', false, true, 'heal-text');
            }

            if (hasEquippedNamedGear('기적의 가브리엘 면갑') && (proc.miracleHelmTick || 0) <= now) {
                proc.miracleHelmTick = now + 720;
                player.novaBarrierValue = (player.novaBarrierValue || 0) + (player.maxHealth * 0.05);
                player.novaBarrierTimer = Math.max(player.novaBarrierTimer || 0, 240);
                showPickupEffect(player.x, player.y - 24, '기적의 면갑: 보호막', false, true, 'shield-border');
            }

            if (hasEquippedNamedGear('세인트 홀릭 성환') && (proc.saintRingTick || 0) <= now) {
                proc.saintRingTick = now + 1200;
                player.shieldStacks = (player.shieldStacks || 0) + 3;
                updateStatusUI();
            }

            if (hasEquippedNamedGear('인도자의 새크리파이스 장갑') && (proc.sacGlovesTick || 0) <= now) {
                proc.sacGlovesTick = now + 600;
                player.justiceShield = (player.justiceShield || 0) + 1;
                updateStatusUI();
            }

            // 왕의 성흔 펜던트: 20초마다 모든 액티브 스킬 쿨타임 1.5초(90프레임) 감소
            if (hasEquippedNamedGear('왕의 성흔 펜던트') && (proc.kingPendantTick || 0) <= now) {
                proc.kingPendantTick = now + 1200;
                for (const sk of getActiveSkillList()) {
                    if (typeof sk.cooldown === 'number') sk.cooldown = Math.max(0, sk.cooldown - 90);
                }
            }

            // 구원받은 성흔 펜던트: 12초마다 최대 HP의 2% 회복
            if (hasEquippedNamedGear('구원받은 성흔 펜던트') && (proc.stigmataTick || 0) <= now) {
                proc.stigmataTick = now + 720;
                const heal = Math.max(1, Math.floor(player.maxHealth * 0.02));
                player.health = Math.min(player.maxHealth, player.health + heal);
                updateHealthUI();
            }

            // 가브리엘의 눈부신 맹세의 성검: 6초마다 성광 폭발
            if (hasEquippedNamedGear('가브리엘의 눈부신 맹세의 성검') && (proc.oathSwordTick || 0) <= now) {
                proc.oathSwordTick = now + 360;
                const radius = 240;
                let hit = 0;
                for (const en of enemies) {
                    if (!en || en.isDead || en.hp <= 0) continue;
                    const dx = en.x - player.x, dy = en.y - player.y;
                    if ((dx*dx + dy*dy) > radius*radius) continue;
                    const dmg = Math.max(1, Math.floor((player.weapon?.damage || 1) * 0.6));
                    en.hp -= dmg;
                    showDamageText(en.x, en.y - 18, dmg, false, false, 'crit-text');
                    holyCrossEffects.push({ x: en.x, y: en.y, life: 30, maxLife: 30, t: 0 });
                    hit++;
                    if (hit >= 4) break;
                }
            }
        }

        function updatePlayer() {
            // [NEW] 유물 특수 효과 런타임 업데이트(쿨다운/주기 효과)
            if (typeof updateRelicRuntime === 'function') updateRelicRuntime();
            updateAngelicNamedGearEffects();
            updateDemonicNamedGearEffects();

            for (const enemy of enemies) {
                if (!enemy || enemy.hp <= 0) continue;
                if ((enemy.purifyingPoisonUntil || 0) > frameCount && frameCount % 60 === 0) {
                    const poisonDmg = Math.max(1, Math.floor((player.weapon.damage || 1) * 0.5));
                    enemy.hp -= poisonDmg;
                    showDamageText(enemy.x, enemy.y - 16, poisonDmg, false, false, 'enemy-purifying-poison-text');
                }
                if ((enemy.darknessUntil || 0) > frameCount) {
                    enemy.wander = true;
                } else {
                    enemy.wander = false;
                }
                if ((enemy.curseTimer || 0) < frameCount) enemy.curseStacks = 0;
                if ((enemy.curseStacks || 0) > 0 && frameCount % 60 === 0) {
                    const curseDmg = Math.max(1, Math.floor((enemy.maxHp || 100) * 0.01 * enemy.curseStacks));
                    enemy.hp -= curseDmg;
                    showDamageText(enemy.x, enemy.y - 30, curseDmg, false, false, 'enemy-curse-text');
                }

                if (hasEquippedNamedGear('검은 합창의 성흔') && frameCount % 300 === 0) {
                    const dx = enemy.x - player.x, dy = enemy.y - player.y;
                    if ((dx * dx + dy * dy) <= (250 * 250)) {
                        const r = Math.random();
                        if (r < 0.20) enemy.tempSpeedMul = 0.92;
                        else if (r < 0.30) enemy.tempSpeedMul = 1.04;
                        enemy.tempSpeedUntil = frameCount + 300;
                    }
                }

            }

            if (player.angelicReviveUsed == null) player.angelicReviveUsed = false;
            if (player.angelicSkyShieldCd == null) player.angelicSkyShieldCd = 0;
            if (player.angelicHitSureCd == null) player.angelicHitSureCd = 0;
            if (player.angelicHitSureNext == null) player.angelicHitSureNext = false;
            if (player.angelicCleanseTimer == null) player.angelicCleanseTimer = 300;
            if (player.angelicCooldownResetTimer == null) player.angelicCooldownResetTimer = 1500;

            player.slowedByCloud = false; 

            // 데스 클라우드 감속은 이동 계산 전에 즉시 판정해야 확실히 반영됨
            for (let i = deathClouds.length - 1; i >= 0; i--) {
                const cloud = deathClouds[i];
                const dxCloud = player.x - cloud.x;
                const dyCloud = player.y - cloud.y;
                const hitRadius = player.radius + cloud.radius;
                if ((dxCloud * dxCloud + dyCloud * dyCloud) < hitRadius * hitRadius) {
                    player.slowedByCloud = true;
                    break;
                }
            }

            if (player.stunTimer > 0) {
                player.stunTimer--;
            }
            // =================================================================
        // [신규] 카인: 페로몬 오버로드 로직
        // =================================================================
        // 카인이 살아있는지 확인
        const cainExists = enemies.some(e => e.isBoss && !e.isArthur && !e.isArchdemon && e.hp > 0);
        
        if (cainExists) {
            // 디버프 스택 총합 계산 (향기, 똥내, 씨앗, 키스, 좆집)
            const overloadStacks = player.darkScentTimers.length + 
                                   player.darkSmellTimers.length + 
                                   player.darkSeedTimers.length + 
                                   player.darkKissTimers.length + 
                                   player.darkReceiverTimers.length;

            // 발동 조건: 30스택 이상이고 아직 발동 안 했을 때
            if (overloadStacks >= 30 && player.pheromoneOverloadTimer <= 0) {
                player.pheromoneOverloadTimer = 600; // 10초 (60fps 기준)
                player.pheromoneOverloadCritCount = 0;
                updatePheromoneOverloadUI();
                pheromoneOverloadStatus.style.display = 'flex';

                // 1. 모든 액티브 스킬 쿨타임 10초 증가
                player.goddessSkill.cooldown += 600;
                player.sacredFaithSkill.cooldown += 600;
                player.limitFocusSkill.cooldown += 600;
                player.novaSkill.cooldown += 600;
                player.divineDashSkill.cooldown += 600;
                
                // UI 갱신
                updateGoddessSkillUI();
                updateSacredFaithUI();
                updateLimitFocusUI();
                updateNovaUI();
                updateDivineDashUI();

                showPickupEffect(player.x, player.y - 80, "페로몬 오버로드!!!", false, true, "boss-warning-text");
            }
        } else {
            // 카인 사망 시 즉시 해제
            if (player.pheromoneOverloadTimer > 0) {
                endPheromoneOverload();
                showPickupEffect(player.x, player.y - 80, "오버로드 해제!(카인 사망)", false, true, "heal-text");
            }
        }

        // 페로몬 오버로드 상태 관리
        if (player.pheromoneOverloadTimer > 0) {
            player.pheromoneOverloadTimer--;

            // 10초 경과로 타이머가 끝났으면 즉시 해제
            if (player.pheromoneOverloadTimer <= 0) {
                endPheromoneOverload();
                showPickupEffect(player.x, player.y - 80, "오버로드 해제!(시간)", false, true, "heal-text");
            } else {
                // 2. 화면에 bloodOverlay 강제 적용
                bloodOverlay.style.opacity = 0.8;

                pheromoneOverloadStatus.style.display = 'flex';
                updatePheromoneOverloadUI();
            }
        } else {
            // 타이머 종료 시 오버레이 복구 (다른 효과와 겹치지 않게 0으로)
            if (bloodOverlay.style.opacity > 0 && !player.majestyActive && player.corruptedBloodTimers.length === 0) {
                 // 서서히 사라지게 하거나 즉시 0 (여기선 자연스럽게 두기 위해 놔둠, 필요시 0 대입)
                 // bloodOverlay.style.opacity = 0; 
            }
            pheromoneOverloadStatus.style.display = 'none';
        }

        // =================================================================
        // [신규] 아키토: 다크니스 오버휠름 로직
        // =================================================================
        // 아키토가 살아있는지 확인 (archdemonName에 '아키토' 포함)
        const akitoExists = enemies.some(e => e.isArchdemon && e.archdemonName.includes('아키토') && e.hp > 0);
        
        if (akitoExists) {
            player.darknessOverwhelmActive = true;
            darknessOverwhelmStatus.style.display = 'flex';
        } else {
            player.darknessOverwhelmActive = false;
            darknessOverwhelmStatus.style.display = 'none';
        }

            // [신규] 스킬 봉인 타이머
            if (player.skillSealTimer > 0) {
                player.skillSealTimer--;
                if (player.skillSealTimer <= 0) {
                    skillSealOverlay.style.display = 'none';
                    showPickupEffect(player.x, player.y - 60, "스킬 봉인 해제!", false, true, "heal-text");
                }
                updateGoddessSkillUI();
                updateSacredFaithUI();
                updateNovaUI();
                updateLimitFocusUI();
                updateDivineDashUI();
            }

            // [신규] 속박(마비 10중첩) 처리
            if (player.rootTimer > 0) {
                player.rootTimer--;
                if (player.rootTimer <= 0) {
                    showPickupEffect(player.x, player.y - 40, "속박 해제", false, false, "heal-text");
                }
            }
            
            // [신규] 군주의 위엄 효과: 쿨타임 회복 속도 25% 감소
            let cooldownRecovery = 1.0;
            if (player.majestyActive) {
                cooldownRecovery *= 0.75;
            }
            // 타락한 정의 효과
            if (player.corruptedJusticeStacks > 0) {
                cooldownRecovery -= (player.corruptedJusticeStacks * 0.25);
            }
            cooldownRecovery *= (1 + Math.min(0.75, player.permanentSkillCooldownReduction || 0));
            if (cooldownRecovery < 0.1) cooldownRecovery = 0.1;

            if (player.goddessSkill.cooldown > 0) {
                player.goddessSkill.cooldown -= cooldownRecovery; 
                updateGoddessSkillUI();
            }

            if (player.sacredFaithSkill.activeTimer > 0) {
                player.sacredFaithSkill.activeTimer--;
                if (player.sacredFaithSkill.activeTimer <= 0) {
                }
            }
            if (player.sacredFaithSkill.cooldown > 0) {
                player.sacredFaithSkill.cooldown -= cooldownRecovery;
                updateSacredFaithUI();
            }
            
            if (player.novaSkill.cooldown > 0) {
                player.novaSkill.cooldown -= cooldownRecovery;
                updateNovaUI();
            }

            if (player.divineDashSkill.cooldown > 0) {
                player.divineDashSkill.cooldown -= cooldownRecovery;
                updateDivineDashUI();
            }

            if (player.limitFocusSkill.activeTimer > 0) {
                player.limitFocusSkill.activeTimer--;
                if(player.limitFocusSkill.activeTimer <= 0) {
                    showPickupEffect(player.x, player.y - 60, "집중 종료", false);
                }
            }

            if (player.limitFocusSkill.cooldown > 0) {
                player.limitFocusSkill.cooldown -= cooldownRecovery;
                updateLimitFocusUI();
            } else if (player.limitFocusSkill.activeTimer > 0) {
                 updateLimitFocusUI();
            }

            if (frameCount % 120 === 0 && player.regen > 0 && player.health > 0) {
    let regenAmount = player.regen;
            if (player.serumContaminationTimers && player.serumContaminationTimers.length > 0) {
                    regenAmount = 0;
                }

    // (선택 사항) 각종 회복 감소 디버프 적용
    if (player.gnawingLifeTimers.length > 0) {
        regenAmount *= (1 - player.gnawingLifeTimers.length * 0.02);
    }
    if (player.majestyActive) {
        regenAmount *= 0.9;
    }

    if (regenAmount > 0) {
        player.health = Math.min(player.maxHealth, player.health + regenAmount);
        updateHealthUI();
      }
  }

            // (삭제) score(시간) 경과에 따라 자동으로 오르던 플레이어 스탯 증가 로직 제거
            //  - 기존: 20초마다 공격력/최대체력/치명타확률/방어력 자동 상승
            //  - 변경: 플레이어 성장은 레벨업 카드/아이템/보스 보상 등으로만 진행


            if (player.invincibleTimer > 0) {
                player.invincibleTimer--;
            }
            if (player.novaBarrierTimer > 0) {
                player.novaBarrierTimer--;
                if (player.novaBarrierTimer <= 0) player.novaBarrierValue = 0;
            }
            if (player.berserkTimer > 0) {
                player.berserkTimer--;
                if (player.berserkTimer <= 0) {
                    player.weapon.damage = player.weapon.baseDamage;
                    player.weapon.autoAttackInterval = player.weapon.baseAutoAttackInterval;
                    berserkStatus.style.display = 'none';
                    showPickupEffect(player.x, player.y - 50, "베르세르크 종료", false);
                }
            }
            
            if (player.weapon.damage < 0.1) player.weapon.damage = 0.1;

            let uiUpdateNeeded = false;
            let dotTimeMult = 1 + (score * 0.003);
            
            const curseRes = processStatusTimers(player.curseTimers);
            player.curseTimers = curseRes.active;
            
            if (curseRes.expired > 0) {
                for(let k=0; k<curseRes.expired; k++) {
                    if (player.immuneCurseEndDamage) {
                        showPickupEffect(player.x, player.y - 40, "저주 종료 피해 면역!", false, true, "heal-text");
                        continue;
                    }
                    let dmg = player.health * 0.05;
                    if (dmg < 1) dmg = 1; 

                    // [NEW] 유물 특수 효과: 봉인된 저주 앰플(장착) - 저주 폭발 피해 25% 확률 무시
                    if (typeof isRelicEquipped === 'function' && isRelicEquipped('inquisition_record') && Math.random() < 0.25) {
                        showPickupEffect(player.x, player.y - 40, '봉인된 저주 앰플: 피해 무시!', false, true, 'heal-text');
                        continue;
                    }

                    takeDamage(dmg, 'curse');
                    showPickupEffect(player.x, player.y - 40, "아파..", false, true, "evil-purple-text");
                }
            }
            if (curseRes.changed) uiUpdateNeeded = true;
            
            const gnawingLifeRes = processStatusTimers(player.gnawingLifeTimers);
            player.gnawingLifeTimers = gnawingLifeRes.active;
            if (gnawingLifeRes.changed) uiUpdateNeeded = true;

            const darkSeedRes = processStatusTimers(player.darkSeedTimers);
            player.darkSeedTimers = darkSeedRes.active;
            if (darkSeedRes.changed) uiUpdateNeeded = true;

            const darkKissRes = processStatusTimers(player.darkKissTimers);
            player.darkKissTimers = darkKissRes.active;
            if (darkKissRes.changed) uiUpdateNeeded = true;

            const darkReceiverRes = processStatusTimers(player.darkReceiverTimers);
            player.darkReceiverTimers = darkReceiverRes.active;
            if (darkReceiverRes.changed) uiUpdateNeeded = true;
            
            const maliceRes = processStatusTimers(player.maliceTimers);
            player.maliceTimers = maliceRes.active;
            if (maliceRes.changed) uiUpdateNeeded = true;
            const maliceStacks = player.maliceTimers.length;
            
            const serumRes = processStatusTimers(player.serumContaminationTimers);
            player.serumContaminationTimers = serumRes.active;
            if (serumRes.changed) uiUpdateNeeded = true;

            const poisonRes = processStatusTimers(player.poisonTimers);
            player.poisonTimers = poisonRes.active;
            if (player.poisonTimers.length > 0) {
                let dmg = player.poisonTimers.length * 0.005 * dotTimeMult;
                if (maliceStacks > 0) {
                    dmg *= (1 + maliceStacks * 0.1);
                }
                // [NEW] 장비 특수옵션: 독(가스) 도트 피해 감소
                const r = (player.reducePoisonDotDamage || 0);
                if (r > 0) dmg *= (1 - r);

                takeDamage(dmg, 'dot');
            }
            if (poisonRes.changed) uiUpdateNeeded = true;
            
            const poopRes = processStatusTimers(player.poopPoisonTimers);
            player.poopPoisonTimers = poopRes.active;
            if (player.poopPoisonTimers.length > 0) {
                let dmg = player.poopPoisonTimers.length * 0.006 * dotTimeMult;
                if (maliceStacks > 0) {
                    dmg *= (1 + maliceStacks * 0.1);
                }
                // [NEW] 장비 특수옵션: 똥독 도트 피해 감소
                const r = (player.reducePoopPoisonDotDamage || 0);
                if (r > 0) dmg *= (1 - r);

                takeDamage(dmg, 'dot');
            }
            if (poopRes.changed) uiUpdateNeeded = true;
            
            const fishyRes = processStatusTimers(player.fishyTimers);
            player.fishyTimers = fishyRes.active;
            if (player.fishyTimers.length > 0) {
                let dmg = player.fishyTimers.length * 0.004 * dotTimeMult;
                if (maliceStacks > 0) {
                    dmg *= (1 + maliceStacks * 0.1);
                }
                // [NEW] 장비 특수옵션: 비린내 도트 피해 감소
                const r = (player.reduceFishyDotDamage || 0);
                if (r > 0) dmg *= (1 - r);

                takeDamage(dmg, 'dot');
            }
            if (fishyRes.changed) uiUpdateNeeded = true;

            const kissRes = processStatusTimers(player.kissTimers);
            player.kissTimers = kissRes.active;
            if (kissRes.changed) uiUpdateNeeded = true;
            
            const semenRes = processStatusTimers(player.semenTimers);
            player.semenTimers = semenRes.active;
            if (semenRes.changed) uiUpdateNeeded = true;
            
            const oralRes = processStatusTimers(player.oralTimers);
            player.oralTimers = oralRes.active;
            if (oralRes.changed) uiUpdateNeeded = true;
            
            const evilMindRes = processStatusTimers(player.evilMindTimers);
            const prevEvilLen = player.evilMindTimers.length;
            player.evilMindTimers = evilMindRes.active;
            if (prevEvilLen !== player.evilMindTimers.length) { updateMaxHealth(); uiUpdateNeeded = true; }
            
            const darkScentRes = processStatusTimers(player.darkScentTimers);
            player.darkScentTimers = darkScentRes.active;
            if (player.darkScentTimers.length > 0) {
                let dmg = player.darkScentTimers.length * 0.0065 * dotTimeMult;
                if (maliceStacks > 0) {
                    dmg *= (1 + maliceStacks * 0.1);
                }
                takeDamage(dmg, 'dot');
            }
            if (darkScentRes.changed) uiUpdateNeeded = true;
            
            const darkSmellRes = processStatusTimers(player.darkSmellTimers);
            player.darkSmellTimers = darkSmellRes.active;
            if (player.darkSmellTimers.length > 0) {
                let dmg = player.darkSmellTimers.length * 0.007 * dotTimeMult;
                if (maliceStacks > 0) {
                    dmg *= (1 + maliceStacks * 0.1);
                }
                takeDamage(dmg, 'dot');
            }
            if (darkSmellRes.changed) uiUpdateNeeded = true;
            
            const evilLightRes = processStatusTimers(player.evilLightTimers);
            const prevEvilLightLen = player.evilLightTimers.length;
            player.evilLightTimers = evilLightRes.active;
            if (prevEvilLightLen !== player.evilLightTimers.length) { updateMaxHealth(); uiUpdateNeeded = true; }
            if (evilLightRes.changed) uiUpdateNeeded = true;

            const darkEcstasyRes = processStatusTimers(player.darkEcstasyTimers);
            player.darkEcstasyTimers = darkEcstasyRes.active;
            if (darkEcstasyRes.changed) uiUpdateNeeded = true;

            const blindRes = processStatusTimers(player.blindTimers);
            player.blindTimers = blindRes.active;
            if (blindRes.changed) uiUpdateNeeded = true;
            
            // [수정] 마비 타이머 처리 추가
            const paralysisRes = processStatusTimers(player.paralysisTimers);
            player.paralysisTimers = paralysisRes.active;
            if (paralysisRes.changed) uiUpdateNeeded = true;
            
            // [신규] 아서 디버프 타이머 처리
            const trueAncestorKissRes = processStatusTimers(player.trueAncestorKissTimers);
            player.trueAncestorKissTimers = trueAncestorKissRes.active;
            if (trueAncestorKissRes.changed) uiUpdateNeeded = true;
         
            const fatalScarRes = processStatusTimers(player.fatalScarTimers);
            player.fatalScarTimers = fatalScarRes.active;
            if (fatalScarRes.changed) uiUpdateNeeded = true;

            const corruptedBloodRes = processStatusTimers(player.corruptedBloodTimers);
            player.corruptedBloodTimers = corruptedBloodRes.active;
            if (corruptedBloodRes.changed) uiUpdateNeeded = true;
            
            // [신규] 죽음의 낙인 처리
            const deathBrandRes = processStatusTimers(player.deathBrandTimers);
            player.deathBrandTimers = deathBrandRes.active;
            if (player.deathBrandTimers.length > 0) {
                deathBrandStatus.style.display = 'flex';
            } else {
                deathBrandStatus.style.display = 'none';
            }
            if (deathBrandRes.changed) uiUpdateNeeded = true;

            // [신규] 암흑 디버프 처리
            const darknessRes = processStatusTimers(player.darknessTimers);
            player.darknessTimers = darknessRes.active;
            if (player.darknessTimers.length > 0) {
                visionOverlay.style.opacity = 1;
                // 플레이어 주변만 보이도록 그라디언트 중심 이동
                visionOverlay.style.background = `radial-gradient(circle at ${player.x}px ${player.y}px, transparent 100px, black 300px)`;
            } else {
                visionOverlay.style.opacity = 0;
            }
            if (darknessRes.changed) uiUpdateNeeded = true;

            // [신규] 정신착란 디버프 처리
            const confusionRes = processStatusTimers(player.confusionTimers);
            player.confusionTimers = confusionRes.active;
            if (player.confusionTimers.length > 0) {
    // 스택이 많을수록 더 눈에 띄게 (원하면 계수 조절)
    const alpha = Math.min(0.90, 0.25 + player.confusionTimers.length * 0.10);
    confusionOverlay.style.setProperty('--confusionAlpha', alpha.toFixed(2));
    confusionOverlay.classList.add('active');
} else {
    confusionOverlay.classList.remove('active');
    confusionOverlay.style.opacity = 0; // 애니메이션 끄고 즉시 숨김
}
            if (confusionRes.changed) uiUpdateNeeded = true;

            const blasphemyRes = processStatusTimers(player.blasphemyTimers);
            player.blasphemyTimers = blasphemyRes.active;
            if (player.blasphemyTimers.length > 0) {
                document.getElementById('blasphemyStatus').style.display = 'flex';
            } else {
                document.getElementById('blasphemyStatus').style.display = 'none';
            }

            // [신규] 절망 타이머 감소
            if (player.despairTimer > 0) player.despairTimer--;

            let stunTriggered = false;
            // [뷰루룻 개편] 스택이 여러 개여도 1개 스택만 타이머(쿨)가 흐르도록: 맨 앞 1개만 감소
            if (player.byururutTimers.length > 0) {
                player.byururutTimers[0]--;
                if (player.byururutTimers[0] <= 0) {
                    stunTriggered = true;
                    player.byururutTimers.shift(); // 1스택만 제거
                    uiUpdateNeeded = true;
                }
            }
            if (stunTriggered) {
                // 0.5초 기절 (60fps 기준 30프레임)
                player.stunTimer = Math.max(player.stunTimer, 30);
                showPickupEffect(player.x, player.y, "뷰릇♥", false, true, "condensed-milk-text");
                uiUpdateNeeded = true;
            }
            if (player.byururutTimers.length === 0 && stunTriggered) uiUpdateNeeded = true;
            
            // 마비 상태 UI 업데이트 체크
            if (player.paralysisTimers.length > 0) {
                paralysisStatus.style.display = 'flex';
                paralysisStacksText.innerText = player.paralysisTimers.length;
            } else {
                paralysisStatus.style.display = 'none';
            }
            
            // [신규] 골절 타이머 처리
            const fractureRes = processStatusTimers(player.fractureTimers);
            player.fractureTimers = fractureRes.active;
            if (fractureRes.changed) uiUpdateNeeded = true;

            if (uiUpdateNeeded) updateStatusUI();

            if (player.semenCooldown > 0) player.semenCooldown--;
            if (player.oralCooldown > 0) player.oralCooldown--;
            if (player.darkReceiverCooldown > 0) player.darkReceiverCooldown--;

            
            if (player.byururutCooldown > 0) player.byururutCooldown--;
           // [신규] 천상의 도약 이동 처리 (최우선)
            if (player.dashTimer > 0) {
                player.dashTimer--;
                player.x += player.dashVx;
                player.y += player.dashVy;
                // 무적 유지
                player.invincibleTimer = Math.max(player.invincibleTimer, 2);
            } else {
                // 돌진 중이 아닐 때만 일반 이동 로직 수행
                let totalSlowFactor = 0;
                if (player.slowedByCloud) totalSlowFactor += 0.25;
                if (player.slowedByStickyCream) totalSlowFactor += 0.25;

                // [신규] 다크니스 오버휠름: 이동 속도 5% 감소
                if (player.darknessOverwhelmActive) {
                    totalSlowFactor += 0.05;
                }
                
                // [신규] 마비 슬로우 효과 (스택당 2.5%)
                if (player.paralysisTimers.length > 0) {
                    totalSlowFactor += (player.paralysisTimers.length * 0.025);
                }

                if (player.stunTimer > 0 || player.rootTimer > 0) {
                    // 기절 또는 속박(마비 10중첩) 상태
                    player.speed = 0;
                    if (player.rootTimer > 0 && frameCount % 30 === 0) {
                        showDamageText(player.x, player.y, "속박됨!", false, false, "weak-text");
                    }
                } else {
                    totalSlowFactor = Math.min(0.9, totalSlowFactor);
                    player.speed = player.baseSpeed * (1 - totalSlowFactor);
                    
                    let moveMult = 1;
                    if (player.confusionTimers.length > 0) {
                        moveMult = -1;
                        // 방향 반전
                        if (frameCount % 60 === 0) showPickupEffect(player.x, player.y, "혼란하다..", false, false, "confusion-border");
                    }

                    let dx = 0, dy = 0;
                    if (keys.ArrowUp) dy = -1 * moveMult;
                    if (keys.ArrowDown) dy = 1 * moveMult;
                    if (keys.ArrowLeft) dx = -1 * moveMult;
                    if (keys.ArrowRight) dx = 1 * moveMult;
                    if (isTouching) {
                        const touchDx = touchCurrent.x - touchStart.x;
                        const touchDy = touchCurrent.y - touchStart.y; const distance = Math.hypot(touchDx, touchDy);
                        if (distance > 10) { dx = touchDx / distance; dy = touchDy / distance;
                        }
                    }
                    
                    if ((dx !== 0 || dy !== 0) && player.hasHypersensitivity) {
                        if (Math.random() < 0.003) {
                            player.stunTimer = 30; 
                            showPickupEffect(player.x, player.y, "과민반응!", false, true, "block-text");
                        }
                    }

                    if (dx !== 0 || dy !== 0) {
                        if (!isTouching) { const length = Math.hypot(dx, dy);
                        dx /= length; dy /= length; }
                        player.vx = dx;
                        player.vy = dy; player.x += dx * player.speed; player.y += dy * player.speed;
                    }
                }
            }
            
            if (player.bodyHitCooldown > 0) player.bodyHitCooldown--;
            player.x = Math.max(player.radius, Math.min(canvas.width - player.radius, player.x)); player.y = Math.max(player.radius, Math.min(canvas.height - player.radius, player.y));

            let attackInterval = player.weapon.autoAttackInterval;
            let atkSpeedReduction = 0;

            if (player.darkKissTimers.length > 0) {
                atkSpeedReduction += (player.darkKissTimers.length * 0.011);
            }

            if (player.darknessOverwhelmActive) {
                atkSpeedReduction += 0.05;
            }
            const speedFactor = 1 - atkSpeedReduction;
            if (speedFactor > 0.1) {
                attackInterval = attackInterval / speedFactor;
            } else {
                attackInterval = attackInterval / 0.1;
            }

            const playerAttackLocked = (player.stunTimer > 0)
                || deathMetalNotes.some(n => n && n.draggingPlayer)
                || enemies.some(e => e && e.hp > 0 && e.isGawain && e.isCruelCharging && e.cruelChargeVictim)
                || blackMoons.some(m => Math.hypot(player.x - m.x, player.y - m.y) < (m.pullRange || 0))
                || enemies.some(e => e && e.hp > 0 && e.isRyuon && e.chargeState === 'charging' && Math.hypot(player.x - e.x, player.y - e.y) < 340);
            if (playerAttackLocked) {
                if (player.weapon.isAttacking) { player.weapon.isAttacking = false; player.weapon.attackTimer = 0; }
                player.weapon.autoTimer = 0;
            }

            if (!player.weapon.isAttacking && !playerAttackLocked) {
                player.weapon.autoTimer++;
                if (player.weapon.autoTimer >= attackInterval) { performAttack(); player.weapon.autoTimer = 0; }
            } else if (playerAttackLocked) {
                player.weapon.autoTimer = 0;
            }
            
            let reachReduction = 0;
            if (player.oralTimers.length > 0) reachReduction += (player.oralTimers.length * 0.008);
            if (player.evilLightTimers.length > 0) reachReduction += 0.05;

            player.weapon.length = player.weapon.baseLength * (1 - reachReduction);
            
            if (player.weapon.isAttacking) {
                player.weapon.attackTimer--;
                if (player.weapon.attackTimer <= 0) { player.weapon.isAttacking = false; }
                const progress = 1 - (player.weapon.attackTimer / 15); player.weapon.angle = player.weapon.baseAngle - Math.PI/2 + (Math.PI * progress);
            } else {
                let currentDir = player.weapon.baseAngle; if (player.vx !== 0 || player.vy !== 0) { currentDir = Math.atan2(player.vy, player.vx); } player.weapon.angle = currentDir - 0.4;
            }
        }
        
        function updateGases() {
    for (let i = gases.length - 1; i >= 0; i--) {
        const g = gases[i];
        if (g.radius < g.maxRadius) g.radius += g.growth;
        g.life--;
        
        if (g.life <= 0) {
            gases.splice(i, 1);
            continue;
        }

        // ★ [최적화] 제곱 거리 비교
        const dx = player.x - g.x;
        const dy = player.y - g.y;
        const distSq = dx * dx + dy * dy;
        const hitRadius = player.radius + g.radius;

        if (distSq < hitRadius * hitRadius) {
            player.slowedByCloud = true;
            takeDamage(0.000625, 'hazardDot', g.accuracy, g.owner || g);
            
            if (frameCount % 30 === 0) {
                if(player.invincibleTimer <= 0) {
                    const stacks = 1 + (g.extraStacks || 0);
                    for(let k=0; k<stacks; k++) {
                        if (!checkShieldBlockStatus('normal', 'poison')) {
                            addStatus('poison', 900, 50);
                        }
                    }
                    showPickupEffect(player.x, player.y, "콜록!", false, true);
                }
            }
        }
    }
}

        // [신규] 박쥐 투사체 업데이트
       function updateBloodBats() {
    for (let i = bloodBats.length - 1; i >= 0; i--) {
        const bat = bloodBats[i];
        const angle = Math.atan2(player.y - bat.y, player.x - bat.x);
        bat.x += Math.cos(angle) * bat.speed;
        bat.y += Math.sin(angle) * bat.speed;
        bat.life--;

        if (bat.life <= 0) {
            bloodBats.splice(i, 1);
            continue;
        }

        // ★ [최적화] 제곱 거리 계산
        const dx = player.x - bat.x;
        const dy = player.y - bat.y;
        const distSq = dx * dx + dy * dy;
        const radii = player.radius + bat.radius;

        if (distSq < radii * radii) {
            if (player.invincibleTimer > 0) {
                bloodBats.splice(i, 1);
                continue;
            }
            const dmg = 34 + Math.floor(score * 0.25);
            takeDamage(dmg, 'direct', bat.accuracy, bat);

            // 아서 체력 회복
            if (bat.owner && bat.owner.hp > 0) {
                let healAmt = dmg * 1.0;
                healAmt = Math.floor(healAmt * (bat.owner.hpRecoveryRate || 1));
                bat.owner.hp = Math.min(bat.owner.hp + healAmt, bat.owner.maxHp);
                showDamageText(bat.owner.x, bat.owner.y, "+" + healAmt, false, false, "heal-text");
            }

            // 진조의 키스 2중첩
            for (let k = 0; k < 2; k++) {
                addStatus('trueAncestorKiss', 1800, 10);
            }
            showPickupEffect(player.x, player.y, "진조의 키스!", false, true, "arthur-text");
            bloodBats.splice(i, 1);
        }
    }
}
        
      function updateBloodPuddles() {
    for (let i = bloodPuddles.length - 1; i >= 0; i--) {
        const p = bloodPuddles[i];
        p.life--;
        if (p.life <= 0) {
            bloodPuddles.splice(i, 1);
            continue;
        }
        
        p.tickTimer++;
        if (p.tickTimer >= 30) { 
            // 1. 플레이어 피격 체크 (최적화)
            const dx = player.x - p.x;
            const dy = player.y - p.y;
            const distSq = dx * dx + dy * dy;
            
            if (distSq < p.radius * p.radius) {
                if (player.invincibleTimer <= 0) {
                    let dmg = 5 + Math.floor(score * 0.1);
                    takeDamage(dmg, 'direct', p.accuracy, p);
                    for(let k = 0; k < 2; k++) {
                        addStatus('corruptedBlood', 1800, 10);
                    }
                    showPickupEffect(player.x, player.y, "더럽혀진 피!", false, false, "corrupted-blood-border");
                }
            }

            // 2. 아서 회복 체크 (최적화)
            if (p.owner && p.owner.hp > 0) {
                const odx = p.owner.x - p.x;
                const ody = p.owner.y - p.y;
                const ownerDistSq = odx * odx + ody * ody;

                if (ownerDistSq < p.radius * p.radius) {
                    let puddleHeal = 5 + Math.floor(score * 0.2);
                    puddleHeal = Math.floor(puddleHeal * (p.owner.hpRecoveryRate || 1));
                    p.owner.hp = Math.min(p.owner.hp + puddleHeal, p.owner.maxHp);
                    showDamageText(p.owner.x, p.owner.y, "+" + puddleHeal, false, false, "heal-text");
                }
            }
            p.tickTimer = 0;
        }
    }
}

     function updatePianissimoSnipes() {
    for (let i = pianissimoSnipes.length - 1; i >= 0; i--) {
        const p = pianissimoSnipes[i];
        
        // 1. 충전 상태
        if (p.state === 'charging') {
            p.chargeTimer++;
            p.alpha = p.chargeTimer / p.chargeMax;
            
            // 완충 시 발사
            if (p.chargeTimer >= p.chargeMax) {
                p.state = 'firing';
                p.alpha = 1.0;
                const angle = Math.atan2(player.y - p.y, player.x - p.x);
                const speed = 10; 
                p.vx = Math.cos(angle) * speed;
                p.vy = Math.sin(angle) * speed;
            }
        } 
        // 2. 발사 상태
        else if (p.state === 'firing') {
            p.x += p.vx;
            p.y += p.vy;
            p.life--;

            // 화면 밖 제거
            if (p.life <= 0 || p.x < -100 || p.x > canvas.width + 100 || p.y < -100 || p.y > canvas.height + 100) {
                pianissimoSnipes.splice(i, 1);
                continue;
            }

            // ★ [최적화] 제곱 거리 계산
            const dx = player.x - p.x;
            const dy = player.y - p.y;
            const distSq = dx * dx + dy * dy;
            const radii = player.radius + p.radius;

            if (distSq < radii * radii) {
                if (player.invincibleTimer <= 0) {
                    let dmg = 10 + Math.floor(score * 0.18);
                    takeDamage(dmg, 'direct', p.accuracy, p);
                    
                    player.stunTimer = Math.max(player.stunTimer || 0, 45);
                    showPickupEffect(player.x, player.y, "포르테..", false, true, "block-text");
                    pianissimoSnipes.splice(i, 1);
                }
            }
        }
    }
}

     function updateDarkGases() {
    for (let i = darkGases.length - 1; i >= 0; i--) {
        const g = darkGases[i];

        // 1. 가스 크기 성장 로직
        if (g.radius < g.maxRadius) {
            g.radius += g.growth;
            if (g.radius >= g.maxRadius) {
                g.radius = g.maxRadius;
                // 폭발 데미지 처리
                if (g.pendingDamage && g.pendingDamage > 0 && !g.hasExploded) {
                    explosions.push({
                        x: g.x,
                        y: g.y,
                        radius: g.maxRadius,
                        life: 20,
                        damage: g.pendingDamage,
                        accuracy: g.accuracy,
                        owner: g.owner,
                        hasHit: false
                    });
                    g.hasExploded = true;
                }
            }
        }

        // 2. 수명 감소 및 제거
        g.life--;
        if (g.life <= 0) {
            darkGases.splice(i, 1);
            continue;
        }

        // [Trail darkgas] purely visual: skip collision/damage for performance
        if (g.isTrail) {
            g.alpha *= 0.985;
            continue;
        }

        // [Mini darkgas] gentle fade but still deals damage/status
        if (g.simpleDraw) {
            g.alpha *= 0.994;
        }

        // ★ [최적화] 제곱 거리 계산
        const dx = player.x - g.x;
        const dy = player.y - g.y;
        const distSq = dx * dx + dy * dy;
        const radii = player.radius + g.radius;

        if (distSq < radii * radii) {
            let baseGasDmg = 0.002;
            let finalGasDmg = baseGasDmg * (g.damageMult || 1.0);

            takeDamage(finalGasDmg, 'hazardDot', g.accuracy, g.owner || g);

            if (frameCount % 60 === 0 && player.invincibleTimer <= 0) {
                addStatus('darkScent', 900, 30);
            }
        }
    }
}

function updateDarkGreenGases() {
    for (let i = darkGreenGases.length - 1; i >= 0; i--) {
        const g = darkGreenGases[i];

        if (g.radius < g.maxRadius) {
            g.radius += g.growth;
            if (g.radius >= g.maxRadius) g.radius = g.maxRadius;
        }

        g.life--;
        if (g.life <= 0) {
            darkGreenGases.splice(i, 1);
            continue;
        }

        const dx = player.x - g.x;
        const dy = player.y - g.y;
        const distSq = dx * dx + dy * dy;
        const radii = player.radius + g.radius;

        if (distSq < radii * radii) {
            let baseGasDmg = 0.002;
            let finalGasDmg = baseGasDmg * (g.damageMult || 1.0);
            takeDamage(finalGasDmg, 'hazardDot', g.accuracy, g.owner || g);

            if (frameCount % 60 === 0 && player.invincibleTimer <= 0) {
                addStatus('gnawingLife', 1800, 15);
            }
        }
    }
}
        

        function updateHollowNight() {
    for (let i = hollowNight.length - 1; i >= 0; i--) {
        const hk = hollowNight[i];
        hk.life--;
        if (hk.life <= 0) {
            hollowNight.splice(i, 1);
            continue;
        }
        if (hk.cooldown > 0) hk.cooldown--;

        // ★ [최적화] 제곱 거리 계산
        // (원본 로직: dist < hk.radius 였으므로 동일하게 적용)
        const dx = player.x - hk.x;
        const dy = player.y - hk.y;
        const distSq = dx * dx + dy * dy;

        if (distSq < hk.radius * hk.radius) {
            if (hk.cooldown <= 0 && player.invincibleTimer <= 0) {
                let dmg = 34 + Math.floor(score * 0.25);
                takeDamage(dmg, 'direct', hk.accuracy, hk);
                addStatus('darkEcstasy', 900, 5);
                showPickupEffect(player.x, player.y, "허무 속으로..", false);

                if (player.shieldStacks > 0) {
                    player.shieldStacks = Math.max(0, player.shieldStacks - 2);
                    updateStatusUI();
                }
                hk.cooldown = 60;
            }
        }
    }
}


        // [최적화] HollowNight(카인) 렌더 캐시 (프레임 드랍 완화)
        function renderHollowNightEffect(ctx, hk) {
            // Lazy init cache
            if (!hk._cache) {
                const canvas = document.createElement('canvas');
                // 작게 렌더한 뒤 업스케일 (GPU/CPU 부담 ↓)
                const size = 280;
                canvas.width = size;
                canvas.height = size;
                hk._cache = {
                    canvas,
                    ctx: canvas.getContext('2d'),
                    size,
                    lastFrame: -9999,
                    lastActive: null,
                    lastPhase: -9999
                };
            }

            const cache = hk._cache;
            const isActive = hk.cooldown <= 0;

            // 캐시 갱신 주기: effectsStride가 커질수록 더 드물게 갱신
            const refreshEvery = Math.max(4, ((performanceState && performanceState.effectsStride) ? performanceState.effectsStride : 1) * 6); // frames (추가 최적화)
            const phaseNow = (Date.now() / 1000);
            const phaseQ = Math.floor(phaseNow * 12); // [추가 최적화] 12fps로 양자화(캐시 갱신 시에만 사용)
            const needRedraw = (cache.lastActive !== isActive) || (frameCount - cache.lastFrame >= refreshEvery) || (cache.lastPhase !== phaseQ);

            if (needRedraw) {
                cache.lastActive = isActive;
                cache.lastFrame = frameCount;
                cache.lastPhase = phaseQ;

                const cctx = cache.ctx;
                const S = cache.size;
                cctx.clearRect(0, 0, S, S);

                // offscreen에서 그릴 때는 기본 반지름(=hk.radius)을 기준으로 그린 뒤,
                // 본 화면에서 pulse 스케일만 적용해서 drawImage로 출력.
                const t = phaseQ / 12;
                const baseR = hk.radius;
                const drawExtent = baseR * 2.35; // 바깥 오라까지 포함한 반경(대략)
                const scale = (S * 0.5) / drawExtent;

                cctx.save();
                cctx.translate(S * 0.5, S * 0.5);
                cctx.scale(scale, scale);

                const R = baseR;

                // 팔레트
                const colOuter  = isActive ? '120, 0, 235' : '95, 95, 95';
                const colMid    = isActive ? '70, 0, 150'  : '70, 70, 70';
                const colBright = isActive ? '235, 205, 255' : '170, 170, 170';
                const coreHex   = isActive ? '#000000' : '#111111';

                // 1) 바깥 오라
                const aura = cctx.createRadialGradient(0, 0, R * 0.15, 0, 0, R * 2.15);
                aura.addColorStop(0.0, 'rgba(0,0,0,0)');
                aura.addColorStop(0.25, `rgba(${colMid}, 0.16)`);
                aura.addColorStop(0.55, `rgba(${colOuter}, 0.20)`);
                aura.addColorStop(1.0, 'rgba(0,0,0,0)');
                cctx.fillStyle = aura;
                cctx.beginPath();
                cctx.arc(0, 0, R * 2.2, 0, Math.PI * 2);
                cctx.fill();

                // 2) 스파이크/코로나 (카운트 축소 + shadowBlur 축소)
                cctx.save();
                cctx.globalCompositeOperation = 'lighter';
                cctx.shadowBlur = isActive ? 14 : 6;
                cctx.shadowColor = `rgba(${colOuter}, ${isActive ? 0.85 : 0.55})`;

                const spikeCount = isActive ? 18 : 12;
                for (let i = 0; i < spikeCount; i++) {
                    const aBase = (i / spikeCount) * Math.PI * 2;
                    const a = aBase + Math.sin(t * 0.65 + i * 1.7) * 0.16;
                    const inner = R * (0.86 + Math.sin(t * 2.2 + i) * 0.03);
                    const len = R * (0.50 + 0.45 * Math.abs(Math.sin(t * 2.8 + i * 1.35)));
                    const mx = Math.cos(a + 0.25 * Math.sin(t * 3.2 + i)) * (inner + len * 0.45);
                    const my = Math.sin(a + 0.25 * Math.sin(t * 3.2 + i)) * (inner + len * 0.45);
                    const ex = Math.cos(a) * (inner + len);
                    const ey = Math.sin(a) * (inner + len);

                    cctx.lineWidth = Math.max(1.4, R * 0.018);
                    cctx.strokeStyle = `rgba(${colOuter}, ${isActive ? 0.20 : 0.10})`;
                    cctx.beginPath();
                    cctx.moveTo(Math.cos(a) * inner, Math.sin(a) * inner);
                    cctx.quadraticCurveTo(mx, my, ex, ey);
                    cctx.stroke();
                }
                cctx.restore();

                // 3) 코어
                const coreGrad = cctx.createRadialGradient(0, 0, 0, 0, 0, R * 1.05);
                coreGrad.addColorStop(0.0, coreHex);
                coreGrad.addColorStop(0.55, coreHex);
                coreGrad.addColorStop(0.78, isActive ? '#120018' : '#222222');
                coreGrad.addColorStop(0.92, isActive ? 'rgba(70, 0, 110, 0.90)' : 'rgba(100,100,100,0.50)');
                coreGrad.addColorStop(1.0, 'rgba(0,0,0,0)');
                cctx.fillStyle = coreGrad;
                cctx.beginPath();
                cctx.arc(0, 0, R * 1.05, 0, Math.PI * 2);
                cctx.fill();

                // 4) 테두리 링
                cctx.save();
                cctx.globalCompositeOperation = isActive ? 'lighter' : 'source-over';
                cctx.shadowBlur = isActive ? 16 : 0;
                cctx.shadowColor = `rgba(${colOuter}, 0.85)`;
                const ringGrad = cctx.createRadialGradient(0, 0, R * 0.55, 0, 0, R * 1.15);
                ringGrad.addColorStop(0.0, `rgba(${colOuter}, 0)`);
                ringGrad.addColorStop(0.55, `rgba(${colOuter}, ${isActive ? 0.18 : 0.08})`);
                ringGrad.addColorStop(1.0, `rgba(${colBright}, ${isActive ? 0.26 : 0.10})`);
                cctx.strokeStyle = ringGrad;
                cctx.lineWidth = Math.max(3, R * 0.14);
                cctx.beginPath();
                cctx.arc(0, 0, R * 0.84, 0, Math.PI * 2);
                cctx.stroke();
                cctx.restore();

                // 5) 내부 소용돌이 (포인트 수 축소)
                cctx.save();
                cctx.globalCompositeOperation = isActive ? 'lighter' : 'source-over';
                cctx.rotate(t * 0.55);
                cctx.lineWidth = Math.max(2, R * 0.028);
                cctx.strokeStyle = isActive ? `rgba(${colOuter}, 0.20)` : `rgba(130,130,130,0.16)`;
                cctx.shadowBlur = isActive ? 6 : 0;
                cctx.shadowColor = `rgba(${colOuter}, 0.75)`;
                const swirlSteps = 22;
                for (let s = 0; s < 2; s++) {
                    cctx.beginPath();
                    for (let k = 0; k <= swirlSteps; k++) {
                        const p = k / swirlSteps;
                        const ang = p * Math.PI * 2 * 1.25 + s * Math.PI;
                        const rr = R * (0.12 + p * 0.66);
                        const x = Math.cos(ang) * rr;
                        const y = Math.sin(ang) * rr;
                        if (k === 0) cctx.moveTo(x, y);
                        else cctx.lineTo(x, y);
                    }
                    cctx.stroke();
                }
                cctx.restore();

                // 6) 내부 번개(활성일 때만, 간소화)
                if (isActive) {
                    cctx.save();
                    cctx.globalCompositeOperation = 'lighter';
                    const boltCount = 2;
                    const steps = 5;

                    for (let b = 0; b < boltCount; b++) {
                        const a0 = t * 1.25 + b * (Math.PI * 2 / boltCount);
                        const r0 = R * 0.15;
                        const r1 = R * 0.78;

                        cctx.beginPath();
                        cctx.lineWidth = Math.max(2, R * 0.030);
                        cctx.strokeStyle = `rgba(${colBright}, 0.58)`;
                        cctx.shadowBlur = 16;
                        cctx.shadowColor = `rgba(${colBright}, 1)`;

                        for (let i = 0; i <= steps; i++) {
                            const p = i / steps;
                            const bend = Math.sin(t * 3.0 + b * 10 + p * 5) * 0.50 * (1 - p);
                            const ang = a0 + bend;
                            const rr = r0 + (r1 - r0) * p;
                            const jit = Math.sin(t * 8.0 + p * 22 + b * 30) * R * 0.035 * (1 - p);
                            const x = Math.cos(ang) * rr + Math.cos(ang + 1.4) * jit;
                            const y = Math.sin(ang) * rr + Math.sin(ang + 1.4) * jit;
                            if (i === 0) cctx.moveTo(x, y);
                            else cctx.lineTo(x, y);
                        }
                        cctx.stroke();
                    }

                    // 중심 스파크
                    cctx.beginPath();
                    cctx.arc(0, 0, R * 0.12, 0, Math.PI * 2);
                    cctx.fillStyle = `rgba(${colBright}, 0.30)`;
                    cctx.shadowBlur = 20;
                    cctx.shadowColor = `rgba(${colBright}, 1)`;
                    cctx.fill();

                    cctx.restore();
                }

                cctx.restore(); // scale/translate
            }

            // 본화면 출력 (가벼움)
            const tNow = Date.now() / 1000;
            const pulse = 1 + Math.sin(tNow * 3.6) * 0.06 + Math.cos(tNow * 9.0 + hk.x * 0.01) * 0.02;
            const drawR = hk.radius * pulse;
            const drawSize = drawR * 2 * 2.35;

            ctx.save();
            ctx.translate(hk.x, hk.y);
            ctx.globalCompositeOperation = (isActive ? 'lighter' : 'source-over');
            ctx.imageSmoothingEnabled = true;
            ctx.globalAlpha = 1.0;
            ctx.drawImage(cache.canvas, -drawSize / 2, -drawSize / 2, drawSize, drawSize);
            ctx.restore();
        }


        function updatePoops() {
    for (let i = poops.length - 1; i >= 0; i--) {
        const p = poops[i];
        p.x += p.vx;
        p.y += p.vy;
        p.life--;


        if (p.life <= 0) {
            poops.splice(i, 1);
            continue;
        }

        // ★ [최적화] Math.hypot 대체
        const dx = player.x - p.x;
        const dy = player.y - p.y;
        const distSq = dx * dx + dy * dy; 
        const radii = player.radius + p.radius;

        if (distSq < radii * radii) {
            if (player.invincibleTimer > 0) continue;

            let damage = p.isGreen ? 1 : 5;
            damage += Math.floor(score * 0.075);
            const maliceStacks = player.maliceTimers.length;
            if (maliceStacks > 0) {
                damage *= (1 + maliceStacks * 0.1);
            }
            takeDamage(damage, 'direct', p.accuracy, p);

            if (!checkShieldBlockStatus('normal', 'poopPoison')) {
                addStatus('poopPoison', 900, 50);
                updatePoopVisual();
                showPickupEffect(player.x, player.y, "똥내..", false, true, "poop-text");
            }
            poops.splice(i, 1);
        }
    }
}

       function updateBigPoops() {
    for (let i = bigPoops.length - 1; i >= 0; i--) {
        const p = bigPoops[i];
        if (p.isHoming) {
            const angle = Math.atan2(player.y - p.y, player.x - p.x);
            p.x += Math.cos(angle) * 2.3;
            p.y += Math.sin(angle) * 2.3;
        }
        p.life--;

        if (p.life <= 0) {
            spawnPoopStain(p.x, p.y);
            bigPoops.splice(i, 1);
            continue;
        }

        // ★ [최적화] 제곱 거리 계산
        const dx = player.x - p.x;
        const dy = player.y - p.y;
        const distSq = dx * dx + dy * dy;
        const radii = player.radius + p.radius;

        if (distSq < radii * radii) {
            if (player.invincibleTimer > 0) continue;

            let dmg = 26;
            if (p.isHoming) dmg = 19;
            else dmg = 13;
            
            dmg += Math.floor(score * 0.15);
            const maliceStacks = player.maliceTimers.length;
            if (maliceStacks > 0) {
                dmg *= (1 + maliceStacks * 0.1);
            }
            takeDamage(dmg, 'direct', p.accuracy, p);

            const stacksToApply = p.isHoming ? 2 : 1;
            let applied = 0;
            const loopCount = p.isHoming ? 2 : 3;

            for (let k = 0; k < loopCount; k++) {
                if (!checkShieldBlockStatus('normal', 'poopPoison')) {
                    addStatus('poopPoison', 900, 50);
                    applied++;
                }
            }
            if (applied > 0) {
                updatePoopVisual();
                showPickupEffect(player.x, player.y, "똥범벅이야..", false, true, "poop-text");
            }
            bigPoops.splice(i, 1);
        }
    }
}

        function updateDarkBigPoops() {
    for (let i = darkBigPoops.length - 1; i >= 0; i--) {
        const p = darkBigPoops[i];
        if (p.isHoming) {
            const angle = Math.atan2(player.y - p.y, player.x - p.x);
            p.x += Math.cos(angle) * 2.3;
            p.y += Math.sin(angle) * 2.3;
        } else {
            p.x += p.vx;
            p.y += p.vy;
        }
        p.life--;

        if (p.life <= 0) {
            spawnPoopStain(p.x, p.y);
            darkBigPoops.splice(i, 1);
            continue;
        }

        // ★ [최적화] 제곱 거리 계산
        const dx = player.x - p.x;
        const dy = player.y - p.y;
        const distSq = dx * dx + dy * dy;
        const radii = player.radius + p.radius;

        if (distSq < radii * radii) {
            if (player.invincibleTimer > 0) continue;

            let dmg = p.isHoming ? 26 : 19;
            dmg += Math.floor(score * 0.15);
            const maliceStacks = player.maliceTimers.length;
            if (maliceStacks > 0) {
                dmg *= (1 + maliceStacks * 0.1);
            }
            takeDamage(dmg, 'direct', p.accuracy, p);

            for (let k = 0; k < 2; k++) addStatus('darkSmell', 900, 30);
            showPickupEffect(player.x, player.y, "악마의 똥내♥", false, true, "poop-text");
            darkBigPoops.splice(i, 1);
        }
    }
}

       function updateDarkWaves() {
    for (let i = darkWaves.length - 1; i >= 0; i--) {
        const w = darkWaves[i];
        w.x += w.vx;
        w.y += w.vy;
        w.life--;
        
        // 벽 튕기기 로직
        let bounced = false;
        if (w.x < w.radius) { w.x = w.radius; w.vx *= -1; bounced = true; }
        else if (w.x > canvas.width - w.radius) { w.x = canvas.width - w.radius; w.vx *= -1; bounced = true; }
        
        if (w.y < w.radius) { w.y = w.radius; w.vy *= -1; bounced = true; }
        else if (w.y > canvas.height - w.radius) { w.y = canvas.height - w.radius; w.vy *= -1; bounced = true; }

        if (bounced) {
            w.bounceCount++;
            w.rotation = Math.atan2(w.vy, w.vx);
            if (w.bounceCount > w.maxBounces) { darkWaves.splice(i, 1); continue; }
        }

        if (w.life <= 0) { darkWaves.splice(i, 1); continue; }

        // [최적화] 충돌 체크 (제곱 거리)
        const dx = player.x - w.x;
        const dy = player.y - w.y;
        const distSq = dx * dx + dy * dy;
        const hitRadius = player.radius + w.radius;

        if (distSq < hitRadius * hitRadius) { 
            if (player.invincibleTimer > 0) continue;

            let dmg = 22 + Math.floor(score * 0.22);
            takeDamage(dmg, 'direct', w.accuracy, w);

            addStatus('darkSmell', 900, 10);
            addStatus('darkScent', 900, 10);
            showPickupEffect(player.x, player.y, "타락해라♥ ", false, true, "corrupted-text");
            darkWaves.splice(i, 1);
        }
    }
}
        
        function updateDragShots() {
    for (let i = dragShots.length - 1; i >= 0; i--) {
        const shot = dragShots[i];
        shot.x += shot.vx;
        shot.y += shot.vy;
        shot.life--;

        if (shot.life <= 0 || shot.x < -100 || shot.x > canvas.width + 100 || shot.y < -100 || shot.y > canvas.height + 100) {
            dragShots.splice(i, 1);
            continue;
        }

        // [최적화] 충돌 체크 (제곱 거리)
        const dx = player.x - shot.x;
        const dy = player.y - shot.y;
        const distSq = dx * dx + dy * dy;
        const hitRadius = player.radius + shot.radius;

        if (distSq < hitRadius * hitRadius) {
            if (player.invincibleTimer > 0) {
                 dragShots.splice(i, 1);
                 continue;
            }
            
            let dmg = 16 + Math.floor(score * 0.15);
            takeDamage(dmg, 'direct', shot.accuracy, shot);
            
            // 끌어당기기 효과
            const pullX = shot.startX;
            const pullY = shot.startY;
            player.x = player.x + (pullX - player.x) * 0.8;
            player.y = player.y + (pullY - player.y) * 0.8;
            
            showPickupEffect(player.x, player.y, "끌려간다!", false, true, "choke-text");
            dragShots.splice(i, 1);
        }
    }
}

        function updateEvilArrows() {
    for (let i = evilArrows.length - 1; i >= 0; i--) {
        const shot = evilArrows[i];
        shot.x += shot.vx;
        shot.y += shot.vy;
        shot.life--;

        // [Evil Arrow] Trail: spawn normal DarkGas (2x size) with real damage + darkScent
        shot.trailT = (shot.trailT || 0) + 1;
        if ((shot.trailT % 30) === 0) {
            const sp = Math.hypot(shot.vx, shot.vy) || 1;
            const nx = -shot.vy / sp;
            const ny = shot.vx / sp;

            // deterministic wobble (no Math.random)
            const off = Math.sin((shot.seed + shot.trailT) * 0.12) * 12;
            spawnDarkGas(
                shot.x - shot.vx * 1.8 + nx * off,
                shot.y - shot.vy * 1.8 + ny * off,
                2.0,                 // size multiplier (2x normal)
                1.0,                 // damage multiplier (normal)
                shot.accuracy || 0,  // accuracy
                0,                   // no explosion damage
                shot.owner || shot
            );
        }

        if (shot.life <= 0 || shot.x < -100 || shot.x > canvas.width + 100 || shot.y < -100 || shot.y > canvas.height + 100) {
            evilArrows.splice(i, 1);
            continue;
        }

        // [최적화] 충돌 체크 (제곱 거리)
        const dx = player.x - shot.x;
        const dy = player.y - shot.y;
        const distSq = dx * dx + dy * dy;
        const hitRadius = player.radius + shot.radius;

        if (distSq < hitRadius * hitRadius) {
            if (player.invincibleTimer > 0) {
                 evilArrows.splice(i, 1);
                 continue;
            }
            let dmg = 18 + Math.floor(score * 0.15);
            takeDamage(dmg, 'direct', shot.accuracy, shot);
            darknessOverlay.style.opacity = 1;
            setTimeout(() => { darknessOverlay.style.opacity = 0; }, 750);

            for (let k = 0; k < 3; k++) {
                const ang = Math.random() * Math.PI * 2;
                const dist = 35 + Math.random() * 70;
                const sx = player.x + Math.cos(ang) * dist;
                const sy = player.y + Math.sin(ang) * dist;
                spawnDarkGas(sx, sy, 2.0, 1.0, shot.accuracy || 0, 0, shot.owner || shot, true);
            }
            showPickupEffect(player.x, player.y, "눈가리기♥", false, true, "evil-purple-text");
            evilArrows.splice(i, 1);
        }
    }
}

function updatePoisonousShots() {
    for (let i = poisonousShots.length - 1; i >= 0; i--) {
        const shot = poisonousShots[i];
        shot.x += shot.vx;
        shot.y += shot.vy;
        shot.life--;

        // [Aki] Poisonous Shot trail: leave 2x Gases that apply '가스 중독'(poison) on contact
        shot.trailTimer = (shot.trailTimer || 0) + 1;
        if (shot.trailTimer % 30 === 0) {
            // Soft cap to avoid excessive perf spikes when many effects exist
            if (gases.length < 450) {
                spawnGas(
                    shot.x - shot.vx * 1.2,
                    shot.y - shot.vy * 1.2,
                    false, // isElite
                    false, // isZako
                    0,     // extraStacks (base 1 stack per tick)
                    2.0,   // sizeMult (2.0x)
                    shot.accuracy || 0,
                    shot.owner || shot
                );
            }
        }

        if (shot.life <= 0 || shot.x < -120 || shot.x > canvas.width + 120 || shot.y < -120 || shot.y > canvas.height + 120) {
            poisonousShots.splice(i, 1);
            continue;
        }

        // 충돌 체크 (제곱 거리)
        const dx = player.x - shot.x;
        const dy = player.y - shot.y;
        const distSq = dx * dx + dy * dy;
        const hitRadius = player.radius + shot.radius;

        if (distSq < hitRadius * hitRadius) {
            if (player.invincibleTimer > 0) {
                poisonousShots.splice(i, 1);
                continue;
            }

            let dmg = 14 + Math.floor(score * 0.15);
            takeDamage(dmg, 'direct', shot.accuracy, shot);

            // 피격 시: '가스 중독' 5중첩 + '똥독' 5중첩 (기존 유지)
            if (!checkShieldBlockStatus('normal', 'poison')) {
                for (let k = 0; k < 5; k++) addStatus('poison', 900, 50);
                for (let k = 0; k < 5; k++) addStatus('poopPoison', 900, 50);
                updatePoopVisual();
            }
            // [추가] 피격 지점 주변에 가스 5개 생성 (연출 + 후속 접촉 중독)
            for (let k = 0; k < 3; k++) {
                const ang = Math.random() * Math.PI * 2;
                const dist = 25 + Math.random() * 70;
                const gx = player.x + Math.cos(ang) * dist;
                const gy = player.y + Math.sin(ang) * dist;
                // Soft cap to avoid excessive perf spikes when many effects exist
                if (gases.length >= 450) break;
                spawnGas(gx, gy, false, false, 0, 2.0, shot.accuracy || 0, shot.owner || shot, true);
            }
            showPickupEffect(player.x, player.y, "방구냄새..", false, true, "poop-text");

            poisonousShots.splice(i, 1);
        }
    }
}


// [신규] 오즈마: 방구 스모그 투사체 업데이트
function updateFartSmogs() {
    // 성능 모드의 투사체 stride를 따라감
    const stride = (performanceState && performanceState.projectileStride) ? performanceState.projectileStride : 1;
    if (frameCount % stride !== 0) return;

    for (let i = fartSmogs.length - 1; i >= 0; i--) {
        const p = fartSmogs[i];
        p.x += p.vx;
        p.y += p.vy;
        p.life--;

        // 지나간 자리에 2배 크기의 gas 생성 (일반 빌런 gas의 2배)
        p.trailTimer = (p.trailTimer || 0) + 1;
        if (p.trailTimer % 24 === 0) {
            if (gases.length < 450) {
                spawnGas(
                    p.x - p.vx * 1.1,
                    p.y - p.vy * 1.1,
                    false, // isElite
                    false, // isZako
                    0,     // extraStacks
                    1.8,   // sizeMult (1.8배)
                    p.accuracy || 0,
                    p.owner || p
                );
            }
        }

        // 화면 밖/수명 종료 제거
        if (p.life <= 0 || p.x < -200 || p.x > canvas.width + 200 || p.y < -200 || p.y > canvas.height + 200) {
            fartSmogs.splice(i, 1);
            continue;
        }

        // 충돌 체크 (제곱 거리)
        const dx = player.x - p.x;
        const dy = player.y - p.y;
        const distSq = dx * dx + dy * dy;
        const radii = player.radius + p.radius;

        if (distSq < radii * radii) {
            // 피격 처리
            if (player.invincibleTimer <= 0) {
                const dmg = 10 + Math.floor(score * 0.15);
                takeDamage(dmg, 'direct', p.accuracy || 0, p.owner || p);

                // 기절 0.3초(약 18프레임)
                player.stunTimer = Math.max(player.stunTimer, 18);

                // 실명 1중첩 + 가스 중독 3중첩 (상태이상 보호막으로 막힘)
                if (!checkShieldBlockStatus('normal', 'blind')) {
                    addStatus('blind', 900, 10);
                    for (let k = 0; k < 3; k++) addStatus('poison', 900, 50);
                }

                // 피격 위치에 4배 크기의 gas 생성
                if (gases.length < 450) {
                    spawnGas(player.x, player.y, false, false, 0, 4.0, p.accuracy || 0, p.owner || p);
                }

                showPickupEffect(player.x, player.y, "퍽!", false, true, "poop-text");
            }

            fartSmogs.splice(i, 1);
        }
    }
}


function updateAntiPassingTentacles() {
    for (let i = antiPassingTentacles.length - 1; i >= 0; i--) {
        const t = antiPassingTentacles[i];
        t.life--;
        t.frame++;

        // [변경] hitDelay(=그림자 경고 시간) 이후에만 실제로 '솟아오름' 진행
        //  - riseProgress: 0(완전 지면 아래) ~ 1(완전 출현)
        const warn = (t.hitDelay || 0);
        const riseDur = (t.riseDuration || 16);
        const riseFrame = (t.frame - warn);
        t.riseProgress = Math.min(1, Math.max(0, riseFrame / riseDur));

        if (t.life <= 0) {
            antiPassingTentacles.splice(i, 1);
            continue;
        }

        if (t.hitApplied) continue;

        // [요청 반영] 촉수가 '완전히' 땅에서 나와야 데미지/디버프 판정
        if (t.riseProgress < 1) continue;

        // [신규] 촉수 완전 출현 시 '가스 중독' 가스 생성 (일반 빌런 gas 크기)
        if (!t.gasSpawned) {
            t.gasSpawned = true;
            // Soft cap to avoid excessive perf spikes when many effects exist
            if (gases.length < 450) {
                spawnGas(
                    t.x,
                    t.y - 20,
                    false, // isElite
                    false,  // isZako (일반 빌런 gas 크기)
                    0,     // extraStacks
                    1.0,   // sizeMult
                    t.accuracy || 0,
                    t.owner || t
                );
            }
        }

        // [히트박스 변경] '보이는 촉수(세그먼트)' 범위대로 판정 (멀티 서클)
        //  - 렌더의 세그먼트 배치(각도/거리/반경)와 동일한 방식으로 중심점을 만들고,
        //    플레이어 원과 각 세그먼트 원의 교차를 검사한다.
        if (!t._hitSegments) {
            const _apBaseR = 42;
            const _apScale = Math.max(0.2, (t.radius || _apBaseR) / _apBaseR);
            const _apDir = (typeof t.baseAngle === 'number') ? t.baseAngle : (-Math.PI / 2);
            const segsFull = Math.max(3, (t.segCount || 7));
            const arr = [];
            for (let sIdx = 0; sIdx < segsFull; sIdx++) {
                const k = (segsFull <= 1) ? 1 : (sIdx / (segsFull - 1));
                const segAngle = _apDir + k * 1.35;
                const dist = k * 132 * _apScale; // rise=1 기준(완전 출현 시)
                const dxs = Math.cos(segAngle) * dist;
                const dys = Math.sin(segAngle) * dist;
                const segR = (22 - k * 8) * _apScale;
                const tip = (7 - k * 2) * _apScale; // 가시 길이(렌더와 동일 계열)
                arr.push({ dx: dxs, dy: dys, r: segR * 1.05 + tip }); // 본체+가시까지 포함
            }
            t._hitSegments = arr;
        }

        let _apHit = false;
        {
            const segs = t._hitSegments;
            for (let s = 0; s < segs.length; s++) {
                const sg = segs[s];
                const hx = t.x + sg.dx;
                const hy = t.y + sg.dy;
                const ddx = player.x - hx;
                const ddy = player.y - hy;
                const rr = player.radius + sg.r;
                if (ddx * ddx + ddy * ddy < rr * rr) { _apHit = true; break; }
            }
        }

        if (_apHit) {
            if (player.invincibleTimer > 0) {
                // 무적이면 이번 촉수는 소비(기존 동작 유지)
                t.hitApplied = true;
                continue;
            }

            let dmg = 14 + Math.floor(score * 0.15);
            takeDamage(dmg, 'direct', t.accuracy, t);

            let applied = 0;
            for (let k = 0; k < 3; k++) {
                if (!checkShieldBlockStatus('normal', 'poison')) { addStatus('poison', 900, 50); applied++; }
            }
            for (let k = 0; k < 3; k++) {
                if (!checkShieldBlockStatus('normal', 'poopPoison')) { addStatus('poopPoison', 900, 50); applied++; }
            }
            for (let k = 0; k < 3; k++) {
                if (!checkShieldBlockStatus('normal', 'fishy')) { addStatus('fishy', 900, 50); applied++; }
            }
            if (applied > 0) {
                updateStatusUI();
                updatePoopVisual();
                showPickupEffect(player.x, player.y, "방구냄새..", false, true, "poop-text");
            }

            t.hitApplied = true;
        }
    }
}

function updateJammingWaves() {
    for (let i = jammingWaves.length - 1; i >= 0; i--) {
        const wave = jammingWaves[i];
        wave.x += wave.vx;
        wave.y += wave.vy;
        wave.life--;
        
        if (wave.life <= 0 || wave.x < -100 || wave.x > canvas.width + 100 || wave.y < -100 || wave.y > canvas.height + 100) {
            jammingWaves.splice(i, 1);
            continue;
        }

        // [최적화] 충돌 체크 (제곱 거리)
        const dx = player.x - wave.x;
        const dy = player.y - wave.y;
        const distSq = dx * dx + dy * dy;
        const hitRadius = player.radius + wave.radius;

        if (distSq < hitRadius * hitRadius) {
            if (player.invincibleTimer > 0) {
                jammingWaves.splice(i, 1);
                continue;
            }
            
            let dmg = 19 + Math.floor(score * 0.17);
            takeDamage(dmg, 'direct', wave.accuracy, wave);
            // 쿨타임 증가
            player.goddessSkill.cooldown += 600;
            player.sacredFaithSkill.cooldown += 600;
            player.novaSkill.cooldown += 600;
            player.limitFocusSkill.cooldown += 600;

            showPickupEffect(player.x, player.y, "재밍!!", false, true, "evil-purple-text");
            
            // 노이즈 이펙트
            const noiseDiv = document.createElement('div');
            noiseDiv.style.position = 'absolute';
            noiseDiv.style.top = 0; noiseDiv.style.left = 0;
            noiseDiv.style.width = '100%'; noiseDiv.style.height = '100%';
            noiseDiv.style.backgroundImage = 'url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHdpZHRoPScxMDAlJyBoZWlnaHQ9JzEwMCUnPjxmaWx0ZXIgaWQ9J25vaXNlJz48ZmVUdXJidWxlbmNlIHR5cGU9J2ZyYWN0YWxOb2lzZScgYmFzZUZyZXF1ZW5jeT0nMC41JyBudW1PY3RhdmVzPScxJyBzdGl0Y2hUaWxlcz0nc3RpdGNoJy8+PC9maWx0ZXI+PHJlY3Qgd2lkdGg9JzEwMCUnIGhlaWdodD0nMTAwJScgZmlsdGVyPSd1cmwoI25vaXNlKScgb3BhY2l0eT0nMC41Jy8+PC9zdmc+")';
            noiseDiv.style.opacity = 0.5;
            noiseDiv.style.pointerEvents = 'none';
            noiseDiv.style.zIndex = 9999;
            document.body.appendChild(noiseDiv);
            setTimeout(() => noiseDiv.remove(), 500);

            jammingWaves.splice(i, 1);
        }
    }
}

        function updateNeuroNeedles() {
    for (let i = neuroNeedles.length - 1; i >= 0; i--) {
        const n = neuroNeedles[i];
        n.x += n.vx;
        n.y += n.vy;
        n.life--;
        
        // 독바늘 꼬리(잔상)
        if (!n.trail) n.trail = [];
        n.trail.push({ x: n.x, y: n.y, size: Math.random() * 10 + 5, life: 20 });
        for (let t = n.trail.length - 1; t >= 0; t--) {
            n.trail[t].life--;
            if (n.trail[t].life <= 0) n.trail.splice(t, 1);
        }

        if (n.life <= 0 || n.x < -100 || n.x > canvas.width + 100 || n.y < -100 || n.y > canvas.height + 100) {
            neuroNeedles.splice(i, 1);
            continue;
        }

        // [최적화] 충돌 체크 (제곱 거리)
        const dx = player.x - n.x;
        const dy = player.y - n.y;
        const distSq = dx * dx + dy * dy;
        const hitRadius = player.radius + n.radius;

        if (distSq < hitRadius * hitRadius) {
            if (player.invincibleTimer > 0) {
                neuroNeedles.splice(i, 1);
                continue;
            }
            
            let dmg = 7 + Math.floor(score * 0.12);
            takeDamage(dmg, 'direct', n.accuracy, n);
            
            addStatus('paralysis', 900, 10);
            if (player.paralysisTimers.length >= 10) {
                player.paralysisTimers = [];
                player.rootTimer = 120;
                showPickupEffect(player.x, player.y, "몸이 굳었다!!", false, true, "evil-purple-text");
            } else {
                showPickupEffect(player.x, player.y, "마비..", false, false, "weak-text");
            }
            updateStatusUI();
            neuroNeedles.splice(i, 1);
        }
    }
}
        
        function updateChaosOrbs() {
    for (let i = chaosOrbs.length - 1; i >= 0; i--) {
        const orb = chaosOrbs[i];
        
        // 유도 움직임
        const angle = Math.atan2(player.y - orb.y, player.x - orb.x);
        orb.vx = Math.cos(angle) * orb.speed;
        orb.vy = Math.sin(angle) * orb.speed;
        
        orb.x += orb.vx;
        orb.y += orb.vy;
        orb.life--;

        if (orb.life <= 0) { chaosOrbs.splice(i, 1); continue; }

        // [최적화] 충돌 체크 (제곱 거리)
        const dx = player.x - orb.x;
        const dy = player.y - orb.y;
        const distSq = dx * dx + dy * dy;
        const hitRadius = player.radius + orb.radius;

        if (distSq < hitRadius * hitRadius) {
            if (player.invincibleTimer <= 0) {
                let dmg = 25 + Math.floor(score * 0.2);
                takeDamage(dmg, 'direct', orb.accuracy, orb);
                
                if (!checkShieldBlockStatus('normal', 'darkness')) {
                    addStatus('darkness', 360, 1);
                    showPickupEffect(player.x, player.y, "암흑♥", false, true, "darkness-border");
                }
                chaosOrbs.splice(i, 1);
            }
        }
    }
}
        function updateShockwaves() {
        for (let i = shockwaves.length - 1; i >= 0; i--) {
        const sw = shockwaves[i];
        sw.radius += sw.speed; // 반경 확장
        sw.alpha -= sw.fade;   // 투명도 감소
        
        if (sw.alpha <= 0) {
            shockwaves.splice(i, 1); // 투명해지면 배열에서 제거
        }
    }
}

function updateItems() {
    for (let i = items.length - 1; i >= 0; i--) {
        const item = items[i];

        // 자석 효과 이동 로직
        if (item.isMagnetized) {
            const angle = Math.atan2(player.y - item.y, player.x - item.x);
            const speed = 15;
            item.x += Math.cos(angle) * speed;
            item.y += Math.sin(angle) * speed;
        }

        const dist = Math.hypot(player.x - item.x, player.y - item.y);
        
        // 플레이어와 아이템 충돌 시
        if (dist < player.radius + item.radius) {

            if (item.type === 'health') {
                // [수정 핵심] healAmount 변수 선언을 가장 먼저 수행합니다.
                let healAmount = player.maxHealth * 0.35;

                // 1. 출혈 체크 (이제 healAmount가 존재하므로 에러가 나지 않습니다)
                if (player.bleedingTimers.length > 0) {
                    let bleedReduction = player.bleedingTimers.length * 0.02;
                    healAmount *= (1 - bleedReduction);
                }

                // 2. 신성 모독 체크 (회복 불가)
                if (player.blasphemyTimers.length > 0) {
                    showPickupEffect(player.x, player.y, "신성 모독!! (회복 불가)", false, true, "corrupted-text");
                    player.stunTimer = 120; // 2초 기절
                    items.splice(i, 1);
                    return;
                }

                // 3. 혈청 오염 체크 (회복 불가)
                if (player.serumContaminationTimers && player.serumContaminationTimers.length > 0) {
                    showPickupEffect(player.x, player.y, "혈청 오염! (회복 불가)", false, true, "corrupted-text");
                    items.splice(i, 1);
                    return;
                }

                // 4. 시간 경과/점수 비례 감소 계산
                const reductionRate = 0.0075;
                let timeReduction = Math.floor(score / 10) * reductionRate;
                timeReduction = Math.min(0.9, timeReduction);
                healAmount *= (1 - timeReduction);

                // 5. 좀먹는 생명 (회복량 감소)
                if (player.gnawingLifeTimers.length > 0) {
                    const reduction = player.gnawingLifeTimers.length * 0.02;
                    healAmount *= (1 - reduction);
                }

                // 6. 군주의 위엄 (회복량 10% 감소)
                if (player.majestyActive) {
                    healAmount *= 0.9;
                }

                // 최소 회복량 보장 및 적용
                if (healAmount < 1) healAmount = 1;

                player.health = Math.min(player.maxHealth, player.health + healAmount);
                player.invincibleTimer = 60;
                showPickupEffect(item.x, item.y, `HP회복(+${Math.floor(healAmount)}) & 무적!`);
                updateHealthUI();

                // [NEW] 유물 특수 효과: 체력 아이템 획득 트리거
                if (typeof relicOnHealthItemPicked === 'function') relicOnHealthItemPicked();

            } else if (item.type === 'berserk') {
                player.berserkTimer = 600;
                player.weapon.autoAttackInterval = player.weapon.baseAutoAttackInterval / 1.5;
                berserkStatus.style.display = 'flex';
                showPickupEffect(item.x, item.y, "베르세르크!", false);

            } else if (item.type === 'white') {
                // ... (기존 화이트 아이템 로직 그대로 유지)
                const debuffKeys = [
                    'poisonTimers', 'poopPoisonTimers', 'maliceTimers', 'kissTimers',
                    'semenTimers', 'oralTimers', 'byururutTimers', 'darknessTimers', 'fishyTimers'
                ];
                let healPower = 15;
                let totalHealed = 0;

                while (healPower > 0) {
                    const activeDebuffs = debuffKeys.filter(key => player[key] && player[key].length > 0);
                    if (activeDebuffs.length === 0) break;
                    const targetKey = activeDebuffs[Math.floor(Math.random() * activeDebuffs.length)];
                    const countToRemove = Math.min(healPower, player[targetKey].length);
                    
                    player[targetKey].sort((a, b) => a - b);
                    player[targetKey].splice(0, countToRemove);
                    
                    healPower -= countToRemove;
                    totalHealed += countToRemove;
                }

                if (totalHealed > 0) {
                    showPickupEffect(item.x, item.y, `연쇄 정화! (-${totalHealed})`, false);
                    if (hasEquippedNamedGear('원시 태동의 결속 장갑') && Math.random() < 0.25) {
                        let extra = 0;
                        for (let t = 0; t < totalHealed; t++) {
                            if (removeOneCleanseableDebuffStack()) extra++;
                        }
                        if (extra > 0) showPickupEffect(item.x, item.y - 30, `결속 장갑: 정화 효과 2배! (-${extra})`, false, true, 'goddess-text');
                    }
                } else {
                    showPickupEffect(item.x, item.y, "정화 완료!", false);
                }
                updateStatusUI();
                updatePoopVisual();

                // [NEW] 유물 특수 효과: 정화 아이템 획득 트리거
                if (typeof relicOnCleansePicked === 'function') relicOnCleansePicked(totalHealed);

            } else if (item.type === 'shield') {
                player.shieldStacks += 7;
                updateStatusUI();
                showPickupEffect(item.x, item.y, "보호막 +7", false);

            } else if (item.type === 'justice') {
                if (player.evilMindTimers.length > 0) {
                    player.evilMindTimers.sort((a, b) => a - b);
                    player.evilMindTimers.splice(0, 2);
                }
                player.justiceShield += 5;
                updateMaxHealth();
                updateStatusUI();
                showPickupEffect(item.x, item.y, "정의 구현!", false);

            } else if (item.type === 'ancientScroll') {
                // [신규] 고대의 두루마리: 레벨업 카드 리로드 기회 +1
                rerollCount++;
                showPickupEffect(item.x, item.y, "리로드!", false, true, "justice-border");
            } else if (item.type === 'fakeHealth') {
                let fakeDamage = 12 + Math.floor(score * 0.17);
                takeDamage(fakeDamage, 'direct', item.accuracy, item);
                player.stunTimer = 60;
                showPickupEffect(player.x, player.y, "가짜였다!!", false, true, "weak-text");

            } else if (item.type === 'magnet') {
                items.forEach(otherItem => {
                    if (otherItem !== item && otherItem.type !== 'health' && otherItem.type !== 'magnet') {
                        otherItem.isMagnetized = true;
                    }
                });
                showPickupEffect(item.x, item.y, "자석 발동!", true);
            }

            onAngelicLootItemPicked(item.type);

            // 타락한 정의(Corrupted Justice)에 의한 아이템 무효화 이펙트
            if (player.corruptedJusticeStacks > 0) {
                updateStatusUI();
                showPickupEffect(item.x, item.y, "정의에 의해 무효화!", false, true, "item-nullified-text");
            }

            // 아이템 제거
            items.splice(i, 1);
        }
    }
}
        

function onAngelicLootItemPicked(itemType) {
    const valid = new Set(['health','white','shield','justice','berserk','ancientScroll']);
    if (!valid.has(itemType)) return;

    // 샤이닝 인페르노: 아이템 획득 시 랜덤 적 폭발
    if (!hasEquippedNamedGear('샤이닝 인페르노')) return;

    const candidates = enemies.filter(e => e && e.hp > 0 && !e.isDead);
    if (!candidates.length) return;
    const target = candidates[Math.floor(Math.random() * candidates.length)];
    const dmg = Math.max(1, Math.floor((player.weapon?.damage || 1) * 1.5));
    target.hp -= dmg;
    showDamageText(target.x, target.y - 24, dmg, false, false, 'crit-text');
    showPickupEffect(target.x, target.y - 48, '🔥 샤이닝 인페르노(공격력 1.5배)', false, true, 'crit-text');
    shiningInfernoEffects.push({ x: target.x, y: target.y, life: 28, maxLife: 28, t: 0 });
}

 function updateEnemies() {
    const ecstasyFlatBonus = player.darkEcstasyTimers.length * 0.8;
    const activeTetora = enemies.find(e => e.isTetora && e.hp > 0);
    const isRhapsodyActive = activeTetora && activeTetora.currentSong === 'rhapsody' && activeTetora.songTimer > 0;

    // [최적화] 성역(가웨인) 범위 카운트는 매 프레임이 아니라 N프레임마다 갱신
    if (frameCount % GAWAIN_SANCTUARY_STRIDE === 0) {
        enemies.forEach(e => e.gawainSanctuaryCount = 0);
    }

    let attachedRapistCount = 0;
    let taroExists = false; 

    for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];

                // [NEW] 장비 강화 레벨에 따른 적 스탯 보정(1회)
                applyEnhanceScalingToEnemyOnce(enemy);
                applyEnemyDifficultyRebalance(enemy);
        const _preX = enemy.x;
        const _preY = enemy.y;
        if ((enemy.voidGrimoireBuffTimer || 0) > 0) {
            enemy.voidGrimoireBuffTimer--;
            enemy.voidGrimoireBuff = 1.25;
        } else {
            enemy.voidGrimoireBuff = 1.0;
        }
        // [신규] 공허의 금서 버프: 스킬 쿨타임 진행 속도 배율
        const cdrSpeed = (enemy.voidGrimoireBuff || 1.0);
        // [신규] 적 상태이상 저항: 25초마다 +1%p
        enemy.statusResist = (enemy.baseStatusResist || 0) + Math.floor(score / ENEMY_SCORE_SCALING.stepSeconds) * ENEMY_SCORE_SCALING.statusResistPerStep;

    // =========================================================
        // [수정] 명중률 실시간 갱신 로직 (score 스케일 + 광시곡 버프)
        // =========================================================
        
        // 1. 기본 명중률 보존
        if (enemy.baseAccuracy === undefined) {
            enemy.baseAccuracy = enemy.accuracy || 0;
        }

        // =========================================================
        // [신규] 치명타 확률/치명타 저항 실시간 갱신 로직 (score 기반 스케일)
        //  - baseCritChance/baseCritResist를 보존하고 매 프레임 재계산
        // =========================================================
        if (enemy.baseCritChance === undefined) {
            enemy.baseCritChance = enemy.critChance || 0;
        }
        if (enemy.baseCritResist === undefined) {
            enemy.baseCritResist = enemy.critResist || 0;
        }
        const timeCritBonus = Math.floor(score / ENEMY_SCORE_SCALING.stepSeconds) * ENEMY_SCORE_SCALING.critPerStep;
        enemy.critChance = enemy.baseCritChance + timeCritBonus;
        enemy.critResist = enemy.baseCritResist + timeCritBonus;

        let accuracyBonus = (score / ENEMY_SCORE_SCALING.stepSeconds) * ENEMY_SCORE_SCALING.accuracyPerStep;

        if (enemy.erectionStacks > 0) {
            let accPerStack = 0.005 + (score / 15000);
            let stackBonus = enemy.erectionStacks * accPerStack;
            let timeBonus = (score / 10) * 0.003;
            accuracyBonus += (stackBonus + timeBonus);
        }

        if (isRhapsodyActive && !enemy.isTetora) {
            accuracyBonus += 0.15;
        }

        enemy.accuracy = enemy.baseAccuracy + accuracyBonus;
        // 1. 심연의 공명 처리
        if (enemy.hasAbyssalResonance) {
            enemy.resonanceDuration--; 
            if (enemy.resonanceDuration <= 0) {
                enemy.hasAbyssalResonance = false;
            }
        }

        // 2. 타로(Taro) 관련 로직
        if (enemy.isTaro) taroExists = true;
        
        if (enemy.isTaro) {
            if (enemy.deathGripActive) {
                enemy.deathGripDuration--;
                player.skillSealTimer = 10; // 스킬 봉인 상태 유지

                // 사슬 연결 거리 제한 (650px)

                if (enemy.baseMoveSpeed == null) enemy.baseMoveSpeed = enemy.speed || 1;
                if ((enemy.tempSpeedUntil || 0) > frameCount) enemy.speed = enemy.baseMoveSpeed * (enemy.tempSpeedMul || 1);
                else enemy.speed = enemy.baseMoveSpeed;

                const dist = Math.hypot(player.x - enemy.x, player.y - enemy.y);
                const maxDist = 650;
                
                // 플레이어가 일정 거리 이상 멀어지면 타로 쪽으로 끌려감
                if (dist > maxDist) {
                    const angle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
                    player.x = enemy.x + Math.cos(angle) * maxDist;
                    player.y = enemy.y + Math.sin(angle) * maxDist;
                }

                const damagePerSec = 4 + (score * 0.04);
                const dmg = damagePerSec / 60;

                // 데스 그립 명중/회피 로직
                // 공식: 100% - (플레이어 회피율 - 적 명중률)
                let hitChance = 1.0 - (player.bonusEvasion - enemy.accuracy);
                
                if (Math.random() < hitChance) {
                    takeDamage(dmg, 'dot');
                } else {
                    // 회피 성공 시 (텍스트 도배 방지를 위해 1초에 한 번만 표시)
                    if (frameCount % 60 === 0) {
                        showDamageText(player.x, player.y, "DODGE", false, false, "weak-text");
                    }
                }

                // 지속시간 종료
                if (enemy.deathGripDuration <= 0) {
                    enemy.deathGripActive = false;
                    enemy.deathGripTimer = 0;
                }
            } else {
                // 쿨타임 진행
                enemy.deathGripTimer += cdrSpeed;
                if (enemy.deathGripTimer >= 600) { // 10초
                    enemy.deathGripActive = true;
                    enemy.deathGripDuration = 480; // 8초
                    showPickupEffect(enemy.x, enemy.y - 60, "데스 그립!", false, false, "wicked-large-text");
                }
            }
        }
        
        // 3. [핵심 수정] 기절(Stun) 처리 로직
        if (enemy.stunTimer > 0) {
            enemy.stunTimer--;
            // 수정됨: 적이 살아있을 때만(HP > 0) 행동을 건너뜁니다.
            // HP가 0 이하라면 continue를 하지 않아, 아래쪽의 사망 처리 코드가 실행됩니다.
            if (enemy.hp > 0) {
                // [v13] 가웨인의 '잔혹한 돌진' 차지/돌진 중에는 기절로 패턴이 끊기지 않도록 예외 처리
                const ignoreStun = enemy.isGawain && (enemy.isCruelChargeCharging || enemy.isCruelCharging);
                if (!ignoreStun) {
                    continue;
                } else {
                    // 차지/돌진 중에는 스턴을 사실상 무시(이동/전환을 막지 않음)
                    enemy.stunTimer = 0;
                }
            }
        }

        if (enemy.isVoidGrimoire) {
            enemy.vx = 0; enemy.vy = 0;
            enemy.gasTimer = (enemy.gasTimer || 0) + cdrSpeed;
            enemy.playerGasTimer = (enemy.playerGasTimer || 0) + cdrSpeed;

            if (enemy.gasTimer >= 90) {
                spawnDeathCloud(enemy.x, enemy.y, false, false, enemy.accuracy, enemy);
                enemy.gasTimer = 0;
            }
            if (enemy.playerGasTimer >= 60) {
                spawnDeathCloud(player.x, player.y, true, false, enemy.accuracy, enemy);
                enemy.playerGasTimer = 0;
            }

            enemies.forEach(ally => {
                if (ally === enemy || ally.hp <= 0 || ally.isVoidGrimoire) return;
                const inRange = Math.hypot(ally.x - enemy.x, ally.y - enemy.y) <= (enemy.allyBuffRange || 190);
                if (inRange) {
                    ally.voidGrimoireBuff = 1.25;
                    ally.voidGrimoireBuffTimer = 5;
                }
            });
        }

// 4. 모놀리스(Monolith) 가스 패턴
        if (enemy.isMonolith) {
            enemy.vx = 0; enemy.vy = 0; // 위치 절대 고정
            
            // 가스 타이머 증가 (초기화 안전장치 포함)
            enemy.gasTimer = (enemy.gasTimer || 0) + cdrSpeed;
            
            // 가스 방출
            if (enemy.gasTimer >= 150) {
                // 1. 비석 주변 (크게)
                spawnDarkGas(enemy.x, enemy.y, 1.5, 1.0, enemy.accuracy, 0, enemy);
                // 2. 플레이어 위치 (중간)
                spawnDarkGas(player.x, player.y, 1.5, 1.0, enemy.accuracy, 0, enemy);
                
                enemy.gasTimer = 0;
            }
        }

                // [추가] 심연의 공명 효과 발동 로직
// 적이 '공명' 상태(hasAbyssalResonance)이고 플레이어와 접촉했을 때
if (enemy.hasAbyssalResonance) {
    // 플레이어와의 거리 계산
    const dist = Math.hypot(player.x - enemy.x, player.y - enemy.y);
    
    // 충돌 판정 (반지름 합 + 약간의 여유)
    if (dist < player.radius + enemy.radius) {
        // 1. 최대 체력의 15% 계산
        let healAmount = Math.floor(enemy.maxHp * 0.15);
        // (선택) 회복률 보정이 있다면 적용
        healAmount = Math.floor(healAmount * (enemy.hpRecoveryRate || 1));
        
        // 2. 체력 회복 적용
        enemy.hp = Math.min(enemy.maxHp, enemy.hp + healAmount);
        
        // 3. 시각 효과 (텍스트 및 이펙트)
        showDamageText(enemy.x, enemy.y, "+" + healAmount, false, false, "heal-text");
        showPickupEffect(enemy.x, enemy.y - 30, "공명 흡수!", false, true, "pink-text");
        
        // 4. 버프 소모 처리 (중복 발동 방지)
        enemy.hasAbyssalResonance = false; 
        enemy.usedAbyssalResonance = true; // 재부여 방지용 플래그
    }
}     
                
                // [신규] 카인 전용 스킬 로직 (아서/아키토/토우야가 아닌 순수 카인)
            if (enemy.isBoss && !enemy.isArthur && !enemy.isArchdemon) {
                // 1. 가스 익스플로젼
                enemy.gasExplosionTimer--;
                if (enemy.gasExplosionTimer <= 0) {
                    enemy.gasExplosionTimer = 1200; // 쿨타임 리셋
                    spawnGasExplosionPattern(enemy.accuracy, enemy);    // 패턴 발동 함수 호출
                    showPickupEffect(enemy.x, enemy.y - 100, "냄새 폭발♥", false, true, "wicked-large-text");
                }

              // 2. 악마의 보호 (쿨타임 14초, 지속 10초)
                // 지속시간 체크 및 해제
                if (enemy.protectionTarget) {
                    enemy.devilsProtectionDuration--;
                    
                    // 지속시간 종료되거나 대상이 죽으면 해제
                    if (enemy.devilsProtectionDuration <= 0 || enemy.protectionTarget.hp <= 0) {
                        if (enemy.protectionTarget.hp > 0) {
                            enemy.protectionTarget.isProtectedByCain = false; // 대상의 플래그 해제
                            showPickupEffect(enemy.protectionTarget.x, enemy.protectionTarget.y - 60, "보호 해제", false, true, "weak-text");
                        }
                        enemy.protectionTarget = null; // 타겟 참조 제거
                    }
                }

                // 쿨타임 체크 및 발동
                enemy.devilsProtectionTimer--;
                if (enemy.devilsProtectionTimer <= 0) {
                    enemy.devilsProtectionTimer = 840; // 14초 쿨타임 리셋
                    
                    // 아키토나 토우야 찾기
                    let candidates = enemies.filter(e => e.isArchdemon && e.hp > 0);
                    if (candidates.length > 0) {
                        // 이미 보호중인 대상이 있다면 해제 후 재시전 (혹은 갱신)
                        if (enemy.protectionTarget) {
                            enemy.protectionTarget.isProtectedByCain = false;
                        }

                        // 랜덤 선택
                        let target = candidates[Math.floor(Math.random() * candidates.length)];
                        enemy.protectionTarget = target;
                        enemy.devilsProtectionDuration = 600; // [설정] 지속시간 10초 (60프레임 * 10)
                        
                        target.isProtectedByCain = true; // 타겟에게 보호 플래그 설정
                        target.protectionVisualTimer = 120; // 시각 효과용
                        showPickupEffect(target.x, target.y - 60, "악마의 보호!", false, true, "shield-border");
                    }
                }

                // 3. 이블 다이제스트 (20초 쿨타임, 16초 지속)
                if (enemy.isEvilDigestActive) {
                    enemy.evilDigestDuration--;
                    if (enemy.evilDigestDuration <= 0) {
                        enemy.isEvilDigestActive = false;
                        showPickupEffect(enemy.x, enemy.y - 60, "소화 끝..", false);
                    } else {
                        // 아이템 흡수 로직
                        for (let k = items.length - 1; k >= 0; k--) {
                            let it = items[k];
                            let d = Math.hypot(enemy.x - it.x, enemy.y - it.y);
                            if (d < (enemy.radius * 1.25) + it.radius + 100) {
                                items.splice(k, 1); // 아이템 삭제
                                // [추가] 이블 다이제스트: 아이템 섭취 시 최대 HP의 5% 회복
                                {
                                    const baseHeal = Math.floor((enemy.maxHp || 0) * 0.05);
                                    const healAmount = Math.floor(baseHeal * (enemy.hpRecoveryRate || 1));
                                    if (healAmount > 0) {
                                        const prevHp = enemy.hp;
                                        enemy.hp = Math.min(enemy.maxHp, enemy.hp + healAmount);
                                        const actualHeal = enemy.hp - prevHp;
                                        if (actualHeal > 0) {
                                            showDamageText(enemy.x, enemy.y, "+" + actualHeal, false, false, "heal-text");
                                        }
                                    }
                                }
                                // 효과: 유도 똥 발사 + 플레이어 발밑 다크가스
                                spawnDarkBigPoop(enemy.x, enemy.y, false, 0, true, enemy.accuracy, enemy);
                                spawnDarkGas(player.x, player.y, 3.0, 1.0, enemy.accuracy, 0, enemy);
                                showPickupEffect(enemy.x, enemy.y, "꺼억~♥", false, true, "poop-text");
                            }
                        }
                    }
                } else {
                    enemy.evilDigestTimer--;
                    if (enemy.evilDigestTimer <= 0) {
                        enemy.evilDigestTimer = 1200;
                        enemy.isEvilDigestActive = true;
                        enemy.evilDigestDuration = 960; 
                        showPickupEffect(enemy.x, enemy.y - 80, "똥싸고 방구껴주마..♥", false, true, "corrupted-text");
                    }
                }
            }

                // [신규] 아서 전용 패턴 로직
                if (enemy.isArthur) {
                    // 스킬 1: 블러드 드레인 (쿨타임 8초)
                    enemy.bloodDrainTimer = (enemy.bloodDrainTimer || 0) + cdrSpeed;
                    if (enemy.bloodDrainTimer >= 480) {
        spawnBloodBat(enemy.x, enemy.y, enemy, enemy.accuracy); // [수정]
        showPickupEffect(enemy.x, enemy.y - 60, "피를 바쳐라!", false, false, "arthur-text");
        enemy.bloodDrainTimer = 0;
                    }
                    
                    // 스킬 2: 엑스칼리버 모르간 (쿨타임 9초)
                    enemy.excaliburTimer = (enemy.excaliburTimer || 0) + cdrSpeed;
                    if (enemy.excaliburTimer >= 540) {
        const angle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
        spawnExcaliburSlash(enemy.x, enemy.y, angle, enemy.accuracy, enemy); // [수정]
        showPickupEffect(enemy.x, enemy.y - 60, "척살..", false, true, "arthur-text");
        enemy.excaliburTimer = 0;
                    }
                    
                    // 스킬 3: 블러드 스웜 (쿨타임 10초)
                    enemy.bloodSwarmTimer = (enemy.bloodSwarmTimer || 0) + cdrSpeed;
                    if (enemy.bloodSwarmTimer >= 600) {
        spawnBloodPuddle(player.x, player.y, enemy, enemy.accuracy); // [수정]
        showPickupEffect(player.x, player.y - 40, "피바다♥", false, false, "arthur-text");
        enemy.bloodSwarmTimer = 0;
                    }
                    
                    // 소환 패턴
                    // 1. 등장 7초 후 (420프레임)
                    if (enemy.initialSummonTimer > 0) {
                        enemy.initialSummonTimer--;
                    if (enemy.initialSummonTimer <= 0) {
                        spawnEnemy(true, 'Ryuon', 0, canvas.height / 2);
                        spawnEnemy(true, 'Gawain', canvas.width, canvas.height / 2);
                           
                             showPickupEffect(enemy.x, enemy.y - 80, "나의 기사들이여!", false, true, "arthur-text");
                        }
                    }
                    
                    // [변경] 아서 소환은 등장 직후 1회만 사용
               }

                // [신규] 루카 패턴: 악의의 탄도
        if (enemy.isLuca) {
            enemy.maliceBallisticTimer = (enemy.maliceBallisticTimer || 0) + cdrSpeed;
            if (enemy.maliceBallisticTimer >= 600) { // 쿨타임 10초 (600프레임)
                const baseAngle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
                // 3발 발사 (부채꼴 형태)
                for (let k = -1; k <= 1; k++) {
                    const angle = baseAngle + (k * 0.25); // 약간 퍼지게 발사
                    spawnMaliceBallistic(enemy.x, enemy.y, angle, enemy.accuracy, enemy);
                }
                showPickupEffect(enemy.x, enemy.y - 60, "헤헤헤♥", false, true, "malice-text");
                enemy.maliceBallisticTimer = 0;
            }
        }

                if (enemy.isRyuon) {
                 if (enemy.firmDarknessActive > 0) {
                    enemy.firmDarknessActive--;
                    const darknessRange = enemy.radius * 2.0; // 마법진 크기 (가웨인과 동일 비율)

                    // 범위 내 아군 버프 부여 (매 프레임 체크)
                    enemies.forEach(ally => {
                        // 살아있는 다른 아군 (자신 포함 or 제외 선택 가능, 여기선 자신도 포함됨)
                        if (ally.hp > 0) { 
                            const dist = Math.hypot(enemy.x - ally.x, enemy.y - ally.y);
                            
                            // 범위 안이고, 아직 버프가 없다면 부여
                            if (dist < darknessRange) {
                                // [Firm Darkness][수정] score(초) 기반 방어 버프 스케일: 50초에 약 +3.5 (기본 1.5 + 0.04/초)
                                const firmDarknessDefenseBonus = 1.5 + (score * 0.04);

                                if (!ally.firmDarknessBuffed) {
                                    ally.defense += firmDarknessDefenseBonus;
                                    ally.firmDarknessDefenseBonus = firmDarknessDefenseBonus;
                                    ally.critResist = (ally.critResist || 0) * 1.2; // 치명타 저항 확률 20% 증가 (곱연산)
                                    ally.firmDarknessBuffed = true;

                                    // (선택) 버프 받는 순간 이펙트
                                    // showDamageText(ally.x, ally.y, "▲", false, false, "heal-text"); 
                                } else {
                                    // 시간이 지나 보너스가 변하면 차이만큼만 보정 (다른 버프와 충돌 최소화)
                                    const prevBonus = ally.firmDarknessDefenseBonus || 0;
                                    const delta = firmDarknessDefenseBonus - prevBonus;
                                    if (Math.abs(delta) > 1e-6) {
                                        ally.defense += delta;
                                        ally.firmDarknessDefenseBonus = firmDarknessDefenseBonus;
                                    }
                                }
                            } 
                            // 범위 밖으로 나갔는데 버프가 있다면 즉시 해제
                            else {
                                if (ally.firmDarknessBuffed) {
                                    const prevBonus = ally.firmDarknessDefenseBonus || 0;
                                    ally.defense -= prevBonus;
                                    ally.firmDarknessDefenseBonus = 0;
                                    ally.critResist /= 1.2; // 치명타 저항 확률 원상복구
                                    ally.firmDarknessBuffed = false;
                                }
                            }
                        }
                    });
                } 
                // 2. 스킬 비활성 (쿨타임) 상태일 때
                else {
                    // 스킬이 막 끝난 직후라면, 남아있는 모든 아군의 버프 강제 해제 (안전장치)
                    if (enemy.firmDarknessBuffApplied) {
                        enemies.forEach(ally => {
                            if (ally.firmDarknessBuffed) {
                                const prevBonus = ally.firmDarknessDefenseBonus || 0;
                                ally.defense -= prevBonus;
                                ally.firmDarknessDefenseBonus = 0;
                                ally.critResist /= 1.2;
                                ally.firmDarknessBuffed = false;
                            }
                        });
                        enemy.firmDarknessBuffApplied = false; // 해제 완료 플래그
                    }

                    // 쿨타임 진행
                    enemy.firmDarknessTimer = (enemy.firmDarknessTimer || 0) + cdrSpeed;
                    
                    if (enemy.firmDarknessTimer >= 840) { 
                        // 스킬 발동!
                        enemy.firmDarknessActive = 600; // 지속 10초 (600프레임)
                        enemy.firmDarknessTimer = 0;
                        enemy.firmDarknessBuffApplied = true; // 버프 관리 시작 플래그

                        showPickupEffect(enemy.x, enemy.y - 80, "굳건한 어둠!", false, true, "shadow-text");
                    }
                }

                // 쿨타임 15초 (900프레임)
                 enemy.abyssalResonanceTimer = (enemy.abyssalResonanceTimer || 0) + cdrSpeed;
    
           if (enemy.abyssalResonanceTimer >= 900) {
        // 시전 텍스트
        showPickupEffect(enemy.x, enemy.y - 60, "공명하라!", false, true, "evil-purple-text");
        
        // 주변 아군(본인 제외)에게 버프 부여
        let buffCount = 0;
        enemies.forEach(ally => {
            if (ally !== enemy && ally.hp > 0 && !ally.isAttached) {
                const dist = Math.hypot(enemy.x - ally.x, enemy.y - ally.y);
                // 범위 350px 내의 아군
                if (dist < 350) {
                    // 이미 버프가 있거나 효과를 본 적이 없는 경우에만 부여 (개개인 1회 제한을 위해 flag 사용)
                    if (!ally.hasAbyssalResonance && !ally.usedAbyssalResonance) {
                        ally.hasAbyssalResonance = true; 
                        ally.resonanceDuration = 360;
                        buffCount++;
                        // 시각 효과 (간단한 이펙트 추가)
                        showDamageText(ally.x, ally.y, "공명", false, false, "evil-purple-text");
                    }
                }
            }
        });

        // 버프를 받은 아군이 1명이라도 있으면 효과음 등 추가 가능
        if (buffCount > 0) {
             // (선택) 효과음 재생 코드 추가
        }

        enemy.abyssalResonanceTimer = 0;
    }
}

                if (enemy.isAki) {
                    enemy.dragShotTimer += cdrSpeed;
                   if (enemy.dragShotTimer >= 600) {
        spawnDragShot(enemy.x, enemy.y, enemy.angle, enemy.accuracy, enemy);
        showPickupEffect(enemy.x, enemy.y - 40, "이리와♥", false, false, "choke-text");
        enemy.dragShotTimer = 0;
                    }

                    enemy.evilArrowTimer += cdrSpeed;
                    if (enemy.evilArrowTimer >= 660) {
        spawnEvilArrow(enemy.x, enemy.y, enemy.angle, enemy.accuracy, enemy);
        // 본체 회피 (옆으로 빠르게 대시) - 발사 직후
        const dashAngle = enemy.angle + (Math.random() < 0.5 ? Math.PI/2 : -Math.PI/2);
        enemy.dashTimer = 20; // 20프레임 동안 대시
        enemy.dashVx = Math.cos(dashAngle) * 15;
        enemy.dashVy = Math.sin(dashAngle) * 15;
        showPickupEffect(enemy.x, enemy.y - 40, "가려주마♥", false, false, "evil-purple-text");
        enemy.evilArrowTimer = 0;
                    }

                    enemy.poisonousShotTimer = (enemy.poisonousShotTimer || 0) + cdrSpeed;
                    if (enemy.poisonousShotTimer >= 480) {
        spawnPoisonousShot(enemy.x, enemy.y, enemy.angle, enemy.accuracy, enemy);
        // 본체 회피 (옆으로 빠르게 대시) - 발사 직후
        const dashAngle = enemy.angle + (Math.random() < 0.5 ? Math.PI/2 : -Math.PI/2);
        enemy.dashTimer = 20; // 20프레임 동안 대시
        enemy.dashVx = Math.cos(dashAngle) * 15;
        enemy.dashVy = Math.sin(dashAngle) * 15;
        showPickupEffect(enemy.x, enemy.y - 40, "포이즈너스 샷♥", false, false, "poop-text");
        enemy.poisonousShotTimer = 0;
                    }

                    enemy.akiSummonTimer += cdrSpeed;
                    if (enemy.akiSummonTimer >= 720) {
                        spawnMinionRapist(enemy.x + 30, enemy.y);
                        spawnMinionRapist(enemy.x - 30, enemy.y);
                        showPickupEffect(enemy.x, enemy.y - 60, "덮쳐라♥", false, false, "aki-text");
                        enemy.akiSummonTimer = 0;
                    }

                     enemy.evilKagerouTimer = (enemy.evilKagerouTimer || 0) + cdrSpeed;
                    if (enemy.evilKagerouTimer >= 1080) {
                        // 1. 제자리에 분신 생성
                        spawnAkiClone(enemy.x, enemy.y, enemy.maxHp, enemy.accuracy, enemy);
                        spawnDarkGas(enemy.x, enemy.y, 3.5, 1.2, enemy.accuracy, 0, enemy);
                        
                        // 2. 본체 회피 (옆으로 빠르게 대시)
                        const dashAngle = enemy.angle + (Math.random() < 0.5 ? Math.PI/2 : -Math.PI/2);
                        enemy.dashTimer = 20; // 20프레임 동안 대시
                        enemy.dashVx = Math.cos(dashAngle) * 15;
                        enemy.dashVy = Math.sin(dashAngle) * 15;
                        
                        // 3. Ghost 이펙트 및 텍스트
                        spawnGhost(enemy.x, enemy.y, enemy.radius, enemy.angle, akiImg, true);
                        showPickupEffect(enemy.x, enemy.y - 80, "방구 분신♥", false, true, "aki-text");
                        
                        enemy.evilKagerouTimer = 0;
                    }
                }
                
                // [신규] 히로 패턴
                if (enemy.isHiro) {
                    if (enemy.antiPassingCharging) {
                        enemy.vx = 0;
                        enemy.vy = 0;
                        spawnJusticeChargeAura(enemy, 'hiroAntiPassing');

                        enemy.antiPassingChargeTimer++;
                        enemy.antiPassingTentacleSpawnTimer = (enemy.antiPassingTentacleSpawnTimer || 0) + cdrSpeed;

                        if (enemy.antiPassingTentacleSpawnTimer >= 24) {
                            spawnAntiPassingTentacle(enemy);
                            enemy.antiPassingTentacleSpawnTimer = 0;
                        }

                        if ((enemy.antiPassingShield || 0) <= 0) {
                            enemy.antiPassingCharging = false;
                            enemy.antiPassingChargeTimer = 0;
                            enemy.antiPassingShield = 0;
                            enemy.antiPassingShieldMax = 0;
                            enemy.antiPassingTentacleSpawnTimer = 0;
                            enemy.antiPassingTimer = 0;
                            showPickupEffect(enemy.x, enemy.y - 60, "쳇..", false, true, "poop-text");
                        } else if (enemy.antiPassingChargeTimer >= (enemy.antiPassingChargeMax || 360)) {
                            enemy.antiPassingCharging = false;
                            enemy.antiPassingChargeTimer = 0;
                            enemy.antiPassingShield = 0;
                            enemy.antiPassingShieldMax = 0;
                            enemy.antiPassingTentacleSpawnTimer = 0;
                            enemy.antiPassingTimer = 0;
                            showPickupEffect(enemy.x, enemy.y - 60, "솟아라♥", false, true, "poop-text");
                        }
                    } else {
                        enemy.antiPassingTimer = (enemy.antiPassingTimer || 0) + cdrSpeed;
                        if (enemy.antiPassingTimer >= 960) {
                            enemy.antiPassingCharging = true;
                            enemy.antiPassingChargeTimer = 0;
                            enemy.antiPassingTentacleSpawnTimer = 0;
                            enemy.antiPassingShieldMax = Math.max(1, Math.floor(enemy.maxHp * 0.25));
                            enemy.antiPassingShield = enemy.antiPassingShieldMax;
                            enemy.antiPassingTimer = 0;
                            showPickupEffect(enemy.x, enemy.y - 65, "솟아라♥♥", false, true, "poop-text");
                        }

                        // 재밍 신호
                        enemy.jammingTimer = (enemy.jammingTimer || 0) + cdrSpeed;
                        if (enemy.jammingTimer >= 420) {
            const angle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
            spawnJammingWave(enemy.x, enemy.y, angle, enemy.accuracy, enemy); // [수정]
            showPickupEffect(enemy.x, enemy.y - 50, "치지직..", false, false, "evil-purple-text");
                            enemy.jammingTimer = 0;
                        }

                        // 신경 독바늘 (5갈래)
                        enemy.needleTimer = (enemy.needleTimer || 0) + cdrSpeed;
                       if (enemy.needleTimer >= 240) {
            const baseAngle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
            for (let k = -2; k <= 2; k++) {
                const angle = baseAngle + (k * 0.08);
                spawnNeuroNeedle(enemy.x, enemy.y, angle, enemy.accuracy, enemy); // [수정]
            }
            showPickupEffect(enemy.x, enemy.y - 40, "마비돼라!", false, false, "paralysis-border");
            enemy.needleTimer = 0;
                        }

                        if (enemy.blackHolyBloodTimer > 0) {
                        enemy.blackHolyBloodTimer--;
                    } else {
                        // 스킬 발사!
                        spawnBlackHolyBlood(enemy.x, enemy.y, enemy.accuracy, enemy);
                        enemy.blackHolyBloodTimer = 720; // 쿨타임 12초 리셋
                    }

                        // 공작원 소환 (8초마다)
                        enemy.hiroSummonTimer = (enemy.hiroSummonTimer || 0) + cdrSpeed;
                        if (enemy.hiroSummonTimer >= 480) {
                            for(let k=0; k<2; k++) {
                                const spawnX = enemy.x + (Math.random() - 0.5) * 100;
                                const spawnY = enemy.y + (Math.random() - 0.5) * 100;

                                // 랜덤 공작원 타입 결정
                                const rand = Math.random();
                                let aType = 'blind';
                                if (rand < 0.33) aType = 'curse';
                                else if (rand < 0.66) aType = 'pain';

                                // spawnEnemy 함수를 변형하여 공작원 직접 생성
                                // 여기서는 직접 객체를 만들어 푸시하는게 안전함
                                let hp = 113; // 45 * 2.5
                                let defense = 1;
                                hp = getEnemySpawnHp(hp);
const agent = {
                                    x: spawnX, y: spawnY, radius: 35, baseRadius: 35,
                                    baseSpeed: (0.6 + Math.random() * 0.6) * 1.5, speed: 0, vx: 0, vy: 0,
                                    accuracy: 0, evasion: 0.05,
                                    critChance: 25, critResist: 15,
                                    gasTimer: Math.random() * 240, gasInterval: 240, bigPoopTimer: 0, scatterTimer: 0, whiteShotTimer: 0,
                                    angle: 0, isElite: false, isZako: false, isAgent: true, agentType: aType,
                                    maxHp: hp, hp: hp, defense: defense,
                                    hitFlash: 0, erectionStacks: 0, erectionTimer: 0, passiveErectionTimer: 0, contactStackTimer: 0,
                                    buffType: -1, eliteType: -1, alpha: 1.0, dashTimer: 0, dashVx: 0, dashVy: 0,
                                    agentDeathTimer: 900, stunTimer: 0
                                };
                                agent.speed = agent.baseSpeed;
                                enemies.push(agent);
                            }
                            showPickupEffect(enemy.x, enemy.y - 60, "처리해라.", false, false, "hiro-text");
                            enemy.hiroSummonTimer = 0;
                        }
                    }
                }
                
                if (enemy.isKai) {
                    // 1. 그림자 망토 (패시브): 6초마다 1초 투명
                    enemy.shadowCloakTimer += cdrSpeed;
                    if (enemy.isInvisible) {
                        enemy.alpha = 0.2; // 투명화
                        enemy.invisibleDuration--;
                        if (enemy.invisibleDuration <= 0) {
                            enemy.isInvisible = false;
                            enemy.alpha = 1.0;
                            showPickupEffect(enemy.x, enemy.y - 40, "모습을 드러냈다", false);
                        }
                    } else {
                        if (enemy.shadowCloakTimer >= 360) { // 6초 (60fps 기준)
                            enemy.isInvisible = true;
                            enemy.invisibleDuration = 60; // 1초
                            enemy.shadowCloakTimer = 0;
                            showPickupEffect(enemy.x, enemy.y - 40, "그림자 망토", false, false, "shadow-text");
                        }
                    }

                    // [신규] 소울 링크 스킬 로직
            if (enemy.soulLinkTarget) {
                if (enemy.soulLinkDuration > 0) enemy.soulLinkDuration--;
                // 연결된 대상이 죽었거나 사라지면 링크 해제
                if (enemy.soulLinkTarget.hp <= 0 || !enemies.includes(enemy.soulLinkTarget) || enemy.soulLinkTarget.isAttached) {
                    enemy.soulLinkTarget = null;
                    enemy.soulLinkCooldown = 900;
                    showDamageText(enemy.x, enemy.y, "링크 파괴!", false, false, "weak-text");
                } else {
                    // 연결된 동안 지속 회복 (120프레임마다)
                    enemy.soulLinkHealTimer += cdrSpeed;
                    if (enemy.soulLinkHealTimer >= 120) {
                        // 기본 10 + 점수(시간)에 따른 추가 회복
                        let heal = 5 + Math.floor(score * 0.05);
                        enemy.hp = Math.min(enemy.maxHp, enemy.hp + heal);
                        showDamageText(enemy.x, enemy.y, "+" + heal, false, false, "heal-text");
                        enemy.soulLinkHealTimer = 0;
                    }
                }
          } else {
                // 쿨타임 감소
                if (enemy.soulLinkCooldown > 0) {
                    enemy.soulLinkCooldown--;
                } else {
                    // 쿨타임 종료 시 타겟 탐색 (엘리트/보스 제외, 살아있는 아군, [추가] 부착되지 않은 적)
                    const candidates = enemies.filter(e => 
                        !e.isElite && 
                        !e.isBoss && 
                        e !== enemy && 
                        e.hp > 0 && 
                        !e.isAttached
                    );

                    if (candidates.length > 0) {
                        // 랜덤 타겟 선정
                        enemy.soulLinkTarget = candidates[Math.floor(Math.random() * candidates.length)];
                        enemy.soulLinkDuration = 420;
                        enemy.soulLinkHealTimer = 0;
                        showPickupEffect(enemy.x, enemy.y - 60, "소울 링크!", false, true, "evil-purple-text");
                    }
                }
            }

                    // 2. 카오스 오브 (8초 쿨타임)
                    enemy.chaosOrbTimer += cdrSpeed;
                    if (enemy.chaosOrbTimer >= 480) {
        spawnChaosOrb(enemy.x, enemy.y, enemy.accuracy, enemy); // [수정]
        showPickupEffect(enemy.x, enemy.y - 50, "가려주마♥", false, false, "evil-purple-text");
        enemy.chaosOrbTimer = 0;
    }

                    // 3.5 공허의 금서 (20초 쿨타임)
                    enemy.voidGrimoireTimer = (enemy.voidGrimoireTimer || 0) + (enemy.voidGrimoireBuff || 1.0);
                    if (enemy.voidGrimoireTimer >= (enemy.voidGrimoireCooldown || 1200)) {
                        const gx = 120 + Math.random() * (canvas.width - 240);
                        const gy = 120 + Math.random() * (canvas.height - 240);
                        spawnVoidGrimoire(gx, gy, enemy.accuracy, enemy);
                        showPickupEffect(enemy.x, enemy.y - 70, "공허의 금서", false, true, "evil-purple-text");
                        enemy.voidGrimoireTimer = 0;
                    }

                    // 3. 그림자 스왑 (15초 쿨타임) - 4초 차지 + 보호막(최대HP 30%), 보호막 파괴 시 취소
                    if (enemy.shadowSwapCharging) {
                        // 차지 중에는 이동 멈춤
                        enemy.vx = 0; enemy.vy = 0;

                        // 류온 정의의 돌진 차지 이펙트 재사용(핑크 테마)
                        spawnJusticeChargeAura(enemy, 'kaiSwap');

                        enemy.shadowSwapChargeTimer++;

                        // 보호막이 깨졌으면 즉시 취소
                        if ((enemy.shadowSwapShield || 0) <= 0) {
                            enemy.shadowSwapCharging = false;
                            enemy.shadowSwapChargeTimer = 0;
                            enemy.shadowSwapShield = 0;
                            enemy.shadowSwapShieldMax = 0;

                            // 쿨타임은 다시 시작
                            enemy.shadowSwapTimer = 0;

                            showPickupEffect(enemy.x, enemy.y - 60, "보호막 파괴! 스왑 취소", false, true, "dirty-pink-text");
                        }
                        // 차지 완료 -> 원래 그림자 스왑 발동
                        else if (enemy.shadowSwapChargeTimer >= (enemy.shadowSwapChargeMax || 240)) {
                            const oldPlayerX = player.x;
                            const oldPlayerY = player.y;

                            // 위치 교환
                            player.x = enemy.x;
                            player.y = enemy.y;
                            enemy.x = oldPlayerX;
                            enemy.y = oldPlayerY;

                            spawnDarkGas(player.x, player.y, 4, 1.0, enemy.accuracy, 0, enemy);

                            // 정신착란 디버프 부여 (5초)
                            addStatus('confusion', 300, 1);
                            showPickupEffect(player.x, player.y, "위치 교환! (정신착란)", false, true, "confusion-border");

                            // 정리
                            enemy.shadowSwapCharging = false;
                            enemy.shadowSwapChargeTimer = 0;
                            enemy.shadowSwapShield = 0;
                            enemy.shadowSwapShieldMax = 0;
                            enemy.shadowSwapTimer = 0;
                        }
                    } else {
                        enemy.shadowSwapTimer += cdrSpeed;
                        if (enemy.shadowSwapTimer >= 900) {
                            // 차지 시작
                            enemy.shadowSwapCharging = true;
                            enemy.shadowSwapChargeTimer = 0;
                            enemy.shadowSwapChargeMax = 240; // 4초(60fps)
                            enemy.shadowSwapShieldMax = Math.max(1, Math.floor(enemy.maxHp * 0.25));
                            enemy.shadowSwapShield = enemy.shadowSwapShieldMax;

                            // 쿨타임은 차지 시작 시 리셋(취소/발동 후 다시 15초)
                            enemy.shadowSwapTimer = 0;

                            showPickupEffect(enemy.x, enemy.y - 60, "그림자 스왑 차지...", false, true, "dirty-pink-text");
                        }
                    }
                }
                
                if (enemy.isJacques) {
                // 1. 사악한 아드레날린
                enemy.jacquesAdrenalineTimer += cdrSpeed;
                if (enemy.jacquesAdrenalineTimer >= 480) {
                    let target = null;
                    let minDist = 99999;
                    // 가장 가까운 강간범 or 소환사 찾기
                    enemies.forEach(ally => {
                        if (ally !== enemy && (ally.normalType === 'rapist' || ally.normalType === 'summoner')) {
                            const d = Math.hypot(enemy.x - ally.x, enemy.y - ally.y);
                            if (d < minDist) { minDist = d; target = ally; }
                        }
                    });

                    if (target) {
                        // 버프 부여: 크기 1.5배, 이속 1.5배, 슈퍼아머
                        target.radius *= 1.5;
                        target.baseSpeed *= 1.5;
                        target.speed *= 1.5;
                        target.isSuperArmor = true; // 넉백 면역 플래그 (넉백 로직 수정 필요)
                        enemy.jacquesAdrenalineTimer = 0;
                        showPickupEffect(target.x, target.y - 40, "아드레날린!!", false, true, "berserk-border");
                    }
                }

                // 2. 최음 가스
                enemy.jacquesGasTimer += cdrSpeed;
                if (enemy.jacquesGasTimer >= 600) {
                    spawnPinkGas(enemy.x, enemy.y);
                    showPickupEffect(enemy.x, enemy.y - 40, "향긋하지?♥", false, false, "pink-text");
                    enemy.jacquesGasTimer = 0;
                }

                // 3. 어둠의 찬가
                enemy.jacquesHymnTimer += cdrSpeed;
                if (enemy.jacquesHymnTimer >= 240) {
                    spawnDarkNote(enemy.x, enemy.y, enemy);
                    enemy.jacquesHymnTimer = 0;
                }
                    if (enemy.pianissimoTimer > 0) {
                       enemy.pianissimoTimer--;
        } else {
        // 12초 쿨타임 (60fps * 12 = 720)
        enemy.pianissimoTimer = 720; 
        
        // 랜덤 장소 3곳에 높은음자리표 소환
        for(let k=0; k<3; k++) {
            const rx = 50 + Math.random() * (canvas.width - 100);
            const ry = 50 + Math.random() * (canvas.height - 100);
            spawnPianissimoSnipe(rx, ry, 0, enemy.accuracy, enemy);
        }
        showPickupEffect(enemy.x, enemy.y - 60, "어둠의 선율..", false, true, "evil-purple-text");
    }
 }
               
               // [신규] 검은 민족 마사쿠니 패턴
                if (enemy.isMasakuni) {
                    // 스킬 사용 중이 아닐 때만 평타 이동 (가스 추진 대쉬) 실행
                    const isUsingSkill = (enemy.flashState !== 'idle') || (enemy.blackMoonState !== 'idle');

                    if (!isUsingSkill) {
                        // 가스 추진 이동 로직
                        if (enemy.moveDashDuration > 0) {
                            // 대쉬 중
                            enemy.x += enemy.dashVx;
                            enemy.y += enemy.dashVy;
                            enemy.moveDashDuration--;
                            
                            // 감속 (마찰력)
                            enemy.dashVx *= 0.95;
                            enemy.dashVy *= 0.95;

                            // 시각 효과: 이동 잔상
                            if (frameCount % 5 === 0) {
                                spawnGhost(enemy.x, enemy.y, enemy.radius, Math.atan2(enemy.dashVy, enemy.dashVx) + Math.PI/2, masakuniImg, true);
                            }
                        } else {
                            // 대쉬 대기 중
                            enemy.vx = 0; enemy.vy = 0;
                            enemy.moveDashTimer += cdrSpeed;
                            
                            // 쿨타임이 차면 플레이어 방향으로 발사
                            if (enemy.moveDashTimer >= enemy.moveDashCooldown) {
                                const angle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
                                const thrustSpeed = 20; // 순간 속도
                                enemy.dashVx = Math.cos(angle) * thrustSpeed;
                                enemy.dashVy = Math.sin(angle) * thrustSpeed;
                                enemy.moveDashDuration = 38;
                                enemy.moveDashTimer = 0;
                                
                                // 추진 이펙트 (검은 연기)
                                spawnDarkGas(enemy.x, enemy.y, 3.5, 0.5, enemy.accuracy, 0, enemy);
                                showPickupEffect(enemy.x, enemy.y - 40, "스텝", false, false, "weak-text");
                            }
                        }
                    }

                    // 1. 일섬 (Flash): 가웨인 돌진 로직 (벽까지 돌진)
                    if (enemy.flashState === 'idle') {
                        enemy.flashTimer += cdrSpeed;
                        if (enemy.flashTimer >= enemy.flashCooldown) {
                            enemy.flashState = 'warmup';
                            enemy.flashTimer = 0;
                            showPickupEffect(enemy.x, enemy.y - 60, "일섬 자세..", false, false, "masakuni-text");
                        }
                    } else if (enemy.flashState === 'warmup') {
                        enemy.vx = 0; enemy.vy = 0; // 정지
                        enemy.moveDashDuration = 0; // 이동 캔슬
                        enemy.flashTimer += cdrSpeed;
                        
                        // 준비 동작 중 플레이어 조준
                        enemy.flashAngle = Math.atan2(player.y - enemy.y, player.x - enemy.x);

                        if (enemy.flashTimer > 90) {
                            enemy.flashState = 'dashing';
                            enemy.flashTimer = 0;
                            enemy.hasHitFlash = false; // 타격 플래그 초기화
                            showPickupEffect(enemy.x, enemy.y - 60, "일섬!!", false, true, "masakuni-text");
                        }
                    } else if (enemy.flashState === 'dashing') {
                        // 벽에 닿을 때까지 고속 이동
                        const speed = 20;
                        enemy.x += Math.cos(enemy.flashAngle) * speed;
                        enemy.y += Math.sin(enemy.flashAngle) * speed;

                        // 잔상 효과 (짙게)
                        if (frameCount % 2 === 0) {
                            spawnGhost(enemy.x, enemy.y, enemy.radius, enemy.flashAngle + Math.PI/2, masakuniImg, true);
                        }

                        // 플레이어 충돌 체크 (스치기만 해도 베임)
                        if (!enemy.hasHitFlash) {
        const dx = player.x - enemy.x;
        const dy = player.y - enemy.y;
        const distSq = dx * dx + dy * dy;
        // 판정 범위: 플레이어 반지름 + 적 반지름 + 30
        const hitRange = player.radius + enemy.radius + 30;

        if (distSq < hitRange * hitRange) {
            if (player.invincibleTimer <= 0) {
                let dmg = 40 + Math.floor(score * 0.23);
                if (enemy.nextAttackCrit) {
                    dmg *= 1.5;
                    enemy.nextAttackCrit = false;
                    showPickupEffect(player.x, player.y, "심안 치명타!!", false, true, "masakuni-text");
                }
                takeDamage(dmg, 'direct', enemy.accuracy, enemy);
                // 출혈 5중첩
                for(let k=0; k<5; k++) { addStatus('bleeding', 600, 20); }
                showPickupEffect(player.x, player.y, "베였다!", false, true, "bleeding-border");
                
                enemy.hasHitFlash = true; // 한 번만 타격
            }
        }
    }

                        // 벽 충돌 체크 (화면 밖으로 나가면 종료)
                        let hitWall = false;
                        if (enemy.x < -100 || enemy.x > canvas.width + 100 || enemy.y < -100 || enemy.y > canvas.height + 100) {
                            hitWall = true;
                        }
                // [v16] 초반 유예 프레임이 남아있으면 벽 판정 무시
                if ((enemy.cruelChargeWallGrace || 0) > 0) {
                    enemy.cruelChargeWallGrace--;
                    hitWall = false;
                }

                if (hitWall) {
                            enemy.flashState = 'idle';
                            enemy.flashTimer = 0;
                            
                            // 맵 안쪽으로 살짝 복귀 (다음 패턴 위해)
                            enemy.x = Math.max(50, Math.min(canvas.width - 50, enemy.x));
                            enemy.y = Math.max(50, Math.min(canvas.height - 50, enemy.y));
                        }
                    }

                    // [스킬 2] 흑월 (Black Moon) - 리메이크 적용
    if (enemy.blackMoonState === 'idle') {
        enemy.blackMoonTimer += cdrSpeed;
        if (enemy.blackMoonTimer >= enemy.blackMoonCooldown) {
            // 쿨타임(10초) 되면 발동
            spawnBlackMoon(enemy.x, enemy.y, enemy.accuracy, enemy);
            
            // 타이머 리셋
            enemy.blackMoonTimer = 0; 
            
            // 시전 대사
            showPickupEffect(enemy.x, enemy.y - 60, "어둠의 달이여..", false, true, "masakuni-text");
        }
    }

                    // 3. 환영검 (Phantom Sword)
                    if (!enemy.phantomSwordsActive) {
                        enemy.phantomSwordCooldown--;
                        if (enemy.phantomSwordCooldown <= 0) {
                            enemy.phantomSwordsActive = true;
                            for(let k=0; k<3; k++) {
                                phantomSwords.push({
                                    owner: enemy,
                                    index: k,
                                    state: 'hover',
                                    x: enemy.x,
                                    y: enemy.y,
                                    angle: 0,
                                    life: 600,
                                    size: 1.35
                                });
                            }
                            showPickupEffect(enemy.x, enemy.y - 60, "환영검", false, false, "masakuni-text");
                            enemy.phantomSwordCooldown = 900;
                        }
                    }
                }
               
               // [신규] 검은 민족 카이토 패턴
                if (enemy.isKaito) {
                    // [패시브] 검은 계약: 체력 30% 이하일 때 쿨타임 감소
                    let cdReduction = 1.0;
                    if (enemy.hp <= enemy.maxHp * 0.3) {
                        cdReduction = 2.0; // 쿨타임 감소 속도 2배 (즉 50% 감소)
                        if (frameCount % 60 === 0) showDamageText(enemy.x, enemy.y, "검은 계약", false, false, "corrupted-text");
                    }

                    // [신규] 5초마다 1초간 은신 패턴
            enemy.kaitoStealthTimer = (enemy.kaitoStealthTimer || 0) + cdrSpeed;
            if (enemy.kaitoStealthTimer >= 300) { // 5초(300프레임) 대기 후
                enemy.isKaitoStealth = true;
                enemy.alpha = 0.2; // 반투명 처리
                
                if (enemy.kaitoStealthTimer >= 360) { // 1초(60프레임) 지속 후 해제
                    enemy.kaitoStealthTimer = 0;
                    enemy.isKaitoStealth = false;
                    enemy.alpha = 1.0; // 투명도 복구
                    showPickupEffect(enemy.x, enemy.y - 40, "숨어서 뿌우욱♥", false);
                }
            }

                    // 1. 네더 그랩 (Nether Grab)
                   if (enemy.netherGrabActive) {
        enemy.netherGrabDuration--;
        player.netherGrabbedBy = enemy; 

        // [수정] 데스 그립과 동일한 "거리 제한" 방식: 멀어지려고 하면 카이토 쪽으로 끌려옴
        const dist = Math.hypot(player.x - enemy.x, player.y - enemy.y);
        const maxDist = 330; // 네더 그랩 사슬 길이 (원하면 숫자만 조절)

        if (dist > maxDist) {
            const angle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
            player.x = enemy.x + Math.cos(angle) * maxDist;
            player.y = enemy.y + Math.sin(angle) * maxDist;
        }

        // 데미지 틱 (기존 유지)
        enemy.netherGrabDamageTick = (enemy.netherGrabDamageTick || 0) + 1;
        if (enemy.netherGrabDamageTick >= 60) {
            let dmg = 5 + Math.floor(score * 0.08);
            takeDamage(dmg, 'direct', enemy.accuracy, enemy);
            enemy.netherGrabDamageTick = 0;
        }

        if (enemy.netherGrabDuration <= 0) {
            enemy.netherGrabActive = false;
            player.netherGrabbedBy = null;
            enemy.netherGrabCooldown = 960;
        }
                    } else {
                        enemy.netherGrabCooldown -= cdReduction;
                        if (enemy.netherGrabCooldown <= 0) {
                            enemy.netherGrabActive = true;
                            enemy.netherGrabDuration = 480; // 8초
                            showPickupEffect(enemy.x, enemy.y - 60, "네더 그랩!", false, true, "evil-purple-text");
                        }
                    }

                    // 2. 보이드 워프 (Void Warp) - 네더 그랩 중이 아닐 때만 사용
    if (!enemy.netherGrabActive) {
    enemy.voidWarpCooldown -= cdReduction;
    if (enemy.voidWarpCooldown <= 0) {
        // 이동 전 위치에 가스
        spawnDarkGas(enemy.x, enemy.y, 4.0, 1.0, enemy.accuracy, 0, enemy);

        const warpDist = 450;
        const awayAngle = Math.atan2(enemy.y - player.y, enemy.x - player.x);
        let targetX = player.x + Math.cos(awayAngle) * warpDist;
        let targetY = player.y + Math.sin(awayAngle) * warpDist;

        // 맵 밖으로 안 나가게 보정
        targetX = Math.max(50, Math.min(canvas.width - 50, targetX));
        targetY = Math.max(50, Math.min(canvas.height - 50, targetY));
        
        enemy.x = targetX;
        enemy.y = targetY;

        // 이동 후 위치에 가스 및 이펙트
        spawnDarkGas(enemy.x, enemy.y, 4.0, 1.0, enemy.accuracy, 0, enemy);
        showPickupEffect(enemy.x, enemy.y - 40, "백어택 워프!", false, true, "evil-purple-text"); // 텍스트 변경 (선택사항)
        
        enemy.voidWarpCooldown = 180; // 3초
    }
}

                    // 3. 다크 매터 (Dark Matter)
                    enemy.darkMatterCooldown -= cdReduction;
                    if (enemy.darkMatterCooldown <= 0) {
                        spawnDarkMatter(enemy.x, enemy.y, enemy);
                        enemy.darkMatterCooldown = 1080; // 18초
                    }

                    // 4. 컨페셔너 (Confessional)
                    enemy.confessionalCooldown -= cdReduction;
                    if (enemy.confessionalCooldown <= 0) {
                        // 맵 랜덤 위치
                        const tx = 50 + Math.random() * (canvas.width - 100);
                        const ty = 50 + Math.random() * (canvas.height - 100);
                        spawnConfessionalTotem(tx, ty, enemy.accuracy, enemy);
                        enemy.confessionalCooldown = 960; // 16초
                    }

                    // 기본 이동 AI (카이팅: 거리 320 유지)
                    const distToPlayer = Math.hypot(player.x - enemy.x, player.y - enemy.y);
                    const angle = Math.atan2(player.y - enemy.y, player.x - enemy.x);

                    if (!enemy.netherGrabActive) {
                        delete enemy.strafeDir;
                        if (distToPlayer < 300) { // 너무 가까우면 후퇴
                            enemy.vx = -Math.cos(angle) * enemy.speed;
                            enemy.vy = -Math.sin(angle) * enemy.speed;
                        } else if (distToPlayer > 340) { // 너무 멀면 접근
                            enemy.vx = Math.cos(angle) * enemy.speed;
                            enemy.vy = Math.sin(angle) * enemy.speed;
                        } else {
                            // 적당한 거리면 주변 배회
                            enemy.vx = Math.cos(angle + Math.PI/2) * enemy.speed;
                            enemy.vy = Math.sin(angle + Math.PI/2) * enemy.speed;
                        }
                        enemy.x += enemy.vx;
                        enemy.y += enemy.vy;
                    } else {
                        // [수정] 네더 그랩 중: 700px까지는 도주, 그 이상이면 횡이동(원형 카이팅)
                        const runSpeed = enemy.speed * 1.25;
                        const strafeSpeed = enemy.speed * 0.95;

                        if (distToPlayer < 700) {
                            // 플레이어 반대 방향으로 도주
                            enemy.vx = -Math.cos(angle) * runSpeed;
                            enemy.vy = -Math.sin(angle) * runSpeed;
                        } else {
                            // 700px 이상이면 횡이동(플레이어 둘레 회전)
                            if (enemy.strafeDir !== 1 && enemy.strafeDir !== -1) {
                                enemy.strafeDir = (Math.random() < 0.5) ? 1 : -1;
                            }

                            enemy.vx = Math.cos(angle + enemy.strafeDir * Math.PI / 2) * strafeSpeed;
                            enemy.vy = Math.sin(angle + enemy.strafeDir * Math.PI / 2) * strafeSpeed;

                            // 너무 멀어지면(760px 이상) 살짝만 안쪽으로 보정
                            if (distToPlayer > 760) {
                                enemy.vx += Math.cos(angle) * (enemy.speed * 0.20);
                                enemy.vy += Math.sin(angle) * (enemy.speed * 0.20);
                            }
                        }

                        enemy.x += enemy.vx;
                        enemy.y += enemy.vy;

                        // 맵 밖으로 안 나가게 보정
                        enemy.x = Math.max(50, Math.min(canvas.width - 50, enemy.x));
                        enemy.y = Math.max(50, Math.min(canvas.height - 50, enemy.y));
                    }
                }

           // [신규] 검은 민족 퀘스타 패턴 (수정됨: 상태 머신 적용)
if (enemy.isQuesta) {
    // ----------------------------------------------------
    // [패시브] 칠흑의 장막 효과 (회피율 증가) - 기존 유지
    // ----------------------------------------------------
    if (enemy.isVeiled) {
        enemy.veilDuration--;
        enemy.evasion = enemy.baseEvasion + 0.20; // 기본 20 + 20 = 40%
        if (enemy.veilDuration <= 0) {
            enemy.isVeiled = false;
            showDamageText(enemy.x, enemy.y, "장막 해제", false, false, "weak-text");
        }
    } else {
        enemy.evasion = enemy.baseEvasion;
        enemy.veilTimer += cdrSpeed;
        if (enemy.veilTimer >= enemy.veilCooldown) {
            enemy.isVeiled = true;
            enemy.veilDuration = 600; // 10초
            enemy.veilTimer = 0;
            showPickupEffect(enemy.x, enemy.y - 60, "칠흑의 장막!", false, true, "shadow-text");
        }
    }

    // 스킬 사용 중인지 체크 (상태 머신 이동보다 우선순위 높음)
    const isUsingSkill = enemy.isFlickering || enemy.boneCrusherState !== 'idle';

    if (!isUsingSkill) {
        // ----------------------------------------------------
        // [이동 AI 변경] 자코(덮치기범) 스타일 상태 머신 적용
        // ----------------------------------------------------
        const dx = player.x - enemy.x;
        const dy = player.y - enemy.y;
        const dist = Math.hypot(dx, dy);

        // 1. [IDLE] 접근: 멀리서는 천천히 다가옴
        if (enemy.state === 'idle') {
            // 플레이어 방향으로 천천히 이동 (속도 2.0)
            enemy.vx = (dx / dist) * 2.0;
            enemy.vy = (dy / dist) * 2.0;
            
            enemy.x += enemy.vx;
            enemy.y += enemy.vy;

            // 거리가 350 미만으로 좁혀지면 공격 준비 태세
            if (dist < 350) {
                enemy.state = 'warmup';
                enemy.actionTimer = 30; // 30프레임(약 0.5초) 경고
            }
        } 
        // 2. [WARMUP] 공격 준비: 멈춰서 경고
        else if (enemy.state === 'warmup') {
            enemy.actionTimer--;
            // 이동 멈춤
            enemy.vx = 0;
            enemy.vy = 0;
            
            // 시각적 효과가 필요하다면 drawEnemies에서 처리하거나 여기서 이펙트 호출

            if (enemy.actionTimer <= 0) {
                // 준비 끝, 돌진 방향 확정 및 상태 전환
                enemy.state = 'dashing';
                enemy.actionTimer = 40; // 40프레임 동안 돌진
                enemy.dashDir = { x: dx / dist, y: dy / dist }; // 현재 플레이어 위치로 방향 고정
            }
        }
        // 3. [DASHING] 돌진: 고정된 방향으로 빠르게 이동
        else if (enemy.state === 'dashing') {
            enemy.actionTimer--;
            
            // 속도 8.0으로 돌진
            const dashSpeed = 8.0; 
            enemy.vx = enemy.dashDir.x * dashSpeed;
            enemy.vy = enemy.dashDir.y * dashSpeed;
            
            enemy.x += enemy.vx;
            enemy.y += enemy.vy;

            if (enemy.actionTimer <= 0) {
                enemy.state = 'cooldown';
                enemy.actionTimer = 90; // 90프레임(약 1.5초) 동안 휴식
            }
        }
        // 4. [COOLDOWN] 휴식: 제자리 멈춤
        else if (enemy.state === 'cooldown') {
            enemy.actionTimer--;
            enemy.vx = 0;
            enemy.vy = 0;

            if (enemy.actionTimer <= 0) {
                enemy.state = 'idle'; // 다시 접근 상태로 복귀
            }
        }
        // 예외 처리: state가 없는 경우(구버전 객체 등) idle로 초기화
        else {
            enemy.state = 'idle';
        }

        // ----------------------------------------------------
        // [스킬 쿨타임 관리] - 이동 로직과 병렬로 쿨타임은 계속 돔
        // ----------------------------------------------------

        // [스킬 1] 그림자 손아귀 (12초)
        enemy.shadowGripTimer += cdrSpeed;
        if (enemy.shadowGripTimer >= enemy.shadowGripCooldown) {
            spawnShadowGrip(enemy.x, enemy.y, enemy);
            enemy.shadowGripTimer = 0;
        }

        // [스킬 2] 다크 플리커 (6초)
        enemy.flickerTimer += cdrSpeed;
        if (enemy.flickerTimer >= enemy.flickerCooldown) {
            enemy.isFlickering = true;
            enemy.flickerCount = 0;
            enemy.flickerStepTimer = 0;
            enemy.flickerTimer = 0;
            // 스킬 시작 시 상태 초기화 (이동 AI 간섭 방지)
            enemy.state = 'idle'; 
            showPickupEffect(enemy.x, enemy.y - 60, "븃븃븃♥", false, true, "masakuni-text");
        }

        // [스킬 4] 본 크러셔 (18초)
        enemy.boneCrusherTimer += cdrSpeed;
        if (enemy.boneCrusherTimer >= enemy.boneCrusherCooldown) {
            enemy.boneCrusherState = 'charging';
            enemy.boneCrusherChargeTimer = 120; // 2초 차지
            enemy.boneCrusherTimer = 0;
            enemy.state = 'idle';
            enemy.boneCrusherVictim = false;
            showPickupEffect(enemy.x, enemy.y - 60, "확실한 임신♥", false, true, "wicked-large-text");
        }

    } 
    // ----------------------------------------------------
    // [스킬 실행 중 로직] - 이동 AI 대신 스킬 동작 수행
    // ----------------------------------------------------
    else {
        if (enemy.isFlickering) {
            // 1. [차지 단계] 0~45프레임 (0.75초) 제자리 대기
            if (enemy.flickerStepTimer < 45) {
                enemy.vx = 0; 
                enemy.vy = 0;
            }
            // 2. [발사 준비] 45프레임 시점에 방향 및 속도 결정
            else if (enemy.flickerStepTimer === 45) {
                const angle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
                const flickerSpeed = 13;
                enemy.dashVx = Math.cos(angle) * flickerSpeed;
                enemy.dashVy = Math.sin(angle) * flickerSpeed;
                // 데스 클라우드 및 이펙트
                spawnDeathCloud(enemy.x, enemy.y, enemy.isElite, enemy.isBoss, enemy.accuracy, enemy);
            }
            // 3. [돌진 단계] 45프레임 이후 실제 이동
            else {
                enemy.x += enemy.dashVx;
                enemy.y += enemy.dashVy;

                // 돌진 중 15프레임마다 데스 클라우드 생성
                if (enemy.flickerStepTimer % 15 === 0) {
                    spawnDeathCloud(enemy.x, enemy.y, enemy.isElite, enemy.isBoss, enemy.accuracy, enemy);
                }
            }

            enemy.flickerStepTimer += cdrSpeed;

            // 피격 쿨타임 감소
            if (enemy.flickerHitCooldown > 0) enemy.flickerHitCooldown--;

            // [최적화] 충돌 체크 (플리커) - 제곱 거리 사용
            // 공격 가능 상태(돌진 중, 쿨타임 없음)일 때만 거리 계산
            if (enemy.flickerStepTimer > 45 && enemy.flickerHitCooldown <= 0) {
                const dx = player.x - enemy.x;
                const dy = player.y - enemy.y;
                const distSq = dx * dx + dy * dy;
                const hitRadius = player.radius + enemy.radius;
                
                // 제곱 거리 비교
                if (distSq < hitRadius * hitRadius) {
                    if (player.invincibleTimer <= 0) {
                        let dmg = 15 + Math.floor(score * 0.15);
                        takeDamage(dmg, 'direct', enemy.accuracy, enemy);
                        
                        // 피격 시 0.5초간 해당 스킬 면역 (연타 방지)
                        enemy.flickerHitCooldown = 30;
                        
                        // 골절 부여
                        for(let k = 0; k < 2; k++) {
                            player.fractureTimers.push(1200); 
                        }
                        updateStatusUI();
                        showPickupEffect(player.x, player.y, "골절!", false, true, "fracture-border");
                        
                        // 패시브: 새디즘 체크
                    const sadismCritResist = getEffectiveDefenderCritResist();
                    if (sadismCritResist <= SADISM_CRITRESIST_THRESHOLD) {
                            let heal = Math.floor(dmg * SADISM_LIFESTEAL_RATIO);
                            enemy.hp = Math.min(enemy.maxHp, enemy.hp + heal);
                            showDamageText(enemy.x, enemy.y, "새디즘 +" + heal, false, false, "heal-text");
                        
                            activateSadismGas(enemy);
}
                    }
                }
            }

            // 4. [단계 종료] 65프레임 지나면 다음 돌진 준비
            if (enemy.flickerStepTimer > 65) { 
                enemy.flickerCount++;        // 돌진 횟수 증가
                enemy.flickerStepTimer = 0;  // 타이머 초기화 (다시 차지부터 시작)
                enemy.dashVx = 0; 
                enemy.dashVy = 0;
                
                // 총 3회 돌진 후 스킬 완전 종료
                if (enemy.flickerCount >= 3) {
                    enemy.isFlickering = false;
                    enemy.flickerCount = 0;  
                    // 스킬 끝나면 잠시 휴식 상태로 전환 (자연스러운 연결)
                    enemy.state = 'cooldown';
                    enemy.actionTimer = 30;
                }
            }
        }

        // [본 크러셔 실행]
        if (enemy.boneCrusherState === 'charging') {
            enemy.boneCrusherChargeTimer--;
            // 차지 중 플레이어 방향 바라보기 (조준)
            enemy.boneCrusherAngle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
            if (enemy.boneCrusherChargeTimer <= 0) {
                enemy.boneCrusherState = 'rushing';
                showPickupEffect(enemy.x, enemy.y - 60, "본 크러셔!!", false, true, "corrupted-text");
            }
       } else if (enemy.boneCrusherState === 'rushing') {
            const speed = 22;
            enemy.x += Math.cos(enemy.boneCrusherAngle) * speed;
            enemy.y += Math.sin(enemy.boneCrusherAngle) * speed;

            // [이펙트] 지나간 자리에 2배 크기 다크가스 (기존 유지)
            if (frameCount % 5 === 0) {
                spawnDarkGas(enemy.x, enemy.y, 2.0, 1.0, enemy.accuracy, 0, enemy);
            }

            // =========================================================
            // [신규 로직 1] 플레이어 드래그 (잡혔을 경우 위치 고정)
            // =========================================================
            if (enemy.boneCrusherVictim) {
                player.x = enemy.x;
                player.y = enemy.y;
            }

            // =========================================================
            // [신규 로직 2] 플레이어 충돌 체크 (데미지 대신 잡기 판정)
            // =========================================================
            // 아직 잡히지 않은 상태에서만 충돌 체크
            if (!enemy.boneCrusherVictim) {
                const dist = Math.hypot(player.x - enemy.x, player.y - enemy.y);
                // 충돌 범위 체크
                if (dist < player.radius + enemy.radius + 10) {
                    if (player.invincibleTimer <= 0) {
                        enemy.boneCrusherVictim = true; // 플레이어를 잡음
                        showPickupEffect(player.x, player.y, "잡혔다!!", false, true, "wicked-large-text");
                    }
                }
            }

            // =========================================================
            // [신규 로직 3] 벽 충돌 체크 (화면 밖으로 나갔을 때)
            // =========================================================
            let hitWall = false;
            if (enemy.x < -50 || enemy.x > canvas.width + 50 || enemy.y < -50 || enemy.y > canvas.height + 50) {
                hitWall = true;
            }

            if (hitWall) {
                enemy.boneCrusherState = 'idle';
                // 맵 안쪽으로 복귀
                enemy.x = Math.max(50, Math.min(canvas.width - 50, enemy.x));
                enemy.y = Math.max(50, Math.min(canvas.height - 50, enemy.y));
                
                // ★ 벽 충돌 시 잡힌 플레이어에게 데미지 부여 (1회)
                if (enemy.boneCrusherVictim) {
                    // 데미지 계산: 기본 데미지 + 골절 중첩당 증가
                    let baseDmg = 34 + Math.floor(score * 0.3); // 벽꽝 데미지는 강력하게 설정
                    let fractureBonus = 1 + (player.fractureTimers.length * 0.15); // 골절 하나당 15% 증폭
                    let finalDmg = baseDmg * fractureBonus;

                    takeDamage(finalDmg, 'direct', enemy.accuracy, enemy);             
                    showPickupEffect(player.x, player.y, "으어얽", false, true, "wicked-large-text");

                    // 퀘스타 패시브: 새디즘 (플레이어 치명타 저항 확률 낮을 시 회복)
                    const sadismCritResist = getEffectiveDefenderCritResist();
                    if (sadismCritResist <= SADISM_CRITRESIST_THRESHOLD) {
                        let heal = Math.floor(finalDmg * SADISM_LIFESTEAL_RATIO);
                        enemy.hp = Math.min(enemy.maxHp, enemy.hp + heal);
                        showDamageText(enemy.x, enemy.y, "새디즘 +" + heal, false, false, "heal-text");
                    
                            activateSadismGas(enemy);
}

                    // 충격파 이펙트
                    shockwaves.push({
                        x: enemy.x, y: enemy.y,
                        radius: 10, speed: 20, alpha: 1.0, fade: 0.05
                    });

                    // 잡기 상태 해제
                    enemy.boneCrusherVictim = false;
                }

                // 스킬 종료 후 휴식
                enemy.state = 'cooldown';
                enemy.actionTimer = 60;
            }
        }
    }
}

               // [신규] 테토라 업데이트 로직
            if (enemy.isTetora) {
                // 1. 카이팅 AI (거리 370 유지)
                const distToPlayer = Math.hypot(player.x - enemy.x, player.y - enemy.y);
                const angle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
                
                if (distToPlayer < 350) { // 너무 가까우면 후퇴
                    enemy.vx = -Math.cos(angle) * enemy.speed;
                    enemy.vy = -Math.sin(angle) * enemy.speed;
                } else if (distToPlayer > 390) { // 너무 멀면 접근
                    enemy.vx = Math.cos(angle) * enemy.speed;
                    enemy.vy = Math.sin(angle) * enemy.speed;
                } else { // 적정 거리면 측면 이동 (회피 기동)
                    enemy.vx = Math.cos(angle + Math.PI/2) * enemy.speed;
                    enemy.vy = Math.sin(angle + Math.PI/2) * enemy.speed;
                }
                enemy.x += enemy.vx;
                enemy.y += enemy.vy;

                // 2. 노래 (버프) 관리
                // 전역 변수 상태 업데이트 (화면 효과용)
                if (enemy.currentSong === 'requiem' && enemy.songTimer > 0) tetoraRequiemActive = true;
                if (enemy.currentSong === 'rhapsody' && enemy.songTimer > 0) tetoraRhapsodyActive = true;

                if (enemy.songTimer > 0) {
                    enemy.songTimer--;
                    // 진혼곡: 120프레임마다 아군 회복
                    if (enemy.currentSong === 'requiem' && enemy.songTimer % 120 === 0) {
                        enemies.forEach(ally => {
                            if (ally === enemy) return;
                            if (ally.hp > 0) {
                                let heal = Math.floor(ally.maxHp * 0.1);
                                ally.hp = Math.min(ally.maxHp, ally.hp + heal);
                                showDamageText(ally.x, ally.y, "+" + heal, false, false, "heal-text");
                            }
                        });
                    }
                } else {
                    // 노래 지속시간 종료 시 쿨타임 체크 후 재사용
                    // 랜덤하게 다음 곡 선정 (쿨타임이 따로 돈다면 여기서 처리)
                    // 요구사항: 쿨타임 16초. 지속 16초.
                    // 여기서는 지속이 끝나면 즉시 쿨타임 대기 상태로 간주하거나 바로 사용 (로직 단순화를 위해 즉시 재사용 패턴 적용)
                    // 만약 공백기를 두려면 별도 쿨타임 변수 필요. 여기선 바로 스위칭합니다.
                    enemy.currentSong = (enemy.currentSong === 'requiem') ? 'rhapsody' : 'requiem';
                    enemy.songTimer = 960;
                    
                    showPickupEffect(enemy.x, enemy.y - 60, enemy.currentSong === 'requiem' ? "진혼곡♥" : "광시곡♥", false, true, "evil-purple-text");
                }

                // 3. 데스메탈 크레센도
                if (enemy.crescendoTimer > 0) enemy.crescendoTimer--;
                else {
                    spawnDeathMetalNote(enemy.x, enemy.y, enemy.angle, enemy);
                    enemy.crescendoTimer = 600; // 10초
                }

                // 4. 다크니스 스포트라이트
                if (enemy.spotlightTimer > 0) enemy.spotlightTimer--;
                else {
                    spawnDarknessSpotlight(enemy.x, enemy.y, enemy);
                    enemy.spotlightTimer = 840; // 14초
                }
                
                // 패시브용 아군 카운트 (데미지 계산 시 사용)
                enemy.allyCount = enemies.filter(e => e.hp > 0).length;
            }

               if (enemy.isGawain) {
            // [스킬/패턴 완전 봉인] 잔혹한 돌진 차지/돌진 중에는 성역/단죄의 검 등 모든 패턴을 수행하지 않음
            const gawainLocked = (enemy.isCruelCharging || enemy.isCruelChargeCharging);

            // ----------------------------
            // 타락한 성역 (Locked 중 처리)
            // - 돌진 중에는 '새 발동'만 금지하고, 이미 켜져 있던 성역의 힐/버프는 계속 적용
            // ----------------------------
            if (enemy.gawainSanctuaryActive > 0) {
                enemy.gawainSanctuaryActive--;

                const sanctuaryRange = enemy.radius * 2.0;
                const sanctuaryRangeSq = sanctuaryRange * sanctuaryRange;

                // [최적화] 성역 범위 체크는 N프레임마다 수행 + 제곱거리 사용
                if (frameCount % GAWAIN_SANCTUARY_STRIDE === 0) {
                    for (let j = 0; j < enemies.length; j++) {
                        const ally = enemies[j];
                        const dx = enemy.x - ally.x;
                        const dy = enemy.y - ally.y;
                        if ((dx * dx + dy * dy) < sanctuaryRangeSq) {
                            ally.gawainSanctuaryCount = (ally.gawainSanctuaryCount || 0) + 1;

                            // 2초마다 소량 회복
                            if (frameCount % 120 === 0 && ally.hp > 0 && ally.hp < ally.maxHp) {
                                let sanctuaryHeal = 4 + Math.floor(score * 0.03);
                                sanctuaryHeal = Math.floor(sanctuaryHeal * (ally.hpRecoveryRate || 1));
                                ally.hp += sanctuaryHeal;
                                showDamageText(ally.x, ally.y, "+" + sanctuaryHeal, false, false, "heal-text");
                            }
                        }
                    }
                }
            } else {
                if (!gawainLocked) enemy.gawainSanctuaryTimer--;

                // Locked 중에는 발동 자체를 금지
                if (!gawainLocked && enemy.gawainSanctuaryTimer <= 0) {
                    enemy.gawainSanctuaryActive = 600;
                    enemy.gawainSanctuaryTimer = 900;
                    showPickupEffect(enemy.x, enemy.y - 60, "성역이여 무너져라..", false, false, "gawain-text");
                }
            }

            // ============================================================
// ============================================================
            // [신규 스킬] 잔혹한 돌진 (수정됨: 벽에 닿을 때까지 무한 돌진)
            // ============================================================
            if (enemy.isCruelCharging) {
                // 1. 돌진 중 이동 (빠른 속도)
                const chargeSpeed = 9.5; 
                enemy.x += Math.cos(enemy.cruelChargeAngle) * chargeSpeed;
                enemy.y += Math.sin(enemy.cruelChargeAngle) * chargeSpeed;
                
                // 돌진 중에는 일반 이동 정지
                enemy.vx = 0; enemy.vy = 0;
                // [v13] 돌진 중에는 스턴으로 끊기지 않도록
                enemy.stunTimer = 0;


                // [v16] 벽에서 시작하는 경우 '돌진이 안 나온 것처럼' 보이는 문제 방지: 초반 몇 프레임은 벽 판정을 유예
                enemy.cruelChargeWallGrace = Math.max(enemy.cruelChargeWallGrace || 0, 0);
                // Ghost 이펙트 (잔상)
                if (frameCount % 3 === 0) {
                     spawnGhost(enemy.x, enemy.y, enemy.radius, 0, gawainImg, true);
                }

                // 2. 플레이어 충돌 체크 (달라붙기 판정)
                if (!enemy.cruelChargeVictim) {
                    const dist = Math.hypot(player.x - enemy.x, player.y - enemy.y);
                    // 충돌 범위 체크
                    if (dist < enemy.radius + player.radius + 10) {
                        // 돌진 중 접촉하면 즉시 '잡힘' 상태로 전환 (무적 여부와 무관)
                        enemy.cruelChargeVictim = true;
                        if (player.invincibleTimer <= 0) {
                            showPickupEffect(player.x, player.y, "끌려간다..", false, true, "pink-text");
                        }
                    }
                }

                // 3. 잡힌 플레이어 강제 이동 (가웨인 위치로 고정)
                if (enemy.cruelChargeVictim) {
                    // 플레이어를 가웨인 '앞쪽'에 붙여서(약간의 오프셋) 충돌 보정/밀림 때문에 돌진이 끊기는 현상을 방지
                    const stickDist = Math.max(0, enemy.radius + player.radius - 6);
                    player.x = enemy.x + Math.cos(enemy.cruelChargeAngle) * stickDist;
                    player.y = enemy.y + Math.sin(enemy.cruelChargeAngle) * stickDist;
                    // 끌려가는 동안 이동/공격 불가
                    player.stunTimer = 2;
                    if (player.weapon.isAttacking) { player.weapon.isAttacking = false; player.weapon.attackTimer = 0; }
                    player.weapon.autoTimer = 0;
                }

                // 4. 벽 충돌 체크 (화면 밖으로 나가는지 확인)
                let hitWall = false;
                if (enemy.x <= enemy.radius || enemy.x >= canvas.width - enemy.radius || 
                    enemy.y <= enemy.radius || enemy.y >= canvas.height - enemy.radius) {
                    hitWall = true;
                }

                // [v16] 초반 유예 프레임이 남아있으면 벽 판정 무시
                if ((enemy.cruelChargeWallGrace || 0) > 0) {
                    enemy.cruelChargeWallGrace--;
                    hitWall = false;
                }

                if (hitWall) {
                    // 벽에 닿음 -> 돌진 종료 및 데미지 처리
                    enemy.isCruelCharging = false;
                    enemy.cruelChargeTimer = 540; // 쿨타임 9초
                    
                    if (enemy.cruelChargeVictim) {
                        // 벽 꽝 추가 데미지
                        let wallDmg = 17 + Math.floor(score * 0.25); 
                        takeDamage(wallDmg, 'direct', enemy.accuracy, enemy);
                        
                        // 디버프 부여: 카인의 좆집, 카인의 씨앗 2중첩씩
                        for (let k = 0; k < 2; k++) {
                        addStatus('darkReceiver', 900, 20); 
                        addStatus('darkSeed', 900, 20);     
                        }
                        showPickupEffect(player.x, player.y, "벽꿍자지삽입♥", false, true, "corrupted-text");
                        enemy.cruelChargeVictim = false;
                        
                        // 충격파 효과
                        shockwaves.push({
                            x: enemy.x, y: enemy.y,
                            radius: 10, speed: 20, alpha: 1.0, fade: 0.05
                        });
                    }
                }

            } else {
                // ------------------------------------------------------------
                // 차지(모으기) 상태: 돌진 직전에 잠깐 멈추고 오오라가 모이게
                // ------------------------------------------------------------
                if (enemy.isCruelChargeCharging) {
                    enemy.vx = 0; enemy.vy = 0;
                    // [v13] 차지 중에는 스턴으로 끊기지 않도록
                    enemy.stunTimer = 0;

                    // 오오라/잔광 생성
                    spawnCruelChargeAura(enemy);

                    // 차지 타이머 감소
                    enemy.cruelChargeWindup = (enemy.cruelChargeWindup || 0) - 1;

                    // 약간의 떨림(무겁지 않게)
                    enemy.x += (Math.random() - 0.5) * 0.6;
                    enemy.y += (Math.random() - 0.5) * 0.6;

                    // 차지 끝 -> 본 돌진 시작
                    if (enemy.cruelChargeWindup <= 0) {
                        enemy.isCruelChargeCharging = false;
                        enemy.isCruelCharging = true;
                        enemy.cruelChargeAngle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
                        enemy.cruelChargeVictim = false;
                        // [v16] 벽 근처에서 시작하면 즉시 종료되는 현상 방지
                        enemy.cruelChargeWallGrace = 8; // 약 0.13초(60fps)
                        // 시작 프레임에 화면 안쪽으로 살짝 클램프
                        enemy.x = Math.min(canvas.width - enemy.radius - 2, Math.max(enemy.radius + 2, enemy.x));
                        enemy.y = Math.min(canvas.height - enemy.radius - 2, Math.max(enemy.radius + 2, enemy.y));
                    }
                } else {
                    // 평상시: 쿨타임 감소
                    enemy.cruelChargeTimer = (enemy.cruelChargeTimer || 0) - 1;

                    // 돌진 발동 조건: 쿨타임 끝 -> 차지 시작
                    if (enemy.cruelChargeTimer <= 0) {
                        enemy.isCruelChargeCharging = true;
                        enemy.cruelChargeWindup = 90;
                        // 돌진은 차지 끝날 때 각도 재계산해서 더 공정하게
                        showPickupEffect(enemy.x, enemy.y - 60, "잔혹한 돌진…", false, true, "wicked-large-text");
                    }
                }
            }
        }
                
                if (enemy.isAkiClone) {
                    enemy.erectionBuffTimer++;
                    if (enemy.erectionBuffTimer >= 180) { // 180프레임(3초)마다
                        let buffedCount = 0;
                        enemies.forEach(ally => {
                            if (ally !== enemy && ally.hp > 0 && !ally.isAkiClone) {
                                const dist = Math.hypot(enemy.x - ally.x, enemy.y - ally.y);
                                if (dist < 320) { // 범위 320
                                    ally.erectionStacks = Math.min((ally.erectionStacks || 0) + 1, 20);
                                    buffedCount++;
                                }
                            }
                        });
                        if (buffedCount > 0) {
                            showDamageText(enemy.x, enemy.y, "발기해라♥", false, false, "pink-text");
                        }
                        enemy.erectionBuffTimer = 0;
                    }
                }

                if (enemy.isAgent) {
                    enemy.agentDeathTimer--;
                    if (enemy.agentDeathTimer <= 0) {
                        enemy.hp = 0; 
                        if (enemy.agentType === 'curse') {
                            for(let k=0; k<2; k++) addStatus('curse', 900, 10);
                            showPickupEffect(player.x, player.y - player.radius - 70, "저주..", false, false, "evil-purple-text");
                        } else if (enemy.agentType === 'pain') {
                            for(let k=0; k<2; k++) addStatus('gnawingLife', 1800, 5); 
                            showPickupEffect(player.x, player.y - player.radius - 70, "좀먹는 생명..", false, false, "gnawing-life-text");
                        } else if (enemy.agentType === 'blind') {
                            let applied = 0;
                            for(let k=0; k<2; k++) {
                                // [수정] 보호막 체크 제거 (실명은 막을 수 없음)
                                addStatus('blind', 900, 10);
                                applied++;
                            }
                            if(applied > 0) showPickupEffect(player.x, player.y - player.radius - 70, `실명..`, false, false, "weak-text");
                        }
                    }
                }

                enemy.passiveErectionTimer = (enemy.passiveErectionTimer || 0) + cdrSpeed;
                
                let erectionInterval = 160;

                if (enemy.passiveErectionTimer >= erectionInterval) {
                    let erectionGain = 1;
                    if (enemy.isZako) {
                        erectionGain = 2;
                    } else if (enemy.isDarkDenizen) {
                        erectionGain = 2;
                    } else if (enemy.isAmbush && enemy.ambushState === 'ambush' && enemy.normalType === 'rapist') {
                        erectionGain = 3; 
                        showPickupEffect(enemy.x, enemy.y, "자지가 터질것같아♥", false, true, "condensed-milk-text");
                    } else if (enemy.normalType === 'rapist' && !enemy.isStealth && !enemy.isAmbush) {
                        erectionGain = 3; 
                    } else if (enemy.isBoss) {
                        erectionGain = 0.5;
                    }
                    enemy.erectionStacks = Math.min(enemy.erectionStacks + erectionGain, 20);
                    enemy.passiveErectionTimer = 0;
                }

                if (enemy.erectionStacks > 0) { 
                    enemy.radius = enemy.baseRadius * (1 + (enemy.erectionStacks * 0.115)); 
                }

                if ((enemy.isAttached) && ((enemy.normalType === 'rapist') || (enemy.isDarkDenizen && enemy.denizenType === 'rai'))) {
                    enemy.attachTimer += cdrSpeed;
                    enemy.x = player.x;
                    enemy.y = player.y + 10;
                    
                    if (enemy.normalType === 'rapist' || enemy.denizenType === 'rai') attachedRapistCount++;

                    if (enemy.isDarkDenizen && enemy.denizenType === 'rai') {
                        if (enemy.attachTimer >= 900) {
                            showPickupEffect(player.x, player.y - 60, "크큭..", false, true, "choke-text");
                            for(let k=0; k<10; k++) { if(!checkShieldBlockStatus('normal', 'malice')) addStatus('malice', 900, 20); }
                            for(let k=0; k<10; k++) { if(!checkShieldBlockStatus('normal', 'fishy')) addStatus('fishy', 900, 50); }
                            showPickupEffect(player.x, player.y - 120, "헤헤..한번 더♥", false, true, "pink-text");
                            enemy.isAttached = false;
                            enemy.attachTimer = 0;
                            const margin = 50;
                            enemy.x = margin + Math.random() * (canvas.width - margin*2);
                            enemy.y = margin + Math.random() * (canvas.height - margin*2);
                            updateStatusUI();
                            continue; 
                        }
                    } else {
                        if (enemy.attachTimer >= 900) {
                             showPickupEffect(player.x, player.y - 60, "으윽..!!", false, true, "choke-text");
                             let cost = 10;
                             let totalShields = player.shieldStacks; 
                             if (totalShields >= cost) {
                                 player.shieldStacks -= cost;
                                 showPickupEffect(player.x, player.y, "아쉽게 된거지ㅋㅋ", false, true, "sticky-text");
                             } else {
                                 player.shieldStacks = 0;
                                 const debuffTypes = ['kiss', 'semen', 'oral'];
                                 const selectedDebuff = debuffTypes[Math.floor(Math.random() * debuffTypes.length)];
                                 let deficit = cost - totalShields; 
                                 for(let k=0; k<deficit; k++) { addStatus(selectedDebuff, 900, 30); }
                                 showPickupEffect(player.x, player.y, "크하하!! 임신해라♥", false, true, "sticky-large-text");
                                 impregnateAudio.currentTime = 0;
                                 impregnateAudio.play().catch(()=>{});
                                 for(let k=0; k<3; k++) { if(!checkShieldBlockStatus('normal', 'fishy')) addStatus('fishy', 900, 50); }
                                 showPickupEffect(player.x, player.y - 120, "안씻은 자지냄새♥", false, true, "unwashed-text");
                             }
                             updateStatusUI();
                             enemy.hp = -1; 
                        }
                    }
                    if (enemy.hp <= 0) {} else { continue; }
                }
                
                if (enemy.isAmbush && enemy.ambushState !== 'complete') {
                    if (enemy.ambushState === 'approach') {
                        enemy.ambushTimer += cdrSpeed;
                        if (enemy.ambushTimer > 90) { enemy.ambushState = 'ambush'; enemy.ambushTimer = 0; }
                    } else if (enemy.ambushState === 'ambush') {
                        enemy.ambushTimer += cdrSpeed;
                        if (enemy.ambushTimer > 420) { enemy.ambushState = 'approach'; enemy.ambushTimer = 0; }
                        const dist = Math.hypot(player.x - enemy.x, player.y - enemy.y);
                        if (dist < player.radius + enemy.radius) {
                             enemy.isAttached = true; enemy.attachTimer = 0; enemy.isAmbush = false; enemy.isStealth = false; enemy.alpha = 1.0;
                             showPickupEffect(player.x, player.y, "잡았다♥", false, true, "evil-purple-text");
                             rapistAttachAudio.currentTime = 0; rapistAttachAudio.play().catch(()=>{});
                        }
                        enemy.speed = 0;
                    }
                }
                
                if ((enemy.darkServiceEcstasyTimer || 0) > 0) {
                    enemy.darkServiceEcstasyTimer--;
                    enemy.enraged = true;
                    enemy.enrageTimer = Math.max(enemy.enrageTimer || 0, 2);
                    if (enemy.darkServiceEcstasyTimer <= 0) {
                        enemy.enraged = false;
                        enemy.enrageTimer = 0;
                        showPickupEffect(enemy.x, enemy.y - 40, "황홀경 종료", false, true, "weak-text");
                    }
                }

                if (enemy.isZako || enemy.isDarkDenizen) {
                    enemy.readyTimer = (enemy.readyTimer || 0) + cdrSpeed;
                    if (enemy.readyTimer >= 360) {
                        const currentStacks = enemy.readyStacks || 0;
                        if (currentStacks < 20) {
                            const stacksToAdd = enemy.isZako ? 2 : 1;
                            const actualAdd = Math.min(stacksToAdd, 20 - currentStacks);
                            if (actualAdd > 0) {
                                enemy.readyStacks = currentStacks + actualAdd;
                                const hpBonus = actualAdd * 1.5;
                                enemy.maxHp += hpBonus; enemy.hp += hpBonus; 
                                showPickupEffect(enemy.x, enemy.y, "서버렸잖아♥", false, true, "condensed-milk-text");
                            }
                        }
                        enemy.readyTimer = 0;
                    }
                    
                    if (enemy.isZako && enemy.enraged) {
                        enemy.enrageTimer--;
                        if (enemy.enrageTimer <= 0) {
                            enemy.enraged = false;
                        }
                    }
                }
                
                if (enemy.contactStackTimer > 0) enemy.contactStackTimer--;
                
                if (enemy.isZako) {
                    let effectiveSpeed = enemy.baseSpeed;
                    // [신규] 자코에게도 광시곡 속도 버프 적용 (1.3배)
            if (isRhapsodyActive) {
                effectiveSpeed *= 1.3;
            }

            if (enemy.enraged) {
                effectiveSpeed *= 2.5;
                enemy.vx = Math.cos(Math.atan2(player.y - enemy.y, player.x - enemy.x)) * effectiveSpeed;
                enemy.vy = Math.sin(Math.atan2(player.y - enemy.y, player.x - enemy.x)) * effectiveSpeed;
                
                if (enemy.state !== 'pouncing' && enemy.state !== 'pounce_warmup' && enemy.state !== 'cooldown') {
                    enemy.x += enemy.vx;
                    enemy.y += enemy.vy;
                }
                    } else {
                         const creepSpeed = 0.2;
                         const creepAngle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
                         if (enemy.state !== 'pouncing') {
                            enemy.x += Math.cos(creepAngle) * creepSpeed;
                            enemy.y += Math.sin(creepAngle) * creepSpeed;
                         }
                    }

                    if (enemy.state === 'idle') {
                        if (!enemy.enraged) { enemy.vx = 0; enemy.vy = 0; } 
                        const d = Math.hypot(player.x - enemy.x, player.y - enemy.y);
                        if (d < 350) { enemy.state = 'pounce_warmup'; enemy.pounceTimer = 15; showPickupEffect(enemy.x, enemy.y, "!", false); }
                    } else if (enemy.state === 'wandering') {
                        if (!enemy.enraged) {
                            enemy.wanderTimer += cdrSpeed;
                            if (enemy.wanderTimer > 60) { enemy.wanderAngle = Math.random() * Math.PI * 2; enemy.wanderTimer = 0; }
                            enemy.vx = Math.cos(enemy.wanderAngle) * enemy.baseSpeed; enemy.vy = Math.sin(enemy.wanderAngle) * enemy.baseSpeed;
                            enemy.x += enemy.vx; enemy.y += enemy.vy; 
                        }
                    } else if (enemy.state === 'pounce_warmup') {
                        enemy.pounceTimer--;
                        if (enemy.pounceTimer <= 0) { 
                            enemy.state = 'pouncing'; 
                            const angle = Math.atan2(player.y - enemy.y, player.x - enemy.x); 
                            const speed = 5 * (1 + (enemy.erectionStacks || 0) * 0.01); 
                            enemy.vx = Math.cos(angle) * speed; enemy.vy = Math.sin(angle) * speed; 
                            enemy.pounceDuration = 40; 
                            showPickupEffect(enemy.x, enemy.y - 40, "한판하자♥", false, false, "dirty-pink-text");
                        }
                    } else if (enemy.state === 'pouncing') {
                        enemy.x += enemy.vx; enemy.y += enemy.vy; enemy.pounceDuration--;
                        if (enemy.pounceDuration <= 0) { enemy.state = 'cooldown'; enemy.cooldownTimer = 120; }
                    } else if (enemy.state === 'cooldown') {
                        enemy.vx = 0; enemy.vy = 0; enemy.cooldownTimer--; if (enemy.cooldownTimer <= 0) enemy.state = 'idle';
                    }
                } else {
                    let speedMult = 1.0;
                if (isRhapsodyActive && !enemy.isTetora) {
        speedMult = 1.3;
    }
                    enemy.speed = (enemy.baseSpeed * (enemy.timeMoveSpeedBonus || 1) * (1 + (enemy.erectionStacks || 0) * 0.01) * speedMult) + ecstasyFlatBonus;


                if (enemy.isAmbush && enemy.ambushState === 'ambush') { enemy.speed = 0; }

                    if (enemy.isElite && !enemy.isBoss) {
                        if (enemy.isCassias && enemy.hp < enemy.maxHp * 0.3) { enemy.speed *= 2.2; }
                    } else if (enemy.isStealth) {
                        enemy.stealthTimer = (enemy.stealthTimer || 0) + cdrSpeed;
                        const cycle = enemy.stealthTimer % 240; if(cycle > 90) enemy.alpha = 0.02; else enemy.alpha = 1.0; 
                    }

                    let angle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
                    
                    if (enemy.isAgent) {
                        const distToPlayer = Math.hypot(player.x - enemy.x, player.y - enemy.y);
                        const targetDist = 320; 
                        const buffer = 10; 
                        if (distToPlayer < targetDist - buffer) {
                            angle = Math.atan2(enemy.y - player.y, enemy.x - player.x);
                        } else if (distToPlayer > targetDist + buffer) {
                            angle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
                        } else {
                            enemy.speed = 0;
                        }
                    }
                    
                    enemy.angle = angle;
                    
                    if (enemy.dashTimer > 0) {
                        enemy.x += enemy.dashVx; enemy.y += enemy.dashVy; enemy.dashTimer--;
                        if (frameCount % 3 === 0) {
                            let img = summonerVillainImg;
                            if (enemy.isArthur) img = arthurImg;
                            else if (enemy.isBoss) img = bossVillainImg;
                            else if (enemy.isRyuon) img = corruptedHeroImg;
                            else if (enemy.isLuca) img = corruptedSniperImg; 
                            else if (enemy.isOzma) img = ozmaImg; 
                            else if (enemy.isTaro) img = taroImg; 
                            else if (enemy.isGawain) img = gawainImg; 
                            else if (enemy.isAki) img = akiImg; 
                            else if (enemy.isHiro) img = hiroImg;
                            else if (enemy.isKai) img = kaiImg;
                            else if (enemy.isJacques) img = jacquesImg;

                            else if (enemy.isElite) img = eliteVillainImg;
                            else if (enemy.isAgent) { 
                                if (enemy.agentType === 'curse') img = agentCurseImg;
                                else if (enemy.agentType === 'pain') img = agentPainImg;
                                else img = agentBlindImg;
                            }
                            else if (enemy.normalType === 'rapist') img = rapistVillainImg;

                            spawnGhost(enemy.x, enemy.y, enemy.radius, enemy.angle + Math.PI / 2, img, enemy.isElite);
                        }
                    } else {
                        if (enemy.isLuca || enemy.isAki || enemy.isOzma || enemy.isHiro || enemy.isKai || enemy.isJacques || enemy.isAkiClone || (enemy.isArchdemon && enemy.archdemonName.includes('토우야'))) { 
                            const distToPlayer = Math.hypot(player.x - enemy.x, player.y - enemy.y);
                            let maintainDist = 320;
                            if (enemy.isLuca || enemy.isAki) maintainDist = 320;
                            if (enemy.isHiro) maintainDist = 320;
                            
                            if (distToPlayer < maintainDist) {
                                enemy.vx = -Math.cos(angle) * enemy.speed;
                                enemy.vy = -Math.sin(angle) * enemy.speed;
                            } else if (distToPlayer > maintainDist + 100) {
                                enemy.vx = Math.cos(angle) * enemy.speed;
                                enemy.vy = Math.sin(angle) * enemy.speed;
                            } else {
                                enemy.vx = 0; 
                                enemy.vy = 0;
                            }
                            if (enemy.isAkiClone) {
                                // 현재 살아있는 아키 본체 찾기
                                const mainAki = enemies.find(e => e.isAki && !e.isAkiClone && e.hp > 0);
                                if (mainAki) {
                                    const distToMain = Math.hypot(enemy.x - mainAki.x, enemy.y - mainAki.y);
                                    const separationDist = 320; // 본체와 유지할 최소 거리
                                    
                                    if (distToMain < separationDist) {
                                        // 본체로부터 멀어지는 방향 계산
                                        const repelAngle = Math.atan2(enemy.y - mainAki.y, enemy.x - mainAki.x);
                                        // 현재 이동 벡터에 밀어내는 힘 추가
                                        enemy.vx += Math.cos(repelAngle) * 2; 
                                        enemy.vy += Math.sin(repelAngle) * 2;
                                    }
                                }
                            }
                        } else {
                            if (enemy.isAgent && enemy.speed === 0) {
                                enemy.vx = 0; enemy.vy = 0;
                            } else {
                                enemy.vx = Math.cos(angle) * enemy.speed; 
                                enemy.vy = Math.sin(angle) * enemy.speed;
                            }
                        }
                        
                        if (enemy.isTaro) {
                            if (enemy.transparentTimer > 0) {
                                enemy.transparentTimer--;
                                enemy.alpha = 0.2;
                            } else {
                                enemy.alpha = 1.0;
                                enemy.isTransparent = false;
                            }

                            if (enemy.speedBoostTimer > 0) {
                                enemy.speedBoostTimer--;
                                enemy.speed *= 2.5; 
                                enemy.vx *= 2.5; enemy.vy *= 2.5;
                            }

                            enemy.backstabTimer = (enemy.backstabTimer || 0) + cdrSpeed;
                            if (enemy.backstabTimer > 360) {
                                const pAngle = Math.atan2(player.vy, player.vx) || player.weapon.angle; 
                                const backAngle = pAngle + Math.PI; 
                                enemy.x = player.x + Math.cos(backAngle) * 250;
                                enemy.y = player.y + Math.sin(backAngle) * 250;
                                
                                enemy.isTransparent = true;
                                enemy.transparentTimer = 120; 
                                enemy.speedBoostTimer = 120; 
                                showPickupEffect(enemy.x, enemy.y - 40, "엉덩이 들어♥", false, false, "dirty-pink-text");
                                
                                enemy.backstabTimer = 0;
                            }

                            if (enemy.sonicState === 'idle') {
                                enemy.sonicBoomTimer = (enemy.sonicBoomTimer || 0) + cdrSpeed;
                                if (enemy.sonicBoomTimer > 420) {
                                    enemy.sonicState = 'warmup';
                                    enemy.sonicBoomTimer = 0;
                                    showPickupEffect(enemy.x, enemy.y - 40, "시원하게 박아주마♥", false, false, "condensed-milk-text");
                                }
                            } else if (enemy.sonicState === 'warmup') {
                                enemy.sonicBoomTimer += cdrSpeed;
                                if (enemy.sonicBoomTimer > 90) { 
                                    enemy.sonicState = 'dash';
                                    enemy.sonicBoomTimer = 0;
                                    
                                    // [수정] 돌진 시작 시, 버프 받은 아군 목록 초기화
                                    enemy.dashBuffedAllies = []; 
                                    
                                    const dashAngle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
                                    enemy.dashVx = Math.cos(dashAngle) * 15; 
                                    enemy.dashVy = Math.sin(dashAngle) * 15;
                                    enemy.sonicWallGrace = 8;
                                    enemy.x = Math.min(canvas.width - enemy.radius - 2, Math.max(enemy.radius + 2, enemy.x));
                                    enemy.y = Math.min(canvas.height - enemy.radius - 2, Math.max(enemy.radius + 2, enemy.y));
                                }
                            } else if (enemy.sonicState === 'dash') {
                                enemy.x += enemy.dashVx;
                                enemy.y += enemy.dashVy;
                                enemy.sonicBoomTimer += cdrSpeed;
                                
                                if (enemy.sonicHitCooldown > 0) enemy.sonicHitCooldown--;

                                // [수정] 이미 버프를 받은 아군은 제외하고 한 번만 적용
                                if (!enemy.dashBuffedAllies) enemy.dashBuffedAllies = []; // 안전 장치

                                enemies.forEach(ally => {
                                    if (ally !== enemy && !enemy.dashBuffedAllies.includes(ally)) {
                                        const dist = Math.hypot(enemy.x - ally.x, enemy.y - ally.y);
                                        if (dist < 210) {
                                            ally.erectionStacks = Math.min(ally.erectionStacks + 3, 20);
                                            enemy.dashBuffedAllies.push(ally); // 버프 받은 목록에 추가
                                            
                                            showDamageText(ally.x, ally.y, "발기해라♥", false, false, "heal-text");
                                        }
                                    }
                                });

                                const distToPlayer = Math.hypot(player.x - enemy.x, player.y - enemy.y);

                                if (distToPlayer < player.radius + enemy.radius) {
                                     if (enemy.sonicHitCooldown <= 0) {
                                         let dmg = 20 + Math.floor(score * 0.18);
                                         takeDamage(dmg, 'direct', enemy.accuracy, enemy);
                                         showPickupEffect(player.x, player.y, "크헉!", false);
                                         enemy.sonicHitCooldown = 30; 
                                     }
                                }

                                const sonicGrace = Math.max(enemy.sonicWallGrace || 0, 0);
                                if (sonicGrace > 0) enemy.sonicWallGrace = sonicGrace - 1;

                                const hitWall = enemy.x <= enemy.radius || enemy.x >= canvas.width - enemy.radius || enemy.y <= enemy.radius || enemy.y >= canvas.height - enemy.radius;
                                if (hitWall && (enemy.sonicWallGrace || 0) <= 0) {
                                    enemy.sonicState = 'idle';
                                    enemy.sonicBoomTimer = 0;
                                    enemy.dashVx = 0;
                                    enemy.dashVy = 0;
                                }
                                return; 
                            }
                        }
                        
                        if (enemy.isGawain) {
                            // [잠금] 잔혹한 돌진 차지/돌진 중에는 다른 스킬(단죄의 검)을 사용하지 않음
                            // 단, 타이머를 초기화하지 않고 '예약'해 두어 돌진이 끝난 뒤 확정 발동되게 함
                            if (enemy.isCruelCharging || enemy.isCruelChargeCharging) {
                                enemy.gawainJumpState = 'idle';
                                enemy.gawainJumpTimer = 0;
                                if (enemy.gawainSwordTimer > 900) {
                                    enemy.gawainJumpQueued = true;
                                }
                            } else {
                            enemy.gawainSwordTimer += cdrSpeed;
                            if (enemy.gawainJumpQueued || enemy.gawainSwordTimer > 900) {
                                enemy.gawainJumpState = 'warmup';
                                enemy.gawainSwordTimer = 0;
                                enemy.gawainJumpQueued = false;
                                showPickupEffect(enemy.x, enemy.y - 60, "단죄의 검!", false, false, "gawain-text");
                            }

                            if (enemy.gawainJumpState === 'warmup') {
                                enemy.gawainJumpTimer += cdrSpeed;
                                enemy.vx = 0; enemy.vy = 0;
                                if (enemy.gawainJumpTimer > 60) {
                                    enemy.gawainJumpState = 'jump'; 
                                    enemy.alpha = 0;
                                    enemy.gawainJumpTimer = 0;
                                    enemy.targetX = player.x;
                                    enemy.targetY = player.y;
                                }
                            } else if (enemy.gawainJumpState === 'jump') {
                                enemy.gawainJumpTimer += cdrSpeed;
                                enemy.x = -1000; enemy.y = -1000; 
                                if (enemy.gawainJumpTimer > 60) {
                                    enemy.gawainJumpState = 'slam';
                                    enemy.gawainJumpTimer = 0;
                                    enemy.x = enemy.targetX; 
                                    enemy.y = enemy.targetY;
                                    enemy.alpha = 1;
                                    
                                    const dist = Math.hypot(player.x - enemy.x, player.y - enemy.y);
                                    if (dist < 300) {
                                        let dmg = 15 + Math.floor(score * 0.17);
                                        takeDamage(dmg, 'direct', enemy.accuracy, enemy);
                                        if (player.shieldStacks > 0) player.shieldStacks = Math.floor(player.shieldStacks * 0.75);
                                        if (player.justiceShield > 0) player.justiceShield = Math.floor(player.justiceShield * 0.75);
                                        updateStatusUI();
                                        showPickupEffect(player.x, player.y, "저항은 소용없다..", false);
                                    }
                                        spawnDarkGas(enemy.x, enemy.y, 3.5, 1.5, enemy.accuracy, 0, enemy);
                                        shockwaves.push({
                                        x: enemy.x,
                                        y: enemy.y,
                                        radius: 300,      
                                        speed: 12,       
                                        alpha: 1.0,      
                                        fade: 0.03       
                                    });

                                    for(let k=0; k<10; k++) {
                                        spawnWhiteShot(enemy.x, enemy.y, true, false, enemy); 
                                    }
                                    
                                    groundCracks.push({
                                        x: enemy.x,
                                        y: enemy.y,
                                        life: 90,
                                        maxLife: 90
                                    });

                                    enemy.gawainJumpState = 'idle';
                                }
                            }
                        
                            }
}
                        
                        if ((!enemy.isTaro || enemy.sonicState === 'idle') && (!enemy.isGawain || enemy.gawainJumpState === 'idle')) {
                            enemy.x += enemy.vx; enemy.y += enemy.vy;
                        }
                    }

                   // [수정됨] 아서는 카인의 패턴을 공유하지 않도록 조건을 추가 (!enemy.isArthur)
                      if (enemy.isBoss && !enemy.isArthur) {
            
            // [신규 수정] 아키토와 토우야(Archdemon)는 카인의 패턴(가스, 똥, 정액, 소환 등)을 사용하지 않음
            if (!enemy.isArchdemon) {
                enemy.hollowNightTimer = (enemy.hollowNightTimer || 0) + cdrSpeed;
                if (enemy.hollowNightTimer > 1200) {
                    spawnHollowNight(enemy.x, enemy.y, enemy.accuracy, enemy);
                    enemy.hollowNightTimer = 0;
                }

                enemy.darkGasTimer += cdrSpeed;
                if (enemy.darkGasTimer > 120) {
                    let sizeMult = 1.25;
                    if (enemy.bossType === 0) sizeMult = 3.5;
                    spawnDarkGas(enemy.x, enemy.y, sizeMult, 1.0, enemy.accuracy, 0, enemy);
                    spawnPoop(enemy.x, enemy.y, true, false, false, enemy.accuracy, enemy);
                    enemy.darkGasTimer = 0;
                }

                if (enemy.bossType === 0) {
                    enemy.darkGasExtraTimer = (enemy.darkGasExtraTimer || 0) + cdrSpeed;
                    if (enemy.darkGasExtraTimer >= 60) {
                        spawnGas(enemy.x, enemy.y, false, false, 0, 4.0, enemy.accuracy, enemy);
                        enemy.darkGasExtraTimer = 0;
                    }
                }

                enemy.darkBigPoopTimer += cdrSpeed;
                if (enemy.bossType === 1) {
                    if (enemy.darkBigPoopTimer % 120 === 0) {
                        spawnDarkBigPoop(enemy.x, enemy.y, false, 0, false, enemy.accuracy, enemy);
                    }
                    if (enemy.darkBigPoopTimer % 240 === 0) {
                        spawnDarkBigPoop(enemy.x, enemy.y, false, 0, true, enemy.accuracy, enemy);
                        showPickupEffect(enemy.x, enemy.y - 60, "받아라!!", false, false, "evil-shout-text");
                    }
                } else if (enemy.darkBigPoopTimer > 360) {
                    spawnDarkBigPoop(enemy.x, enemy.y, false, 0, false, enemy.accuracy, enemy);
                    enemy.darkBigPoopTimer = 0;
                }
                if (enemy.darkBigPoopTimer > 24000) enemy.darkBigPoopTimer = 0;

                if (enemy.bossType === 2) {
                    enemy.darkNormalSemenTimer = (enemy.darkNormalSemenTimer || 0) + cdrSpeed;
                    if (enemy.darkNormalSemenTimer > 120) {
                        spawnDarkSemen(enemy.x, enemy.y, false, enemy.angle, 1.0, enemy.accuracy, enemy);
                        enemy.darkNormalSemenTimer = 0;
                    }
                }

                if (enemy.bossType === 2) {
                    enemy.darkTargetSemenTimer = (enemy.darkTargetSemenTimer || 0) + cdrSpeed;
                    if (enemy.darkTargetSemenTimer > 360) {
                        spawnDarkSemen(enemy.x, enemy.y, true, 0, 3.0, enemy.accuracy, enemy);
                        showPickupEffect(enemy.x, enemy.y - 60, "임신시켜주마", false, false, "pregnancy-text");
                        enemy.darkTargetSemenTimer = 0;
                    }
                }

                enemy.mindBreakTimer += cdrSpeed;
                const mbInterval = (enemy.bossType === 3) ? 60 : 480;
                if (enemy.mindBreakTimer >= mbInterval) {
                    spawnMindSkull(enemy.x, enemy.y, enemy.accuracy, enemy);
                    enemy.mindBreakTimer = 0;
                    showPickupEffect(enemy.x, enemy.y - 80, "마인드 브레이크!", false, false, "mind-break-text");
                }

                if (enemy.bossType === 4) {
                    enemy.tanetsukeTimer += cdrSpeed;
                    if (enemy.tanetsukeTimer > 360) {
                        for (let k = 0; k < 3; k++) addStatus('darkReceiver', 900, 20);
                        showPickupEffect(player.x, player.y, "넌 내 좆집이다!", false, false, "evil-shout-text");
                        enemy.tanetsukeTimer = 0;
                    }

                    enemy.tanetsukeTeleportTimer = (enemy.tanetsukeTeleportTimer || 0) + cdrSpeed;
                    if (enemy.tanetsukeTeleportTimer >= 360) {
                        const pAngle = Math.atan2(player.vy || 0, player.vx || 1);
                        const backAngle = pAngle + Math.PI;
                        const dist = 140 + Math.random() * 50;
                        enemy.x = player.x + Math.cos(backAngle) * dist;
                        enemy.y = player.y + Math.sin(backAngle) * dist;

                        const baseAngle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
                        const fan = [-0.22, 0, 0.22];
                        for (const off of fan) {
                            spawnDarkSemen(enemy.x, enemy.y, false, baseAngle + off, 1.0, enemy.accuracy, enemy);
                        }
                        showPickupEffect(enemy.x, enemy.y - 70, "후면 강습♥", false, false, "evil-shout-text");
                        enemy.tanetsukeTeleportTimer = 0;
                    }
                }

                enemy.demonSummonTimer += cdrSpeed;
                if (enemy.demonSummonTimer > 2760) {
                    spawnArchdemons(enemy.x, enemy.y);
                    showPickupEffect(enemy.x, enemy.y - 80, "하하하하", false, false, "evil-summon-text");
                    enemy.demonSummonTimer = 0;
                }
            } // [끝] 카인 패턴 종료

            // 아키토 패턴
            if (enemy.isArchdemon && enemy.archdemonName.includes('아키토')) {
                enemy.pandemoniumTimer = (enemy.pandemoniumTimer || 0) + cdrSpeed;
                if (enemy.pandemoniumTimer > 600) {
                    spawnPandemonium(enemy.x, enemy.y, enemy.accuracy, enemy);
                    showPickupEffect(enemy.x, enemy.y - 60, "판데모니움!", false, false, "wicked-large-text");
                    enemy.pandemoniumTimer = 0;
                }
                
                if (enemy.soulHarvestTimer === undefined) enemy.soulHarvestTimer = 400;
                if (enemy.catastropheTimer === undefined) enemy.catastropheTimer = 600;

                // 1. 소울 하비스트
                if (enemy.soulHarvestTimer > 0) {
                    enemy.soulHarvestTimer--;
                } else {
                    castSoulHarvest(enemy);
                    enemy.soulHarvestTimer = 840;
                }

                // 2. 커스드 카타스트로피
                if (enemy.catastropheTimer > 0) {
                    enemy.catastropheTimer--;
                } else {
                    spawnCursedCatastrophe(enemy.x, enemy.y, enemy.accuracy, enemy);
                    enemy.catastropheTimer = 960;
                }
            }

            // 토우야 패턴
            if (enemy.isArchdemon && enemy.archdemonName.includes('토우야')) {
                // 1. 프리즘 스윕 (쿨타임 21초 = 1260프레임)
                enemy.prismSweepCooldown = (enemy.prismSweepCooldown || 0) + cdrSpeed;
                if (enemy.prismSweepCooldown >= 1260) {
                    spawnPrismSweep(player.x, player.y - 100, enemy.accuracy, enemy);
                    enemy.prismSweepCooldown = 0;
                }

                // 2. 오클루전 스풀 (쿨타임 15초 = 900프레임)
                enemy.occlusionSpoolCooldown = (enemy.occlusionSpoolCooldown || 0) + cdrSpeed;
                if (enemy.occlusionSpoolCooldown >= 900) {
                    spawnOcclusionSpool(enemy.accuracy, enemy);
                    enemy.occlusionSpoolCooldown = 0;
                }
                enemy.evilLightTimer = (enemy.evilLightTimer || 0) + cdrSpeed;
                if (enemy.evilLightTimer > 1500) {
                    triggerEvilLight(enemy);
                    enemy.evilLightTimer = 0;
                }

                enemy.darkServiceCooldown = (enemy.darkServiceCooldown || 0) + cdrSpeed;
                if (enemy.darkServiceCooldown >= 360) {
                    castDarkService(enemy);
                    enemy.darkServiceCooldown = 0;
                }

                if ((enemy.darkServicePulseTimer || 0) > 0) {
                    enemy.darkServicePulseTimer -= cdrSpeed;
                    if (enemy.darkServicePulseTimer <= 0) {
                        triggerDarkServicePulse(enemy);
                        enemy.darkServicePulseTimer = 0;
                    }
                }
            }
        } else {
            let cooldownMult = 1.0;
                        if (enemy.isCassias && enemy.hp < enemy.maxHp * 0.3) { cooldownMult = 0.5; }

                        // [수정] 속도 배율(발기 스택 기반) - 공격 간격 계산 등에 사용
                        const speedMultiplier = 1 + ((enemy.erectionStacks || 0) * 0.01);

                        enemy.gasTimer += cdrSpeed;
                        const currentGasInterval = Math.max(30, (enemy.gasInterval / Math.sqrt(speedMultiplier)) * cooldownMult);
                        
                        if (enemy.isRyuon) {
                            enemy.darkWaveTimer = (enemy.darkWaveTimer || 0) + cdrSpeed;
                            if (enemy.darkWaveTimer > 240 * cooldownMult) {
        const angle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
        spawnDarkWave(enemy.x, enemy.y, angle, enemy.accuracy, enemy); // [수정] accuracy 전달
        showPickupEffect(enemy.x, enemy.y - 50, "타락하라!!", false, false, "corrupted-text");
        enemy.darkWaveTimer = 0;
    }
                            
                            if (enemy.chargeState === 'idle') {
                                enemy.chargeTimer = (enemy.chargeTimer || 0) + 1;
                                if (enemy.chargeTimer > 360 * cooldownMult) {
                                    enemy.chargeState = 'warmup';
                                    enemy.chargeTimer = 0;
                                    showPickupEffect(enemy.x, enemy.y - 50, "정의는 죽었다..", false, false, "corrupted-text");
                                }
                            } else if (enemy.chargeState === 'warmup') {
                                enemy.chargeTimer++;
                                enemy.vx = 0; enemy.vy = 0; 

                                // [신규] 류온 '정의의 돌진' 차지 이펙트: 검붉은 방구 구름이 류온에게 모여듦
                                spawnJusticeChargeAura(enemy);

                                if (enemy.chargeTimer > 90) {
                                    enemy.chargeState = 'charging';
                                    enemy.chargeTimer = 0;
                                    const angle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
                                    enemy.dashVx = Math.cos(angle) * 8.2;
                                    enemy.dashVy = Math.sin(angle) * 8.2;
                                }
                            } else if (enemy.chargeState === 'charging') {
                                enemy.x += enemy.dashVx;
                                enemy.y += enemy.dashVy;
                                enemy.chargeTimer++;
                                if (frameCount % 15 === 0) {
                                    spawnDeathCloud(enemy.x, enemy.y, enemy.isElite, enemy.isBoss, enemy.accuracy, enemy);
                                }
                                if (enemy.chargeTimer > 60) {
                                    if (enemy.chargeCount < 1) {
                                        enemy.chargeState = 'warmup';
                                        enemy.chargeTimer = 0;
                                        enemy.chargeCount++;
                                    } else {
                                        enemy.chargeState = 'idle';
                                        enemy.chargeTimer = 0;
                                        enemy.chargeCount = 0;
                                    }
                                }
                            }
                        }
                        
                                               if (enemy.isLuca) {
                            enemy.aimTimer = (enemy.aimTimer || 0) + cdrSpeed;
                            if (enemy.aimTimer > 420 * cooldownMult) { 
                                if (enemy.aimTimer < 480 * cooldownMult) {
                                } else {
                                    const shot = {
                                        x: enemy.x, y: enemy.y,
                                        vx: Math.cos(enemy.angle) * 15,
                                        vy: Math.sin(enemy.angle) * 15,
                                        radius: 10,
                                        life: 120,
                                        isZako: false, isElite: true,
                                        isStun: true,
                                        isLucaShot: true 
                                    };
                                    whiteshots.push(shot);
                                    showPickupEffect(enemy.x, enemy.y - 50, "얼굴에 싼다!♥", false, false, "sniper-text");
                                    enemy.aimTimer = 0;
                                }
                            }
                            
                                                        // (Luca) 일반 화이트샷 패턴 제거: 빨간 조준 후 발사만 사용
                            enemy.lucaSummonTimer = (enemy.lucaSummonTimer || 0) + cdrSpeed;

            // 7초(420프레임)마다 실행
            if (enemy.lucaSummonTimer >= 420) {
                // 랜덤 자코 2마리 소환 반복문
                for (let k = 0; k < 2; k++) {
                    const zakoTypes = [null, 'terrorist', 'plague']; // 자코 타입 목록 (일반, 자폭, 역병)
                    const randomZako = zakoTypes[Math.floor(Math.random() * zakoTypes.length)]; // 랜덤 선택
                    
                    // 루카 주변 랜덤한 위치에 소환
                    const spawnX = enemy.x + (Math.random() - 0.5) * 100;
                    const spawnY = enemy.y + (Math.random() - 0.5) * 100;
                    
                    spawnZako(spawnX, spawnY, randomZako);
                }

                // 대사/이펙트 출력 (원하는 멘트로 수정 가능)
                showPickupEffect(enemy.x, enemy.y - 60, "나와라 얘들아♥", false, false, "pink-text");
                
                // 타이머 초기화
                enemy.lucaSummonTimer = 0;
            }

enemy.blinkMineTimer = (enemy.blinkMineTimer || 0) + cdrSpeed;
                            if (enemy.blinkMineTimer >= 360) { // 360프레임 = 6초
                            spawnBlinkMines(enemy.x, enemy.y, 3, enemy, enemy.accuracy);
                            enemy.blinkMineTimer = 0;
            }

                            enemy.pheromoneTimer = (enemy.pheromoneTimer || 0) + cdrSpeed;
                            if (enemy.pheromoneTimer > 300 * cooldownMult) {
        spawnPheromoneMarker(enemy.x, enemy.y, enemy.angle, enemy.accuracy, enemy); // [수정]
        showPickupEffect(enemy.x, enemy.y - 30, "페로몬 발사!", false, false, "pink-text");
        enemy.pheromoneTimer = 0;
                            }
                        }
                        
                        if (enemy.isOzma) {
                            enemy.healPulseTimer = (enemy.healPulseTimer || 0) + cdrSpeed;
                            if (enemy.healPulseTimer > 240 * cooldownMult) {
                                let healedAny = false;
                                let healAmount = 15 + Math.floor(score * 0.12);
                                for (let ally of enemies) {
                                    if (ally !== enemy && ally.hp > 0) { 
                                        const dist = Math.hypot(enemy.x - ally.x, enemy.y - ally.y);
                                        if (dist < 250) {
                                            if (ally.hp < ally.maxHp) {
                                            let finalHeal = Math.floor(healAmount * (ally.hpRecoveryRate || 1));
                                            ally.hp = Math.min(ally.maxHp, ally.hp + finalHeal);
                                            ally.erectionStacks = Math.min(ally.erectionStacks + 1, 20);
                                            showDamageText(ally.x, ally.y, "+" + finalHeal, false, false, 'heal-text');
                                            healedAny = true;
                                           }
                                        }
                                    }
                                }
                                if (healedAny) {
                                    showPickupEffect(enemy.x, enemy.y - 30, "치유♥", false, false, "heal-text");
                                }
                                enemy.healPulseTimer = 0;
                            }
                            
                            enemy.pleasureZoneTimer = (enemy.pleasureZoneTimer || 0) + cdrSpeed;
                            if (enemy.pleasureZoneTimer > 480 * cooldownMult) {
        spawnPleasureZone(player.x, player.y, enemy.accuracy, enemy); // [수정]
        showPickupEffect(enemy.x, enemy.y - 50, "밟아볼래♥", false, false, "pink-text");
        enemy.pleasureZoneTimer = 0;
                            }
                            


                            // [신규] 방구 스모그 (쿨타임 8초) - 플레이어에게 갈색 방구 구름 발사
                            enemy.fartSmogTimer = (enemy.fartSmogTimer || 0) + cdrSpeed;
                            if (enemy.fartSmogTimer > 480 * cooldownMult) {
                                spawnFartSmog(enemy.x, enemy.y, enemy.accuracy || 0, enemy);
                                showPickupEffect(enemy.x, enemy.y - 45, "방구 스모그!", false, false, "poop-text");
                                enemy.fartSmogTimer = 0;
                            }

                            // 비석 소환 타이머
                        enemy.monolithSummonTimer = (enemy.monolithSummonTimer || 0) + cdrSpeed;
        
                        if (enemy.monolithSummonTimer >= 1020) {
            // 플레이어 주변 랜덤한 위치에 소환
            const angle = Math.random() * Math.PI * 2;
            const dist = 150 + Math.random() * 150; // 150~300 거리
            const mx = player.x + Math.cos(angle) * dist;
            const my = player.y + Math.sin(angle) * dist;
            
            // 맵 밖으로 나가지 않게 보정
            const finalX = Math.max(50, Math.min(canvas.width - 50, mx));
            const finalY = Math.max(50, Math.min(canvas.height - 50, my));
            
            spawnMonolith(finalX, finalY, enemy.accuracy, enemy);
            
            enemy.monolithSummonTimer = 0;
        }

                            enemy.darkBlessingTimer = (enemy.darkBlessingTimer || 0) + cdrSpeed;
                            if (enemy.darkBlessingTimer > 420 * cooldownMult) {
                                let blessed = false;
                                for (let ally of enemies) {
                                    if (ally !== enemy) { 
                                        const dist = Math.hypot(enemy.x - ally.x, enemy.y - ally.y);
                                        if (dist < 600) {
                                            ally.hasShield = true;
                                            blessed = true;
                                        }
                                    }
                                }
                                if (blessed) {
                                    showPickupEffect(enemy.x, enemy.y - 50, "단단해져라♥", false, false, "evil-purple-text");
                                }
                                enemy.darkBlessingTimer = 0;
                            }
                        }
                        
                        if (enemy.gasTimer > currentGasInterval) {
                            if (enemy.isCassias) {
                                spawnGas(enemy.x, enemy.y, true, false, 1, 2, enemy.accuracy, enemy);
                                spawnPoop(enemy.x, enemy.y, { isElite: true, sizeMult: 2, speedMin: 0.50, speedMax: 2.0, accuracy: enemy.accuracy, owner: enemy });
                                enemy.dashTimer = 30; enemy.dashVx = Math.cos(enemy.angle) * 6; enemy.dashVy = Math.sin(enemy.angle) * 6;
                                showPickupEffect(enemy.x, enemy.y - 40, "뿌우욱♥", false, true, "dirty-brown-text");
                                enemy.gasTimer = 0;
                            } else if (!enemy.isRyuon && !enemy.isLuca && !enemy.isOzma && !enemy.isTaro && !enemy.isGawain && !enemy.isAki && !enemy.isHiro && !enemy.isJacques && !enemy.isKai) {
                                spawnGas(enemy.x, enemy.y, enemy.isElite, enemy.isZako, 0, 1, enemy.accuracy, enemy);
                                enemy.x -= enemy.vx * 5; enemy.y -= enemy.vy * 5;
                                enemy.gasTimer = 0;
                            }
                        }

                        enemy.whiteShotTimer += cdrSpeed;
                        const shotInterval = (enemy.isElite ? 180 : 300) * cooldownMult;
                        if (enemy.whiteShotTimer > shotInterval) {
                            const canUseWhiteShot = enemy.isElite
                                ? enemy.isCassias
                                : (!enemy.isLuca && !enemy.isAgent && !enemy.isGawain && !enemy.isAki && !enemy.isHiro);

                            if (canUseWhiteShot) {
                                spawnWhiteShot(enemy.x, enemy.y, enemy.isElite, false, 0, false, enemy.accuracy, enemy);
                            }
                            enemy.whiteShotTimer = 0;
                        }

                        if (enemy.isDarkDenizen && enemy.denizenType === 'louie') {
                            enemy.darkHeartTimer += cdrSpeed;
                            if (enemy.darkHeartTimer > 300) { spawnDarkHeart(enemy.x, enemy.y, enemy.accuracy, enemy); enemy.darkHeartTimer = 0; }
                        }

                        if (enemy.isElite) {
                            if (enemy.isCassias) {
                                enemy.bigPoopTimer += cdrSpeed;
                                enemy.homingPoopTimer = (enemy.homingPoopTimer || 0) + cdrSpeed;
                                enemy.homingSemenTimer = (enemy.homingSemenTimer || 0) + cdrSpeed;

                                if (enemy.bigPoopTimer > 180 * cooldownMult) {
                                    spawnBigPoop(enemy.x, enemy.y, enemy.accuracy, enemy);
                                    enemy.bigPoopTimer = 0;
                                }
                                if (enemy.homingPoopTimer > 300 * cooldownMult) {
                                    spawnHomingBigPoop(enemy.x, enemy.y, enemy.accuracy, enemy);
                                    enemy.homingPoopTimer = 0;
                                }
                                if (enemy.homingSemenTimer > 420 * cooldownMult) {
                                    spawnHomingSemen(enemy.x, enemy.y, enemy.accuracy, enemy);
                                    showPickupEffect(enemy.x, enemy.y - 40, "유도 정액!", false);
                                    enemy.homingSemenTimer = 0;
                                }
                            }

                            if (!enemy.isCassias && !enemy.isSummoned && !enemy.isBoss && !enemy.isRyuon && !enemy.isLuca && !enemy.isOzma && !enemy.isTaro && !enemy.isGawain && !enemy.isAki && !enemy.isHiro && !enemy.isKai && !enemy.isJacques) {
                                enemy.darkDenizenSummonTimer = (enemy.darkDenizenSummonTimer || 0) + cdrSpeed;
                                if (!enemy.hasSummonedDenizen && enemy.darkDenizenSummonTimer > 240) { 
                                    spawnDarkDenizen(enemy.x + 40, enemy.y, 'louie');
                                    spawnDarkDenizen(enemy.x - 40, enemy.y, 'rai');
                                    showPickupEffect(enemy.x, enemy.y - 80, "어둠이여..", false, false, "evil-summon-text");
                                    darkDenizenSummonAudio.currentTime = 0;
                                    darkDenizenSummonAudio.play().catch(()=>{});
                                    enemy.darkDenizenSummonTimer = 0;
                                    enemy.hasSummonedDenizen = true; 
                                }
                            }
                        }

                        if (!enemy.isElite) {
                            if (enemy.normalType !== 'rapist' && !enemy.isDarkDenizen && !enemy.isAgent) { 
                                enemy.summonTimer += cdrSpeed;
                                if (enemy.summonTimer > 600) {
                                    if (enemy.eliteType === 1) { spawnZako(enemy.x + 30, enemy.y, 'terrorist'); spawnZako(enemy.x - 30, enemy.y, 'terrorist'); } 
                                    else if (enemy.eliteType === 2) { spawnZako(enemy.x + 30, enemy.y, 'plague'); spawnZako(enemy.x - 30, enemy.y, 'plague'); } 
                                    else { spawnZako(enemy.x + 30, enemy.y); spawnZako(enemy.x - 30, enemy.y); }
                                    enemy.summonTimer = 0; 
                                    
                                    let summonText = "덮쳐주마♥";
                                    if (enemy.eliteType === 1) summonText = "좀 비릴거야♥";
                                    else if (enemy.eliteType === 2) summonText = "냄새에 파뭍혀라♥";
                                    showPickupEffect(enemy.x, enemy.y - 40, summonText, false, false, "evil-summon-text");
                                }
                            }
                        }
                    }
                }
                
                if (enemy.hp <= 0) {
                      let xpAmount = 1; // 기본 자코
                        if (enemy.isElite) xpAmount = 25;
                        if (enemy.isRoyal) xpAmount = 75;
                        if (enemy.isBoss) xpAmount = 120;
                        if (enemy.isAgent) xpAmount = 5;
                        if (enemy.isArchdemon && enemy.archdemonName && (enemy.archdemonName.includes('아키토') || enemy.archdemonName.includes('토우야'))) xpAmount = 35;
                        
                        let timeBonus = Math.floor(score / 10) * 2.4;
                        xpAmount += timeBonus;
                        gainXp(xpAmount); // 경험치 획득 함수 호출

                      if (enemy.isBoss && !enemy.isArchdemon) {
                         player.bonusAccuracy += 0.01;
                         player.bonusEvasion += 0.01;
                         showPickupEffect(player.x, player.y - 50, "명중/회피 +1% 상승!", true, true, "goddess-text");
                     }
                    let atkBonus = 0;
                    let hpBonus = 0;
                    let healAmount = 0;

                    if (enemy.isArchdemon) { atkBonus = 0.8; hpBonus = 5; healAmount = player.maxHealth * 0.01; } 
                    else if (enemy.isBoss) { atkBonus = 2.5; hpBonus = 6; healAmount = player.maxHealth * 0.01; } 
                    else if (enemy.isRoyal) { atkBonus = 1.5; hpBonus = 5.5; healAmount = player.maxHealth * 0.01; }
                    else if (enemy.isDarkDenizen) { atkBonus = 0.3; hpBonus = 2; healAmount = player.maxHealth * 0; } 
                    else if (enemy.isElite) { atkBonus = 0.6; hpBonus = 4; healAmount = player.maxHealth * 0.01; } 
                    else if (enemy.isZako) { atkBonus = 0.05; hpBonus = 0.4; healAmount = 0; } 
                    else if (enemy.isAgent) { atkBonus = 0.2; hpBonus = 1.5; healAmount = player.maxHealth * 0; } 
                    else { atkBonus = 0.2; hpBonus = 1.5; healAmount = player.maxHealth * 0; }
                    let reductionFactor = Math.min(0.5, score * 0.0005);
                    let multiplier = 1 - reductionFactor;
                    atkBonus *= multiplier;
                    hpBonus *= multiplier;

                    if (!enemy.isZako) { killCount++; killVal.innerText = killCount; }
                    if (hasEquippedNamedGear('피의 거래 흉갑') && Math.random() < 0.10) {
                        player.health = Math.min(player.maxHealth, player.health + player.maxHealth * 0.03);
                        updateHealthUI();
                    }

                    if (healAmount > 0) { 
                        // [신규] 군주의 위엄 (처치 회복량 10% 감소)
                        if (player.majestyActive) {
                            healAmount *= 0.9;
                        }
                        player.health = Math.min(player.maxHealth, player.health + healAmount); 
                        updateHealthUI(); 
                    }

                    if (atkBonus > 0) { player.weapon.baseDamage += atkBonus; player.weapon.damage = player.weapon.baseDamage; }

                    if (hpBonus > 0) { player.baseMaxHealth += hpBonus; updateMaxHealth(); }

                    if (enemy.archdemonName && enemy.archdemonName.includes('토우야')) {
                        const stacksToRemove = enemy.appliedEvilLightCount || 0;
                        if (stacksToRemove > 0 && player.evilLightTimers.length > 0) {
                            const removeCount = Math.min(stacksToRemove, player.evilLightTimers.length);
                            player.evilLightTimers.splice(-removeCount, removeCount); 
                        }
                        updateMaxHealth(); updateStatusUI();
                        showPickupEffect(player.x, player.y - 50, "어둠이여 영원하라..", false, true, "evil-purple-text");
                    }
                    
                    if (enemy.isRyuon) {
                         player.corruptedOathStacks = Math.max(0, player.corruptedOathStacks - 1);
                         updateStatusUI();
                         showPickupEffect(player.x, player.y - 50, "맹세한다..", false, true);
                    }
                    if (enemy.isLuca) {
                         player.dangerousJudgmentStacks = Math.max(0, player.dangerousJudgmentStacks - 1);
                         updateStatusUI();
                         showPickupEffect(player.x, player.y - 50, "판단력이 돌아온다", false, true);
                    }
                    if (enemy.isOzma) {
                         player.deepDarknessStacks = Math.max(0, player.deepDarknessStacks - 1);
                         updateStatusUI();
                         showPickupEffect(player.x, player.y - 50, "어둠이 걷힌다", false, true);
                    }
                    if (enemy.isAki) {
                        activeAkiCount = Math.max(0, activeAkiCount - 1);
                        showPickupEffect(player.x, player.y - 50, "어둠의 기세가 꺾인다", false, true);
                    }
                    if (enemy.isJacques) {
                    // 신성 모독: 5초 (300프레임)
                    // 상태이상 방어막 무시 (checkShieldBlockStatus 호출 안함)
                    addStatus('blasphemy', 300, 1);
                    showPickupEffect(player.x, player.y, "신성 모독!!", false, true, "corrupted-text");
                }
                    if (enemy.isGawain) {
                        player.corruptedJusticeStacks = Math.max(0, player.corruptedJusticeStacks - 1);
                        updateStatusUI();
                        showPickupEffect(player.x, player.y - 50, "정의가 회복된다!", false, true);
                    }
                    if (enemy.isHiro) {
                        const remainingHiro = enemies.some(e => e !== enemy && e.isHiro && e.hp > 0);

                        if (!remainingHiro) {
                        player.skillSealTimer = 0;
                        skillSealOverlay.style.display = 'none';
                        showPickupEffect(player.x, player.y - 50, "방해 전파 차단!", false, true);
                    }
                }    
                    
                    if (enemy.isKai) {
                        items = items.filter(item => item.type !== 'fakeHealth');
                        showPickupEffect(player.x, player.y - 50, "환영이 사라졌다..", false, true);
                    }
                    if (enemy.isAkiClone) {
                        spawnDarkGas(enemy.x, enemy.y, 3.5, 1.2, enemy.accuracy, 0, enemy); // 3.5배 크기
                        showPickupEffect(enemy.x, enemy.y, "부루룩♥", false, true, "darkness-border");
                        spawnDarkBigPoop(enemy.x, enemy.y, false, 0, true, enemy.accuracy, enemy);

                    }
                 

                    if (enemy.isArthur) {
                        const remainingArthur = enemies.some(e => e !== enemy && e.isArthur && e.hp > 0);
                        if (!remainingArthur) {
                        player.majestyActive = false;
                        updateStatusUI();
                        showPickupEffect(player.x, player.y - 50, "군주의 위엄이 사라졌다..", false, true, "majesty-border");
                    }
               }
               // [신규] 전리품 드랍 -> 인벤토리 자동 저장
               handleLootDrop(enemy);
                    handleEquipmentDrop(enemy);

               // [NEW] 유물 특수 효과: 적 처치 트리거(장착 시)
               if (typeof relicOnEnemyKilled === 'function') relicOnEnemyKilled(enemy);

               // 적 처치 아이템 드랍 (확률 조정)
               // HP회복(health) 3% / 상태이상 방어막(shield) 5% / 상태이상 회복(white) 4% / 저스티스 실드(justice) 5% / 버서크(berserk) 3%
               // magnet 1% (기존 유지)
               const itemRoll = Math.random();
               if (itemRoll < 0.05) { spawnDroppedItem(enemy.x, enemy.y, 'shield'); }
               else if (itemRoll < 0.08) { spawnDroppedItem(enemy.x, enemy.y, 'health'); }
               else if (itemRoll < 0.13) { spawnDroppedItem(enemy.x, enemy.y, 'justice'); }
               else if (itemRoll < 0.17) { spawnDroppedItem(enemy.x, enemy.y, 'white'); }
               else if (itemRoll < 0.20) { spawnDroppedItem(enemy.x, enemy.y, 'berserk'); }
               else if (itemRoll < 0.21) { spawnDroppedItem(enemy.x, enemy.y, 'magnet'); }
                    // [신규] 고대의 두루마리: 적 처치 시 1% 확률 드랍 (+ 유물: 종말의 예언)
                    const baseScrollChance = 0.01;
                    let scrollChance = baseScrollChance;
                    if (typeof isRelicEquipped === 'function' && isRelicEquipped('end_prophecy')) {
                        // 설명대로 '일반' 적 처치에만 추가 보정
                        if (!enemy.isElite && !enemy.isRoyal && !enemy.isBoss) scrollChance += 0.01;
                    }
                    if (Math.random() < scrollChance) {
                        spawnDroppedItem(enemy.x, enemy.y, 'ancientScroll');
                    }

                    if (!enemy.isZako) { spawnDeathCloud(enemy.x, enemy.y, enemy.isElite, enemy.isBoss, enemy.accuracy, enemy); }

                    enemies.splice(i, 1); 
                    continue;
                }
                
                if (enemy.hitFlash > 0) enemy.hitFlash--;

                const dist = Math.hypot(player.x - enemy.x, player.y - enemy.y);
                if (dist < player.radius + enemy.radius) {
                    
                    if (player.bodyHitCooldown <= 0) {
                    if ((!enemy.isElite && enemy.normalType === 'rapist') || (enemy.isDarkDenizen && enemy.denizenType === 'rai')) {
                        if (!enemy.isAttached) {
                            enemy.isAttached = true; enemy.attachTimer = 0; enemy.isStealth = false; enemy.alpha = 1.0;
                            showPickupEffect(player.x, player.y, "잡았다♥", false, true, "evil-purple-text");
                            if (enemy.isDarkDenizen && enemy.denizenType === 'rai') { raiAttachAudio.currentTime = 0; raiAttachAudio.play().catch(()=>{}); } 
                            else { rapistAttachAudio.currentTime = 0; rapistAttachAudio.play().catch(()=>{}); }
                        }
                    } else {
                        if (player.invincibleTimer <= 0) {
                            let dmg = 0;
                                if (enemy.isBoss) dmg = 25; else if (enemy.isElite) dmg = 15; else if (enemy.isRoyal) dmg = 20; else dmg = 8; 
                                if (enemy.isBoss) dmg *= 1.25; else if (enemy.isElite) dmg *= 1.25; else if (enemy.isRoyal) dmg *= 1.25; else dmg *= 1.25;
                                dmg *= 0.25; dmg += Math.floor(score * 0.2); dmg *= 0.5; dmg *= 3;

                                if (enemy.isMasakuni && enemy.nextAttackCrit) {
                                dmg *= 1.5; // 치명타 2배
                                enemy.nextAttackCrit = false; // 소모
                                showPickupEffect(player.x, player.y, "심안 치명타!!", false, true, "masakuni-text");
                            }
                                if (enemy.isRyuon) {
                                    dmg += 1.5;
                                if (enemy.chargeState === 'charging') {
                                    dmg += 20;
    }
                                }
                                
                                if (enemy.isTaro) {
                                    dmg += 1.5; 
                                }

                                if (enemy.zakoType === 'terrorist') {
                                    dmg = 10; let applied = 0;
                                    for(let k=0; k<5; k++) { if(!checkShieldBlockStatus('normal', 'fishy')) { addStatus('fishy', 900, 50); applied++; } }
                                    if(applied > 0) showPickupEffect(player.x, player.y, "자멘샤워♥", false, true, "condensed-milk-text");
                                    showPickupEffect(enemy.x, enemy.y, "뷰르릇..받아라♥", false, true, "condensed-milk-text");
                                } else if (enemy.zakoType === 'plague') {
                                    dmg = 10; let applied = 0;
                                    for(let k=0; k<5; k++) { if (!checkShieldBlockStatus('normal', 'malice')) { addStatus('malice', 900, 20); applied++; } }
                                    if(applied > 0) showPickupEffect(player.x, player.y, `악의의 바이러스 +${applied}!`, false, true);
                                    showPickupEffect(enemy.x, enemy.y, "감염♥", false, true, "evil-purple-text");
                                }

                                takeDamage(dmg, 'direct', enemy.accuracy, enemy);

                            if (Math.random() < 0.05) {
                                if (!checkShieldBlockStatus('normal', 'malice')) addStatus('malice', 900, 20);
                            }
                            }
                            
                            if (enemy.isZako && enemy.state === 'pouncing' && enemy.hp > 0) {
                                if (!enemy.zakoType) { 
                                    let applied = 0; for(let k=0; k<2; k++) { if (!checkShieldBlockStatus('normal', 'byururut')) { addStatus('byururut', 900, 9999); applied++; } }
                                    if(applied > 0) showPickupEffect(player.x, player.y, `뷰루룻♡ +${applied}`, false, true, "condensed-milk-text");
                                }
                                enemy.state = 'cooldown'; enemy.cooldownTimer = 120;
                                const angle = Math.atan2(player.y - enemy.y, player.x - enemy.x); enemy.x -= Math.cos(angle) * 50; enemy.y -= Math.sin(angle) * 50;
                            }
                            
                            player.bodyHitCooldown = 48;
                        }
                    }
                    
                    if (!(enemy.normalType === 'rapist') && !(enemy.isDarkDenizen && enemy.denizenType === 'rai')) {
                        if (enemy.contactStackTimer <= 0) {
                            let gained = false;
                           if (enemy.isBoss) { 
                              enemy.erectionStacks = Math.min(enemy.erectionStacks + 1, 20); // 한 번에 1스택 상승
                              enemy.contactStackTimer = 19; // 50% 더 빠른 중첩 속도
                              gained = true; 
                            } 
                            else if (!enemy.zakoType) { 
                                      enemy.erectionStacks = Math.min(enemy.erectionStacks + 1, 20); // 한 번에 1스택 상승
                                      enemy.contactStackTimer = 19; // 50% 더 빠른 중첩 속도
                                      gained = true; 
                            }
                            
                            if (gained) { 
                                showPickupEffect(enemy.x, enemy.y, "뷰르릇♥", false, true, "condensed-milk-text"); 
                                if (enemy.isTaro) {
                                    if (!checkShieldBlockStatus('normal', 'semen')) {
                                        addStatus('semen', 900, 30);
                                    }
                                }
                            }
                            
                            if (enemy.isBoss && enemy.bossType === 4) { addStatus('darkReceiver', 900, 20); }

                            if (enemy.isArchdemon) {
                                 addStatus('darkKiss', 900, 20); addStatus('darkReceiver', 900, 20); addStatus('darkSeed', 900, 20); 
                                 showPickupEffect(player.x, player.y, "츄르릅♥", false, true, "pink-text");
                            }
                        }
                    }

                    if (player.bodyHitCooldown === 30 && !(enemy.normalType === 'rapist') && !enemy.zakoType && !(enemy.isDarkDenizen && enemy.denizenType === 'rai')) { 
                        if (player.vx !== 0 || player.vy !== 0) {
                            const dx = enemy.x - player.x; const dy = enemy.y - player.y; const dotProduct = (player.vx * dx) + (player.vy * dy);
                            
                            let stacksToAdd = 1; if (enemy.isElite || enemy.isZako) { stacksToAdd = 2; }

                            if (dotProduct > 0) { 
                                // [수정] 정면 충돌: 아서가 아닌 보스(카인)만 카인의 키스 발동
                                if (enemy.isBoss && !enemy.isArthur) {
                                   addStatus('darkKiss', 900, 20); showPickupEffect(player.x, player.y, "카인과 딥키스..!", true);
                                } 
                                // 아서를 포함한 나머지 적들은 일반 속박 키스 발동
                                else if (player.kissTimers.length < 30) { 
                                    for(let k=0; k<stacksToAdd; k++) { if (!checkShieldBlockStatus('normal', 'kiss')) { addStatus('kiss', 900, 30); } }
                                }
                                
                                // [수정] 구내사정: 보스가 아니거나, 보스여도 아서라면 발동
                                if ((!enemy.isBoss || enemy.isArthur) && 
                                    player.oralTimers.length < 30 && player.oralCooldown <= 0) { 
                                    for(let k=0; k<stacksToAdd; k++) { if (!checkShieldBlockStatus('normal', 'oral')) { addStatus('oral', 900, 30); } }
                                    player.oralCooldown = 48;
                                }

                            } else { 
                                // [수정] 후면 충돌: 아서가 아닌 보스(카인)만 카인의 좆집 발동
                                if (enemy.isBoss && !enemy.isArthur) {
                                   addStatus('darkReceiver', 900, 20); addStatus('darkSeed', 900, 20); player.darkReceiverCooldown = 60; showVillainSpeech(enemy.x, enemy.y, "카인의 정자 주입♥");
                                } 
                                // 아서를 포함한 나머지 적들은 일반 질내사정(점액) + 뷰루룻 동시 발동
                                else { 
                                    // 1) 기존 점액(semen) 유지
                                    if (player.semenTimers.length < 30 && player.semenCooldown <= 0) { 
                                        for(let k=0; k<stacksToAdd; k++) { if (!checkShieldBlockStatus('normal', 'semen')) { addStatus('semen', 900, 30); } }
                                        player.semenCooldown = 48;
                                    }
                                    // 2) 뷰루룻(byururut)도 함께 부여
                                    if (player.byururutTimers.length < 30 && player.byururutCooldown <= 0) { 
                                        for(let k=0; k<stacksToAdd; k++) { if (!checkShieldBlockStatus('normal', 'byururut')) { addStatus('byururut', 900, 30); } }
                                        player.byururutCooldown = 48;
                                    }
                                }
                            }
                        }
                    }
                }
            
        // [패치] 히로 '안티 패싱' 차지 중: 이동/대시 완전 금지
        if (enemy.isHiro && enemy.antiPassingCharging) {
            enemy.x = _preX;
            enemy.y = _preY;
            enemy.vx = 0;
            enemy.vy = 0;
            enemy.dashTimer = 0;
            enemy.dashVx = 0;
            enemy.dashVy = 0;
            enemy.moveDashDuration = 0;
        }
}
            
            const prevHyper = player.hasHypersensitivity;
            player.hasHypersensitivity = taroExists;
            if (prevHyper !== player.hasHypersensitivity) updateStatusUI();
            
            player.geoptalCount = attachedRapistCount;
            if (player.geoptalCount > 0) updateStatusUI();

        }

        function draw() {
            ctx.fillStyle = '#c0c0c0'; 
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            poopStains.forEach(stain => {
                ctx.save(); ctx.translate(stain.x, stain.y); 
                const alpha = Math.min(0.8, stain.life / 60);
                
                if (stain.puffs) {
                    stain.puffs.forEach(p => {
                        ctx.beginPath();
                        ctx.arc(p.dx, p.dy, p.r, 0, Math.PI * 2);
                        const gradient = ctx.createRadialGradient(p.dx, p.dy, 0, p.dx, p.dy, p.r);
                        gradient.addColorStop(0, `rgba(90, 50, 10, ${alpha * 0.8})`); 
                        gradient.addColorStop(0.5, `rgba(70, 40, 5, ${alpha * 0.5})`);
                        gradient.addColorStop(1, `rgba(60, 30, 5, 0)`);
                        ctx.fillStyle = gradient;
                        ctx.fill();
                    });
                } else {
                    ctx.fillStyle = `rgba(90, 50, 10, ${alpha})`;
                    ctx.beginPath(); ctx.ellipse(0, 0, stain.radius * 1.5, stain.radius, 0, 0, Math.PI * 2); ctx.fill();
                }
                
                if (stain.life > 0) {
                    ctx.strokeStyle = 'rgba(139, 69, 19, 0.4)'; ctx.lineWidth = 1.5;
                    const time = Date.now() / 300;
                    for(let i=0; i<3; i++) {
                        ctx.beginPath();
                        const startX = (i - 1) * 20; const startY = -stain.radius * 0.5 + Math.sin(time + i) * 8;
                        ctx.moveTo(startX, startY); ctx.quadraticCurveTo(startX + 10, startY - 20, startX, startY - 40);
                        ctx.stroke();
                    }
                }
                ctx.restore();
            });
            
            darkWaves.forEach(w => {
                ctx.save();
                ctx.translate(w.x, w.y);
                ctx.rotate(w.rotation);
                
                const gradient = ctx.createLinearGradient(0, -w.radius, 0, w.radius);
                gradient.addColorStop(0, 'rgba(139, 0, 0, 0)');
                gradient.addColorStop(0.5, 'rgba(139, 0, 0, 0.8)');
                gradient.addColorStop(1, 'rgba(139, 0, 0, 0)');
                
                ctx.fillStyle = gradient;
                
                ctx.beginPath();
                ctx.arc(-20, 0, w.radius * 1.5, -Math.PI/3, Math.PI/3);
                ctx.arc(0, 0, w.radius, Math.PI/3, -Math.PI/3, true);
                ctx.fill();
                if (Math.random() < 0.5) { // 50% 확률로 프레임마다 번쩍임
                ctx.strokeStyle = '#8B0000'; // 검붉은색 (DarkRed)
                ctx.lineWidth = 2;
                ctx.shadowBlur = 10;
                ctx.shadowColor = '#DC143C'; // 붉은 광채 (Crimson)
                ctx.lineCap = 'round';
        
                ctx.beginPath();
             // 웨이브를 가로지르는 지그재그 전류
                let currentX = -w.radius;
                let currentY = (Math.random() - 0.5) * 20;
                ctx.moveTo(currentX, currentY);
        
                for(let k=0; k<5; k++) {
                currentX += (w.radius * 2 / 5);
                currentY += (Math.random() - 0.5) * 30; // Y축으로 랜덤하게 튐
                ctx.lineTo(currentX, currentY);
        }
        ctx.stroke();
        ctx.shadowBlur = 0; // 그림자 초기화
    }
                
                ctx.restore();
            });
            
            jammingWaves.forEach(w => {
                ctx.save();
                ctx.translate(w.x, w.y);
                ctx.rotate(w.angle);
                
                // [수정] 지지직거리는 전파 방해 이펙트
                // 1. 스타일: 형광 보라색 글로우 + 밝은 심지
                ctx.shadowColor = '#d000ff'; // 밝은 마젠타 글로우
                ctx.shadowBlur = 15;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';

                // 2. 여러 겹의 파동 그리기 (볼륨감)
                const layers = 3; // 파동의 겹 수
                
                for (let k = 1; k <= layers; k++) {
                    ctx.beginPath();
                    
                    // 안쪽일수록 진하고, 바깥쪽일수록 얇게
                    ctx.lineWidth = (layers - k + 1) * 1.5; 
                    
                    // 색상: 안쪽은 흰색에 가깝게, 바깥쪽은 보라색
                    if (k === 1) ctx.strokeStyle = '#FFFFFF';
                    else if (k === 2) ctx.strokeStyle = '#E0B0FF'; // 연보라
                    else ctx.strokeStyle = '#8A2BE2'; // 보라

                    // 파동의 반지름 (점점 커짐)
                    const baseRadius = w.radius * (k / 1.5);
                    
                    // 지지직거리는 노이즈 라인 생성
                    // -Math.PI/2 ~ Math.PI/2 (반원 형태)
                    const segments = 20; // 쪼개는 횟수
                    for (let j = 0; j <= segments; j++) {
                        const angle = -Math.PI / 2 + (Math.PI * j / segments);
                        
                        // 랜덤 지터(Jitter)로 지지직 효과 연출
                        // 매 프레임마다 모양이 바뀜
                        const jitter = (Math.random() - 0.5) * 15; 
                        const r = baseRadius + jitter;
                        
                        const px = Math.cos(angle) * r;
                        const py = Math.sin(angle) * r;
                        
                        if (j === 0) ctx.moveTo(px, py);
                        else ctx.lineTo(px, py);
                    }
                    ctx.stroke();
                }
                
                // 3. 중심부 스파크 (전기 튀는 효과)
                ctx.shadowBlur = 0;
                ctx.fillStyle = "#FFFFFF";
                for(let i=0; i<3; i++) {
                    const sparkAngle = (Math.random() - 0.5) * Math.PI; // 전방 부채꼴 내
                    const dist = Math.random() * w.radius;
                    const sx = Math.cos(sparkAngle) * dist;
                    const sy = Math.sin(sparkAngle) * dist;
                    ctx.beginPath();
                    ctx.arc(sx, sy, 2, 0, Math.PI*2);
                    ctx.fill();
                }

                ctx.restore();
            });
            
           neuroNeedles.forEach(n => {
                // 1. 녹색 최음 가스 트레일 그리기
                if (n.trail) {
                    n.trail.forEach(t => {
                        ctx.save();
                        ctx.translate(t.x, t.y);
                        const alpha = t.life / 20; // 서서히 사라짐
                        const r = t.size;
                        
                        // 녹색 가스 그라데이션
                        const gasGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, r);
                        gasGrad.addColorStop(0, `rgba(50, 205, 50, ${alpha * 0.8})`);   // LimeGreen
                        gasGrad.addColorStop(0.6, `rgba(0, 100, 0, ${alpha * 0.4})`);   // DarkGreen
                        gasGrad.addColorStop(1, `rgba(0, 50, 0, 0)`);                   // 투명
                        
                        ctx.fillStyle = gasGrad;
                        ctx.beginPath();
                        ctx.arc(0, 0, r, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.restore();
                    });
                }

                ctx.save();
                ctx.translate(n.x, n.y);
                ctx.rotate(n.angle);
                
                // 2. 볼륨감 있는 독바늘 본체 (원통형 그라데이션)
                const needleGrad = ctx.createLinearGradient(0, -4, 0, 4);
                needleGrad.addColorStop(0, '#4B0082');   // 위쪽: 어두운 보라
                needleGrad.addColorStop(0.4, '#E6E6FA'); // 중간: 밝은 하이라이트 (금속 질감)
                needleGrad.addColorStop(0.6, '#9370DB'); // 중간: 보라
                needleGrad.addColorStop(1, '#191970');   // 아래: 짙은 남색 그림자

                ctx.fillStyle = needleGrad;
                
                // 바늘 모양 패스
                ctx.beginPath();
                ctx.moveTo(15, 0);  // 앞 뾰족한 끝
                ctx.lineTo(-10, 4); // 뒤 아래
                ctx.lineTo(-10, -4); // 뒤 위
                ctx.closePath();
                ctx.fill();
                // 윤곽선(가시성 강화)
                ctx.lineWidth = 2.2;
                ctx.strokeStyle = 'rgba(0,0,0,0.78)';
                ctx.stroke();
// 3. 지지직 거리는 전기 이펙트
                if (Math.random() < 0.8) { // 80% 확률로 프레임마다 발생
                    ctx.strokeStyle = '#00FF00'; // 형광 연두색 전기
                    ctx.lineWidth = 1.5;
                    ctx.shadowColor = '#32CD32';
                    ctx.shadowBlur = 5;
                    ctx.beginPath();
                    
                    // 바늘 주변을 감싸는 랜덤 지그재그 선
                    let lx = -10;
                    let ly = 0;
                    ctx.moveTo(lx, ly);
                    for(let k=0; k<4; k++) {
                        lx += 7; 
                        ly = (Math.random() - 0.5) * 15; // 위아래로 튐
                        ctx.lineTo(lx, ly);
                    }
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                }

                ctx.restore();
            });
             
            

              pianissimoSnipes.forEach(p => {
    ctx.save();
    ctx.translate(p.x, p.y);
    ctx.globalAlpha = p.alpha;
    
    // 1. 사악한 검보라색 전류 이펙트
    if (Math.random() < 0.7) { // 70% 확률로 지직거림
        ctx.strokeStyle = Math.random() < 0.5 ? "#000000" : "#8A2BE2"; // 검정 또는 보라
        ctx.lineWidth = 2;
        ctx.shadowColor = "#4B0082";
        ctx.shadowBlur = 10;
        ctx.beginPath();
        
        // 전류 줄기 랜덤 생성
        for(let k=0; k<3; k++) {
            const angle = Math.random() * Math.PI * 2;
            const r = p.radius;
            ctx.moveTo(Math.cos(angle)*r*0.5, Math.sin(angle)*r*0.5);
            ctx.lineTo(Math.cos(angle)*r*1.8, Math.sin(angle)*r*1.8);
        }
        ctx.stroke();
    }

    // 2. 높은음자리표 본체
    ctx.shadowColor = "#4B0082"; // 인디고 글로우
    ctx.shadowBlur = 20;
    ctx.fillStyle = "black";
    ctx.font = "bold 60px serif"; // 크기 조절
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    
    // 흔들림 효과 (충전 중일 때 더 심하게)
    const shake = p.state === 'charging' ? 2 : 0;
    const dx = (Math.random() - 0.5) * shake;
    const dy = (Math.random() - 0.5) * shake;
    
    ctx.fillText("𝄞", dx, dy); // 높은음자리표 유니코드
    
    // 3. 내부 코어 (보라색 포인트)
    ctx.shadowBlur = 0;
    ctx.fillStyle = "#9370DB"; // MediumPurple
    ctx.font = "bold 55px serif";
    ctx.fillText("𝄞", dx, dy);

    ctx.restore();
});

            
             // [수정됨] 블러드 스웜 (피 장판) - 불규칙하고 입체적인 웅덩이
            bloodPuddles.forEach(p => {
                if (p.x === 0 && p.y === 0) return;
                ctx.save();
                ctx.translate(p.x, p.y);
                
                // 1. 입체감을 위한 방사형 그라데이션 (중앙은 밝고 외곽은 어둡게)
                const gradient = ctx.createRadialGradient(0, 0, p.radius * 0.2, 0, 0, p.radius);
                gradient.addColorStop(0, 'rgba(220, 20, 60, 0.9)');   // Crimson (중앙, 밝음)
                gradient.addColorStop(0.6, 'rgba(139, 0, 0, 0.8)');   // DarkRed (중간)
                gradient.addColorStop(1, 'rgba(50, 0, 0, 0)');        // 투명하게 퍼짐
                
                ctx.fillStyle = gradient;
                
                // 2. 불규칙한 원형 그리기 (Sin/Cos 파동을 이용해 울렁거리는 액체 표현)
                ctx.beginPath();
                const time = Date.now() / 200; // 시간 기반 애니메이션
                const vertices = 20; // 꼭짓점 개수
                
                for (let i = 0; i <= vertices; i++) {
                    const angle = (i / vertices) * Math.PI * 2;
                    
                    // 반지름을 불규칙하게 변형 (기본 반지름 + 파동)
                    // p.tickTimer 등을 이용해 웅덩이마다 다른 움직임을 줄 수도 있음
                    const noise = Math.sin(angle * 5 + time) * 5 + Math.cos(angle * 3 - time) * 5;
                    const r = p.radius + noise;
                    
                    const px = Math.cos(angle) * r;
                    const py = Math.sin(angle) * r;
                    
                    if (i === 0) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                }
                ctx.closePath();
                ctx.fill();

                // 3. 표면 광택 (액체 느낌 추가)
                ctx.globalAlpha = 0.4;
                ctx.fillStyle = '#FFaaaa';
                ctx.beginPath();
                ctx.ellipse(-p.radius * 0.3, -p.radius * 0.3, p.radius * 0.2, p.radius * 0.1, Math.PI / 4, 0, Math.PI * 2);
                ctx.fill();
                
                // 4. 외곽선 (끓어오르는 느낌)
                if (frameCount % 30 < 15) {
                    ctx.strokeStyle = 'rgba(255, 50, 50, 0.3)';
                    ctx.lineWidth = 3;
                    ctx.stroke();
                }

                ctx.restore();
            });

            groundCracks.forEach(crack => {
                ctx.save();
                ctx.translate(crack.x, crack.y);
                ctx.globalAlpha = crack.life / crack.maxLife;
                ctx.strokeStyle = '#3E2723'; 
                ctx.lineWidth = 4;
                
                for (let i = 0; i < 5; i++) {
                    ctx.save();
                    ctx.rotate((Math.PI * 2 / 5) * i);
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(15, 5);
                    ctx.lineTo(30, -5);
                    ctx.lineTo(50, 8);
                    ctx.lineTo(70, 0);
                    ctx.stroke();
                    ctx.restore();
                }
                
                ctx.fillStyle = '#1a0d00';
                ctx.beginPath();
                ctx.moveTo(-10, -5);
                ctx.lineTo(10, -5);
                ctx.lineTo(0, 20);
                ctx.fill();

                ctx.restore();
            });

            enemies.forEach(e => {
                // 기절 효과 그리기 (별)
                if (e.stunTimer > 0) {
                     ctx.save();
                     ctx.translate(e.x, e.y - e.radius - 20);
                     const time = Date.now() / 150;
                     for(let k=0; k<3; k++) {
                         const angle = (k / 3) * Math.PI * 2 + time;
                         const starX = Math.cos(angle) * 15;
                         const starY = Math.sin(angle) * 5;
                         ctx.fillStyle = "yellow";
                         ctx.beginPath();
                         ctx.arc(starX, starY, 3, 0, Math.PI*2);
                         ctx.fill();
                     }
                     ctx.restore();
                }

             if (e.isGawain && e.gawainSanctuaryActive > 0) {
                    ctx.save();
                    ctx.translate(e.x, e.y);
                    
                    const sanctuaryRadius = e.radius * 2.0; // 성역 크기
                    const time = Date.now() / 300; // 애니메이션 시간

                    // 1. [볼륨감] 반구형 돔 그라데이션 (입체적인 구체 느낌)
                    const domeGrad = ctx.createRadialGradient(0, 0, sanctuaryRadius * 0.2, 0, 0, sanctuaryRadius);
                    domeGrad.addColorStop(0, 'rgba(20, 0, 20, 0.1)');      // 중심부는 투명하게 (내부가 보이도록)
                    domeGrad.addColorStop(0.7, 'rgba(75, 0, 130, 0.4)');   // 가장자리는 짙은 보라
                    domeGrad.addColorStop(0.95, 'rgba(0, 0, 0, 0.8)');      // 외곽선 근처는 검정
                    domeGrad.addColorStop(1, 'rgba(148, 0, 211, 0.6)');     // 외곽선은 빛나는 보라

                    ctx.fillStyle = domeGrad;
                    ctx.beginPath();
                    ctx.arc(0, 0, sanctuaryRadius, 0, Math.PI * 2);
                    ctx.fill();

                    // 2. [최음 가스 효과] 성역 내부에서 소용돌이치는 가스 구름
                    const gasCount = 3; 
                    for (let k = 0; k < gasCount; k++) {
                        const angle = (Math.PI * 2 * k / gasCount) + time; // 회전함
                        const dist = sanctuaryRadius * 0.6 + Math.sin(time * 2 + k) * 20; // 안팎으로 움직임
                        
                        const gx = Math.cos(angle) * dist;
                        const gy = Math.sin(angle) * dist;
                        const gSize = 40 + Math.sin(time * 3 + k) * 10; // 크기 변화

                        // 가스 그라데이션 (검정 + 짙은 핑크/보라)
                        const gasGrad = ctx.createRadialGradient(gx, gy, 0, gx, gy, gSize);
                        gasGrad.addColorStop(0, 'rgba(0, 0, 0, 0.7)'); 
                        gasGrad.addColorStop(0.6, 'rgba(139, 0, 139, 0.5)'); // DarkMagenta
                        gasGrad.addColorStop(1, 'rgba(0, 0, 0, 0)');

                        ctx.fillStyle = gasGrad;
                        ctx.beginPath();
                        ctx.arc(gx, gy, gSize, 0, Math.PI * 2);
                        ctx.fill();
                    }

                    // [추가] 갈색의 냄새나는 더러운 수많은 방구 조각 가스들
                    const fartGasCount = 8;
                    for (let k = 0; k < fartGasCount; k++) {
                        // 위치 랜덤성 부여 (시간에 따라 부유하는 느낌)
                        const fAngle = (k * 137.5) + Math.sin(time * 0.8 + k) * 0.5; 
                        const fDist = (sanctuaryRadius * 0.7) * Math.abs(Math.sin(k * 1.1 + time * 0.3));
                        
                        const fx = Math.cos(fAngle) * fDist;
                        const fy = Math.sin(fAngle) * fDist;
                        const fSize = 25 + Math.sin(time * 2 + k) * 8; // 크기 펄럭임

                        // 더러운 갈색/똥색 그라데이션
                        const fartGrad = ctx.createRadialGradient(fx, fy, 0, fx, fy, fSize);
                        fartGrad.addColorStop(0, 'rgba(80, 50, 10, 0.9)');    // 진한 똥색
                        fartGrad.addColorStop(0.6, 'rgba(101, 67, 33, 0.6)'); // 갈색
                        fartGrad.addColorStop(1, 'rgba(60, 40, 0, 0)');       // 투명

                        ctx.fillStyle = fartGrad;
                        ctx.beginPath();
                        ctx.arc(fx, fy, fSize, 0, Math.PI * 2);
                        ctx.fill();
                    }

                    // [추가] 검정색 꾸물거리는 수많은 올챙이
                    const tadpoleCount = 10;
                    for (let k = 0; k < tadpoleCount; k++) {
                        // 성역 내부를 불규칙하게 회전
                        const tAngle = (k / tadpoleCount * Math.PI * 2) - (time * 1.5); 
                        // 거리는 사인파로 안팎 이동
                        const tDist = (sanctuaryRadius * 0.4) + (Math.sin(time * 4 + k * 10) * 30) + (k % 5) * 20;
                        const finalDist = Math.min(tDist, sanctuaryRadius * 0.9); // 성역 밖으로 안 나가게 제한

                        const tx = Math.cos(tAngle) * finalDist;
                        const ty = Math.sin(tAngle) * finalDist;

                        ctx.save();
                        ctx.translate(tx, ty);
                        ctx.rotate(tAngle + Math.PI / 2); // 진행 방향 바라보기

                        // 올챙이 머리
                        ctx.fillStyle = 'black';
                        ctx.beginPath();
                        ctx.arc(0, 0, 3.5, 0, Math.PI * 2);
                        ctx.fill();

                        // 올챙이 꼬리 (빠르게 꾸물거림)
                        ctx.strokeStyle = 'black';
                        ctx.lineWidth = 1.5;
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        const tailWiggle = Math.sin(time * 20 + k) * 4; // 꼬리 흔들림
                        ctx.quadraticCurveTo(0, 5, tailWiggle, 10);
                        ctx.stroke();

                        ctx.restore();
                    }

                    // 3. [테두리 이펙트] 바닥의 마법진 링 (회전)
                    ctx.save();
                    ctx.rotate(-time * 0.5); // 반대 방향 회전
                    ctx.strokeStyle = '#8A2BE2'; // BlueViolet
                    ctx.lineWidth = 3;
                    ctx.setLineDash([]);
                    ctx.beginPath();
                    ctx.arc(0, 0, sanctuaryRadius, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.restore();

                    // 4. [전류] 가끔씩 튀는 검은 전류
                    if (Math.random() < 0.3) {
                        ctx.strokeStyle = 'black';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        const startAngle = Math.random() * Math.PI * 2;
                        const r = sanctuaryRadius;
                        ctx.moveTo(Math.cos(startAngle) * r, Math.sin(startAngle) * r);
                        ctx.lineTo(Math.cos(startAngle + 0.5) * r * 0.8, Math.sin(startAngle + 0.5) * r * 0.8);
                        ctx.stroke();
                    }

                    ctx.restore();
                }
    });

            
            antiPassingTentacles.forEach(t => {
                _ensureAntiPassingAssets();

                ctx.save();
                ctx.translate(t.x, t.y);

                // radius가 커지면 비주얼도 같이 커지도록 스케일 적용
                const _apBaseR = 42;
                const _apScale = Math.max(0.2, (t.radius || _apBaseR) / _apBaseR);

                // 텔레그래프(그림자) 강도/맥동
                const _apWarnDen = Math.max(1, (t.hitDelay || t.riseDuration || 30));
                const _apWarnT = Math.min(1, (t.frame || 0) / _apWarnDen);
                const _apPulse = 0.94 + 0.06 * Math.sin(frameCount * 0.28 + (t.x + t.y) * 0.01);
                const _apLifeF = Math.min(1, (t.life || 0) / (t.maxLife || 72));

                // [텔레그래프] 촉수 실루엣(방향/길이) - 캐시 텍스처를 스케일/회전해서 그려 퍼포먼스 개선
                const _apDir = (typeof t.baseAngle === 'number') ? t.baseAngle : (-Math.PI / 2);
                const _apR = (t.radius || _apBaseR);
                const _apLen = _apR * (2.4 + 0.9 * _apWarnT) * _apPulse;
                const _apW = _apR * (1.00 + 0.15 * _apWarnT);

                const _apA = Math.min(0.98, (0.60 + 0.70 * _apWarnT) * (0.70 + 0.30 * _apLifeF));

                ctx.save();
                ctx.translate(0, 12 * _apScale);
                ctx.scale(1, 0.55); // 바닥 실루엣 느낌(납작하게)
                ctx.rotate(_apDir);
                ctx.globalAlpha = _apA;
                ctx.drawImage(_apTeleTex, 0, -_apTeleTex.height / 2, _apLen, _apW);
                ctx.restore();

                // [변경] 그림자 경고 동안엔 촉수/가스는 숨김(완전 지면 아래)
                const rise = (t.riseProgress || 0);
                if (rise <= 0) { ctx.restore(); return; }

                // 녹갈색 방구 구름 가스 - per-frame gradient 생성 대신 캐시 스프라이트 사용
                const gasAlpha = Math.min(1, (t.life || 0) / (t.maxLife || 52)) * (0.20 + 0.80 * Math.min(1, rise));
                const bursts = (t.gasBursts || []);
                let drawBurstN = 0;
                if (rise < 0.35) drawBurstN = 2;
                else if (rise < 0.7) drawBurstN = 3;
                else drawBurstN = Math.min(6, bursts.length);
                if (antiPassingTentacles.length > 3) drawBurstN = Math.min(drawBurstN, 3);

                if (drawBurstN > 0) {
                    ctx.save();
                    ctx.globalAlpha = 0.75 * gasAlpha;
                    for (let idx = 0; idx < drawBurstN; idx++) {
                        const g = bursts[idx];
                        const wobble = Math.sin((frameCount * 0.08) + idx) * 8 * _apScale;
                        const gDist = (g.dist || 0) * _apScale;

                        const gx = Math.cos(g.angle + frameCount * 0.01 * g.drift) * (gDist + wobble * 0.2);
                        const gy = Math.sin(g.angle + frameCount * 0.013 * g.drift) * (gDist + wobble * 0.15)
                                   - 20 * _apScale
                                   - Math.sin(frameCount * 0.06 + idx) * 6 * _apScale;

                        const rr = (g.size || 0) * _apScale * (0.85 + Math.sin(frameCount * 0.05 + idx) * 0.08);
                        const d = rr * 2;
                        ctx.drawImage(_apSmokeTex, gx - rr, gy - rr, d, d);
                    }
                    ctx.restore();
                }

                // 갈색 가시 촉수 - 상승 중에는 LOD(세그먼트/가시 줄임), 그라데이션 제거로 퍼포먼스 개선
                const segsFull = Math.max(3, (t.segCount || 7));
                const segsDraw = (rise < 1) ? Math.max(3, Math.floor(segsFull * (0.35 + 0.65 * rise))) : segsFull;

                const tipScale = 0.45 + rise * 0.55;

                for (let sIdx = 0; sIdx < segsDraw; sIdx++) {
                    const k = (segsDraw <= 1) ? 1 : (sIdx / (segsDraw - 1));
                    const segAngle = _apDir + k * 1.35;

                    const dist = k * 132 * rise * _apScale;
                    const sx = Math.cos(segAngle) * dist;
                    const sy = Math.sin(segAngle) * dist - (1 - rise) * 48 * _apScale;

                    const segR = (22 - k * 8) * tipScale * _apScale;

                    // 본체(그라데이션 대신 단색+하이라이트)
                    ctx.fillStyle = '#8b6228';
                    ctx.strokeStyle = '#1a1309';
                    ctx.lineWidth = Math.max(1, 2.2 * _apScale);
                    ctx.beginPath();
                    ctx.ellipse(sx, sy, segR * 1.05, segR * 0.9, segAngle + Math.PI * 0.4, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();

                    ctx.save();
                    ctx.globalAlpha = 0.55;
                    ctx.fillStyle = '#c39a53';
                    ctx.beginPath();
                    ctx.ellipse(sx - segR * 0.25, sy - segR * 0.3, segR * 0.55, segR * 0.45, segAngle + Math.PI * 0.4, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();

                    // 가시는 완전 출현 후, 모든 세그먼트에 그리기
                    if (rise >= 1) {
                        const spikes = (antiPassingTentacles.length > 2) ? 3 : 4;
                        for (let pIdx = 0; pIdx < spikes; pIdx++) {
                            const pa = (Math.PI * 2 / spikes) * pIdx + segAngle;
                            const px = sx + Math.cos(pa) * segR * 0.9;
                            const py = sy + Math.sin(pa) * segR * 0.75;

                            const tip = (7 - k * 2) * _apScale;

                            ctx.fillStyle = '#bfc4b5';
                            ctx.strokeStyle = '#0c0c0c';
                            ctx.lineWidth = Math.max(0.8, 1.3 * _apScale);
                            ctx.beginPath();
                            ctx.moveTo(px, py);
                            ctx.lineTo(px + Math.cos(pa) * tip, py + Math.sin(pa) * tip);
                            ctx.lineTo(px + Math.cos(pa + 0.5) * (tip * 0.35), py + Math.sin(pa + 0.5) * (tip * 0.35));
                            ctx.closePath();
                            ctx.fill();
                            ctx.stroke();
                        }
                    }
                }

                ctx.restore();
            });
shockwaves.forEach(wave => {
                ctx.save();
                ctx.translate(wave.x, wave.y);
                ctx.beginPath();
                ctx.arc(0, 0, wave.radius, 0, Math.PI * 2);
               if (wave.color) {
                ctx.strokeStyle = wave.color;
                ctx.globalAlpha = wave.alpha; // 헥사 코드 색상일 경우 투명도는 globalAlpha로 조절
            } else {
                ctx.strokeStyle = `rgba(255, 255, 255, ${wave.alpha})`;
            }

            ctx.lineWidth = 5;
            ctx.stroke();
            ctx.restore();
        });

            // [렌더 순서] 아키 발사체(드래그 샷/이블 애로우/포이즈너스 샷)는 적 이미지 위(전경)에 그리기 위해 뒤쪽에서 렌더링합니다.
pheromoneMarkers.forEach(p => {
                ctx.save(); 
                ctx.translate(p.x, p.y); 
                
                // 1. 하트 주변의 보라/핑크색 가스 이펙트 (맥동함)
                const time = Date.now() / 200;
                const pulse = 1 + Math.sin(time) * 0.2;
                
                const gasGrad = ctx.createRadialGradient(0, 0, p.radius * 0.5, 0, 0, p.radius * 2.5 * pulse);
                gasGrad.addColorStop(0, 'rgba(255, 105, 180, 0.6)');   // HotPink (중심)
                gasGrad.addColorStop(0.5, 'rgba(138, 43, 226, 0.3)'); // BlueViolet (중간)
                gasGrad.addColorStop(1, 'rgba(0, 0, 0, 0)');          // 투명 (외곽)
                
                ctx.fillStyle = gasGrad;
                ctx.beginPath();
                ctx.arc(0, 0, p.radius * 3, 0, Math.PI * 2);
                ctx.fill();

                // 2. 하트 본체 그리기 (크기 조정 및 형태)
                const scale = (p.radius / 15); // 크기 스케일
                ctx.scale(scale, scale);
                
                ctx.beginPath(); 
                ctx.moveTo(0, -10); 
                ctx.bezierCurveTo(-25, -35, -55, -15, 0, 45); 
                ctx.bezierCurveTo(55, -15, 25, -35, 0, -10); 
                ctx.closePath();
                
                // [저장] 클리핑을 위해 현재 경로 저장 (올챙이가 하트 안에만 보이게)
                ctx.save();
                ctx.clip();

                // 3. 3D 입체감 그라데이션 (빛이 왼쪽 위에서 오는 느낌)
                const heartGrad = ctx.createRadialGradient(-10, -10, 5, 0, 0, 50); 
                heartGrad.addColorStop(0, '#ff99cc');   // 하이라이트 (연분홍)
                heartGrad.addColorStop(0.4, '#FF1493'); // 본체 (DeepPink)
                heartGrad.addColorStop(1, '#4B0082');   // 그림자 (Indigo)
                
                ctx.fillStyle = heartGrad; 
                ctx.fill();

                // 4. 검정색 올챙이(정자)들이 우글거리는 효과
                ctx.fillStyle = "black";
                ctx.strokeStyle = "black";
                ctx.lineWidth = 1.5;
                
                // 하트 내부에서 움직이는 5~7마리의 올챙이 생성
                for(let i = 0; i < 6; i++) {
                    // 시간과 인덱스를 이용해 불규칙한 움직임 생성
                    const t = time * 2 + i * 15;
                    // 하트 내부를 돌아다니는 궤적 (Lissajous curve 느낌)
                    const tx = Math.sin(t * 0.7) * 20; 
                    const ty = Math.cos(t * 0.5) * 20; 
                    
                    // 올챙이 머리
                    ctx.beginPath();
                    ctx.arc(tx, ty, 2.5, 0, Math.PI*2);
                    ctx.fill();
                    
                    // 올챙이 꼬리 (머리 뒤로 흔들리며 따라옴)
                    ctx.beginPath();
                    ctx.moveTo(tx, ty);
                    // 꼬리가 진행 반대 방향으로 휘어짐
                    const tailX = tx - (Math.sin(t * 0.7) * 8);
                    const tailY = ty - (Math.cos(t * 0.5) * 8);
                    // 꼬리의 흔들림
                    const wiggle = Math.sin(t * 10) * 3;
                    
                    ctx.quadraticCurveTo(
                        (tx + tailX)/2 + wiggle, (ty + tailY)/2 + wiggle, 
                        tailX, tailY
                    );
                    ctx.stroke();
                }
                
                ctx.restore(); // 클리핑 해제

                // 5. 하트 외곽선 및 광택
                ctx.shadowColor = '#FF1493'; 
                ctx.shadowBlur = 10;
                ctx.strokeStyle = 'rgba(255, 192, 203, 0.5)';
                ctx.lineWidth = 1;
                ctx.stroke();
                
                // 상단 광택 (하이라이트)
                ctx.shadowBlur = 0; 
                ctx.fillStyle = 'rgba(255, 255, 255, 0.4)'; 
                ctx.beginPath(); 
                ctx.ellipse(-10, -15, 8, 4, -Math.PI / 4, 0, Math.PI * 2); 
                ctx.fill();
               
                ctx.restore();
            });
            
          pleasureZones.forEach(z => {
        ctx.save();
        ctx.translate(z.x, z.y);
        const time = Date.now() / 500; // 애니메이션 시간 변수

        // 1. [장판 배경] 돔 형태의 그라데이션
        const zoneGrad = ctx.createRadialGradient(0, 0, z.radius * 0.1, 0, 0, z.radius);
        zoneGrad.addColorStop(0, 'rgba(255, 192, 203, 0.2)');
        zoneGrad.addColorStop(0.6, 'rgba(255, 105, 180, 0.5)');
        zoneGrad.addColorStop(1, 'rgba(199, 21, 133, 0.0)');
        ctx.fillStyle = zoneGrad;
        ctx.beginPath();
        ctx.arc(0, 0, z.radius, 0, Math.PI * 2);
        ctx.fill();

        // 장판 테두리 (빛나는 효과)
        ctx.beginPath();
        ctx.arc(0, 0, z.radius, 0, Math.PI * 2);
        ctx.lineWidth = 6;
        ctx.strokeStyle = '#FF1493';
        ctx.shadowColor = '#FF69B4';
        ctx.shadowBlur = 15;
        ctx.stroke();
        ctx.shadowBlur = 0;
        ctx.lineWidth = 1;

        // 2. [올챙이] 꾸물거리는 검정색 올챙이들
        const tadpoleCount = 60;
        for(let i = 0; i < tadpoleCount; i++) {
            const t = time * 2 + i * 113.7; 
            const rMax = z.radius * 0.85;
            const dist = (Math.sin(t * 0.3) * 0.5 + 0.5) * rMax; 
            const angle = t * 0.5 + (i * (Math.PI * 2 / 13));
            
            const tx = Math.cos(angle) * dist;
            const ty = Math.sin(angle) * dist;

            // 머리
            const headSize = 5 + Math.sin(t * 3) * 1;
            const headGrad = ctx.createRadialGradient(tx - 1.5, ty - 1.5, 1, tx, ty, headSize);
            headGrad.addColorStop(0, '#555555');
            headGrad.addColorStop(0.4, '#000000');
            headGrad.addColorStop(1, '#000000');
            
            ctx.fillStyle = headGrad;
            ctx.beginPath();
            ctx.arc(tx, ty, headSize, 0, Math.PI * 2);
            ctx.fill();

            // 꼬리
            ctx.beginPath();
            ctx.moveTo(tx, ty);
            const moveDir = angle + Math.PI / 2; 
            const wiggle = Math.sin(t * 15) * 8;
            const tailLen = 22;
            const tailBaseAngle = moveDir + Math.PI;
            const tailEndX = tx + Math.cos(tailBaseAngle) * tailLen + Math.cos(tailBaseAngle + Math.PI/2) * wiggle;
            const tailEndY = ty + Math.sin(tailBaseAngle) * tailLen + Math.sin(tailBaseAngle + Math.PI/2) * wiggle;
            const cpX = (tx + tailEndX) / 2 + Math.cos(tailBaseAngle + Math.PI/2) * (wiggle * 0.5);
            const cpY = (ty + tailEndY) / 2 + Math.sin(tailBaseAngle + Math.PI/2) * (wiggle * 0.5);

            ctx.strokeStyle = "black";
            ctx.lineWidth = 3.5;
            ctx.lineCap = "round";
            ctx.quadraticCurveTo(cpX, cpY, tailEndX, tailEndY);
            ctx.stroke();
            ctx.strokeStyle = "#333"; 
            ctx.lineWidth = 1;
            ctx.stroke();
        }

        // 3. [기존 가스] 핑크색 최음 가스 (방구 가스 위로 살짝 섞임)
        const gasParticles = 5;
        for (let i = 0; i < gasParticles; i++) {
            const angle = (Math.PI * 2 * i / gasParticles) + time * 0.5;
            const dist = z.radius * 0.4 + Math.sin(time + i) * (z.radius * 0.2);
            const size = z.radius * 0.3 + Math.cos(time * 2 + i) * 5;
            const gx = Math.cos(angle) * dist;
            const gy = Math.sin(angle) * dist;

            const gasGrad = ctx.createRadialGradient(gx, gy, 0, gx, gy, size);
            gasGrad.addColorStop(0, 'rgba(255, 20, 147, 0.4)');
            gasGrad.addColorStop(1, 'rgba(255, 182, 193, 0)');

            ctx.fillStyle = gasGrad;
            ctx.beginPath();
            ctx.arc(gx, gy, size, 0, Math.PI * 2);
            ctx.fill();
        }

        // 4. [하트] 입체적인 하트
        const r = z.radius * 0.6;
        ctx.beginPath();
        ctx.moveTo(0, -r * 0.5);
        ctx.bezierCurveTo(-r * 1.5, -r * 1.5, -r * 1.5, r, 0, r * 1.5);
        ctx.bezierCurveTo(r * 1.5, r, r * 1.5, -r * 1.5, 0, -r * 0.5);
        
        const heartGrad = ctx.createLinearGradient(-r, -r, r, r);
        heartGrad.addColorStop(0, '#FF69B4');
        heartGrad.addColorStop(1, '#C71585');
        ctx.fillStyle = heartGrad;
        ctx.fill();
        
        ctx.strokeStyle = '#FF1493';
        ctx.lineWidth = 2;
        ctx.stroke();

        ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
        ctx.beginPath();
        ctx.ellipse(-r * 0.5, -r * 0.5, r * 0.2, r * 0.1, -Math.PI / 4, 0, Math.PI * 2);
        ctx.fill();

        // =====================================================================
        // [수정됨] 방구 가스 그리기 로직을 가장 마지막으로 이동 (위로 올라오게 함)
        // =====================================================================
        const fartParticles = 30; // 가스 덩어리 개수
        for (let i = 0; i < fartParticles; i++) {
            // 느릿하고 묵직하게 움직이는 가스
            const ft = time * 0.4 + i * 33.3; 
            
            // 위치: 장판 내부에서 불규칙하게 솟아오름
            const dist = (Math.sin(ft * 0.5) * 0.3 + 0.4) * z.radius; 
            const angle = ft + Math.sin(i * 10);
            
            const fx = Math.cos(angle) * dist;
            const fy = Math.sin(angle) * dist;

            // 크기: 몽글몽글하게 커졌다 작아졌다 함
            const fSize = z.radius * (0.25 + Math.sin(ft * 1.2) * 0.1);

            // [색상] 더러운 갈색 + 썩은 녹색 그라데이션
            const fartGrad = ctx.createRadialGradient(fx, fy, 0, fx, fy, fSize);
            fartGrad.addColorStop(0, 'rgba(101, 67, 33, 0.6)');   // 중심: 똥색 (Dark Brown)
            fartGrad.addColorStop(0.5, 'rgba(139, 69, 19, 0.4)'); // 중간: 진한 갈색
            fartGrad.addColorStop(1, 'rgba(85, 107, 47, 0.0)');   // 외곽: 썩은 올리브색 (투명하게)

            ctx.fillStyle = fartGrad;
            ctx.beginPath();
            ctx.arc(fx, fy, fSize, 0, Math.PI * 2);
            ctx.fill();
        }
        // =====================================================================

        ctx.restore();
    });
            
            ghosts.forEach(g => { ctx.save(); ctx.translate(g.x, g.y); ctx.rotate(g.rotation); ctx.globalAlpha = g.life / g.maxLife * 0.5; const size = g.radius * 2.5; ctx.beginPath();
             ctx.arc(0, 0, size / 2, 0, Math.PI * 2); 
             ctx.clip(); try { ctx.drawImage(g.img, -size/2, -size/2, size, size); } catch(e) {} ctx.restore(); });
            bigPoops.forEach(bp => { 
                ctx.save(); 
                ctx.translate(bp.x, bp.y); 
                const r = bp.radius; // 큽니다

                // 색상 팔레트 (더 진한 갈색)
                const baseColor = '#5D4037'; 
                const midColor = '#8D6E63';  
                const darkColor = '#3E2723'; 

                // 3단 쌓기 렌더링
                const drawLump = (yOffset, width, height) => {
                    ctx.beginPath();
                    // 입체감을 위한 그라데이션
                    const grad = ctx.createRadialGradient(-width*0.3, yOffset-height*0.3, width*0.1, 0, yOffset, width);
                    grad.addColorStop(0, midColor);
                    grad.addColorStop(0.4, baseColor);
                    grad.addColorStop(1, darkColor);
                    ctx.fillStyle = grad;
                    
                    // 약간 찌그러진 원형으로 자연스럽게
                    ctx.ellipse(0, yOffset, width, height, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // 더러운 덩어리 질감 (반점)
                    ctx.fillStyle = 'rgba(30, 10, 5, 0.4)';
                    for(let i=0; i<5; i++) {
                        ctx.beginPath();
                        ctx.arc((Math.random()-0.5)*width*1.2, yOffset+(Math.random()-0.5)*height, r*0.08, 0, Math.PI*2);
                        ctx.fill();
                    }
                };

                // 바닥, 중간, 끝 (크기 비율 조정)
                drawLump(r * 0.4, r, r * 0.6);
                drawLump(-r * 0.2, r * 0.8, r * 0.55);
                drawLump(-r * 0.8, r * 0.5, r * 0.5);
                
                // 꼭대기 하이라이트 (번들거림)
                ctx.fillStyle = 'rgba(255, 255, 255, 0.15)';
                ctx.beginPath();
                ctx.ellipse(r*0.2, -r*0.9, r*0.15, r*0.1, -0.5, 0, Math.PI*2);
                ctx.fill();

                // 강렬한 냄새 효과
                const time = Date.now() / 150;
                ctx.strokeStyle = 'rgba(101, 67, 33, 0.6)';
                ctx.lineWidth = 3;
                ctx.beginPath();
                for(let k=0; k<3; k++) {
                    const startX = (k-1) * r * 0.5;
                    ctx.moveTo(startX, -r);
                    ctx.bezierCurveTo(startX + 20, -r*2, startX - 20, -r*3, startX + Math.sin(time+k)*10, -r*4);
                }
                ctx.stroke();

                ctx.restore(); 
            });
            darkBigPoops.forEach(bp => {
                // [최적화] 스프라이트 캐시로 drawImage만 수행 (그라데이션/쉐도우/ellipse는 radius별 1회)
                const spr = getDarkBigPoopSprite(bp.radius);
                const half = spr.__half || (spr.width / 2);
                ctx.drawImage(spr, bp.x - half, bp.y - half);

                // 아주 가벼운 흔들림(옵션): 유도 똥만 살짝 '숨쉬기' 느낌
                // ※ 연산 최소화 위해 sin/cos 1회 + 선 1~2개만
                if (bp.isHoming) {
                    const t = frameCount * 0.06;
                    const wob = Math.sin(t + (bp.x + bp.y) * 0.01) * 4;
                    ctx.save();
                    ctx.globalAlpha = 0.45;
                    ctx.strokeStyle = 'rgba(75, 0, 130, 0.35)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(bp.x - 8, bp.y - (bp.radius * 1.2));
                    ctx.lineTo(bp.x + wob, bp.y - (bp.radius * 2.8));
                    ctx.stroke();
                    ctx.restore();
                }
            });

                        darkGases.forEach(gas => {
                // [Trail darkgas] simpler draw (avoid heavy gradients/bubbles)
                if (gas.isTrail || gas.simpleDraw) {
                    const denom = gas.isTrail ? 80 : (gas.lifeMax || 150);
                    const lifeA = Math.max(0, Math.min(1, (gas.life || 0) / denom));
                    const baseA = gas.isTrail ? (gas.alpha || 0.55) : (gas.alpha || 0.72);
                    const a = baseA * lifeA;

                    ctx.save();
                    ctx.globalAlpha = a;
                    ctx.fillStyle = gas.isTrail ? 'rgba(0, 0, 0, 0.55)' : 'rgba(0, 0, 0, 0.70)';
                    ctx.beginPath();
                    ctx.arc(gas.x, gas.y, gas.radius, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.globalAlpha = a * 0.85;
                    ctx.fillStyle = gas.isTrail ? 'rgba(50, 0, 60, 0.55)' : 'rgba(70, 0, 85, 0.60)';
                    ctx.beginPath();
                    ctx.arc(gas.x + 6, gas.y - 3, gas.radius * 0.75, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                    return;
                }

                if (gas.puffs) {
                    gas.puffs.forEach(puff => {
                        const px = gas.x + Math.cos(puff.angle) * (gas.radius * puff.distRel);
                        const py = gas.y + Math.sin(puff.angle) * (gas.radius * puff.distRel);
                        const pRadius = gas.radius * puff.sizeRel;
                        
                        const gradient = ctx.createRadialGradient(px, py, 0, px, py, pRadius);
                        gradient.addColorStop(0, `rgba(0, 0, 0, ${gas.alpha})`);          
                        gradient.addColorStop(0.5, `rgba(60, 0, 60, ${gas.alpha * 0.9})`); 
                        gradient.addColorStop(1, `rgba(0, 0, 0, 0)`); 

                        ctx.fillStyle = gradient;
                        ctx.beginPath();
                        ctx.arc(px, py, pRadius, 0, Math.PI * 2);
                        ctx.fill();
                    });
                } else {
                    const gradient = ctx.createRadialGradient(gas.x, gas.y, 0, gas.x, gas.y, gas.radius);
                    gradient.addColorStop(0, `rgba(0, 0, 0, ${gas.alpha})`);          
                    gradient.addColorStop(0.5, `rgba(60, 0, 60, ${gas.alpha * 0.9})`); 
                    gradient.addColorStop(1, `rgba(0, 0, 0, 0)`); 
                    ctx.fillStyle = gradient; ctx.beginPath(); ctx.arc(gas.x, gas.y, gas.radius, 0, Math.PI * 2); ctx.fill();
                }

            });

            darkGreenGases.forEach(gas => {
                if (gas.puffs) {
                    gas.puffs.forEach(puff => {
                        const px = gas.x + Math.cos(puff.angle) * (gas.radius * puff.distRel);
                        const py = gas.y + Math.sin(puff.angle) * (gas.radius * puff.distRel);
                        const pRadius = gas.radius * puff.sizeRel;

                        const gradient = ctx.createRadialGradient(px, py, 0, px, py, pRadius);
                        gradient.addColorStop(0, `rgba(0, 0, 0, ${gas.alpha})`);
                        gradient.addColorStop(0.5, `rgba(8, 42, 26, ${gas.alpha * 0.9})`);
                        gradient.addColorStop(1, `rgba(0, 0, 0, 0)`);

                        ctx.fillStyle = gradient;
                        ctx.beginPath();
                        ctx.arc(px, py, pRadius, 0, Math.PI * 2);
                        ctx.fill();
                    });
                } else {
                    const gradient = ctx.createRadialGradient(gas.x, gas.y, 0, gas.x, gas.y, gas.radius);
                    gradient.addColorStop(0, `rgba(0, 0, 0, ${gas.alpha})`);
                    gradient.addColorStop(0.5, `rgba(8, 42, 26, ${gas.alpha * 0.9})`);
                    gradient.addColorStop(1, `rgba(0, 0, 0, 0)`);
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(gas.x, gas.y, gas.radius, 0, Math.PI * 2);
                    ctx.fill();
                }
            });

            gases.forEach(gas => {
                 if (gas.puffs) {
                    gas.puffs.forEach(puff => {
                        const px = gas.x + Math.cos(puff.angle) * (gas.radius * puff.distRel);
                        const py = gas.y + Math.sin(puff.angle) * (gas.radius * puff.distRel);
                        const pRadius = gas.radius * puff.sizeRel;

                        const gradient = ctx.createRadialGradient(px, py, 0, px, py, pRadius);
                        gradient.addColorStop(0, `rgba(20, 10, 0, ${gas.alpha})`); 
                        gradient.addColorStop(0.5, `rgba(80, 50, 20, ${gas.alpha * 0.7})`); 
                        gradient.addColorStop(1, `rgba(50, 40, 0, 0)`);                   
                        
                        ctx.fillStyle = gradient;
                        ctx.beginPath();
                        ctx.arc(px, py, pRadius, 0, Math.PI * 2);
                        ctx.fill();
                    });
                } else {
                    const gradient = ctx.createRadialGradient(gas.x, gas.y, 0, gas.x, gas.y, gas.radius);
                    gradient.addColorStop(0, `rgba(20, 10, 0, ${gas.alpha})`); gradient.addColorStop(0.3, `rgba(50, 35, 10, ${gas.alpha * 0.9})`); gradient.addColorStop(0.6, `rgba(80, 50, 20, ${gas.alpha * 0.7})`); gradient.addColorStop(1, `rgba(50, 40, 0, 0)`);                   
                    ctx.fillStyle = gradient; ctx.beginPath(); ctx.arc(gas.x, gas.y, gas.radius, 0, Math.PI * 2); ctx.fill();
                }
            });

            deathClouds.forEach(cloud => {
                ctx.save(); ctx.translate(cloud.x, cloud.y); const lifeRatio = cloud.life / 270;
                const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, cloud.radius); gradient.addColorStop(0, `rgba(0, 0, 0, ${lifeRatio})`); gradient.addColorStop(0.6, `rgba(75, 0, 130, ${lifeRatio * 0.8})`); gradient.addColorStop(1, `rgba(50, 0, 50, 0)`);                    
                ctx.fillStyle = gradient; ctx.beginPath(); ctx.arc(0, 0, cloud.radius, 0, Math.PI * 2); ctx.fill(); 
                if (lifeRatio > 0.1) {
                     ctx.fillStyle = `rgba(20, 20, 20, ${lifeRatio})`;
                     const bubbles = 5; const time = Date.now() / 200;
                     for(let k=0; k<bubbles; k++) {
                         ctx.beginPath(); const angle = (k / bubbles) * Math.PI * 2 + time; const dist = Math.sin(time * 2 + k) * (cloud.radius * 0.5); const bx = Math.cos(angle) * dist; const by = Math.sin(angle) * dist; const size = 15 + Math.sin(time + k) * 5; ctx.arc(bx, by, size, 0, Math.PI*2); ctx.fill();
                     }
                }
                ctx.restore();
            });
            
         poops.forEach(poop => { 
                ctx.save(); 
                ctx.translate(poop.x, poop.y); 
                // 회전은 제거하거나 약간만 주어 입체감 유지 (여기서는 제거하여 쌓인 모양 유지)
                // ctx.rotate(poop.rotation); 

                const r = poop.radius; 
                
                // 색상 팔레트 설정 (갈색 vs 녹색)
                let baseColor, midColor, darkColor;
                if (poop.isGreen) {
                    baseColor = '#556B2F'; // DarkOliveGreen
                    midColor = '#6B8E23';  // OliveDrab
                    darkColor = '#006400'; // DarkGreen
                } else {
                    baseColor = '#8B4513'; // SaddleBrown (중간)
                    midColor = '#A0522D';  // Sienna (밝은 부분)
                    darkColor = '#3e2723'; // Very Dark Brown (그림자)
                }

                // 똥 그리기 함수 (3단)
                const drawLump = (yOffset, width, height, color) => {
                    ctx.beginPath();
                    const grad = ctx.createRadialGradient(-width*0.2, yOffset-height*0.2, width*0.1, 0, yOffset, width);
                    grad.addColorStop(0, midColor);
                    grad.addColorStop(0.5, baseColor);
                    grad.addColorStop(1, darkColor);
                    ctx.fillStyle = grad;
                    ctx.ellipse(0, yOffset, width, height, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // 질감 (더러운 점)
                    ctx.fillStyle = 'rgba(0,0,0,0.3)';
                    for(let i=0; i<3; i++) {
                        ctx.beginPath();
                        ctx.arc((Math.random()-0.5)*width, yOffset+(Math.random()-0.5)*height, r*0.1, 0, Math.PI*2);
                        ctx.fill();
                    }
                };

                // 1단 (바닥 - 넙데데)
                drawLump(r * 0.3, r, r * 0.7, baseColor);
                // 2단 (중간)
                drawLump(-r * 0.3, r * 0.75, r * 0.6, baseColor);
                // 3단 (꼭대기 - 뾰족)
                drawLump(-r * 0.9, r * 0.4, r * 0.5, baseColor);

                // 냄새 아지랑이 효과 (물결)
                if (frameCount % 60 < 40) {
                    ctx.strokeStyle = poop.isGreen ? 'rgba(50, 205, 50, 0.6)' : 'rgba(139, 69, 19, 0.5)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    const time = Date.now() / 200;
                    // 왼쪽 아지랑이
                    ctx.moveTo(-r * 0.5, -r);
                    ctx.quadraticCurveTo(-r, -r * 2, -r * 0.5 + Math.sin(time) * 5, -r * 3);
                    // 오른쪽 아지랑이
                    ctx.moveTo(r * 0.5, -r);
                    ctx.quadraticCurveTo(r, -r * 2, r * 0.5 + Math.cos(time) * 5, -r * 3);
                    ctx.stroke();
                }

                ctx.restore(); 
            });

            homingSemens.forEach(shot => {
                ctx.save(); ctx.translate(shot.x, shot.y); const angle = Math.atan2(shot.vy, shot.vx); ctx.rotate(angle); const scale = shot.radius / 15; 
                ctx.shadowColor = 'rgba(230, 230, 200, 0.4)'; ctx.shadowBlur = 5; ctx.fillStyle = '#FFFDD0'; 
                ctx.beginPath(); const radius = 15 * scale; ctx.moveTo(radius, 0); for (let i = 1; i <= 8; i++) { const angle = (i / 8) * Math.PI * 2; const wobble = Math.sin(Date.now() / 100 + i * 10) * (radius * 0.2); const r = radius + wobble; const x = Math.cos(angle) * r; const y = Math.sin(angle) * r; const cpAngle = angle - (Math.PI / 8); const cpR = radius * 0.8; const cpx = Math.cos(cpAngle) * cpR; const cpy = Math.sin(cpAngle) * cpR; ctx.quadraticCurveTo(cpx, cpy, x, y); } ctx.closePath(); ctx.fill();
                ctx.fillStyle = 'rgba(255, 253, 220, 0.9)'; for(let k=0; k<3; k++) { ctx.beginPath(); const tailX = -radius * (1.2 + k * 0.5); const tailY = Math.sin(Date.now()/50 + k) * (radius * 0.4); const tailR = radius * (0.3 - k * 0.05); ctx.ellipse(tailX, tailY, tailR * 1.2, tailR * 0.8, k, 0, Math.PI*2); ctx.fill(); }
                ctx.restore();
            });

            darkSemens.forEach(shot => {
                ctx.save(); ctx.translate(shot.x, shot.y); const angle = Math.atan2(shot.vy, shot.vx); ctx.rotate(angle);
                ctx.shadowColor = 'rgba(75, 0, 130, 0.6)'; ctx.shadowBlur = 5; ctx.fillStyle = '#111111'; 
                ctx.beginPath(); const radius = shot.radius; ctx.moveTo(radius, 0); for (let i = 1; i <= 8; i++) { const angle = (i / 8) * Math.PI * 2; const wobble = Math.sin(Date.now() / 100 + i * 10) * (radius * 0.2); const r = radius + wobble; const x = Math.cos(angle) * r; const y = Math.sin(angle) * r; const cpAngle = angle - (Math.PI / 8); const cpR = radius * 0.8; const cpx = Math.cos(cpAngle) * cpR; const cpy = Math.sin(cpAngle) * cpR; ctx.quadraticCurveTo(cpx, cpy, x, y); } ctx.closePath(); ctx.fill();
                ctx.fillStyle = 'rgba(20, 0, 20, 0.9)'; for(let k=0; k<3; k++) { ctx.beginPath(); const tailX = -radius * (1.2 + k * 0.5); const tailY = Math.sin(Date.now()/50 + k) * (radius * 0.4); const tailR = radius * (0.3 - k * 0.05); ctx.ellipse(tailX, tailY, tailR * 1.2, tailR * 0.8, k, 0, Math.PI*2); ctx.fill(); }
                ctx.shadowBlur = 0; ctx.fillStyle = 'rgba(100, 100, 100, 0.3)'; ctx.beginPath(); ctx.ellipse(-radius * 0.3, -radius * 0.3, radius * 0.3, radius * 0.15, -0.5, 0, Math.PI * 2); ctx.fill();
                ctx.restore();
            });


            whiteshots.forEach(shot => {
                ctx.save(); ctx.translate(shot.x, shot.y); const angle = Math.atan2(shot.vy, shot.vx); ctx.rotate(angle);
                ctx.shadowColor = 'rgba(230, 230, 200, 0.4)'; ctx.shadowBlur = 5; ctx.fillStyle = '#FFFDD0'; 
                ctx.beginPath(); const radius = shot.radius; ctx.moveTo(radius, 0); for (let i = 1; i <= 8; i++) { const angle = (i / 8) * Math.PI * 2; const wobble = Math.sin(Date.now() / 100 + i * 10) * (radius * 0.2); const r = radius + wobble; const x = Math.cos(angle) * r; const y = Math.sin(angle) * r; const cpAngle = angle - (Math.PI / 8); const cpR = radius * 0.8; const cpx = Math.cos(cpAngle) * cpR; const cpy = Math.sin(cpAngle) * cpR; ctx.quadraticCurveTo(cpx, cpy, x, y); } ctx.closePath(); ctx.fill();
                ctx.fillStyle = 'rgba(255, 253, 220, 0.9)'; for(let k=0; k<3; k++) { ctx.beginPath(); const tailX = -radius * (1.2 + k * 0.5); const tailY = Math.sin(Date.now()/50 + k) * (radius * 0.4); const tailR = radius * (0.3 - k * 0.05); ctx.ellipse(tailX, tailY, tailR * 1.2, tailR * 0.8, k, 0, Math.PI*2); ctx.fill(); }
                ctx.shadowBlur = 0; ctx.fillStyle = 'rgba(255, 255, 255, 0.7)'; ctx.beginPath(); ctx.ellipse(-radius * 0.3, -radius * 0.3, radius * 0.3, radius * 0.15, -0.5, 0, Math.PI * 2); ctx.fill();
                ctx.restore();
            });

            darkHearts.forEach(p => {
                ctx.save(); ctx.translate(p.x, p.y); 
                const pulse = 1 + Math.sin(Date.now() / 150) * 0.1; const scale = (p.radius / 30) * pulse; ctx.scale(scale, scale);
                ctx.beginPath(); ctx.moveTo(0, -10); ctx.bezierCurveTo(-25, -35, -55, -15, 0, 45); ctx.bezierCurveTo(55, -15, 25, -35, 0, -10); ctx.closePath();
                const gradient = ctx.createRadialGradient(-15, -15, 5, 0, 0, 50); gradient.addColorStop(0, '#FF69B4'); gradient.addColorStop(0.4, '#8B008B'); gradient.addColorStop(0.8, '#4B0082'); gradient.addColorStop(1, '#1a001a'); 
                ctx.fillStyle = gradient; ctx.shadowColor = '#FF1493'; ctx.shadowBlur = 15; ctx.fill();
                ctx.shadowBlur = 0; ctx.fillStyle = 'rgba(255, 255, 255, 0.3)'; ctx.beginPath(); ctx.ellipse(-15, -15, 10, 5, -Math.PI / 4, 0, Math.PI * 2); ctx.fill();
                ctx.restore();
            });

           // [수정됨] 최음 가스 그리기 (볼륨감 있는 핑크 구름)
            pinkGases.forEach(g => {
                ctx.save();
                ctx.translate(g.x, g.y);
                
                // 등장 시 서서히 진해짐
                if (g.alpha < g.maxAlpha) g.alpha += 0.01;
                ctx.globalAlpha = g.alpha * (g.life / 480); // 사라질 때 자연스럽게

                // 구름 조각들 그리기
                if (g.puffs) {
                    g.puffs.forEach(p => {
                        // 등장 시 퐁! 하고 커지는 연출
                        if (p.scale < 1.0) p.scale += 0.05;
                        
                        const currentR = p.r * p.scale;
                        
                        // 부드러운 구름 느낌을 위한 방사형 그라데이션
                        const gradient = ctx.createRadialGradient(p.dx, p.dy, 0, p.dx, p.dy, currentR);
                        gradient.addColorStop(0, 'rgba(255, 182, 193, 0.9)'); // 중심: LightPink
                        gradient.addColorStop(0.6, 'rgba(255, 105, 180, 0.4)'); // 중간: HotPink
                        gradient.addColorStop(1, 'rgba(255, 105, 180, 0)');   // 외곽: 투명
                        
                        ctx.fillStyle = gradient;
                        ctx.beginPath();
                        ctx.arc(p.dx, p.dy, currentR, 0, Math.PI * 2);
                        ctx.fill();
                    });
                }
                ctx.restore();
            });

            // [신규] 퀘스타 '새디즘' 갈색 방구 가스 그리기 (핑크가스와 동일한 볼륨감 스타일)
            sadismBrownGases.forEach(g => {
                ctx.save();
                ctx.translate(g.x, g.y);

                if (g.alpha < g.maxAlpha) g.alpha += 0.01;
                ctx.globalAlpha = g.alpha * (g.life / (g.maxLife || 240));

                if (g.puffs) {
                    g.puffs.forEach(p => {
                        if (p.scale < 1.0) p.scale += 0.05;

                        const currentR = p.r * p.scale;

                        const gradient = ctx.createRadialGradient(p.dx, p.dy, 0, p.dx, p.dy, currentR);
                        gradient.addColorStop(0, 'rgba(198, 134, 66, 0.85)');  // 중심(더러운 연갈색)
                        gradient.addColorStop(0.6, 'rgba(101, 67, 33, 0.40)'); // 중간(짙은 갈색)
                        gradient.addColorStop(1, 'rgba(101, 67, 33, 0)');      // 외곽(투명)

                        ctx.fillStyle = gradient;
                        ctx.beginPath();
                        ctx.arc(p.dx, p.dy, currentR, 0, Math.PI * 2);
                        ctx.fill();
                    });
                }
                ctx.restore();
            });

            // [수정됨] 어둠의 음표 그리기 (볼륨감 + 사악한 전류 이펙트)
            darkNotes.forEach(n => {
                ctx.save();
                ctx.translate(n.x, n.y);

                // 1. 사악한 검보라색 전류 이펙트 (찌릿찌릿)
                ctx.strokeStyle = '#8A2BE2'; // BlueViolet
                ctx.shadowColor = '#9400D3'; // DarkViolet Glow
                ctx.shadowBlur = 15;
                ctx.lineWidth = 2;
                ctx.lineCap = 'round';
                
                // 랜덤한 번개 줄기 3개 생성
                for (let k = 0; k < 3; k++) {
                    ctx.beginPath();
                    // 음표 중심에서 시작하지 않고 약간 떨어진 곳에서 번개
                    const startAngle = Math.random() * Math.PI * 2;
                    let lx = Math.cos(startAngle) * 15;
                    let ly = Math.sin(startAngle) * 15;
                    ctx.moveTo(lx, ly);
                    
                    // 지그재그 선 그리기
                    for (let j = 0; j < 4; j++) {
                        lx += (Math.random() - 0.5) * 20;
                        ly += (Math.random() - 0.5) * 20;
                        ctx.lineTo(lx, ly);
                    }
                    ctx.stroke();
                }

                // 2. 볼륨감 있는 음표 본체
                ctx.shadowColor = '#4B0082'; // Indigo 깊은 그림자
                ctx.shadowBlur = 20;
                ctx.fillStyle = "black"; 
                ctx.font = "bold 45px Arial"; // 크기 키움
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                
                // 약간의 떨림 효과로 불안정한 에너지 표현
                const shakeX = (Math.random() - 0.5) * 2;
                const shakeY = (Math.random() - 0.5) * 2;
                ctx.fillText("♪", shakeX, shakeY);
                
                // 3. 내부 코어 (보라색으로 살짝 빛나게)
                ctx.shadowBlur = 0;
                ctx.fillStyle = "#9370DB"; // MediumPurple
                ctx.font = "bold 40px Arial";
                ctx.fillText("♪", shakeX, shakeY);

                ctx.restore();
            });

            
    // 오클루전 스풀 그리기 (바닥 장판) - [OPT] 그라데이션/랜덤 연산 최소화
occlusionSpools.forEach(s => {
    ctx.save();
    ctx.translate(s.x, s.y);

    const stride = (performanceState && performanceState.particleStride) ? performanceState.particleStride : 1;

    // 울렁거리는 검보라빛 번개 필드 (기존 느낌 유지)
    const pulse = 1 + Math.sin(Date.now() / 100) * 0.1;

    // (1) 바닥 디스크는 텍스처 캐시로 그리기 (createRadialGradient 제거)
    const disc = getOcclusionSpoolDiscTex(s.radius);
    const dw = disc.width * pulse;
    const dh = disc.height * pulse;
    ctx.drawImage(disc, -dw / 2, -dh / 2, dw, dh);

    // (2) 번개 지지직(랜덤)도 매 프레임 생성하지 않고 주기 갱신
    //     - 색/굵기 동일 유지
    ctx.strokeStyle = "#6A00FF"; // Deep Purple
    ctx.lineWidth = 2;

    // 스풀별 시드(한 번만)
    if (s._seed == null) s._seed = Math.random() * 9999;

    const updateEvery = Math.max(10, 16 * stride); // [추가 최적화] 더 드물게 갱신
    if (!s._sparkTick) s._sparkTick = 0;
    s._sparkTick++;

    if (!s._sparks || (s._sparkTick % updateEvery) === 0) {
        const lineCount = Math.max(2, Math.floor(4 / stride));
        const stepCount = 4;
        const jitter = 16;

        s._sparks = [];
        for (let k = 0; k < lineCount; k++) {
            const baseA = __hash01(s._seed + k * 13.3 + Math.floor(s._sparkTick / updateEvery) * 7.7) * Math.PI * 2;
            let lx = 0, ly = 0;
            const pts = [{ x: 0, y: 0 }];
            for (let j = 0; j < stepCount; j++) {
                lx += Math.cos(baseA) * (s.radius / stepCount);
                ly += Math.sin(baseA) * (s.radius / stepCount);

                const h1 = __hash01(s._seed * 1.7 + k * 31.1 + j * 17.9 + s._sparkTick);
                const h2 = __hash01(s._seed * 2.3 + k * 19.7 + j * 23.1 + s._sparkTick);
                lx += (h1 - 0.5) * jitter;
                ly += (h2 - 0.5) * jitter;
                pts.push({ x: lx, y: ly });
            }
            s._sparks.push(pts);
        }
    }

    ctx.beginPath();
    for (let pIdx = 0; pIdx < s._sparks.length; pIdx++) {
        const pts = s._sparks[pIdx];
        ctx.moveTo(pts[0].x, pts[0].y);
        for (let j = 1; j < pts.length; j++) ctx.lineTo(pts[j].x, pts[j].y);
    }
    ctx.stroke();

    ctx.restore();
});
// 프리즘 스윕 그리기 (공중 유닛 느낌)
        prismSweeps.forEach(p => {
            ctx.save();
            ctx.translate(p.x, p.y);
            
            // 프리즘 본체 (3색 삼각형)
            ctx.fillStyle = "black";
            ctx.shadowColor = "purple";
            ctx.shadowBlur = 20;
            ctx.beginPath();
            ctx.moveTo(0, -30);
            ctx.lineTo(25, 20);
            ctx.lineTo(-25, 20);
            ctx.closePath();
            ctx.fill();
            ctx.shadowBlur = 0;

            // 레이저 (바닥까지 빔 발사)
            if (p.laserTimer < 10) { // 발사 순간 반짝임
                ctx.strokeStyle = p.colors[Math.floor(Date.now() / 6000) % 3];
                ctx.lineWidth = 40;
                ctx.globalAlpha = 0.6;
                ctx.beginPath();
                ctx.moveTo(0, 20);
                ctx.lineTo(0, 1000); // 화면 아래까지
                ctx.stroke();
            }
            ctx.restore();
        });

            mindSkulls.forEach(skull => {
            drawMindSkullFast(ctx, skull);
        });

            enemies.forEach(enemy => {
if (enemy.isTaro && enemy.deathGripActive) {
        ctx.save();

        const startX = enemy.x;
        const startY = enemy.y;
        const endX = player.x;
        const endY = player.y;

        // 곡선 제어점 계산 (흔들림 효과)
        const midX = (startX + endX) / 2;
        const midY = (startY + endY) / 2;
        const wiggle = Math.sin(frameCount * 0.2) * 20;
        const cpX = midX;
        const cpY = midY + wiggle;

        // 거리 계산 및 링크 개수 설정
        const dist = Math.sqrt(Math.pow(endX - startX, 2) + Math.pow(endY - startY, 2));
        const linkSize = 20; 
        const linkCount = Math.floor(dist / (linkSize * 0.6)); // 링크 간 겹침 고려

        // 사슬 전체 글로우 효과 (먼저 그림)
        ctx.beginPath();
        ctx.moveTo(startX, startY);
        ctx.quadraticCurveTo(cpX, cpY, endX, endY);
        ctx.lineWidth = 12;
        ctx.strokeStyle = 'rgba(138, 43, 226, 0.2)'; // 은은한 보라색 오라
        ctx.lineCap = 'round';
        ctx.stroke();

        // 사슬 마디 그리기 루프
        for (let i = 0; i <= linkCount; i++) {
            const t = i / linkCount;
            const t1 = 1 - t;

            // 2차 베지에 곡선 공식으로 현재 위치(curX, curY) 계산
            const curX = t1 * t1 * startX + 2 * t1 * t * cpX + t * t * endX;
            const curY = t1 * t1 * startY + 2 * t1 * t * cpY + t * t * endY;

            // 다음 위치를 예측하여 회전 각도 계산
            const tNext = Math.min(1, (i + 0.1) / linkCount);
            const t1Next = 1 - tNext;
            const nextX = t1Next * t1Next * startX + 2 * t1Next * tNext * cpX + tNext * tNext * endX;
            const nextY = t1Next * t1Next * startY + 2 * t1Next * tNext * cpY + tNext * tNext * endY;
            const angle = Math.atan2(nextY - curY, nextX - curX);

            ctx.save();
            ctx.translate(curX, curY);
            ctx.rotate(angle);

            ctx.lineWidth = 3;
            // 짝수/홀수 번갈아가며 마디 모양 변경 (사슬 느낌)
            if (i % 2 === 0) {
                // 눕혀진 타원형 마디
                ctx.strokeStyle = '#808080';
                ctx.beginPath();
                ctx.ellipse(0, 0, 10, 4, 0, 0, Math.PI * 2);
                ctx.stroke();
                // 하이라이트
                ctx.strokeStyle = '#D3D3D3';
                ctx.lineWidth = 1;
                ctx.stroke();
            } else {
                // 세워진 마디 (작은 원 혹은 두꺼운 선)
                ctx.fillStyle = '#505050';
                ctx.beginPath();
                ctx.arc(0, 0, 4, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#A9A9A9';
                ctx.lineWidth = 1;
                ctx.stroke();
            }
            ctx.restore();
        }
        ctx.restore();
    }
                if (enemy.isMonolith) {
             ctx.save();
             ctx.translate(enemy.x, enemy.y);

             // 1. 바닥의 혼돈 오라
             const pulse = 0.5 + Math.sin(Date.now() / 200) * 0.2;
             ctx.globalAlpha = pulse;
             ctx.fillStyle = "#4B0082"; // Indigo
             ctx.beginPath();
             ctx.ellipse(0, 15, 35, 15, 0, 0, Math.PI * 2);
             ctx.fill();
             ctx.globalAlpha = 1.0;

             // 2. 비석 본체
             ctx.fillStyle = "#2F4F4F"; // DarkSlateGray
             ctx.strokeStyle = "#1a1a1a";
             ctx.lineWidth = 2;
             ctx.beginPath();
             ctx.moveTo(-20, 15);
             ctx.lineTo(-15, -50);
             ctx.lineTo(15, -50);
             ctx.lineTo(20, 15);
             ctx.closePath();
             ctx.fill();
             ctx.stroke();

             // 3. 새겨진 룬 문자
             ctx.shadowBlur = 15;
             ctx.shadowColor = "#FF00FF";
             ctx.strokeStyle = "#D8BFD8";
             ctx.lineWidth = 3;
             ctx.beginPath();
             ctx.moveTo(0, -35);
             ctx.lineTo(0, -5);
             ctx.moveTo(-10, -25);
             ctx.lineTo(10, -15);
             ctx.moveTo(-10, -15);
             ctx.lineTo(10, -25);
             ctx.stroke();
             ctx.shadowBlur = 0;

           // 4. 체력바
             const hpPercent = Math.max(0, enemy.hp) / enemy.maxHp;
             ctx.fillStyle = "black";
             ctx.fillRect(-20, -enemy.radius - 15, 40, 6); 
             ctx.fillStyle = '#ff3333';
             ctx.fillRect(-20, -enemy.radius - 15, 40 * hpPercent, 6);

             ctx.restore();
             return; // 비석을 그렸으므로 아래의 기본 적 그리기 로직은 건너뜀
        }
                if (enemy.isVoidGrimoire) {
             ctx.save();
             ctx.translate(enemy.x, enemy.y);

             const pulse = 0.65 + Math.sin(Date.now() / 180) * 0.18;
             const aura = ctx.createRadialGradient(0, 10, 5, 0, 10, 58);
             aura.addColorStop(0, `rgba(96, 0, 128, ${0.60 * pulse})`);
             aura.addColorStop(0.55, `rgba(44, 0, 66, ${0.45 * pulse})`);
             aura.addColorStop(1, 'rgba(0, 0, 0, 0)');
             ctx.fillStyle = aura;
             ctx.beginPath();
             ctx.ellipse(0, 14, 62, 26, 0, 0, Math.PI * 2);
             ctx.fill();

             ctx.rotate(Math.sin(Date.now() / 900) * 0.05);
             ctx.fillStyle = '#1d0d2f';
             ctx.strokeStyle = '#b985ff';
             ctx.lineWidth = 2.2;
             ctx.beginPath();
             ctx.moveTo(-24, -34);
             ctx.quadraticCurveTo(-8, -45, 0, -32);
             ctx.quadraticCurveTo(8, -45, 24, -34);
             ctx.lineTo(24, 38);
             ctx.quadraticCurveTo(8, 30, 0, 40);
             ctx.quadraticCurveTo(-8, 30, -24, 38);
             ctx.closePath();
             ctx.fill();
             ctx.stroke();

             ctx.strokeStyle = 'rgba(210, 150, 255, 0.9)';
             ctx.lineWidth = 1.5;
             for (let r = 0; r < 5; r++) {
                 const yy = -22 + r * 12;
                 ctx.beginPath();
                 ctx.moveTo(-15, yy);
                 ctx.lineTo(15, yy + (r % 2 === 0 ? 2 : -2));
                 ctx.stroke();
             }

             ctx.shadowBlur = 12;
             ctx.shadowColor = '#f0c0ff';
             ctx.fillStyle = '#f7e6ff';
             ctx.font = 'bold 18px Black Han Sans';
             ctx.textAlign = 'center';
             ctx.fillText('禁', 0, 5);
             ctx.shadowBlur = 0;

             const hpPercent = Math.max(0, enemy.hp) / enemy.maxHp;
             ctx.fillStyle = 'black';
             ctx.fillRect(-20, -enemy.radius - 15, 40, 6);
             ctx.fillStyle = '#b050ff';
             ctx.fillRect(-20, -enemy.radius - 15, 40 * hpPercent, 6);

             ctx.restore();
             return;
        }
                if (enemy.isAmbush && enemy.ambushState === 'ambush') {
                    ctx.save(); ctx.translate(enemy.x, enemy.y); const ambushAlpha = 0.3 + Math.sin(Date.now() / 200) * 0.1;
                    const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, 20); gradient.addColorStop(0, `rgba(255, 0, 0, ${ambushAlpha * 0.5})`); gradient.addColorStop(1, `rgba(255, 0, 0, 0)`);
                    ctx.fillStyle = gradient; ctx.beginPath(); ctx.arc(0, 0, 20, 0, Math.PI * 2); ctx.fill(); ctx.restore(); return; 
                }

                if (enemy.isKai && enemy.soulLinkTarget && enemy.soulLinkTarget.hp > 0) {
            ctx.save();
            ctx.translate(enemy.x, enemy.y); // 카이의 위치로 기준점 이동

            // 선 스타일 설정
            ctx.strokeStyle = '#FF0000'; // 붉은색
            ctx.lineWidth = 3;
            ctx.shadowColor = '#FF0000';
            ctx.shadowBlur = 15;
            ctx.lineCap = 'round';

            // 카이(0,0) 부터 타겟까지의 상대 좌표 계산
            const tx = enemy.soulLinkTarget.x - enemy.x;
            const ty = enemy.soulLinkTarget.y - enemy.y;
            const dist = Math.hypot(tx, ty);

            ctx.beginPath();
            ctx.moveTo(0, 0);

            // 지그재그 전류 효과
            const segments = Math.floor(dist / 20); // 20픽셀 단위로 꺾임
            for (let i = 1; i < segments; i++) {
                const t = i / segments;
                // 직선 상의 위치
                let px = tx * t;
                let py = ty * t;
                // 랜덤 떨림 추가
                px += (Math.random() - 0.5) * 15;
                py += (Math.random() - 0.5) * 15;
                ctx.lineTo(px, py);
            }
            ctx.lineTo(tx, ty); // 끝점 연결
            ctx.stroke();
            
            // 연결된 대상 강조 원
            ctx.beginPath();
            ctx.arc(tx, ty, enemy.soulLinkTarget.radius + 10, 0, Math.PI*2);
            ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            ctx.restore();
        }

                ctx.save(); ctx.translate(enemy.x, enemy.y); ctx.rotate(enemy.angle + Math.PI / 2);
                if (enemy.hitFlash > 0) { ctx.shadowColor = "white"; ctx.shadowBlur = 20; } 
                else if (enemy.isBoss) { ctx.shadowColor = "purple"; ctx.shadowBlur = 50; }
                else if (enemy.isRoyal) { ctx.shadowColor = "#00CED1"; ctx.shadowBlur = 30; }
                else if (enemy.isElite) { ctx.shadowColor = "red"; ctx.shadowBlur = 20; }
                else if (enemy.isAgent) { ctx.shadowColor = "#FFA500"; ctx.shadowBlur = 20; } 
                
                if (enemy.isLuca && enemy.aimTimer > 420 && enemy.aimTimer < 480) {
                     ctx.save();
                     ctx.strokeStyle = `rgba(255, 0, 0, ${Math.random() * 0.5 + 0.5})`;
                     ctx.lineWidth = 2;
                     ctx.beginPath();
                     ctx.moveTo(0, 0);
                     ctx.lineTo(0, -1000); 
                     ctx.stroke();
                     ctx.restore();
                }
                
                if (enemy.hasShield) {
                    ctx.save();
                    ctx.strokeStyle = '#FFFF00'; 
                    ctx.lineWidth = 4;
                    ctx.shadowColor = '#FFFF00';
                    ctx.shadowBlur = 10;
                    ctx.beginPath();
                    ctx.arc(0, 0, enemy.radius + 10, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.restore();
                }
                 if (enemy.isRyuon && enemy.firmDarknessActive > 0) {
                    ctx.save();
                    // (주의: 이미 상위 코드에서 ctx.translate(enemy.x, enemy.y)가 되어 있어야 함)
                    
                    const sanctuaryRadius = enemy.radius * 2.0; // 성역 크기
                    const time = Date.now() / 300; // 애니메이션 시간

                    const domeCanvas = getFirmDarknessDomeCanvas(sanctuaryRadius);
                    ctx.drawImage(
                    domeCanvas,
                    -Math.round(sanctuaryRadius),
                    -Math.round(sanctuaryRadius)
                  );

                    // 2. [가스 효과] 내부에서 소용돌이치는 검은 안개
                    const gasCount = 3; 
                    for (let k = 0; k < gasCount; k++) {
                        const angle = (Math.PI * 2 * k / gasCount) + time; // 회전함
                        const dist = sanctuaryRadius * 0.6 + Math.sin(time * 2 + k) * 20; // 안팎으로 움직임
                        
                        const gx = Math.cos(angle) * dist;
                        const gy = Math.sin(angle) * dist;
                        const gSize = 40 + Math.sin(time * 3 + k) * 10; // 크기 변화

                        // 가스 그라데이션 (검정 + 짙은 회색)
                        const gasGrad = ctx.createRadialGradient(gx, gy, 0, gx, gy, gSize);
                        gasGrad.addColorStop(0, 'rgba(0, 0, 0, 0.8)'); 
                        gasGrad.addColorStop(0.6, 'rgba(40, 0, 60, 0.5)'); // Dark Purple Mist
                        gasGrad.addColorStop(1, 'rgba(0, 0, 0, 0)');

                        ctx.fillStyle = gasGrad;
                        ctx.beginPath();
                        ctx.arc(gx, gy, gSize, 0, Math.PI * 2);
                        ctx.fill();
                    }

                    // 3. [입자 효과] 검보라색/검정 방구 가스 (갈색 -> 검정 변경)
                    const fartGasCount = 8;
                    for (let k = 0; k < fartGasCount; k++) {
                        // 위치 랜덤성 부여
                        const fAngle = (k * 137.5) + Math.sin(time * 0.8 + k) * 0.5; 
                        const fDist = (sanctuaryRadius * 0.7) * Math.abs(Math.sin(k * 1.1 + time * 0.3));
                        
                        const fx = Math.cos(fAngle) * fDist;
                        const fy = Math.sin(fAngle) * fDist;
                        const fSize = 25 + Math.sin(time * 2 + k) * 8; 

                        // 더러운 검정/보라 그라데이션
                        const fartGrad = ctx.createRadialGradient(fx, fy, 0, fx, fy, fSize);
                        fartGrad.addColorStop(0, 'rgba(10, 10, 10, 0.9)');    // 진한 검정
                        fartGrad.addColorStop(0.6, 'rgba(48, 25, 52, 0.6)'); // 짙은 바이올렛
                        fartGrad.addColorStop(1, 'rgba(0, 0, 0, 0)');        // 투명

                        ctx.fillStyle = fartGrad;
                        ctx.beginPath();
                        ctx.arc(fx, fy, fSize, 0, Math.PI * 2);
                        ctx.fill();
                    }

                    // 4. [추가] 검정색 꾸물거리는 올챙이 (그림자 정령 느낌)
                    const tadpoleCount = 10;
                    for (let k = 0; k < tadpoleCount; k++) {
                        const tAngle = (k / tadpoleCount * Math.PI * 2) - (time * 1.5); 
                        const tDist = (sanctuaryRadius * 0.4) + (Math.sin(time * 4 + k * 10) * 30) + (k % 5) * 20;
                        const finalDist = Math.min(tDist, sanctuaryRadius * 0.9);

                        const tx = Math.cos(tAngle) * finalDist;
                        const ty = Math.sin(tAngle) * finalDist;

                        ctx.save();
                        ctx.translate(tx, ty);
                        ctx.rotate(tAngle + Math.PI / 2); 

                        // 머리 (검정)
                        ctx.fillStyle = 'black';
                        ctx.beginPath();
                        ctx.arc(0, 0, 3.5, 0, Math.PI * 2);
                        ctx.fill();

                        // 꼬리 (어두운 회색)
                        ctx.strokeStyle = '#333';
                        ctx.lineWidth = 1.5;
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        const tailWiggle = Math.sin(time * 20 + k) * 4; 
                        ctx.quadraticCurveTo(0, 5, tailWiggle, 10);
                        ctx.stroke();

                        ctx.restore();
                    }

                    // 5. [테두리 이펙트] 바닥의 마법진 링 (회전)
                    ctx.save();
                    ctx.rotate(-time * 0.5); // 반대 방향 회전
                    ctx.strokeStyle = '#4B0082'; // Indigo
                    ctx.lineWidth = 3;
                    ctx.setLineDash([]); // 실선
                    ctx.beginPath();
                    ctx.arc(0, 0, sanctuaryRadius, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.restore();

                    // 6. [전류] 가끔씩 튀는 검은/보라 전류
                    if (Math.random() < 0.3) {
                        ctx.strokeStyle = '#8A2BE2'; // BlueViolet
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        const startAngle = Math.random() * Math.PI * 2;
                        const r = sanctuaryRadius;
                        ctx.moveTo(Math.cos(startAngle) * r, Math.sin(startAngle) * r);
                        ctx.lineTo(Math.cos(startAngle + 0.5) * r * 0.8, Math.sin(startAngle + 0.5) * r * 0.8);
                        ctx.stroke();
                    }

                    ctx.restore();
                }
// ★ [수정됨] 심연의 공명 이펙트 (빨간색 + 정사각형 테두리)
if (enemy.hasAbyssalResonance) {
    ctx.save();

    // 1. 스타일 설정 (붉은색 네온)
    ctx.strokeStyle = "rgba(255, 50, 50, 0.9)"; // 선 색상: 밝은 빨강
    ctx.lineWidth = 3;           // 선 두께
    ctx.shadowBlur = 15;         // 빛 번짐 정도
    ctx.shadowColor = "#ff0000"; // 번짐 색상: 진한 빨강
    
    // 2. 정사각형 크기 설정 (이미지에 딱 맞게)
    // 적의 radius를 절반 크기(half-size)로 사용 (여유분 +5px)
    const s = enemy.radius + 5; 
    
    // 3. 정사각형 4개 꼭짓점 정의 (상좌, 상우, 하우, 하좌)
    const corners = [
        {x: -s, y: -s}, 
        {x: s, y: -s},  
        {x: s, y: s},   
        {x: -s, y: s}   
    ];

    ctx.beginPath();
    ctx.moveTo(corners[0].x, corners[0].y); // 시작점

    // 4. 각 변을 따라가며 전류(지그재그) 그리기
    for (let i = 0; i < 4; i++) {
        const start = corners[i];
        const end = corners[(i + 1) % 4]; // 다음 꼭짓점 (마지막은 처음으로 연결)

        // 한 변을 몇 번 꺾을지 (전류 디테일)
        const segments = 4; 

        for (let j = 1; j < segments; j++) {
            const t = j / segments; // 0.25, 0.5, 0.75 ...
            
            // 직선상의 중간 지점 계산
            const mx = start.x + (end.x - start.x) * t;
            const my = start.y + (end.y - start.y) * t;

            // 랜덤하게 흔들기 (Jitter)
            const jitter = (Math.random() - 0.5) * 10; 
            
            // 가로 변인지 세로 변인지에 따라 흔들리는 방향 조정
            if (i % 2 === 0) { 
                // 상, 하 변(가로) -> Y축으로 흔들림
                ctx.lineTo(mx, my + jitter);
            } else { 
                // 좌, 우 변(세로) -> X축으로 흔들림
                ctx.lineTo(mx + jitter, my);
            }
        }
        // 다음 모서리에 연결
        ctx.lineTo(end.x, end.y);
    }

    ctx.closePath();
    ctx.stroke();

    // (선택) 더 강렬한 효과를 위해 내부에 흰색 실선 추가
    ctx.strokeStyle = "white";
    ctx.lineWidth = 1;
    ctx.globalAlpha = 0.5;
    ctx.stroke();

    ctx.restore();
}
// [신규] 마사쿠니 흑월 이펙트
if (enemy.isMasakuni && enemy.blackMoonState === 'charging') {
    ctx.save();
    
    // [핵심 변경] 이펙트 좌표를 마사쿠니가 아닌 '플레이어(player)' 중심으로 설정
    ctx.translate(player.x, player.y);
    
    // 차징 시간에 따라 점점 진해짐
    const chargeRatio = enemy.blackMoonCharge / 60;
    ctx.globalAlpha = chargeRatio;
    
    ctx.beginPath();
    ctx.arc(0, 0, 120, 0, Math.PI * 2); // 반경 120 범위
    
    // [디자인] 보라색 오오라 그라데이션 적용
    const gradient = ctx.createRadialGradient(0, 0, 60, 0, 0, 120);
    gradient.addColorStop(0, "rgba(0, 0, 0, 1)");          // 중심: 완전 검정
    gradient.addColorStop(0.7, "rgba(50, 0, 50, 0.8)");   // 중간: 어두운 보라
    gradient.addColorStop(1, "rgba(139, 0, 255, 0.6)");   // 외곽: 밝은 보라색
    
    ctx.fillStyle = gradient;
    ctx.fill();
    
    // [디자인] 강력한 보라색 글로우 (위협감 조성)
    ctx.shadowColor = "#9400D3"; // 짙은 보라색
    ctx.shadowBlur = 60;         // 오오라 범위
    
    // 내부 흰색 실선 (살짝 보이게)
    ctx.strokeStyle = "white";
    ctx.lineWidth = 1;
    ctx.globalAlpha = chargeRatio * 0.5;
    ctx.stroke();

    ctx.restore();
}
                // 마사쿠니 심안 발동 상태 표시 (눈이 빛남)
                if (enemy.isMasakuni && enemy.nextAttackCrit) {
                    ctx.save();
                    ctx.translate(enemy.x, enemy.y - 40); // 머리 위
                    ctx.fillStyle = "red";
                    ctx.shadowColor = "red";
                    ctx.shadowBlur = 10;
                    ctx.beginPath();
                    ctx.arc(-15, 0, 5, 0, Math.PI*2);
                    ctx.arc(15, 0, 5, 0, Math.PI*2);
                    ctx.fill();
                    ctx.restore();
                }

                ctx.save();
                ctx.globalAlpha = enemy.alpha; 
                const size = enemy.radius * 2.5;
                try {
                    if (enemy.hitFlash > 0) ctx.filter = 'brightness(200%)';
                    if (enemy.isBoss) ctx.filter = 'brightness(50%) contrast(120%)';
                    if (enemy.isAkiClone) ctx.filter = 'brightness(60%) sepia(30%)';

                    let imgToDraw = summonerVillainImg;
                    
                    if (enemy.isBoss) {
                        if (enemy.isArthur) {
                            imgToDraw = arthurImg;
                        } else if (enemy.isArchdemon) {
                            if (enemy.archdemonName.includes('아키토')) imgToDraw = akitoImg;
                            else if (enemy.archdemonName.includes('토우야')) imgToDraw = touyaImg;
                            else imgToDraw = bossVillainImg;
                        } else {
                            imgToDraw = bossVillainImg;
                        }
                    } else if (enemy.isDarkDenizen) {
                        if (enemy.denizenType === 'louie') imgToDraw = louieImg;
                        else if (enemy.denizenType === 'rai') imgToDraw = raiImg;
                    } else if (enemy.isAkiClone) {
                            imgToDraw = akiImg;
                    } else if (enemy.isRoyal) { 
                        if (enemy.isMasakuni) imgToDraw = masakuniImg;
                        else if (enemy.isKaito) imgToDraw = kaitoImg;
                        else if (enemy.isQuesta) imgToDraw = questaImg;
                        else if (enemy.isTetora) imgToDraw = tetoraImg;
                    } else if (enemy.isElite) {
                        if (enemy.isRyuon) imgToDraw = corruptedHeroImg;
                        else if (enemy.isLuca) imgToDraw = corruptedSniperImg; 
                        else if (enemy.isOzma) imgToDraw = ozmaImg; 
                        else if (enemy.isTaro) imgToDraw = taroImg; 
                        else if (enemy.isGawain) imgToDraw = gawainImg; 
                        else if (enemy.isAki) imgToDraw = akiImg;
                        else if (enemy.isHiro) imgToDraw = hiroImg;
                        else if (enemy.isKai) imgToDraw = kaiImg;
                        else if (enemy.isJacques) imgToDraw = jacquesImg;
                        else imgToDraw = eliteVillainImg;
                    } else if (enemy.isZako) {
                        if (enemy.zakoType === 'terrorist') imgToDraw = zakoTerroristImg;
                        else if (enemy.zakoType === 'plague') imgToDraw = zakoPlagueImg;
                        else imgToDraw = zakoVillainImg;
                    } else if (enemy.isAgent) {
                         if (enemy.agentType === 'curse') imgToDraw = agentCurseImg;
                         else if (enemy.agentType === 'pain') imgToDraw = agentPainImg;
                         else if (enemy.agentType === 'blind') imgToDraw = agentBlindImg;
                    } else if (enemy.normalType === 'rapist') {
                        imgToDraw = rapistVillainImg;
                    }
                    // [추가된 코드] 원형으로 자르기 시작
                    ctx.save(); // ✅ clip 영향 범위 제한 (이미지에만 적용)
                    ctx.beginPath();
                    ctx.arc(0, 0, size / 2, 0, Math.PI * 2); 
                    ctx.clip();
            // [추가된 코드 끝]
                    ctx.drawImage(imgToDraw, -size/2, -size/2, size, size);
                    ctx.filter = 'none';
                    ctx.restore(); // ✅ clip 해제 (이펙트가 안 잘리게)
                } catch (e) { ctx.fillStyle = '#333'; ctx.beginPath(); ctx.arc(0, 0, enemy.radius, 0, Math.PI*2); ctx.fill(); }
                  if (enemy.isQuesta) {
            if (enemy.isVeiled) {
                // [OPT] 칠흑의 장막: 기존 색감 유지 + 캐시로 최적화
                drawQuestaVeilCached(ctx, size);
            }
            // 본 크러셔 이펙트도 여기에 두면 이미지 위에 그려집니다.
            if (enemy.boneCrusherState === 'rushing') {
                ctx.save();
                ctx.rotate(enemy.boneCrusherAngle - (enemy.angle + Math.PI/2));
                ctx.strokeStyle = "#4B0082"; 
                ctx.lineWidth = 5; 
                ctx.beginPath(); 
                ctx.moveTo(0, 0); 
                ctx.lineTo(0, -100); 
                ctx.stroke(); 
                ctx.restore();
            }
        }
                ctx.restore();

                if (enemy.isEvilDigestActive) {
    ctx.save();
    
    const time = Date.now() / 40; // 전류 애니메이션 속도
    
    // (1) 메인 갈색 전류
    ctx.beginPath();
    ctx.strokeStyle = "#5D4037"; // 진한 갈색
    ctx.lineWidth = 3;
    ctx.shadowColor = "#3E2723"; // 어두운 갈색 광채
    ctx.shadowBlur = 15;
    
    for (let i = 0; i <= 360; i += 10) {
        const angle = (i * Math.PI) / 180;
        // 적 반지름보다 조금 더 크게 설정 (radius * 1.3)
        const noise = Math.sin(angle * 10 + time) * 5 + Math.cos(angle * 20 - time) * 5;
        const r = (enemy.radius * 1.3) + noise; 
        
        const px = Math.cos(angle) * r;
        const py = Math.sin(angle) * r;
        
        if (i === 0) ctx.moveTo(px, py);
        else ctx.lineTo(px, py);
    }
    ctx.closePath();
    ctx.stroke();
    
    // (2) 내부의 탁한 흐름 (디테일 추가)
    ctx.beginPath();
    ctx.strokeStyle = "rgba(160, 82, 45, 0.7)"; // 탁한 황갈색
    ctx.lineWidth = 1;
    ctx.shadowBlur = 0;
    
    for (let i = 0; i <= 360; i += 15) {
        const angle = (i * Math.PI) / 180;
        const noise = Math.sin(angle * 15 - time) * 3;
        const r = (enemy.radius * 1.25) + noise; 
        
        const px = Math.cos(angle) * r;
        const py = Math.sin(angle) * r;
        
        if (i === 0) ctx.moveTo(px, py);
        else ctx.lineTo(px, py);
    }
    ctx.stroke();
    
    ctx.restore();
}

ctx.restore(); // 적의 좌표 변환(translate/rotate) 종료

                const hpPercent = Math.max(0, enemy.hp) / enemy.maxHp;

                // [신규] 카이 그림자 스왑 차지 보호막 게이지(노란색) - HP바 바로 위
                const activeShieldValue = Math.max(enemy.shadowSwapShield || 0, enemy.antiPassingShield || 0);
                const activeShieldMax = activeShieldValue === (enemy.antiPassingShield || 0) ? (enemy.antiPassingShieldMax || 0) : (enemy.shadowSwapShieldMax || 0);
                if (activeShieldValue > 0 && activeShieldMax > 0) {
                    const shieldPercent = Math.max(0, activeShieldValue) / activeShieldMax;
                    const sy = enemy.y - enemy.radius - 22;
                    ctx.fillStyle = 'black'; ctx.fillRect(enemy.x - 20, sy, 40, 5);
                    ctx.fillStyle = '#FFD700'; ctx.fillRect(enemy.x - 20, sy, 40 * shieldPercent, 5);
                }

                ctx.fillStyle = 'black'; ctx.fillRect(enemy.x - 20, enemy.y - enemy.radius - 15, 40, 6);
                ctx.fillStyle = '#ff3333'; ctx.fillRect(enemy.x - 20, enemy.y - enemy.radius - 15, 40 * hpPercent, 6);
                
                let drawName = false;
                let nameText = "";
                let nameColor = "white";

                if (enemy.isElite) {
                    drawName = true;
                    if(enemy.isBoss) {
                        if (enemy.isArchdemon) {
                            nameText = enemy.archdemonName;
                            nameColor = "#FF4500"; 
                        } else {
                            if (enemy.isArthur) {
                                nameText = "타락한 로드 아서";
                                nameColor = "#DC143C";
                            }
                            else if(enemy.bossType === 0) nameText = "방구킹 카인 (블랙 미스트)";
                            else if(enemy.bossType === 1) nameText = "방구킹 카인 (다크 테러리스트)";
                            else if(enemy.bossType === 2) nameText = "방구킹 카인 (테러블 자멘)";
                            else if(enemy.bossType === 3) nameText = "방구킹 카인 (호러블 네크로맨서)";
                            else if(enemy.bossType === 4) nameText = "방구킹 카인 (타네츠케 데빌)";
                            
                            if (!enemy.isArthur && !nameColor) nameColor = "#9370DB";
                        }
                    } else if (enemy.isDarkDenizen) {
                    } else {
                         if (enemy.isRyuon) { nameText = "타락한 용사 류온"; nameColor = "#8B0000"; }
                         else if (enemy.isLuca) { nameText = "타락한 스나이퍼 루카"; nameColor = "#FFFFFF"; } 
                         else if (enemy.isOzma) { nameText = "타락한 마법사 오즈마"; nameColor = "#FF00FF"; }
                         else if (enemy.isTaro) { nameText = "타락한 암살자 타로"; nameColor = "#708090"; }
                         else if (enemy.isGawain) { nameText = "타락한 성기사 가웨인"; nameColor = "#9370DB"; } 
                         else if (enemy.isAki) { nameText = "타락한 사냥꾼 아키"; nameColor = "#1a1a1a"; }
                         else if (enemy.isHiro) { nameText = "타락한 첩보원 히로"; nameColor = "#9932CC"; }
                         else if (enemy.isKai) { nameText = "흑마법사 카이"; nameColor = "#4B0082"; }
                         else if (enemy.isVoidGrimoire) { nameText = "저주받은 공허의 금서"; nameColor = "#C08CFF"; }
                         else if (enemy.isJacques) { nameText = "타락한 바드 자크"; nameColor = "#FFFFFF"; }
                         else {
                             nameText = "똥방구 카시아스";
                         }
                    }
                } 
                // ... (나머지 이름 그리기 로직) ...
                else if (!enemy.isZako) {
                    drawName = true;
                    if (enemy.isRoyal) {
                    if (enemy.isMasakuni) {
                        nameText = "검은 민족 마사쿠니";
                        nameColor = "#190000";
                   } else if (enemy.isKaito) {
                        nameText = "검은 민족 카이토";
                        nameColor = "#190000";
                   }
                     else if (enemy.isQuesta) {
                        nameText = "검은 민족 퀘스타";
                        nameColor = "#190000";
                   }
                     else if (enemy.isTetora) {
                        nameText = "검은 민족 테토라";
                        nameColor = "#190000";
                   }
              }
                   else if (enemy.isAgent) {
                         if (enemy.agentType === 'curse') { nameText = `공작원(저주) ${Math.ceil(enemy.agentDeathTimer/60)}`; nameColor = "#4B0082"; }
                         else if (enemy.agentType === 'pain') { nameText = `공작원(고통) ${Math.ceil(enemy.agentDeathTimer/60)}`; nameColor = "#6B8E23"; }
                         else { nameText = `공작원(실명) ${Math.ceil(enemy.agentDeathTimer/60)}`; nameColor = "#808080"; }
                    } else if (enemy.isDarkDenizen) {
                        if (enemy.denizenType === 'louie') nameText = "어둠의 주민 루이";
                        else nameText = "어둠의 주민 라이";
                        nameColor = "#800080";
                    } else if (enemy.normalType === 'rapist') {
                        if (enemy.isStealth) nameText = "강간범 (은신)";
                        else if (enemy.isAmbush) nameText = "강간범 (매복)";
                        else nameText = "강간범";
                        nameColor = "#FF1493";
                    } else if (enemy.normalType === 'summoner') {
                        if (enemy.eliteType === 1) nameText = "소환사(테러범)";
                        else if (enemy.eliteType === 2) nameText = "소환사(역병)";
                        else nameText = "소환사(덮치기범)";
                        nameColor = "#CCCCCC";
                    }
                } else if (enemy.isZako) {
                    drawName = true;
                    if (enemy.zakoType === 'terrorist') { nameText = "자코(테러범)"; nameColor = "#FF6347"; } 
                    else if (enemy.zakoType === 'plague') { nameText = "자코(역병)"; nameColor = "#32CD32"; } 
                    else { nameText = "자코(덮치기범)"; nameColor = "#AAAAAA"; }
                    if (enemy.enraged) { nameText = "격분한 " + nameText; nameColor = "#FF0000"; }
                }

              if (drawName) {
                ctx.font = "bold 12px Arial";
                ctx.textAlign = "center";
                ctx.fillStyle = nameColor;
                ctx.fillText(nameText, enemy.x, enemy.y - enemy.radius - 20);
            }
            ctx.restore();

            // [수정됨] 악마의 보호 마크 표시 (사악한 검보라색 방패)
            if (enemy.isProtectedByCain && enemy.hp > 0) {
                ctx.save();
                // 위치를 머리 위로 조정
                ctx.translate(enemy.x, enemy.y - enemy.radius - 40);

                // 사악한 보라색 광채
                ctx.shadowColor = "#8A2BE2"; // BlueViolet
                ctx.shadowBlur = 15;

                // 방패 모양 경로 그리기
                ctx.beginPath();
                ctx.moveTo(0, -20);
                ctx.quadraticCurveTo(20, -20, 20, 5);   // 우측 상단
                ctx.bezierCurveTo(20, 25, 0, 40, 0, 40); // 우측 하단 -> 끝점
                ctx.bezierCurveTo(0, 40, -20, 25, -20, 5); // 좌측 하단
                ctx.quadraticCurveTo(-20, -20, 0, -20);  // 좌측 상단
                ctx.closePath();

                // 내부 채우기 (어두운 보라 그라데이션)
                const shieldGrad = ctx.createLinearGradient(-10, -20, 10, 40);
                shieldGrad.addColorStop(0, "#4B0082"); // Indigo
                shieldGrad.addColorStop(1, "#000000"); // Black
                ctx.fillStyle = shieldGrad;
                ctx.fill();

                // 테두리 (검정)
                ctx.strokeStyle = "#000000";
                ctx.lineWidth = 3;
                ctx.stroke();

                // 방패 내부 문양 (V자 형광 보라)
                ctx.beginPath();
                ctx.moveTo(-10, -5);
                ctx.lineTo(0, 15);
                ctx.lineTo(10, -5);
                ctx.strokeStyle = "#D8BFD8"; // Thistle (연한 보라)
                ctx.lineWidth = 2;
                ctx.shadowColor = "#FF00FF";
                ctx.stroke();

                ctx.restore();
            }
        });
            // [렌더 순서] 오즈마 '방구 스모그' 발사체는 적들보다 위(전경)에 보이도록, 적 렌더링 이후에 그립니다.
            // [신규] 방구 스모그 투사체 (스프라이트)
            fartSmogs.forEach(p => {
                if (!fartSmogImg || !fartSmogImg.complete) return;
                ctx.save();
                ctx.translate(p.x, p.y);
                const angle = Math.atan2(p.vy, p.vx);
                ctx.rotate(angle);
                ctx.globalAlpha = 0.95;
                const w = p.radius * 2.8;
                const h = w * (fartSmogImg.height && fartSmogImg.width ? (fartSmogImg.height / fartSmogImg.width) : 0.6);
                ctx.drawImage(fartSmogImg, -w / 2, -h / 2, w, h);
                ctx.restore();
            });


            // 네더 그랩 그리기 (선 연결)
    if (player.netherGrabbedBy && player.netherGrabbedBy.hp > 0 && player.netherGrabbedBy.netherGrabActive) {
        ctx.save();
        ctx.strokeStyle = "#120A8F"; // Ultramarine
        ctx.lineWidth = 3;
        ctx.shadowColor = "#000080";
        ctx.shadowBlur = 10;
        
        ctx.beginPath();
        ctx.moveTo(player.netherGrabbedBy.x, player.netherGrabbedBy.y);
        
        // 지그재그 전류 효과
        const segments = 10;
        const dx = (player.x - player.netherGrabbedBy.x) / segments;
        const dy = (player.y - player.netherGrabbedBy.y) / segments;
        
        for(let k=1; k<segments; k++) {
            const jitter = (Math.random()-0.5) * 20;
            ctx.lineTo(player.netherGrabbedBy.x + dx*k + jitter, player.netherGrabbedBy.y + dy*k + jitter);
        }
        ctx.lineTo(player.x, player.y);
        ctx.stroke();
        ctx.restore();
    } else {
        player.netherGrabbedBy = null; // 연결 끊김 안전장치
    }

            // ... (아이템 그리기 등 생략) ...
            hollowNight.forEach(hk => {
                renderHollowNightEffect(ctx, hk);
            });


            items.forEach(item => {
                ctx.save(); ctx.translate(item.x, item.y); if (item.life < 120 && Math.floor(item.life / 10) % 2 === 0) ctx.globalAlpha = 0.5;
                function drawHeart(color, borderColor) { ctx.fillStyle = color; ctx.beginPath(); const r = item.radius; ctx.moveTo(0, -r * 0.5); ctx.bezierCurveTo(-r * 1.5, -r * 1.5, -r * 1.5, r, 0, r * 1.5); ctx.bezierCurveTo(r * 1.5, r, r * 1.5, -r * 1.5, 0, -r * 0.5); ctx.fill(); if(borderColor) { ctx.strokeStyle = borderColor; ctx.lineWidth = 2; ctx.stroke(); } }
                if (item.type === 'health') { drawHeart('#ff4d4d', '#cc0000'); ctx.fillStyle = 'white'; ctx.font = "bold 16px Arial"; ctx.textAlign = "center"; ctx.textBaseline = "middle"; ctx.fillText("+", 0, -2); } 
                else if (item.type === 'berserk') { ctx.drawImage(berserkItemImg, -item.radius, -item.radius, item.radius*2, item.radius*2); } 
                else if (item.type === 'white') { drawHeart('#FFFFFF', '#E0E0E0'); } 
                else if (item.type === 'shield') { ctx.drawImage(shieldItemImg, -item.radius, -item.radius, item.radius*2, item.radius*2); } 
                else if (item.type === 'justice') { ctx.drawImage(justiceItemImg, -item.radius, -item.radius, item.radius*2, item.radius*2); }
                else if (item.type === 'magnet') { ctx.drawImage(magnetItemImg, -item.radius, -item.radius, item.radius*2, item.radius*2); }
                else if (item.type === 'fakeHealth') {
                    // 진짜와 똑같이 그리되 테두리만 다르게 호출
                    // 옅은 보라색 테두리 (#9370DB)
                    drawHeart('#ff4d4d', '#9370DB'); 
                    ctx.fillStyle = 'white'; ctx.font = "bold 16px Arial"; ctx.textAlign = "center"; ctx.textBaseline = "middle"; ctx.fillText("+", 0, -2);
                }
                else if (item.type === 'ancientScroll') {
                    const r = item.radius;

                    // 1) 바닥 그림자
                    ctx.fillStyle = 'rgba(20, 8, 0, 0.35)';
                    ctx.beginPath();
                    ctx.ellipse(0, r * 0.48, r * 1.05, r * 0.34, 0, 0, Math.PI * 2);
                    ctx.fill();

                    // 2) 금빛 테두리 오라
                    const halo = ctx.createRadialGradient(0, 0, r * 0.55, 0, 0, r * 1.55);
                    halo.addColorStop(0, 'rgba(255, 230, 150, 0)');
                    halo.addColorStop(0.68, 'rgba(255, 214, 102, 0.08)');
                    halo.addColorStop(1, 'rgba(255, 180, 60, 0.24)');
                    ctx.fillStyle = halo;
                    ctx.beginPath();
                    ctx.arc(0, 0, r * 1.55, 0, Math.PI * 2);
                    ctx.fill();

                    // 3) 본체 양피지(그라디언트)
                    const parchment = ctx.createLinearGradient(-r, -r * 0.75, r, r * 0.75);
                    parchment.addColorStop(0.00, '#FFF2C8');
                    parchment.addColorStop(0.45, '#F7DFA8');
                    parchment.addColorStop(1.00, '#E7C47B');
                    ctx.fillStyle = parchment;
                    ctx.strokeStyle = '#7A4A1B';
                    ctx.lineWidth = 2.6;
                    ctx.beginPath();
                    ctx.roundRect(-r * 0.92, -r * 0.68, r * 1.84, r * 1.36, r * 0.17);
                    ctx.fill();
                    ctx.stroke();

                    // 4) 좌우 말림(더 고급스럽고 입체감 있게)
                    const rollGrad = ctx.createLinearGradient(-r, 0, r, 0);
                    rollGrad.addColorStop(0, '#E0B86F');
                    rollGrad.addColorStop(0.5, '#C99850');
                    rollGrad.addColorStop(1, '#E0B86F');
                    ctx.fillStyle = rollGrad;
                    ctx.strokeStyle = '#6E3C12';
                    ctx.lineWidth = 1.4;
                    ctx.beginPath(); ctx.ellipse(-r * 0.95, 0, r * 0.34, r * 0.40, 0, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
                    ctx.beginPath(); ctx.ellipse( r * 0.95, 0, r * 0.34, r * 0.40, 0, 0, Math.PI * 2); ctx.fill(); ctx.stroke();

                    // 5) 금박 프레임 + 중앙 봉인
                    ctx.strokeStyle = 'rgba(255, 222, 120, 0.95)';
                    ctx.lineWidth = 1.5;
                    ctx.beginPath();
                    ctx.roundRect(-r * 0.74, -r * 0.46, r * 1.48, r * 0.92, r * 0.10);
                    ctx.stroke();

                    const seal = ctx.createRadialGradient(0, 0, r * 0.04, 0, 0, r * 0.24);
                    seal.addColorStop(0, '#FFEAA6');
                    seal.addColorStop(0.5, '#F7C457');
                    seal.addColorStop(1, '#A76A16');
                    ctx.fillStyle = seal;
                    ctx.beginPath();
                    ctx.arc(0, 0, r * 0.24, 0, Math.PI * 2);
                    ctx.fill();

                    // 6) 장식 문양 (R+1 텍스트 제거)
                    ctx.strokeStyle = 'rgba(90, 46, 8, 0.8)';
                    ctx.lineWidth = 1.2;
                    ctx.beginPath();
                    ctx.moveTo(-r * 0.36, -r * 0.05);
                    ctx.quadraticCurveTo(0, -r * 0.26, r * 0.36, -r * 0.05);
                    ctx.moveTo(-r * 0.36, r * 0.06);
                    ctx.quadraticCurveTo(0, r * 0.28, r * 0.36, r * 0.06);
                    ctx.stroke();
                }
                ctx.restore();
            });

          pandemoniums.forEach(p => {
                ctx.save(); ctx.translate(p.x, p.y); const gradient = ctx.createRadialGradient(0, 0, 20, 0, 0, p.radius); gradient.addColorStop(0, '#39FF14'); gradient.addColorStop(0.6, '#0f000f'); gradient.addColorStop(1, 'rgba(0, 0, 0, 0)'); ctx.fillStyle = gradient; ctx.beginPath();
                ctx.arc(0, 0, p.radius, 0, Math.PI * 2);
                ctx.fill();
                
                // 판데모니움 내부 혼돈 효과
                const time = Date.now() / 100;
                ctx.strokeStyle = '#FFFFFF';
                ctx.lineWidth = 2;
                ctx.beginPath();
                for(let k=0; k<5; k++) {
                    const angle = (k / 5) * Math.PI * 2 + time;
                    const r = p.radius * 0.6 + Math.sin(time * 3 + k) * 10;
                    const px = Math.cos(angle) * r;
                    const py = Math.sin(angle) * r;
                    if (k===0) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                }
                ctx.closePath();
                ctx.stroke();
                
                ctx.restore();
            });
            
            // [신규] 카오스 오브 그리기
            chaosOrbs.forEach(p => {
                ctx.save(); ctx.translate(p.x, p.y);
                
                // 주황 -> 보라 -> 투명 그라데이션
                const gradient = ctx.createRadialGradient(0, 0, 20, 0, 0, p.radius);
                gradient.addColorStop(0, '#FF4500'); // OrangeRed (중심)
                gradient.addColorStop(0.6, '#800080'); // Purple (중간)
                gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(0, 0, p.radius, 0, Math.PI * 2);
                ctx.fill();
                
                // 내부 혼돈 효과 (빨간색 라인으로 위협적으로 표현)
                const time = Date.now() / 100;
                ctx.strokeStyle = '#FF0000'; // Red
                ctx.lineWidth = 2;
                ctx.beginPath();
                for(let k=0; k<5; k++) {
                    const angle = (k / 5) * Math.PI * 2 + time;
                    const r = p.radius * 0.6 + Math.sin(time * 3 + k) * 10;
                    const px = Math.cos(angle) * r;
                    const py = Math.sin(angle) * r;
                    if (k===0) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                }
                ctx.closePath();
                ctx.stroke();
                
                ctx.restore();
            });

                // [수정됨] 블러드 드레인 (박쥐 투사체) - 3D 볼륨감 있는 박쥐
                    bloodBats.forEach(b => {
                    ctx.save();
                    ctx.translate(b.x, b.y);
                    const angle = Math.atan2(player.y - b.y, player.x - b.x);
                    ctx.rotate(angle);

     // 1. 그림자 추가 (입체감)
    ctx.shadowColor = 'rgba(0, 0, 0, 0.6)';
    ctx.shadowBlur = 8;
    ctx.shadowOffsetY = 5;

    // 2. 박쥐 몸통 그라데이션
    const batGrad = ctx.createLinearGradient(0, -10, 0, 10);
    batGrad.addColorStop(0, '#ff4d4d'); // 위쪽은 밝은 빨강
    batGrad.addColorStop(1, '#500000'); // 아래쪽은 어두운 빨강
    ctx.fillStyle = batGrad;

    // 3. 곡선을 이용한 날개 모양 그리기 (기존 삼각형 -> 베지어 곡선)
    ctx.beginPath();
    ctx.moveTo(15, 0); // 머리 (앞쪽)
    
    // 오른쪽 날개 (위)
    ctx.bezierCurveTo(5, -10, -5, -25, -20, -15); 
    // 오른쪽 날개 (아래 - 갈퀴 모양)
    ctx.quadraticCurveTo(-10, -5, -5, 0);
    // 왼쪽 날개 (대칭)
    ctx.quadraticCurveTo(-10, 5, -20, 15);
    ctx.bezierCurveTo(-5, 25, 5, 10, 15, 0);
    
    ctx.fill();

    // 4. 눈 (노란색으로 포인트)
    ctx.shadowBlur = 0; // 눈에는 그림자 제거
    ctx.fillStyle = '#FFFF00';
    ctx.beginPath();
    ctx.arc(8, -3, 2, 0, Math.PI*2); // 오른쪽 눈
    ctx.arc(8, 3, 2, 0, Math.PI*2); // 왼쪽 눈
    ctx.fill();

    ctx.restore();
});

// [추가] 엑스칼리버 연기 궤적 그리기
slashTrails.forEach(t => {
    ctx.save();
    ctx.translate(t.x, t.y);
    const alpha = t.life / t.maxLife;
    // 검붉은색 그라데이션
    const grad = ctx.createRadialGradient(0, 0, 0, 0, 0, t.radius);
    grad.addColorStop(0, `rgba(50, 0, 0, ${alpha * 0.8})`); // 내부: 아주 어두운 빨강
    grad.addColorStop(1, `rgba(0, 0, 0, 0)`); // 외부: 투명
    
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.arc(0, 0, t.radius, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
});

// [추가] 엑스칼리버 참격(본체 + 전류) 그리기
excaliburSlashes.forEach(s => {
    ctx.save();
    ctx.translate(s.x, s.y);
    ctx.rotate(s.angle);

    // 1. 검은색 참격 본체 (초승달 모양)
    ctx.fillStyle = 'black';
    ctx.shadowColor = '#8B0000'; // DarkRed 그림자
    ctx.shadowBlur = 20;
    
    ctx.beginPath();
    ctx.arc(-20, 0, 60, -Math.PI/2.5, Math.PI/2.5); // 바깥쪽 호
    ctx.arc(-10, 0, 50, Math.PI/2.5, -Math.PI/2.5, true); // 안쪽 호
    ctx.closePath();
    ctx.fill();
    ctx.shadowBlur = 0; // 그림자 초기화

    // 2. 시뻘건 전류 이펙트 (무작위 지그재그 선)
    ctx.strokeStyle = '#DC143C'; // Crimson 색상
    ctx.lineWidth = 3;
    ctx.lineJoin = 'round';
    
    // 전류 3줄기 생성
    for (let k = 0; k < 3; k++) {
        ctx.beginPath();
        // 참격의 앞부분(오른쪽)을 감싸는 형태
        const startY = -40 + Math.random() * 80;
        ctx.moveTo(-20, startY); 
        
        let cx = -20;
        let cy = startY;
        // 지그재그 그리며 오른쪽으로 이동
        for(let j=0; j<5; j++) {
            cx += 10 + Math.random() * 10;
            cy += (Math.random() - 0.5) * 20;
            ctx.lineTo(cx, cy);
        }
        ctx.stroke();
    }
    
    // 3. 중심부 붉은 코어
    ctx.fillStyle = 'rgba(139, 0, 0, 0.8)';
    ctx.beginPath();
    ctx.ellipse(10, 0, 30, 5, 0, 0, Math.PI*2);
    ctx.fill();

    ctx.restore();
});

            // ==================================================================================
            // [플레이어 그리기]
            // ==================================================================================
            ctx.save();
            ctx.translate(player.x, player.y);
            
            // 무적 상태 깜빡임
            if (player.invincibleTimer > 0 && Math.floor(Date.now() / 50) % 2 === 0) {
                ctx.globalAlpha = 0.5;
            }

            // 무기 그리기 (회전)
            ctx.save();
            ctx.rotate(player.weapon.angle);
            ctx.fillStyle = player.weapon.color;
            
            // 베르세르크 상태면 무기가 붉게 빛남
            if (player.berserkTimer > 0) {
                ctx.shadowColor = 'red';
                ctx.shadowBlur = 15;
                ctx.fillStyle = '#8B0000';
            }
            
            // 무기 (긴 막대 형태)
            ctx.fillRect(0, -player.weapon.width / 2, player.weapon.length, player.weapon.width);
            ctx.fillRect(0, -player.weapon.width / 2, -player.weapon.length, player.weapon.width);
            // 공격 중 이펙트 (잔상)
            if (player.weapon.isAttacking) {
                ctx.beginPath();
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.lineWidth = 2;
                ctx.moveTo(10, 0);
                ctx.lineTo(player.weapon.length, 0);
                ctx.stroke();
            }
            ctx.restore();

            if (player.sacredFaithSkill.activeTimer > 0) {
                ctx.save();
                // 시간이 지날수록 깜빡이는 효과 (Pulse)
                const pulse = 1 + Math.sin(Date.now() / 200) * 0.1;
                
                // 빛나는 그라데이션 원
                const grad = ctx.createRadialGradient(0, 0, player.radius, 0, 0, player.radius * 2.5 * pulse);
                grad.addColorStop(0, "rgba(255, 215, 0, 0.4)"); // 안쪽 (골드)
                grad.addColorStop(1, "rgba(255, 215, 0, 0)");   // 바깥쪽 (투명)
                
                ctx.fillStyle = grad;
                ctx.beginPath();
                ctx.arc(0, 0, player.radius * 3, 0, Math.PI * 2);
                ctx.fill();
                
                // 외곽선 링
                ctx.strokeStyle = "rgba(255, 255, 0, 0.6)";
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(0, 0, player.radius * 2 * pulse, 0, Math.PI * 2);
                ctx.stroke();
                
                ctx.restore();
            }
            // 플레이어 본체
            const pSize = player.radius * 2.8;
            
            // 상태이상 시각 효과 (그림자)
            ctx.shadowBlur = 0;
            if (player.berserkTimer > 0) {
                ctx.shadowColor = 'red';
                ctx.shadowBlur = 20;
            } else if (player.justiceShield > 0) {
                 ctx.shadowColor = '#FFD700'; // 골드
                 ctx.shadowBlur = 20;
            } else if (player.shieldStacks > 0) {
                ctx.shadowColor = '#00BFFF'; // 딥 스카이 블루
                ctx.shadowBlur = 15;
            } else if (player.poisonTimers.length > 0 || player.poopPoisonTimers.length > 0) {
                ctx.shadowColor = '#00FF00';
                ctx.shadowBlur = 15;
            }

            try {
                // 스턴 상태면 회전하거나 흔들림 효과를 줄 수 있음
                if (player.stunTimer > 0) {
                    ctx.rotate(Math.sin(Date.now() / 50) * 0.2);
                }
                ctx.drawImage(playerImg, -pSize/2, -pSize/2, pSize, pSize);
                
                // 스턴 별 표시
                if (player.stunTimer > 0) {
                    ctx.font = "20px Arial";
                    ctx.fillStyle = "yellow";
                    ctx.fillText("★", 0, -player.radius - 15);
                }
                if (player.deathBrandTimers.length > 0) {
                ctx.save();
                // 플레이어 머리 위로 위치 이동 (좌표계는 이미 player.x, player.y)
                // 둥둥 떠다니는 애니메이션 효과 추가
                const floatY = Math.sin(Date.now() / 200) * 5;
                ctx.translate(0, -player.radius * 2.8 + floatY); 

                const s = 30; // 해골 크기

                // 1. 검붉은 후광 (사악한 기운)
                ctx.shadowColor = '#8B0000'; // DarkRed
                ctx.shadowBlur = 20;

                // 2. 두개골 형태 그리기 (입체적 곡선)
                ctx.beginPath();
                ctx.moveTo(0, -s * 0.4);
                ctx.bezierCurveTo(-s * 0.35, -s * 0.4, -s * 0.45, -s * 0.1, -s * 0.4, s * 0.1);
                ctx.bezierCurveTo(-s * 0.45, s * 0.25, -s * 0.25, s * 0.3, -s * 0.2, s * 0.45); // 왼쪽 광대
                ctx.lineTo(-s * 0.1, s * 0.65); // 턱
                ctx.quadraticCurveTo(0, s * 0.75, s * 0.1, s * 0.65);
                ctx.lineTo(s * 0.2, s * 0.45); // 오른쪽 광대
                ctx.bezierCurveTo(s * 0.25, s * 0.3, s * 0.45, s * 0.25, s * 0.4, s * 0.1);
                ctx.bezierCurveTo(s * 0.45, -s * 0.1, s * 0.35, -s * 0.4, 0, -s * 0.4);
                ctx.closePath();

                // 3. 입체감 있는 검붉은 그라데이션 채색
                const skullGrad = ctx.createRadialGradient(-s*0.1, -s*0.1, s*0.1, 0, 0, s*0.6);
                skullGrad.addColorStop(0, '#ff6666');   // 하이라이트 (연한 붉은색)
                skullGrad.addColorStop(0.4, '#800000'); // 중간 (진한 밤색)
                skullGrad.addColorStop(1, '#1a0000');   // 그림자 (거의 검정)
                
                ctx.fillStyle = skullGrad;
                ctx.fill();
                
                // 4. 눈 (검은 구멍 + 붉은 안광)
                ctx.fillStyle = 'black';
                ctx.shadowBlur = 0; // 눈 내부는 선명하게
                
                // 왼쪽 눈
                ctx.beginPath();
                ctx.moveTo(-s*0.12, s*0.05);
                ctx.bezierCurveTo(-s*0.2, -s*0.05, -s*0.35, -s*0.05, -s*0.32, s*0.15);
                ctx.bezierCurveTo(-s*0.3, s*0.25, -s*0.15, s*0.25, -s*0.12, s*0.05);
                ctx.fill();
                
                // 오른쪽 눈
                ctx.beginPath();
                ctx.moveTo(s*0.12, s*0.05);
                ctx.bezierCurveTo(s*0.2, -s*0.05, s*0.35, -s*0.05, s*0.32, s*0.15);
                ctx.bezierCurveTo(s*0.3, s*0.25, s*0.15, s*0.25, s*0.12, s*0.05);
                ctx.fill();

                // 붉은 안광 (포인트)
                ctx.fillStyle = '#ff0000';
                ctx.shadowColor = '#ff0000';
                ctx.shadowBlur = 10;
                ctx.beginPath();
                ctx.arc(-s*0.22, s*0.1, 2, 0, Math.PI*2);
                ctx.arc(s*0.22, s*0.1, 2, 0, Math.PI*2);
                ctx.fill();

                ctx.restore();
            }
                // 실명 표시
                if (player.blindTimers.length > 0) {
                    ctx.font = "16px Arial";
                    ctx.fillStyle = "#888";
                    ctx.fillText("?", 0, -player.radius - 5);
                }

            } catch (e) {
                // 이미지 로드 실패 시 대체 원
                ctx.fillStyle = '#4CAF50';
                ctx.beginPath();
                ctx.arc(0, 0, player.radius, 0, Math.PI * 2);
                ctx.fill();
            }

            ctx.restore();
            
            // 모바일 조작 가이드 (터치 중일 때 표시)
            if (isTouching) {
                ctx.save();
                ctx.beginPath();
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.lineWidth = 2;
                ctx.arc(touchStart.x, touchStart.y, 30, 0, Math.PI*2);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.arc(touchCurrent.x, touchCurrent.y, 30, 0, Math.PI*2);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.moveTo(touchStart.x, touchStart.y);
                ctx.lineTo(touchCurrent.x, touchCurrent.y);
                ctx.stroke();
                
                ctx.restore();
                     }
            // [Aki] Projectiles (foreground): draw AFTER enemies so they appear on top of enemy sprites
            dragShots.forEach(shot => {
                drawAkiDragShot(ctx, shot, frameCount);
            });
            evilArrows.forEach(arrow => {
                drawAkiEvilArrow(ctx, arrow, frameCount);
            });
            poisonousShots.forEach(shot => {
                drawAkiPoisonousShot(ctx, shot, frameCount);
            });


                drawFloatingTexts();
        }

        function updateHealthUI() {
            const percent = Math.max(0, player.health / player.maxHealth) * 100;
            healthBar.style.width = percent + '%';
            
            // HP 텍스트 업데이트 추가
            const currentHp = Math.ceil(Math.max(0, player.health));
            const maxHp = Math.ceil(player.maxHealth);
            document.getElementById('healthText').innerText = `HP: ${currentHp} / ${maxHp}`;
        }

        function updateMaxHealth() {
             player.maxHealth = player.baseMaxHealth;

             if (player.evilLightTimers.length > 0) {
               player.maxHealth = Math.floor(player.maxHealth * 0.85);
             }

             // 사악한 마음 스택 당 최대 체력 감소 효과 적용 (스택 당 10)
             if (player.evilMindTimers.length > 0) {
                 const reductionRatio = player.evilMindTimers.length * 0.02; 
                 const reductionAmount = Math.floor(player.baseMaxHealth * reductionRatio);
                 player.maxHealth -= reductionAmount;
             }

             // 최대 체력이 1 미만으로 떨어지지 않게 방지
             if (player.maxHealth < 1) player.maxHealth = 1;

             // 현재 체력이 최대 체력을 넘지 않도록 조정
             if (player.health > player.maxHealth) {
                 player.health = player.maxHealth;
             }

             updateHealthUI();
        }

        function updatePoopVisual() {
            if (player.poopPoisonTimers.length > 0) {
                poopOverlay.style.opacity = Math.min(0.8, player.poopPoisonTimers.length * 0.1);
            } else {
                poopOverlay.style.opacity = 0;
            }
        }

        function updateStatusUI() {
            function updateIcon(element, timers, stackElement) {
                if (timers && timers.length > 0) {
                    element.style.display = 'flex';
                    if (stackElement) stackElement.innerText = timers.length;
                } else {
                    element.style.display = 'none';
                }
            }

            // 기존 상태이상 업데이트
            updateIcon(poisonStatus, player.poisonTimers, poisonStacksText);
            updateIcon(poopStatus, player.poopPoisonTimers, poopStacksText);
            updateIcon(maliceStatus, player.maliceTimers, maliceStacksText);
            updateIcon(kissStatus, player.kissTimers, kissStacksText);
            updateIcon(semenStatus, player.semenTimers, semenStacksText);
            updateIcon(oralStatus, player.oralTimers, oralStacksText);
            updateIcon(byururutStatus, player.byururutTimers, byururutStacksText);
            updateIcon(fractureStatus, player.fractureTimers, fractureStacksText);

            // 겁탈
            if (player.geoptalCount > 0) {
                geoptalStatus.style.display = 'flex';
                geoptalStacksText.innerText = player.geoptalCount;
            } else {
                geoptalStatus.style.display = 'none';
            }
            
            // [신규] 절망, 세례 UI
            if (player.despairTimer > 0) {
                despairStatus.style.display = 'flex';
                // 남은 시간 표시는 선택사항 (여기선 생략하거나 아이콘만 표시)
            } else {
                despairStatus.style.display = 'none';
            }

            if (player.baptismStacks > 0) {
                baptismStatus.style.display = 'flex';
                baptismStacksText.innerText = player.baptismStacks;
            } else {
                baptismStatus.style.display = 'none';
            }

            // [수정] 과민 반응 (위치 이동 및 갱신 보장)
            if (player.hasHypersensitivity) {
                hypersensitivityStatus.style.display = 'flex';
            } else {
                hypersensitivityStatus.style.display = 'none';
            }

            // 출혈 UI
            if (player.bleedingTimers.length > 0) {
                bleedingStatus.style.display = 'flex';
                document.getElementById('bleedingVal').innerText = `x ${player.bleedingTimers.length}`;
            } else {
                bleedingStatus.style.display = 'none';
            }

            // 차광 UI
            if (player.shadingTimers.length > 0) {
                shadingStatus.style.display = 'flex';
            } else {
                shadingStatus.style.display = 'none';
            }

            // [추가] 신규 엘리트 디버프 4종 갱신 로직
            if (player.corruptedOathStacks > 0) {
                corruptedOathStatus.style.display = 'flex';
                corruptedOathStacksText.innerText = player.corruptedOathStacks;
            } else {
                corruptedOathStatus.style.display = 'none';
            }

            if (player.dangerousJudgmentStacks > 0) {
                dangerousJudgmentStatus.style.display = 'flex';
                dangerousJudgmentStacksText.innerText = player.dangerousJudgmentStacks;
            } else {
                dangerousJudgmentStatus.style.display = 'none';
            }

            if (player.deepDarknessStacks > 0) {
                deepDarknessStatus.style.display = 'flex';
                deepDarknessStacksText.innerText = player.deepDarknessStacks;
            } else {
                deepDarknessStatus.style.display = 'none';
            }

            if (player.corruptedJusticeStacks > 0) {
                corruptedJusticeStatus.style.display = 'flex';
                corruptedJusticeStacksText.innerText = player.corruptedJusticeStacks;
            } else {
                corruptedJusticeStatus.style.display = 'none';
            }
            if (player.serumContaminationTimers.length > 0) {
                serumContaminationStatus.style.display = 'flex';
            } else {
                serumContaminationStatus.style.display = 'none';
            }
            // -----------------------------------------------------

            updateIcon(fishyStatus, player.fishyTimers, fishyStacksText);
            updateIcon(blindStatus, player.blindTimers, blindStacksText);
            
            // [수정] 마비 아이콘 업데이트 (Timers 기반)
            updateIcon(paralysisStatus, player.paralysisTimers, paralysisStacksText);

            updateIcon(evilMindStatus, player.evilMindTimers, evilMindStacksText);
            updateIcon(curseStatus, player.curseTimers, curseStacksText);
            updateIcon(gnawingLifeStatus, player.gnawingLifeTimers, gnawingLifeStacksText);
            
            updateIcon(darkScentStatus, player.darkScentTimers, darkScentStacksText);
            updateIcon(darkSmellStatus, player.darkSmellTimers, darkSmellStacksText);
            updateIcon(darkSeedStatus, player.darkSeedTimers, darkSeedStacksText);
            updateIcon(darkKissStatus, player.darkKissTimers, darkKissStacksText);
            updateIcon(darkReceiverStatus, player.darkReceiverTimers, darkReceiverStacksText);
            updateIcon(darkEcstasyStatus, player.darkEcstasyTimers, darkEcstasyStacksText);
            // [추가] 아서 전용 디버프 UI 업데이트
            updateIcon(trueAncestorKissStatus, player.trueAncestorKissTimers, trueAncestorKissStacksText);
            updateIcon(fatalScarStatus, player.fatalScarTimers, fatalScarStacksText);
            updateIcon(corruptedBloodStatus, player.corruptedBloodTimers, corruptedBloodStacksText);

            // [신규] 암흑 및 정신착란 아이콘 업데이트
            if (darknessStatusEl) updateIcon(darknessStatusEl, player.darknessTimers, null);
            if (confusionStatusEl) updateIcon(confusionStatusEl, player.confusionTimers, null);

            // [추가] 군주의 위엄 (스택형이 아닌 활성화 여부)
            if (player.majestyActive) {
                majestyStatus.style.display = 'flex';
            } else {
                majestyStatus.style.display = 'none';
            }

            // 보호막
            if (player.shieldStacks > 0) {
                shieldStatus.style.display = 'flex';
                shieldStacksText.innerText = player.shieldStacks;
            } else {
                shieldStatus.style.display = 'none';
            }

            // 정의의 가호
            if (player.justiceShield > 0) {
                justiceStatus.style.display = 'flex';
                justiceStacksText.innerText = player.justiceShield;
            } else {
                justiceStatus.style.display = 'none';
            }
            
            // 사악한 빛
            if (player.evilLightTimers.length > 0) evilLightStatus.style.display = 'flex';
            else evilLightStatus.style.display = 'none';
            
            // 사악한 마음 오버레이
            if (player.evilMindTimers.length > 0) {
                mindOverlay.style.opacity = Math.min(0.8, player.evilMindTimers.length * 0.1);
            } else {
                mindOverlay.style.opacity = 0;
            }
            
            updatePoopVisual();
        }

        // 이펙트 업데이트 함수 (잔상 제거용)
     function updateEffects() {
    // 똥 자국 업데이트
    for (let i = poopStains.length - 1; i >= 0; i--) {
        poopStains[i].life--;
        if (poopStains[i].life <= 0) poopStains.splice(i, 1);
    }

    // 죽음 구름 업데이트 & 플레이어 충돌 체크
    let inDeathCloudThisFrame = false;
    for (let i = deathClouds.length - 1; i >= 0; i--) {
        const cloud = deathClouds[i];
        cloud.life--;

        // ★ [최적화] 제곱 거리 비교
        const dx = player.x - cloud.x;
        const dy = player.y - cloud.y;
        const distSq = dx * dx + dy * dy;
        const hitRadius = player.radius + cloud.radius;

        if (distSq < hitRadius * hitRadius) {
            player.slowedByCloud = true;
            inDeathCloudThisFrame = true;
            takeDamage(0.0025, 'hazardDot', cloud.accuracy, cloud.owner || cloud);
        }

        if (cloud.life <= 0) deathClouds.splice(i, 1);
    }

    if (inDeathCloudThisFrame) {
        // [패치] deathcloud 피격 시 '사악한 마음' 최초 적용을 1초(1000ms) 후로 지연
        // - frameDt(밀리초) 기반으로 누적하여, 주사율/프레임에 따라 중첩 속도가 달라지지 않게 처리
        const _dt = (typeof frameDt === 'number' ? frameDt : (1000 / 60));
        player.deathCloudTimer = (player.deathCloudTimer || 0) + _dt;
        if (player.deathCloudTimer >= 1000) {
            addStatus('evilMind', 900, 15);
            player.deathCloudTimer = 0;
        }
    } else {
        player.deathCloudTimer = 0;
    }

            // 땅 갈라짐 업데이트
            for (let i = groundCracks.length - 1; i >= 0; i--) {
                groundCracks[i].life--;
                if (groundCracks[i].life <= 0) groundCracks.splice(i, 1);
            }
        }
      function updateAndDrawDarkMatters() {
    for (let i = darkMatters.length - 1; i >= 0; i--) {
        const m = darkMatters[i];
        m.life--;

        // 유도 이동
        const targetAngle = Math.atan2(player.y - m.y, player.x - m.x);
        let angleDiff = targetAngle - m.angle;
        while (angleDiff <= -Math.PI) angleDiff += Math.PI * 2;
        while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
        m.angle += angleDiff * 0.05;
        
        m.vx = Math.cos(m.angle) * 2.0;
        m.vy = Math.sin(m.angle) * 2.0;
        m.x += m.vx;
        m.y += m.vy;

        m.gasTrailTimer++;
        if (m.gasTrailTimer >= 20) {
            spawnDarkGas(m.x, m.y, 3.0, 0.5, m.accuracy, 0, m.owner);
            m.gasTrailTimer = 0;
        }

        // ★ [최적화] 충돌 체크
        const dx = player.x - m.x;
        const dy = player.y - m.y;
        const distSq = dx * dx + dy * dy;
        const radii = player.radius + m.radius;

        if (distSq < radii * radii) {
            if (player.invincibleTimer <= 0) {
                let dmg = 38 + Math.floor(score * 0.21);
                takeDamage(dmg, 'direct', m.accuracy, m);
                player.despairTimer = 1200;
                updateStatusUI();
                showPickupEffect(player.x, player.y, "절망...", false, true, "evil-purple-text");
                darkMatters.splice(i, 1);
                continue;
            }
        }

        // 수명 종료 시 폭발
        if (m.life <= 0) {
            spawnDarkGas(m.x, m.y, 2.0, 1.0, m.accuracy, 0, m.owner);
            darkMatters.splice(i, 1);
            continue;
        }
        // 그리기 로직 (다크 매터 3D 볼륨 강화: 푸른 링 + 점성 보라 연유 + 꼬불꼬불 털)
        ctx.save();

        // 바닥 그림자(볼륨감)
        const R = m.radius;
        const t = Date.now() / 220;
        ctx.globalAlpha = 0.28;
        ctx.fillStyle = 'rgba(0,0,0,0.85)';
        ctx.beginPath();
        ctx.ellipse(m.x + R * 0.10, m.y + R * 0.78, R * 0.92, R * 0.42, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;

        // 구체 좌표계
        ctx.translate(m.x, m.y);

        // 가짜 광원(좌상단)
        const lx = -R * 0.38;
        const ly = -R * 0.42;

        // 1) 외곽 푸른 오라/링 (첨부 이미지 느낌)
        ctx.save();
        const glowR = R + 16;
        const aura = ctx.createRadialGradient(0, 0, R * 0.58, 0, 0, glowR);
        aura.addColorStop(0.00, 'rgba(0,0,0,0)');
        aura.addColorStop(0.55, 'rgba(20,120,255,0.18)');
        aura.addColorStop(0.78, 'rgba(70,210,255,0.55)');
        aura.addColorStop(1.00, 'rgba(120,240,255,0.00)');
        ctx.fillStyle = aura;
        ctx.beginPath();
        ctx.arc(0, 0, glowR, 0, Math.PI * 2);
        ctx.fill();

        // 전기 링(밝게)
        ctx.globalCompositeOperation = 'lighter';
        ctx.shadowColor = 'rgba(90,220,255,0.95)';
        ctx.shadowBlur = 26;
        ctx.lineWidth = 7;
        ctx.strokeStyle = 'rgba(70,200,255,0.95)';
        ctx.beginPath();
        ctx.arc(0, 0, R + 6, 0, Math.PI * 2);
        ctx.stroke();

        // 미세 번쩍임
        ctx.shadowBlur = 0;
        ctx.lineWidth = 2;
        ctx.strokeStyle = 'rgba(180,250,255,0.55)';
        ctx.beginPath();
        ctx.arc(0, 0, R + 2, 0, Math.PI * 2);
        ctx.stroke();

        ctx.globalCompositeOperation = 'source-over';
        ctx.restore();

        // 2) 본체(구체) - 3D 음영(빛 방향 오프셋 그라데이션)
        ctx.save();
        const bodyGrad = ctx.createRadialGradient(lx, ly, R * 0.18, 0, 0, R);
        bodyGrad.addColorStop(0.00, 'rgba(35, 0, 60, 0.95)');   // 하이라이트 근처
        bodyGrad.addColorStop(0.22, 'rgba(18, 0, 40, 0.98)');
        bodyGrad.addColorStop(0.55, 'rgba(5, 0, 18, 0.98)');
        bodyGrad.addColorStop(1.00, 'rgba(0, 0, 0, 1.00)');     // 가장자리 암부
        ctx.fillStyle = bodyGrad;
        ctx.beginPath();
        ctx.arc(0, 0, R, 0, Math.PI * 2);
        ctx.fill();

        // 림 다크(두께감)
        const rimDark = ctx.createRadialGradient(0, 0, R * 0.70, 0, 0, R);
        rimDark.addColorStop(0, 'rgba(0,0,0,0)');
        rimDark.addColorStop(1, 'rgba(0,0,0,0.55)');
        ctx.fillStyle = rimDark;
        ctx.beginPath();
        ctx.arc(0, 0, R, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();

        // 3) 내부 "끈적하고 꾸덕한 보라 연유"(클립 + 출렁임/덩어리/광택)
        ctx.save();
        ctx.beginPath();
        ctx.arc(0, 0, R - 6, 0, Math.PI * 2);
        ctx.clip();

        // 내부 유체의 중심 오프셋(움직임 방향으로 살짝 밀리게 해서 3D 착시)
        const driftX = (-m.vx || 0) * 3.2;
        const driftY = (-m.vy || 0) * 3.2;

        // 큰 출렁임(보라 연유 바닥층)
        const gooGrad = ctx.createRadialGradient(driftX + R*0.08, driftY + R*0.18, R*0.10, driftX, driftY, R*0.98);
        gooGrad.addColorStop(0.00, 'rgba(190, 90, 255, 0.30)');
        gooGrad.addColorStop(0.22, 'rgba(130, 50, 220, 0.24)');
        gooGrad.addColorStop(0.55, 'rgba(75, 25, 140, 0.18)');
        gooGrad.addColorStop(1.00, 'rgba(20, 5, 40, 0.12)');
        ctx.fillStyle = gooGrad;
        ctx.beginPath();
        ctx.arc(0, 0, R - 6, 0, Math.PI * 2);
        ctx.fill();

        // 점성 덩어리(꾸덕함) - 여러 개의 어두운/밝은 보라 덩어리
        for (let k = 0; k < 12; k++) {
            const a = (k / 12) * Math.PI * 2 + Math.sin(t * 0.7 + k * 2.1) * 0.35;
            const rr = (R * 0.18) + (Math.sin(t * 1.1 + k * 3.7) * R * 0.05);
            const px = Math.cos(a) * (R * 0.36) + driftX * 0.65;
            const py = Math.sin(a) * (R * 0.30) + driftY * 0.65;

            const blob = ctx.createRadialGradient(px - rr*0.35, py - rr*0.35, rr*0.10, px, py, rr);
            blob.addColorStop(0, 'rgba(210, 140, 255, 0.16)');
            blob.addColorStop(0.45, 'rgba(140, 70, 235, 0.13)');
            blob.addColorStop(1, 'rgba(35, 10, 70, 0.0)');
            ctx.fillStyle = blob;
            ctx.beginPath();
            ctx.arc(px, py, rr, 0, Math.PI * 2);
            ctx.fill();
        }

        // 표면 출렁임 하이라이트(유체 수면)
        ctx.globalCompositeOperation = 'lighter';
        ctx.globalAlpha = 0.45;
        ctx.lineWidth = 2.2;
        ctx.strokeStyle = 'rgba(210, 160, 255, 0.55)';
        for (let s = 0; s < 4; s++) {
            const yy = -R * 0.10 + s * (R * 0.12) + Math.sin(t * 1.8 + s * 1.3) * (R * 0.05);
            ctx.beginPath();
            ctx.ellipse(driftX * 0.35, yy + driftY * 0.25, R * (0.48 - s * 0.05), R * (0.16 - s * 0.01), 0.15, 0, Math.PI * 2);
            ctx.stroke();
        }
        ctx.globalAlpha = 1;
        ctx.globalCompositeOperation = 'source-over';

        // 스파클(내부 자잘한 보라 점)
        for (let p = 0; p < 18; p++) {
            const aa = (p / 18) * Math.PI * 2 + Math.sin(t * 1.2 + p) * 0.6;
            const pr = (R * 0.10) + (Math.sin(t * 1.9 + p * 3.1) * R * 0.06);
            const px = Math.cos(aa) * (R * 0.55) + driftX * 0.5;
            const py = Math.sin(aa) * (R * 0.45) + driftY * 0.5;
            ctx.globalAlpha = 0.55;
            ctx.fillStyle = 'rgba(210, 120, 255, 0.85)';
            ctx.beginPath();
            ctx.arc(px, py, 1.2 + (pr * 0.10), 0, Math.PI * 2);
            ctx.fill();
        }
        ctx.globalAlpha = 1;

        // 유리질 하이라이트(3D 느낌 핵심)
        ctx.globalCompositeOperation = 'lighter';
        ctx.globalAlpha = 0.65;
        ctx.fillStyle = 'rgba(210, 230, 255, 0.35)';
        ctx.beginPath();
        ctx.ellipse(lx * 0.55, ly * 0.55, R * 0.45, R * 0.30, -0.35, 0, Math.PI * 2);
        ctx.fill();

        ctx.globalAlpha = 0.35;
        ctx.fillStyle = 'rgba(200, 220, 255, 0.28)';
        ctx.beginPath();
        ctx.ellipse(lx * 0.15, ly * 0.10, R * 0.25, R * 0.16, -0.10, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;
        ctx.globalCompositeOperation = 'source-over';

        ctx.restore(); // clip end

        // 4) 기분 나쁜 꼬불꼬불 털 (더 두껍고 더 길게)
        ctx.save();
        const hairCount = 36;
        for (let j = 0; j < hairCount; j++) {
            const a = (j / hairCount) * Math.PI * 2;
            const wig = Math.sin(t * 2.1 + j * 91.7) * 1.05;

            const sx = Math.cos(a) * (R - 1);
            const sy = Math.sin(a) * (R - 1);

            const len = 24 + (Math.sin(j * 1.9) * 10) + (Math.sin(t + j) * 5);
            const curl = 13 + (Math.cos(j * 2.3) * 8);

            // 살짝 "앞/뒤" 느낌: 아래쪽 털은 더 진하고 두껍게
            const front = Math.max(0, Math.sin(a)); // 아래쪽(양수)일수록 전면
            ctx.lineWidth = 1.9 + front * 2.0;

            // 뿌리색(그림자) + 끝색(보라 기운)
            const alpha = 0.60 + front * 0.28;
            ctx.strokeStyle = `rgba(${15 + front*25}, ${8 + front*12}, ${28 + front*36}, ${alpha})`;

            const cp1a = a + 0.9 + wig * 0.30;
            const cp2a = a - 0.8 - wig * 0.25;

            const cp1x = Math.cos(cp1a) * (R + len * 0.35);
            const cp1y = Math.sin(cp1a) * (R + len * 0.35);
            const cp2x = Math.cos(cp2a) * (R + len * 0.70);
            const cp2y = Math.sin(cp2a) * (R + len * 0.70);

            const ex = Math.cos(a + wig * 0.45) * (R + len) + Math.cos(a * 3 + t) * (curl * 0.30);
            const ey = Math.sin(a + wig * 0.45) * (R + len) + Math.sin(a * 2 - t) * (curl * 0.30);

            ctx.beginPath();
            ctx.moveTo(sx, sy);
            ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, ex, ey);
            ctx.stroke();

            // 털 끝에 보라 점액 느낌
            if (j % 3 === 0) {
                ctx.globalAlpha = 0.40 + front * 0.24;
                ctx.fillStyle = 'rgba(180, 95, 255, 0.72)';
                ctx.beginPath();
                ctx.arc(ex, ey, 2.2 + front * 1.2, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
            }
        }
        ctx.restore();

        // 5) 30프레임마다 연보라빛 펄스 글로우
        ctx.save();
        const pulse = (Math.floor(frameCount / 30) % 2 === 0) ? 1 : 0;
        const pulseAlpha = 0.22 + pulse * 0.38;
        ctx.globalCompositeOperation = 'lighter';
        const pulseGlow = ctx.createRadialGradient(0, 0, R * 0.42, 0, 0, R * 1.65);
        pulseGlow.addColorStop(0.0, `rgba(225, 185, 255, ${0.08 + pulseAlpha * 0.16})`);
        pulseGlow.addColorStop(0.6, `rgba(193, 145, 255, ${pulseAlpha})`);
        pulseGlow.addColorStop(1.0, 'rgba(160, 120, 255, 0)');
        ctx.fillStyle = pulseGlow;
        ctx.beginPath();
        ctx.arc(0, 0, R * 1.65, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalCompositeOperation = 'source-over';
        ctx.restore();

        // 6) 가장자리 미세 림 라이트(구체 볼륨 강조)
        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        const rim = ctx.createRadialGradient(0, 0, R * 0.75, 0, 0, R + 2);
        rim.addColorStop(0.0, 'rgba(0,0,0,0)');
        rim.addColorStop(1.0, 'rgba(90, 200, 255, 0.22)');
        ctx.fillStyle = rim;
        ctx.beginPath();
        ctx.arc(0, 0, R + 2, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalCompositeOperation = 'source-over';
        ctx.restore();

        ctx.restore();
    }
}

      function updateAndDrawShadowGrips() {
    for (let i = shadowGrips.length - 1; i >= 0; i--) {
        const g = shadowGrips[i];
        g.x += g.vx; g.y += g.vy; g.life--;

        // 플레이어 충돌
        const dist = Math.hypot(player.x - g.x, player.y - g.y);
        if (dist < player.radius + g.radius) {
            if (player.invincibleTimer <= 0) {
                let dmg = 34 + Math.floor(score * 0.17);
                takeDamage(dmg, 'direct', g.accuracy, g);
                
                // 실명 2중첩 (방어 가능)
                if (!checkShieldBlockStatus('normal', 'blind')) addStatus('blind', 900, 2);
                if (!checkShieldBlockStatus('normal', 'blind')) addStatus('blind', 900, 2); 

                // 퀘스타 앞으로 끌고 옴
                if (g.owner && g.owner.hp > 0) {
                    player.x = g.owner.x + Math.cos(g.angle + Math.PI)*60;
                    player.y = g.owner.y + Math.sin(g.angle + Math.PI)*60;
                    showPickupEffect(player.x, player.y, "이리와♥", false, true, "choke-text");
                    
                    // 패시브: 새디즘 체크
                    const sadismCritResist = getEffectiveDefenderCritResist();
                    if (sadismCritResist <= SADISM_CRITRESIST_THRESHOLD) {
                        let heal = Math.floor(dmg * SADISM_LIFESTEAL_RATIO);
                        g.owner.hp = Math.min(g.owner.maxHp, g.owner.hp + heal);
                        showDamageText(g.owner.x, g.owner.y, "새디즘 +" + heal, false, false, "heal-text");
                        activateSadismGas(g.owner);
                    }
                }
                shadowGrips.splice(i, 1);
                continue;
            }
        }

        if (g.life <= 0) {
            shadowGrips.splice(i, 1);
            continue;
        }
        // ==========================================
        // [수정됨] 그리기: 검보라색 '주먹' + 사악한 오라
        // ==========================================
        ctx.save();
        ctx.translate(g.x, g.y);
        ctx.rotate(g.angle); // 진행 방향으로 회전

        // g.radius(피격/충돌) 기반으로 그림도 같이 스케일
        const s = (g.radius / 40);
        ctx.scale(s, s);

        const t = Date.now() / 250;

        // 1) 주변 오라(볼륨감 있는 검보라 연무)
        ctx.globalAlpha = 0.40;
        ctx.fillStyle = "rgba(35, 0, 70, 0.55)";
        ctx.shadowColor = "rgba(160, 60, 255, 0.95)";
        ctx.shadowBlur = 22;
        ctx.beginPath();
        ctx.ellipse(10, 0, 46, 28, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
        ctx.globalAlpha = 1;

        // 2) 뒤로 흐르는 꼬리(그림자 잔상)
        const trail = ctx.createLinearGradient(-75, 0, -12, 0);
        trail.addColorStop(0, "rgba(0,0,0,0)");
        trail.addColorStop(0.35, "rgba(20, 0, 30, 0.35)");
        trail.addColorStop(1, "rgba(90, 0, 140, 0.65)");
        ctx.fillStyle = trail;
        ctx.beginPath();
        ctx.ellipse(-45, 0, 34, 18, 0, 0, Math.PI * 2);
        ctx.fill();

        // 3) 주먹 본체(볼륨감: 라디얼 그라데이션)
        const bodyGrad = ctx.createRadialGradient(10, -12, 6, 14, 0, 62);
        bodyGrad.addColorStop(0, "#6b2bb8");
        bodyGrad.addColorStop(0.25, "#3a0a63");
        bodyGrad.addColorStop(0.65, "#13001f");
        bodyGrad.addColorStop(1, "#000000");

        ctx.fillStyle = bodyGrad;
        ctx.strokeStyle = "rgba(190, 90, 255, 0.20)";
        ctx.lineWidth = 2;

        // 손바닥(주먹) 실루엣: 둥근 사각형에 가까운 형태
        const x0 = -18, y0 = -22, w = 62, h = 44, r = 16;
        ctx.beginPath();
        ctx.moveTo(x0 + r, y0);
        ctx.quadraticCurveTo(x0 + w, y0, x0 + w, y0 + r);
        ctx.quadraticCurveTo(x0 + w, y0 + h, x0 + w - r, y0 + h);
        ctx.lineTo(x0 + r, y0 + h);
        ctx.quadraticCurveTo(x0, y0 + h, x0, y0 + h - r);
        ctx.lineTo(x0, y0 + r);
        ctx.quadraticCurveTo(x0, y0, x0 + r, y0);
        ctx.closePath();
        ctx.shadowColor = "rgba(70, 0, 110, 0.9)";
        ctx.shadowBlur = 18;
        ctx.fill();
        ctx.shadowBlur = 0;
        ctx.stroke();

        // 4) 너클(주먹 앞부분) - 살짝 돌출된 느낌
        const knuckleGrad = ctx.createRadialGradient(40, -16, 2, 40, -16, 16);
        knuckleGrad.addColorStop(0, "rgba(220, 170, 255, 0.55)");
        knuckleGrad.addColorStop(0.35, "rgba(120, 40, 200, 0.45)");
        knuckleGrad.addColorStop(1, "rgba(0, 0, 0, 0.85)");
        ctx.fillStyle = knuckleGrad;
        ctx.globalAlpha = 0.95;

        const kx = [28, 36, 44, 52];
        for (let n = 0; n < 4; n++) {
            ctx.beginPath();
            ctx.ellipse(kx[n], -10 + ((n % 2) ? 1.2 : 0), 8.5, 7.5, 0, 0, Math.PI * 2);
            ctx.fill();
        }
        ctx.globalAlpha = 1;

        // 5) 엄지(옆 라인) - 주먹 형태 완성
        const thumbGrad = ctx.createRadialGradient(20, 12, 2, 20, 12, 18);
        thumbGrad.addColorStop(0, "rgba(180, 90, 255, 0.45)");
        thumbGrad.addColorStop(1, "rgba(0, 0, 0, 0.9)");
        ctx.fillStyle = thumbGrad;
        ctx.beginPath();
        ctx.ellipse(18, 14, 16, 10, 0.45, 0, Math.PI * 2);
        ctx.fill();

        // 6) 하이라이트/균열 같은 사악한 무늬
        ctx.strokeStyle = "rgba(200, 120, 255, 0.55)";
        ctx.lineWidth = 1.5;
        ctx.globalAlpha = 0.65;
        ctx.beginPath();
        ctx.moveTo(6, -6);
        ctx.lineTo(26, -14);
        ctx.lineTo(36, -6);
        ctx.stroke();
        ctx.globalAlpha = 1;

        // 7) 전류 이펙트(지지직)
        if (Math.random() < 0.65) {
            ctx.strokeStyle = "rgba(190, 90, 255, 0.9)";
            ctx.shadowColor = "rgba(210, 120, 255, 0.95)";
            ctx.shadowBlur = 16;
            ctx.lineWidth = 2;
            ctx.lineCap = 'round';

            ctx.beginPath();
            const baseX = 10 + Math.sin(t) * 2;
            const baseY = Math.cos(t * 1.3) * 2;
            ctx.moveTo(baseX, baseY);
            for (let j = 0; j < 6; j++) {
                const px = baseX + 10 + j * 9 + (Math.random() - 0.5) * 6;
                const py = baseY + (Math.random() - 0.5) * 22;
                ctx.lineTo(px, py);
            }
            ctx.stroke();

            ctx.shadowBlur = 0;
        }

        ctx.restore();

    }
}

      function updateAndDrawConfessionalTotems() {
    let inAnyTotemRange = false;

    for (let i = confessionalTotems.length - 1; i >= 0; i--) {
        const t = confessionalTotems[i];
        
        // =================================================================
        // [업데이트 로직 유지] (사용자 코드 보존)
        // =================================================================
        t.life--;
        if (t.life <= 0) {
            confessionalTotems.splice(i, 1);
            continue;
        }

        // 플레이어 범위 체크
        const dist = Math.hypot(player.x - t.x, player.y - t.y);
        if (dist < t.range) {
            inAnyTotemRange = true;
            
            // 데미지 및 디버프 (0.5초마다)
            t.damageTimer++;
            if (t.damageTimer >= 30) {
                if (player.invincibleTimer <= 0) {
                    let dmg = 4 + Math.floor(score * 0.12);
                    takeDamage(dmg, 'direct', t.accuracy, t);
                    
                    // 세례 중첩 (방어 불가)
                    player.baptismStacks = Math.min(5, player.baptismStacks + 1);
                    updateStatusUI();
                    showPickupEffect(player.x, player.y, "회개하라..", false, false, "weak-text");
                }
                t.damageTimer = 0;
            }
        }

        // =================================================================
        // [그리기 로직 수정] 볼륨감 있는 마법진 + 3D 돌 질감 손 토템
        // =================================================================
        ctx.save();
        ctx.translate(t.x, t.y);
        
        const time = Date.now() / 1000;

        // -----------------------------------------------------------
        // 1. 볼륨감 있는 마법진 (Volumetric Magic Circle)
        // -----------------------------------------------------------
        // (1) 바닥 오라 (입체적인 붉은 안개)
        const pulse = 1 + Math.sin(time * 3) * 0.05;
        const areaRadius = t.range * pulse;
        
        // 중심은 투명하고 가장자리가 짙어지는 도넛형 그라데이션
        const auraGrad = ctx.createRadialGradient(0, 0, areaRadius * 0.2, 0, 0, areaRadius);
        auraGrad.addColorStop(0, "rgba(20, 0, 0, 0)");
        auraGrad.addColorStop(0.6, "rgba(60, 0, 0, 0.15)");
        auraGrad.addColorStop(0.9, "rgba(100, 0, 0, 0.4)"); // 가장자리 강조
        auraGrad.addColorStop(1, "rgba(0, 0, 0, 0)");

        ctx.fillStyle = auraGrad;
        ctx.beginPath();
        ctx.arc(0, 0, areaRadius, 0, Math.PI * 2);
        ctx.fill();

        // (2) 3D 원근감이 적용된 룬 링
        ctx.save();
        ctx.scale(1, 0.4); // Y축을 눌러서 바닥에 깔린 느낌 연출
        
        // 외곽 룬 링
        ctx.strokeStyle = "rgba(139, 0, 0, 0.8)"; // 짙은 붉은색
        ctx.lineWidth = 3;
        ctx.setLineDash([15, 10, 5, 10]); 
        ctx.lineDashOffset = time * 20; // 회전
        ctx.beginPath();
        ctx.arc(0, 0, t.range * 0.9, 0, Math.PI * 2);
        ctx.stroke();

        // 내부 링 (반대 회전)
        ctx.strokeStyle = "rgba(0, 0, 0, 0.6)"; 
        ctx.lineWidth = 2;
        ctx.setLineDash([5, 5]);
        ctx.lineDashOffset = -time * 15;
        ctx.beginPath();
        ctx.arc(0, 0, t.range * 0.6, 0, Math.PI * 2);
        ctx.stroke();
        ctx.restore(); // 스케일 복구

        // -----------------------------------------------------------
        // 2. 3D 돌 느낌의 손 토템 (Hand Shape Stone Totem)
        // -----------------------------------------------------------
        ctx.translate(0, 15); // 마법진 중심보다 약간 아래서 시작 (원근감)

        // (1) 그림자
        ctx.fillStyle = "rgba(0, 0, 0, 0.6)";
        ctx.beginPath();
        ctx.ellipse(0, 0, 25, 10, 0, 0, Math.PI * 2);
        ctx.fill();

        // (2) 돌 질감 그라데이션 (입체감의 핵심)
        // 좌측(어둠) -> 중앙(하이라이트) -> 우측(어둠)으로 빛을 받은 돌 느낌
        const stoneGrad = ctx.createLinearGradient(-25, 0, 25, 0);
        stoneGrad.addColorStop(0, "#1a1a1a");   // 암부 (아주 어두운 회색)
        stoneGrad.addColorStop(0.2, "#333333"); // 중간톤
        stoneGrad.addColorStop(0.4, "#5a5a5a"); // 명부 (하이라이트, 탁한 회색)
        stoneGrad.addColorStop(0.6, "#333333"); // 중간톤
        stoneGrad.addColorStop(1, "#0d0d0d");   // 암부

        ctx.fillStyle = stoneGrad;
        ctx.strokeStyle = "#111"; // 외곽선은 아주 진하게
        ctx.lineWidth = 1;

        // --- 손 모양 Path 그리기 (하나의 덩어리로 연결) ---
        ctx.beginPath();
        
        // 손목 (바닥)
        ctx.moveTo(-18, 0); 
        
        // 손바닥 왼쪽 라인
        ctx.quadraticCurveTo(-22, -20, -25, -35); 
        
        // [엄지] 
        ctx.quadraticCurveTo(-40, -45, -30, -55); // 끝
        ctx.quadraticCurveTo(-20, -45, -20, -35); // 안쪽
        
        // [검지]
        ctx.lineTo(-15, -45); 
        ctx.quadraticCurveTo(-18, -75, -10, -85); // 끝 (더 길게 솟음)
        ctx.quadraticCurveTo(-2, -70, 0, -45);    // 안쪽

        // [중지] (가장 높음)
        ctx.lineTo(2, -45);
        ctx.quadraticCurveTo(5, -90, 10, -95);    // 끝
        ctx.quadraticCurveTo(15, -85, 12, -45);   // 안쪽

        // [약지]
        ctx.lineTo(15, -45);
        ctx.quadraticCurveTo(22, -75, 20, -80);   // 끝
        ctx.quadraticCurveTo(18, -65, 18, -40);   // 안쪽

        // [새끼]
        ctx.lineTo(20, -38);
        ctx.quadraticCurveTo(32, -50, 35, -55);   // 끝
        ctx.quadraticCurveTo(28, -35, 22, -25);   // 안쪽
        
        // 손바닥 오른쪽 라인 -> 손목
        ctx.quadraticCurveTo(25, -10, 18, 0);
        
        // 손목 바닥 마감
        ctx.lineTo(-18, 0);
        
        ctx.fill();   // 그라데이션 채우기
        ctx.stroke(); // 외곽선

        // (3) 손바닥 중앙의 붉은 룬 (음각 느낌)
        ctx.save();
        ctx.shadowColor = "#ff0000";
        ctx.shadowBlur = 10;
        ctx.fillStyle = "rgba(200, 0, 0, 0.9)";
        ctx.font = "bold 24px serif";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        // 손바닥 중앙 좌표 쯤에 위치
        ctx.fillText("†", 0, -35);
        ctx.restore();

        // (4) 사악한 기운 (손 주변 검은 아지랑이)
        ctx.shadowBlur = 0;
        ctx.strokeStyle = "rgba(0, 0, 0, 0.3)";
        ctx.lineWidth = 2;
        ctx.beginPath();
        // 손 주변을 감싸는 불규칙한 라인
        ctx.moveTo(-20, 0);
        ctx.bezierCurveTo(-30, -20, -40, -60, -10, -90);
        ctx.moveTo(20, 0);
        ctx.bezierCurveTo(30, -20, 40, -60, 10, -90);
        ctx.stroke();

        ctx.restore();
    }

    // =================================================================
    // [업데이트 로직 유지] 범위 밖 해제
    // =================================================================
    if (!inAnyTotemRange && player.baptismStacks > 0) {
        player.baptismStacks = 0;
        updateStatusUI();
        showPickupEffect(player.x, player.y, "세례 해제", false, true);
    }
}
       function handleMaliceGasParticles() {
    for (let i = maliceGasParticles.length - 1; i >= 0; i--) {
        const p = maliceGasParticles[i];
        p.life--;
        p.size += 0.3; // 가스가 점점 퍼짐
        p.y -= 0.2;    // 가스가 살짝 위로 올라감 (기체 성질)

        if (p.life <= 0) {
            maliceGasParticles.splice(i, 1);
            continue;
        }

        ctx.save();
        ctx.translate(p.x, p.y);
        ctx.rotate(p.angle);
        
        // 갈색 더러운 가스 색상
        const alpha = p.life / 60; // 서서히 투명해짐
        ctx.fillStyle = `rgba(101, 67, 33, ${alpha * 0.6})`;
        
        ctx.beginPath();
        // 뭉게구름 모양
        ctx.arc(0, 0, p.size, 0, Math.PI * 2);
        ctx.arc(p.size * 0.6, -p.size * 0.4, p.size * 0.7, 0, Math.PI * 2);
        ctx.arc(-p.size * 0.6, -p.size * 0.4, p.size * 0.7, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.restore();
    }
}

    function handlePhantomGasParticles() {
  for (let i = phantomGasParticles.length - 1; i >= 0; i--) {
    const p = phantomGasParticles[i];
    p.life--;
    p.size += 0.35;
    p.y -= 0.15;

    if (p.life <= 0) {
      phantomGasParticles.splice(i, 1);
      continue;
    }

    ctx.save();
    ctx.translate(p.x, p.y);
    ctx.rotate(p.angle);

    const a = p.life / p.maxLife;

    // "더러운 청록 가스": 청록 + 탁한 갈색을 섞은 느낌
    // (원하면 숫자만 바꿔도 분위기 바뀜)
    ctx.fillStyle = `rgba(30, 80, 70, ${a * 0.35})`;   // 청록 탁함
    ctx.beginPath();
    ctx.arc(0, 0, p.size, 0, Math.PI * 2);
    ctx.arc(p.size * 0.6, -p.size * 0.4, p.size * 0.7, 0, Math.PI * 2);
    ctx.arc(-p.size * 0.6, -p.size * 0.4, p.size * 0.7, 0, Math.PI * 2);
    ctx.fill();

    // "때" 같은 얼룩 레이어(선택)
    ctx.fillStyle = `rgba(20, 10, 5, ${a * 0.18})`;
    ctx.beginPath();
    ctx.arc(p.size*0.2, 0, p.size*0.35, 0, Math.PI*2);
    ctx.fill();

    ctx.restore();
  }
}

    function handlePhantomSparkParticles() {
  for (let i = phantomSparkParticles.length - 1; i >= 0; i--) {
    const p = phantomSparkParticles[i];
    p.life--;
    p.x += p.vx;
    p.y += p.vy;

    if (p.life <= 0) {
      phantomSparkParticles.splice(i, 1);
      continue;
    }

    const a = p.life / p.maxLife;

    ctx.save();
    ctx.strokeStyle = `rgba(0, 206, 209, ${0.9 * a})`;
    ctx.lineWidth = p.w;
    ctx.lineJoin = "round";
    ctx.shadowColor = `rgba(0, 206, 209, ${0.8 * a})`;
    ctx.shadowBlur = 8;

    // 작은 지그재그 번개
    ctx.beginPath();
    ctx.moveTo(p.x, p.y);
    let cx = p.x, cy = p.y;
    for (let k = 0; k < 3; k++) {
      cx += (Math.random() - 0.5) * 8;
      cy += (Math.random() - 0.5) * 8;
      ctx.lineTo(cx, cy);
    }
    ctx.stroke();

    ctx.restore();
  }
}

        // [신규 이펙트] 가웨인 '잔혹한 돌진' 차지(모으기) 오오라
        function handleCruelChargeAuras() {
    // v14: 더 강한 최적화
    // - 캐시를 "저해상도(0.45x)"로 렌더 후 본화면에 확대(drawImage 1회)
    // - 캐시 갱신도 더 드물게(Stride*2) + 차지 후반(모임이 강해질수록) 연산 줄임
    // - 소용돌이/가스는 텍스처(1회 생성) 기반으로 drawImage 중심
    const stride = Math.max(2, performanceState.particleStride | 0);
    const updateEvery = Math.max(2, stride * 2); // 캐시 갱신 빈도
    const doUpdate = (frameCount % updateEvery === 0);

    for (let i = cruelChargeAuras.length - 1; i >= 0; i--) {
        const a = cruelChargeAuras[i];
        const owner = a.owner;

        if (!owner || owner.hp <= 0 || !owner.isCruelChargeCharging) {
            cruelChargeAuras.splice(i, 1);
            continue;
        }

        // 파라미터
        a.ringR = owner.radius * 2.25;
        a.ringW = Math.max(14, owner.radius * 0.52);
        a.phase = (a.phase ?? 0) + 0.06;
        a.swirlT = ((a.swirlT ?? 0) + (a.swirlSpeed ?? 0.012)) % 1;

        const coreR = Math.max(14, owner.radius * 0.65);

        // 저해상도 캐시(성능 핵심)
        const cacheScale = 0.45;
        const needSize = Math.ceil((a.ringR + a.ringW + 80) * 2);
        const needSizeLo = Math.max(64, Math.ceil(needSize * cacheScale));

        if (!a.cacheCanvas || a.cacheSize < needSize) {
            a.cacheCanvas = document.createElement('canvas');
            a.cacheCanvas.width = needSizeLo;
            a.cacheCanvas.height = needSizeLo;
            a.cacheCtx = a.cacheCanvas.getContext('2d');
            a.cacheSize = needSize;
            a.cacheScale = cacheScale;

            // 텍스처 캐시
            a.swirlTex = getCruelSpiralTex(needSizeLo);
            a.gasTex = getCruelGasBlobTex(128);
        } else if (a.cacheCanvas.width !== needSizeLo) {
            a.cacheCanvas.width = needSizeLo;
            a.cacheCanvas.height = needSizeLo;
            a.cacheCtx = a.cacheCanvas.getContext('2d');
            a.swirlTex = getCruelSpiralTex(needSizeLo);
        }

        const cctx = a.cacheCtx;
        const csz = a.cacheCanvas.width;
        const cx = csz / 2;
        const cy = csz / 2;

        // 차지 후반에 모임이 강해질수록 연산/입자 수를 줄여서 프레임 드랍 방지
        const t = Math.max(0, Math.min(1, a.swirlT));
        const late = (t > 0.65);

        // -----------------------
        // 캐시 갱신 (드물게)
        // -----------------------
        if (doUpdate) {
            cctx.clearRect(0, 0, csz, csz);

            // 합성: 빛겹침
            cctx.save();
            cctx.globalCompositeOperation = 'lighter';

            // 1) 링(가벼운 왜곡)
            const seg = late ? 14 : 20;
            const wob = late ? 0.06 : 0.09;
            cctx.lineWidth = Math.max(3, (a.ringW * 0.16) * a.cacheScale);
            cctx.strokeStyle = 'rgba(140, 0, 240, 0.35)';
            cctx.beginPath();
            for (let s = 0; s <= seg; s++) {
                const u = (Math.PI * 2) * (s / seg);
                const rr = (a.ringR * a.cacheScale) * (1 + Math.sin(a.phase * 1.4 + u * 3.0) * wob);
                const x = cx + Math.cos(u) * rr;
                const y = cy + Math.sin(u) * rr;
                if (s === 0) cctx.moveTo(x, y); else cctx.lineTo(x, y);
            }
            cctx.closePath();
            cctx.stroke();

            // 2) 중심 코어(진한 검보라)
            const coreGlowR = (coreR * 2.5) * a.cacheScale;
            const grd = cctx.createRadialGradient(cx, cy, 0, cx, cy, coreGlowR);
            grd.addColorStop(0.0, 'rgba(230, 80, 255, 0.55)');
            grd.addColorStop(0.35, 'rgba(130, 0, 240, 0.38)');
            grd.addColorStop(1.0, 'rgba(0, 0, 0, 0)');
            cctx.fillStyle = grd;
            cctx.beginPath();
            cctx.arc(cx, cy, coreGlowR, 0, Math.PI * 2);
            cctx.fill();

            // 3) 소용돌이 스트릭(텍스처 회전/스케일)
            cctx.save();
            cctx.translate(cx, cy);
            cctx.rotate(a.phase * 0.65);
            const swirlScale = 1.0 + (late ? 0.10 : 0.22);
            const drawSz = csz * swirlScale;
            cctx.globalAlpha = late ? 0.65 : 0.85;
            cctx.drawImage(a.swirlTex, -drawSz / 2, -drawSz / 2, drawSz, drawSz);
            cctx.restore();

            // 4) 가스(뿜어져나와 중심으로 흡입) — 소수만, 텍스처 기반
            const gasN = late ? 4 : 6; // keep low for perf
            for (let g = 0; g < gasN; g++) {
                const ang = a.phase * 0.9 + g * (Math.PI * 2 / gasN);
                const baseR = (a.ringR * (1.10 - t * 0.55)) * a.cacheScale;
                const gx = cx + Math.cos(ang) * baseR;
                const gy = cy + Math.sin(ang) * baseR;
                const sz = (late ? 46 : 58) * a.cacheScale;
                cctx.globalAlpha = late ? 0.32 : 0.42;
                cctx.drawImage(a.gasTex, gx - sz/2, gy - sz/2, sz, sz);

                // 흡입 스트릭 1개 (짧게)
                const tx = cx + Math.cos(ang + 0.9) * (baseR * 0.55);
                const ty = cy + Math.sin(ang + 0.9) * (baseR * 0.55);
                cctx.lineWidth = 2.2 * a.cacheScale;
                cctx.strokeStyle = 'rgba(200, 60, 255, 0.42)';
                cctx.beginPath();
                cctx.moveTo(gx, gy);
                cctx.lineTo(tx, ty);
                cctx.stroke();
            }

            // 5) 번개(하드캡, 드물게)
            if (!a.bolts) a.bolts = [];
            if (a.boltCD == null) a.boltCD = 0;
            a.boltCD--;
            const boltCap = 3;
            if (a.boltCD <= 0 && a.bolts.length < boltCap) {
                a.boltCD = late ? (10 + (Math.random() * 6)) : (7 + (Math.random() * 5));
                a.bolts.push(makeMiniBolt(owner, a.ringR * (1.05 - t * 0.35)));
            }
            for (let b = a.bolts.length - 1; b >= 0; b--) {
                const bolt = a.bolts[b];
                bolt.life--;
                if (bolt.life <= 0) { a.bolts.splice(b, 1); continue; }
                // draw bolt
                cctx.save();
                cctx.translate(cx, cy);
                cctx.rotate(a.phase * 0.25);
                cctx.globalAlpha = 0.55;
                cctx.lineWidth = 2.0 * a.cacheScale;
                cctx.strokeStyle = 'rgba(210, 80, 255, 0.28)';
                cctx.beginPath();
                for (let p = 0; p < bolt.pts.length; p++) {
                    const pt = bolt.pts[p];
                    const x = pt.x * a.cacheScale;
                    const y = pt.y * a.cacheScale;
                    if (p === 0) cctx.moveTo(x, y); else cctx.lineTo(x, y);
                }
                cctx.stroke();
                cctx.restore();
            }

            cctx.restore();
        }

        // -----------------------
        // 본화면 출력 (가벼움)
        // -----------------------
        ctx.save();
        ctx.translate(owner.x, owner.y);
        ctx.globalCompositeOperation = 'lighter';

        const drawW = a.cacheSize;
        const drawH = a.cacheSize;
        const loW = a.cacheCanvas.width;
        const loH = a.cacheCanvas.height;

        // 스케일 업 (이미지 스무딩)
        ctx.imageSmoothingEnabled = true;
        ctx.globalAlpha = 1.0;
        ctx.drawImage(a.cacheCanvas, -drawW/2, -drawH/2, drawW, drawH);

        ctx.restore();
    }
}
// ============================================================
// [신규 FX] 류온 '정의의 돌진' 차지(모으기) 이펙트
// - 검붉은빛 + 사악한 냄새날 것 같은 볼륨감 있는 방구 구름이 류온에게 모여듦
// - 가웨인의 잔혹한 돌진 오오라와 동일한 "저해상도 캐시 → drawImage 1회" 방식으로 가볍게 처리
// ============================================================
function handleJusticeChargeAuras() {
    const stride = Math.max(2, performanceState.particleStride | 0);
    const updateEvery = Math.max(2, stride * 2);
    const doUpdate = (frameCount % updateEvery === 0);

    for (let i = justiceChargeAuras.length - 1; i >= 0; i--) {
        const a = justiceChargeAuras[i];
        const owner = a.owner;

        // [확장] theme별 유지 조건
        const theme = (a.theme || 'justice');
        const isActive =
            (theme === 'justice' && owner && owner.hp > 0 && owner.chargeState === 'warmup') ||
            (theme === 'kaiSwap' && owner && owner.hp > 0 && owner.shadowSwapCharging) ||
            (theme === 'hiroAntiPassing' && owner && owner.hp > 0 && owner.antiPassingCharging);

        if (!isActive) {
            justiceChargeAuras.splice(i, 1);
            continue;
        }

        // 진행도(0~1): warmup이 90프레임(1.5초) 기준
        const totalWarmup = (a.totalWarmup || 90);
        const timerVal = (theme === 'kaiSwap') ? (owner.shadowSwapChargeTimer || 0)
            : (theme === 'hiroAntiPassing') ? (owner.antiPassingChargeTimer || 0)
            : (owner.chargeTimer || 0);
        const t = Math.max(0, Math.min(1, timerVal / totalWarmup));
        const late = (t > 0.70);
        // theme 색상 팔레트
        let ringStroke, core0, core1, core2, gasA, gasB;
        if (theme === 'hiroAntiPassing') {
            // 히로 안티 패싱: 녹갈색
            ringStroke = 'rgba(151, 171, 86, 0.33)';
            core0 = 'rgba(151, 171, 86, 0.55)';
            core1 = 'rgba(98, 86, 43, 0.42)';
            core2 = 'rgba(53, 45, 22, 0.16)';
            gasA = 'rgba(151, 171, 86, 0.40)';
            gasB = 'rgba(98, 86, 43, 0.22)';
        } else if (theme === 'kaiSwap') {
            // 카이 그림자 스왑: 원래 연분홍 테마
            ringStroke = 'rgba(255, 105, 180, 0.33)';
            core0 = 'rgba(255, 182, 193, 0.55)';
            core1 = 'rgba(255, 105, 180, 0.42)';
            core2 = 'rgba(140, 0, 70, 0.15)';
            gasA = 'rgba(255, 105, 180, 0.40)';
            gasB = 'rgba(255, 182, 193, 0.20)';
        } else {
            // 류온 정의의 돌진: 기본 검붉은 테마
            ringStroke = 'rgba(170, 10, 10, 0.33)';
            core0 = 'rgba(255, 90, 70, 0.55)';
            core1 = 'rgba(170, 10, 10, 0.42)';
            core2 = 'rgba(60, 0, 0, 0.15)';
            gasA = 'rgba(120, 0, 0, 0.40)';
            gasB = 'rgba(255, 90, 70, 0.20)';
        }



        // 파라미터
        a.ringR = owner.radius * 2.15;
        a.ringW = Math.max(14, owner.radius * 0.55);
        a.phase = (a.phase ?? 0) + 0.075;
        a.swirlT = ((a.swirlT ?? 0) + (a.swirlSpeed ?? 0.018)) % 1;

        const coreR = Math.max(14, owner.radius * 0.70);

        // 저해상도 캐시
        const cacheScale = 0.45;
        const needSize = Math.ceil((a.ringR + a.ringW + 90) * 2);
        const needSizeLo = Math.max(64, Math.ceil(needSize * cacheScale));

        if (!a.cacheCanvas || a.cacheSize < needSize) {
            a.cacheCanvas = document.createElement('canvas');
            a.cacheCanvas.width = needSizeLo;
            a.cacheCanvas.height = needSizeLo;
            a.cacheCtx = a.cacheCanvas.getContext('2d');
            a.cacheSize = needSize;
            a.cacheScale = cacheScale;

            // 텍스처
            a.swirlTex = getJusticeSpiralTex(needSizeLo);
            a.gasTex = getJusticeGasBlobTex(128);
        } else if (a.cacheCanvas.width !== needSizeLo) {
            a.cacheCanvas.width = needSizeLo;
            a.cacheCanvas.height = needSizeLo;
            a.cacheCtx = a.cacheCanvas.getContext('2d');
            a.swirlTex = getJusticeSpiralTex(needSizeLo);
        }

        const cctx = a.cacheCtx;
        const csz = a.cacheCanvas.width;
        const cx = csz / 2, cy = csz / 2;

        // -----------------------
        // 캐시 갱신(드물게)
        // -----------------------
        if (doUpdate) {
            cctx.clearRect(0, 0, csz, csz);

            cctx.save();
            cctx.globalCompositeOperation = 'lighter';

            // 1) 링 (검붉은 테두리)
            const seg = late ? 14 : 20;
            const wob = late ? 0.05 : 0.085;
            cctx.lineWidth = Math.max(3, (a.ringW * 0.16) * a.cacheScale);
            cctx.strokeStyle = ringStroke;
            cctx.beginPath();
            for (let s = 0; s <= seg; s++) {
                const u = (Math.PI * 2) * (s / seg);
                const rr = (a.ringR * a.cacheScale) * (1 + Math.sin(a.phase * 1.35 + u * 3.0) * wob);
                const x = cx + Math.cos(u) * rr;
                const y = cy + Math.sin(u) * rr;
                if (s === 0) cctx.moveTo(x, y); else cctx.lineTo(x, y);
            }
            cctx.closePath();
            cctx.stroke();

            // 2) 중심 코어 (검붉은 맥동)
            const coreGlowR = (coreR * 2.7) * a.cacheScale;
            const grd = cctx.createRadialGradient(cx, cy, 0, cx, cy, coreGlowR);
            grd.addColorStop(0.0, core0);
            grd.addColorStop(0.22, core1);
            grd.addColorStop(0.52, core2);
            grd.addColorStop(1.0, 'rgba(0, 0, 0, 0)');
            cctx.fillStyle = grd;
            cctx.beginPath();
            cctx.arc(cx, cy, coreGlowR, 0, Math.PI * 2);
            cctx.fill();

            // 3) 소용돌이(텍스처)
            cctx.save();
            cctx.translate(cx, cy);
            cctx.rotate(a.phase * 0.70 + a.swirlT * 1.35);
            const swirlScale = 1.0 + (late ? 0.07 : 0.18);
            const drawSz = csz * swirlScale;
            cctx.globalAlpha = late ? 0.75 : 0.92;
            cctx.drawImage(a.swirlTex, -drawSz / 2, -drawSz / 2, drawSz, drawSz);
            cctx.restore();

            // 4) 가스(덩어리) — 바깥에서 시작해서 점점 중심으로 모이기
            const gasN = late ? 5 : 7;
            for (let g = 0; g < gasN; g++) {
                const ang = a.phase * 0.85 + g * (Math.PI * 2 / gasN);
                const baseR = (a.ringR * (1.18 - t * 0.72)) * a.cacheScale;

                const gx = cx + Math.cos(ang) * baseR;
                const gy = cy + Math.sin(ang) * baseR;

                const sz = (late ? 54 : 66) * a.cacheScale;
                cctx.globalAlpha = late ? 0.34 : 0.46;
                cctx.drawImage(a.gasTex, gx - sz / 2, gy - sz / 2, sz, sz);

                // 흡입 스트릭(짧게)
                const tx = cx + Math.cos(ang + 0.85) * (baseR * 0.55);
                const ty = cy + Math.sin(ang + 0.85) * (baseR * 0.55);
                cctx.lineWidth = 2.1 * a.cacheScale;
                cctx.strokeStyle = (theme === 'kaiSwap') ? 'rgba(255, 182, 193, 0.36)' : 'rgba(255, 90, 70, 0.36)';
                cctx.beginPath();
                cctx.moveTo(gx, gy);
                cctx.lineTo(tx, ty);
                cctx.stroke();
            }

            cctx.restore();

            // 5) 암부(냄새나는 어둠 느낌) — 소스오버로 살짝 눌러주기
            cctx.save();
            cctx.globalCompositeOperation = 'source-over';
            cctx.globalAlpha = 0.10 + t * 0.14;
            cctx.fillStyle = 'rgba(0, 0, 0, 0.35)';
            cctx.beginPath();
            cctx.arc(cx, cy, (coreR * 1.20) * a.cacheScale, 0, Math.PI * 2);
            cctx.fill();
            cctx.restore();
        }

        // -----------------------
        // 본 화면에 그리기(1회 drawImage)
        // -----------------------
        const drawW = a.cacheCanvas.width / a.cacheScale;
        const drawH = a.cacheCanvas.height / a.cacheScale;

        ctx.save();
        ctx.translate(owner.x, owner.y);
        ctx.globalCompositeOperation = 'lighter';
        ctx.globalAlpha = 0.92;

        ctx.imageSmoothingEnabled = true;
        ctx.drawImage(a.cacheCanvas, -drawW / 2, -drawH / 2, drawW, drawH);

        ctx.restore();
    }
}


// --- 텍스처 생성(1회 캐시) ---
const _cruelSpiralTexCache = new Map();
function getCruelSpiralTex(size) {
    const key = size | 0;
    if (_cruelSpiralTexCache.has(key)) return _cruelSpiralTexCache.get(key);
    const c = document.createElement('canvas');
    c.width = key; c.height = key;
    const cctx = c.getContext('2d');
    const cx = key/2, cy = key/2;

    cctx.clearRect(0,0,key,key);
    cctx.globalCompositeOperation = 'lighter';

    // 여러 개의 곡선 스트릭을 "한 번만" 그려 텍스처화
    const lines = 26;
    for (let i=0;i<lines;i++){
        const baseA = (Math.PI*2) * (i/lines);
        const turns = 2.4;
        const maxR = key*0.46;
        cctx.beginPath();
        for (let s=0;s<=24;s++){
            const tt = s/24;
            const a = baseA + tt*turns + Math.sin((i*9.7)+tt*6.0)*0.08;
            const r = maxR*(1-tt*0.88) + Math.sin(tt*10 + i)*4;
            const x = cx + Math.cos(a)*r;
            const y = cy + Math.sin(a)*r;
            if (s===0) cctx.moveTo(x,y); else cctx.lineTo(x,y);
        }
        cctx.lineWidth = 1.5 + Math.random()*1.4;
        cctx.strokeStyle = `rgba(190, 40, 255, ${0.10 + Math.random()*0.10})`;
        cctx.stroke();
    }

    // 중심 암부(검보라 느낌)
    const grd = cctx.createRadialGradient(cx,cy,0,cx,cy,key*0.35);
    grd.addColorStop(0,'rgba(40,0,60,0.25)');
    grd.addColorStop(1,'rgba(0,0,0,0)');
    cctx.fillStyle = grd;
    cctx.beginPath();
    cctx.arc(cx,cy,key*0.35,0,Math.PI*2);
    cctx.fill();

    _cruelSpiralTexCache.set(key, c);
    return c;
}

let _cruelGasBlobTex = null;
function getCruelGasBlobTex(size) {
    if (_cruelGasBlobTex) return _cruelGasBlobTex;
    const c = document.createElement('canvas');
    c.width = size; c.height = size;
    const cctx = c.getContext('2d');
    const cx = size/2, cy = size/2;

    // 부드러운 가스 블롭 1개 (캐시)
    const g = cctx.createRadialGradient(cx,cy,0,cx,cy,size*0.5);
    g.addColorStop(0.0,'rgba(230, 80, 255, 0.55)');
    g.addColorStop(0.35,'rgba(120, 0, 240, 0.38)');
    g.addColorStop(1.0,'rgba(0, 0, 0, 0)');
    cctx.fillStyle = g;
    cctx.beginPath();
    cctx.arc(cx,cy,size*0.5,0,Math.PI*2);
    
    // 추가: '방구 구름' 느낌의 덩어리(한 번만 그려서 캐시) — 성능 영향 거의 없음
    cctx.globalCompositeOperation = 'lighter';
    for (let k = 0; k < 6; k++) {
        const a = Math.random() * Math.PI * 2;
        const r = (size * 0.12) + Math.random() * (size * 0.18);
        const px = cx + Math.cos(a) * r;
        const py = cy + Math.sin(a) * r;
        const rr = (size * 0.10) + Math.random() * (size * 0.12);
        const gg = cctx.createRadialGradient(px, py, 0, px, py, rr);
        gg.addColorStop(0.0, 'rgba(180, 20, 255, 0.22)');
        gg.addColorStop(1.0, 'rgba(0, 0, 0, 0)');
        cctx.fillStyle = gg;
        cctx.beginPath();
        cctx.arc(px, py, rr, 0, Math.PI * 2);
        cctx.fill();
    }
cctx.fill();

    _cruelGasBlobTex = c;
    return c;
}



// --- [류온 정의의 돌진 차지 이펙트] 텍스처 생성(1회 캐시) ---
const _justiceSpiralTexCache = new Map();
function getJusticeSpiralTex(size) {
    const key = size | 0;
    if (_justiceSpiralTexCache.has(key)) return _justiceSpiralTexCache.get(key);

    const c = document.createElement('canvas');
    c.width = key; c.height = key;
    const cctx = c.getContext('2d');
    const cx = key / 2, cy = key / 2;

    cctx.clearRect(0, 0, key, key);
    cctx.globalCompositeOperation = 'lighter';

    // 검붉은 소용돌이 스트릭
    const lines = 26;
    for (let i = 0; i < lines; i++) {
        const baseA = (Math.PI * 2) * (i / lines);
        const turns = 2.35;
        const maxR = key * 0.46;

        cctx.beginPath();
        for (let s = 0; s <= 24; s++) {
            const tt = s / 24;
            const a = baseA + tt * turns + Math.sin((i * 9.2) + tt * 6.2) * 0.08;
            const r = maxR * (1 - tt * 0.88) + Math.sin(tt * 10 + i) * 4;
            const x = cx + Math.cos(a) * r;
            const y = cy + Math.sin(a) * r;
            if (s === 0) cctx.moveTo(x, y); else cctx.lineTo(x, y);
        }

        cctx.lineWidth = 1.5 + Math.random() * 1.4;
        cctx.strokeStyle = `rgba(255, 70, 60, ${0.08 + Math.random() * 0.10})`;
        cctx.stroke();
    }

    // 중심 암부(검붉은/검정)
    const grd = cctx.createRadialGradient(cx, cy, 0, cx, cy, key * 0.35);
    grd.addColorStop(0, 'rgba(60, 0, 0, 0.28)');
    grd.addColorStop(1, 'rgba(0, 0, 0, 0)');
    cctx.fillStyle = grd;
    cctx.beginPath();
    cctx.arc(cx, cy, key * 0.35, 0, Math.PI * 2);
    cctx.fill();

    _justiceSpiralTexCache.set(key, c);
    return c;
}

let _justiceGasBlobTex = null;
function getJusticeGasBlobTex(size) {
    if (_justiceGasBlobTex) return _justiceGasBlobTex;

    const c = document.createElement('canvas');
    c.width = size; c.height = size;
    const cctx = c.getContext('2d');
    const cx = size / 2, cy = size / 2;

    // 부드러운 검붉은 가스 블롭(캐시)
    const g = cctx.createRadialGradient(cx, cy, 0, cx, cy, size * 0.52);
    g.addColorStop(0.0, 'rgba(255, 90, 70, 0.52)');
    g.addColorStop(0.34, 'rgba(170, 10, 10, 0.36)');
    g.addColorStop(0.62, 'rgba(55, 0, 0, 0.22)');
    g.addColorStop(1.0, 'rgba(0, 0, 0, 0)');
    cctx.fillStyle = g;
    cctx.beginPath();
    cctx.arc(cx, cy, size * 0.52, 0, Math.PI * 2);

    // 덩어리(볼륨감): 냄새나는 "방구 구름" 텍스처
    cctx.globalCompositeOperation = 'lighter';
    for (let k = 0; k < 7; k++) {
        const a = Math.random() * Math.PI * 2;
        const r = (size * 0.12) + Math.random() * (size * 0.20);
        const px = cx + Math.cos(a) * r;
        const py = cy + Math.sin(a) * r;
        const rr = (size * 0.10) + Math.random() * (size * 0.14);

        const gg = cctx.createRadialGradient(px, py, 0, px, py, rr);
        gg.addColorStop(0.0, 'rgba(255, 60, 60, 0.18)');
        gg.addColorStop(0.55, 'rgba(90, 0, 0, 0.10)');
        gg.addColorStop(1.0, 'rgba(0, 0, 0, 0)');

        cctx.fillStyle = gg;
        cctx.beginPath();
        cctx.arc(px, py, rr, 0, Math.PI * 2);
        cctx.fill();
    }

    cctx.fill();

    _justiceGasBlobTex = c;
    return c;
}
function makeMiniBolt(owner, radius) {
    const pts = [];
    const seg = 6 + (Math.random()*3)|0;
    const baseA = Math.random()*Math.PI*2;
    const baseR = Math.max(30, radius*0.55);
    for (let i=0;i<seg;i++){
        const t = i/(seg-1);
        const a = baseA + t*0.7 + (Math.random()-0.5)*0.35;
        const r = baseR*(1-t*0.75) + (Math.random()-0.5)*14;
        pts.push({x: Math.cos(a)*r, y: Math.sin(a)*r});
    }
    return {pts, life: 14};
}

        // ---- [캐시 캔버스] 중심 코어 / 링 ----
        const cruelChargeFxCache = { core: new Map(), ring: new Map(), gas: new Map() };

        function getCruelChargeCoreCanvas(r) {
            const key = r;
            if (cruelChargeFxCache.core.has(key)) return cruelChargeFxCache.core.get(key);

            const s = r * 4;
            const c = document.createElement('canvas');
            c.width = s; c.height = s;
            const g = c.getContext('2d');

            const cx = s / 2, cy = s / 2;

            // 외곽 글로우
            const grad = g.createRadialGradient(cx, cy, r * 0.2, cx, cy, r * 1.8);
            grad.addColorStop(0.0, 'rgba(255,220,255,0.55)');
            grad.addColorStop(0.25, 'rgba(190,80,255,0.55)');
            grad.addColorStop(0.55, 'rgba(110,20,180,0.25)');
            grad.addColorStop(1.0, 'rgba(0,0,0,0)');
            g.fillStyle = grad;
            g.beginPath();
            g.arc(cx, cy, r * 1.8, 0, Math.PI * 2);
            g.fill();

            // 중심 코어(작은 진한 구체)
            const grad2 = g.createRadialGradient(cx, cy, 0, cx, cy, r * 0.75);
            grad2.addColorStop(0.0, 'rgba(255,240,255,0.85)');
            grad2.addColorStop(0.4, 'rgba(210,120,255,0.75)');
            grad2.addColorStop(1.0, 'rgba(120,20,180,0.0)');
            g.fillStyle = grad2;
            g.beginPath();
            g.arc(cx, cy, r * 0.75, 0, Math.PI * 2);
            g.fill();

            cruelChargeFxCache.core.set(key, c);
            return c;
        }

        function getCruelChargeRingCanvas(ringR, ringW) {
            const key = ringR + 'x' + ringW;
            if (cruelChargeFxCache.ring.has(key)) return cruelChargeFxCache.ring.get(key);

            const s = Math.round((ringR + ringW) * 2.2);
            const c = document.createElement('canvas');
            c.width = s; c.height = s;
            const g = c.getContext('2d');
            const cx = s / 2, cy = s / 2;

            // 링 기본(그라데이션)
            g.globalCompositeOperation = 'source-over';
            g.lineCap = 'round';

            // 여러 겹으로 얇게 그려서 "왜곡 링"처럼
            for (let k = 0; k < 4; k++) {
                const w = Math.max(2, ringW * (0.22 - k * 0.035));
                g.lineWidth = w;
                const a = 0.18 - k * 0.03;
                g.strokeStyle = `rgba(180, 70, 255, ${Math.max(0.05, a)})`;
                g.beginPath();
                g.arc(cx, cy, ringR + (k - 1.5) * 2, 0, Math.PI * 2);
                g.stroke();
            }

            // 링에 짧은 스트릭(소용돌이/왜곡 느낌) - 개수 하드캡
            const streakN = 14;
            for (let i = 0; i < streakN; i++) {
                const ang = (i / streakN) * Math.PI * 2 + (Math.random() - 0.5) * 0.25;
                const r0 = ringR + (Math.random() - 0.5) * ringW * 0.45;
                const r1 = r0 - (10 + Math.random() * 18);
                g.lineWidth = 1.6;
                g.strokeStyle = `rgba(255, 220, 255, ${0.18 + Math.random() * 0.12})`;
                g.beginPath();
                g.moveTo(cx + Math.cos(ang) * r0, cy + Math.sin(ang) * r0);
                g.lineTo(cx + Math.cos(ang + 0.12) * r1, cy + Math.sin(ang + 0.12) * r1);
                g.stroke();
            }

            cruelChargeFxCache.ring.set(key, c);
            return c;
        }

        function getCruelChargeGasCanvas(sz) {
            const key = sz;
            if (cruelChargeFxCache.gas.has(key)) return cruelChargeFxCache.gas.get(key);

            const s = Math.max(32, Math.round(sz));
            const c = document.createElement('canvas');
            c.width = s; c.height = s;
            const g = c.getContext('2d');
            const cx = s / 2, cy = s / 2;

            const grad = g.createRadialGradient(cx, cy, 1, cx, cy, s * 0.48);
            grad.addColorStop(0.0, 'rgba(190, 60, 255, 0.55)');
            grad.addColorStop(0.35, 'rgba(110, 0, 200, 0.35)');
            grad.addColorStop(1.0, 'rgba(0, 0, 0, 0.0)');
            g.fillStyle = grad;
            g.beginPath();
            g.arc(cx, cy, s * 0.48, 0, Math.PI * 2);
            g.fill();

            g.globalCompositeOperation = 'lighter';
            for (let i = 0; i < 5; i++) {
                const rr = s * (0.10 + Math.random() * 0.14);
                const ax = cx + (Math.random() - 0.5) * s * 0.30;
                const ay = cy + (Math.random() - 0.5) * s * 0.30;
                const a = 0.10 + Math.random() * 0.14;
                g.fillStyle = `rgba(150, 0, 220, ${a})`;
                g.beginPath();
                g.arc(ax, ay, rr, 0, Math.PI * 2);
                g.fill();
            }

            cruelChargeFxCache.gas.set(key, c);
            return c;
        }


        function spawnCruelChargeAura(enemy) {
            // 성능 옵션(프레임 스트라이드) 반영
            const doFx = frameCount % performanceState.particleStride === 0;
            if (!doFx) return;

            // 이미 컨트롤러가 있으면 수명만 갱신
            for (let i = 0; i < cruelChargeAuras.length; i++) {
                const a = cruelChargeAuras[i];
                if (a && a.type === 'controller' && a.owner === enemy) {
                    a.life = a.maxLife; // 유지
                    return;
                }
            }

            // [컨트롤러 1개] 가웨인 1명당 1개의 오오라만 유지 (프레임드랍 방지)
            cruelChargeAuras.push({
                type: 'controller',
                owner: enemy,
                life: 999999,      // 오너 상태로 관리(죽으면 제거)
                maxLife: 999999,
                phase: Math.random() * Math.PI * 2,
                ringR: enemy.radius * 2.25,
                ringW: Math.max(18, enemy.radius * 0.55),
                // 소용돌이 스트릭(파티클 대신 절약형)
                swirlT: Math.random(),
                swirlSpeed: 0.028 + Math.random() * 0.01,
                streakAngles: Array.from({ length: 16 }, (_, k) => (Math.PI * 2 * k / 16) + (Math.random() - 0.5) * 0.35),
                streakOffsets: Array.from({ length: 16 }, () => Math.random()),
                boltCD: 0,
                bolts: [],
                gases: [],
                gasCD: 0,
            });
        }


function spawnJusticeChargeAura(enemy, theme = 'justice') {
    // 성능 옵션(프레임 스트라이드) 반영
    const doFx = frameCount % performanceState.particleStride === 0;
    if (!doFx) return;

    // 이미 컨트롤러가 있으면 유지 (owner + theme 기준)
    for (let i = 0; i < justiceChargeAuras.length; i++) {
        const a = justiceChargeAuras[i];
        if (a && a.type === 'controller' && a.owner === enemy && (a.theme || 'justice') === theme) {
            a.life = a.maxLife;
            return;
        }
    }

    // 1명당 theme별 1개만 유지
    const totalWarmup = (theme === 'kaiSwap') ? 240 : (theme === 'hiroAntiPassing') ? (enemy.antiPassingChargeMax || 360) : 90;

    justiceChargeAuras.push({
        type: 'controller',
        theme: theme,
        owner: enemy,
        life: 999999,
        maxLife: 999999,
        phase: Math.random() * Math.PI * 2,
        ringR: enemy.radius * 2.15,
        ringW: Math.max(18, enemy.radius * 0.55),
        swirlT: Math.random(),
        swirlSpeed: 0.020 + Math.random() * 0.010,
        totalWarmup: totalWarmup,
    });
}


    function updateAndDrawPhantomSwords() {
  for (let i = phantomSwords.length - 1; i >= 0; i--) {
    const s = phantomSwords[i];

    // 주인이 죽으면 제거
    if (!s.owner || s.owner.hp <= 0) {
      phantomSwords.splice(i, 1);
      continue;
    }

    // 1. 대기 상태 (주인 주변 회전)
    if (s.state === 'hover') {
      const orbitSpeed = Date.now() / 500;
      const offsetX = Math.cos(orbitSpeed + (s.index * 2.09)) * 60;
      const offsetY = Math.sin(orbitSpeed + (s.index * 2.09)) * 60;
      const targetX = s.owner.x + offsetX;
      const targetY = s.owner.y + offsetY;

      s.x += (targetX - s.x) * 0.1;
      s.y += (targetY - s.y) * 0.1;
      s.angle = Math.atan2(s.y - s.owner.y, s.x - s.owner.x);

      // ★ [최적화] 발사 감지 거리 체크 (400px)
      const dx = player.x - s.owner.x;
      const dy = player.y - s.owner.y;
      if (dx * dx + dy * dy < 160000) { // 400 * 400
        s.state = 'fire';
        const fireAngle = Math.atan2(player.y - s.y, player.x - s.x);
        s.vx = Math.cos(fireAngle) * 12;
        s.vy = Math.sin(fireAngle) * 12;
        s.angle = fireAngle;
      }
    }

    // 2. 발사 상태
    else if (s.state === 'fire') {
      s.x += s.vx;
      s.y += s.vy;
      s.life--;

      const backX = s.x - s.vx * 0.6;
      const backY = s.y - s.vy * 0.6;
      // (1) 더러운 가스: 1~2개씩
      const gasCount = 1 + (Math.random() < 0.35 ? 1 : 0);
      for (let g = 0; g < gasCount; g++) {
        phantomGasParticles.push({
           x: backX + (Math.random() - 0.5) * 10,
           y: backY + (Math.random() - 0.5) * 10,
           vx: (Math.random() - 0.5) * 0.6,
           vy: (Math.random() - 0.5) * 0.6,
           size: (3 + Math.random() * 4) * (s.size ?? 1),
           life: 28 + Math.floor(Math.random() * 10),
           maxLife: 38
          });
       }

         // (2) 전류 스파크: 너무 많으면 시끄러우니 확률로
       if (Math.random() < 0.6) {
       phantomSparkParticles.push({
          x: backX + (Math.random() - 0.5) * 6,
          y: backY + (Math.random() - 0.5) * 6,
          vx: (Math.random() - 0.5) * 1.8 - s.vx * 0.05,
          vy: (Math.random() - 0.5) * 1.8 - s.vy * 0.05,
          life: 10 + Math.floor(Math.random() * 8),
          maxLife: 18,
         // 번쩍이는 길이/굵기 느낌용
          len: 10 + Math.random() * 12,
          w: 1 + Math.random() * 1.5
        });
      }

      if (s.life <= 0 || s.x < -100 || s.x > canvas.width + 100) {
        phantomSwords.splice(i, 1);
        continue;
      }

      // ★ [최적화] 충돌 체크 (검 크기 약 20) + size 반영
      const dx = player.x - s.x;
      const dy = player.y - s.y;
      const sc = (s.size ?? 1);
      const hitR = 20 * sc;
      const distSq = dx * dx + dy * dy;

      if (distSq < hitR * hitR) {
        if (player.invincibleTimer <= 0) {
          let dmg = 20 + Math.floor(score * 0.19);
          if (s.owner.nextAttackCrit) {
            dmg *= 1.5;
            s.owner.nextAttackCrit = false;
            showPickupEffect(player.x, player.y, "치명상!", false, true, "masakuni-text");
          }
          takeDamage(dmg, 'direct', s.owner.accuracy, s.owner);
          for (let k = 0; k < 2; k++) addStatus('bleeding', 600, 20);
          showPickupEffect(player.x, player.y, "환영의 검..", false, true, "bleeding-border");
          phantomSwords.splice(i, 1);
          continue;
        }
      }
    }

    // 3. 그리기 로직 (size 반영)
    ctx.save();
    ctx.translate(s.x, s.y);
    ctx.rotate(s.angle);

    const drawSc = (s.size ?? 1);
    ctx.scale(drawSc, drawSc);

    ctx.shadowColor = "#00CED1";
    ctx.shadowBlur = 10;

    ctx.beginPath();
    ctx.moveTo(0, -25);
    ctx.lineTo(5, 5);
    ctx.lineTo(0, 10);
    ctx.lineTo(-5, 5);
    ctx.closePath();

    ctx.fillStyle = "black";
    ctx.fill();

    ctx.strokeStyle = "#2F4F4F";
    ctx.lineWidth = 2;
    ctx.stroke();

    ctx.restore();
  }

  // 4. 사후 정리 로직 (기존 유지)
  if (phantomSwords.length > 0) {
    phantomSwords = phantomSwords.filter(s => s.owner && s.owner.hp > 0);
    enemies.forEach(e => {
      if (e.isMasakuni && phantomSwords.filter(s => s.owner === e).length === 0) {
        e.phantomSwordsActive = false;
      }
    });
  }
}

function animate() {
    // 1. 게임 실행 여부 및 일시정지 체크
    if (!isGameRunning) return;
    if (isLevelUpPaused || isGearPanelOpen || isEquipPanelOpen || isRelicPanelOpen) return;

    // 2. 시간(dt) 계산
    const now = Date.now();
    let dt = now - lastTime;
    lastTime = now;
    if (dt > 100) dt = 1000 / 60; // 렉 방지

    // [프레임 보정] 60fps 기준 dt 스케일 (유도/진동 등에 사용)
    frameDt = dt;
    frameDtScale = dt / (1000 / 60);
    // [NEW] 장비 조건부 보너스(특수옵션) 갱신
    updateGearDynamicBonuses();
    if (frameDtScale < 0.25) frameDtScale = 0.25;
    if (frameDtScale > 2.5) frameDtScale = 2.5;

    updatePerformanceState();
    const doEffects = frameCount % performanceState.effectsStride === 0;
    const doParticles = frameCount % performanceState.particleStride === 0;
    const doProjectiles = frameCount % performanceState.projectileStride === 0;

    // 3. 일반 적(Zako) 생성 타이머 (일반 적은 자주 나오므로 dt로 계속 계산)
    enemyTimer += dt;
    let spawnInterval = Math.max(1000, 2500 - (score * 2.5));
    spawnInterval *= performanceState.enemySpawnMultiplier;
    if (enemyTimer >= spawnInterval) {
        spawnEnemy(false); // 일반 적 소환
        enemyTimer = 0;    // 타이머 리셋
    }

    // 4. 프레임 증가
    frameCount++;
     
   // 5. [핵심] 1초마다 점수 증가 및 엘리트/보스 스폰 체크
if (now - lastScoreTime >= 1000) {
    score++;
    scoreVal.innerText = score;
    lastScoreTime = now;

    // (1) 마사쿠니: 점수가 50의 배수일 때 (50, 100, 150...) [25 -> 50 변경]
  if (score % 50 === 0) {
                const bossExists = enemies.some(e => e.isBoss && e.hp > 0);
                if (!bossExists) {
                    const rand = Math.random();
                    // 4등분하여 25% 확률로 각각 소환
                    if (rand < 0.25) {
                        spawnMasakuni();
                    } else if (rand < 0.50) {
                        spawnKaito();
                    } else if (rand < 0.75) {
                        spawnQuesta();
                    } else {
                        spawnTetora(); // [추가] 테토라 등장
                    }
                }
            }
    // (2) 보스 빌런: 점수가 90의 배수일 때
    if (score % 90 === 0) {
        spawnBoss();
    }
    // (3) 엘리트 빌런: 15의 배수이면서, 50의 배수(마사쿠니)는 아닐 때
    else if (score % 15 === 0 && score % 50 !== 0) {
        const cainExists = enemies.some(e => e.isBoss && !e.isArchdemon);
        if (!cainExists) {
            for (let i = 0; i < 2; i++) { spawnEnemy(true); }
        }
    }
}

            updatePlayer();
            updateGeoptalHeal();
            
            updateGases();
            updateDarkGases();
            updateDarkGreenGases();
            
            updatePoops();
            updateBigPoops();
            updateDarkBigPoops();
            updateDarkWaves();
            updatePleasureZones();
            updatePheromoneMarkers();
            updateHollowNight();
            updateBloodBats();
            updateBloodPuddles();
            updateShockwaves();
            updatePinkGases();
            updateSadismGasEmitters();
            updateSadismBrownGases();
            updateDarkNotes();
            updatePianissimoSnipes();
            updatePrismSweeps();
            updateOcclusionSpools();
            updateBlackMoons();
            updateMaliceBallistics();
            updateDeathMetalNotes();
            updateDarknessSpotlights();
            updatePlayerBleeding(); // 도트뎀 및 상태이상 시간 감소
            updateEffects(); 
            updateFloatingTexts();
            // 기타 투사체 업데이트 통합 처리
            const projectiles = [
                { arr: homingSemens, baseDmg: 8, status: 'semen' }, 
                { arr: darkSemens, baseDmg: 11, status: 'darkSemens' }, 
                { arr: whiteshots, baseDmg: 6, status: null }, 
                { arr: darkHearts, baseDmg: 15, status: 'curse' }, 
                { arr: mindSkulls, baseDmg: 11, status: 'evilMind' },
            ];

            if (doProjectiles) {
                projectiles.forEach(type => {
                    for (let i = type.arr.length - 1; i >= 0; i--) {
                        const p = type.arr[i];
                        
                        if (p.isHoming) {
                             let angle = Math.atan2(player.y - p.y, player.x - p.x);

                             // [신규] 불규칙 유도 궤적(랜덤 오프셋 + 잔잔한 와블)
                             if (p.irregularHoming) {
                                 p.irregularTimer = (p.irregularTimer || 0) + 1;
                                 const interval = (p.irregularInterval || 12);
                                 if (p.irregularTimer >= interval) {
                                     p.irregularTimer = 0;
                                     const amp = (p.irregularAmp || 0.6);
                                     p.irregularTargetOffset = (Math.random() * 2 - 1) * amp;
                                     p.irregularInterval = 6 + Math.floor(Math.random() * 14);
                                 }
                                 const cur = (p.irregularOffset || 0);
                                 const target = (p.irregularTargetOffset || 0);
                                 p.irregularOffset = cur * 0.85 + target * 0.15;

                                 const seed = (p.irregularSeed || 0);
                                 angle += p.irregularOffset + Math.sin((score + seed) / 6) * 0.12;
                             }

                             const speed = p.speed || 3;
                             p.vx = Math.cos(angle) * speed;
                             p.vy = Math.sin(angle) * speed;
                        }
                        
                        p.x += p.vx; p.y += p.vy; p.life--;

                        if (type.arr === darkSemens) {
                            p.stickyTrailTimer = (p.stickyTrailTimer || 0) + 1;
                            if (p.owner && p.owner.isBoss && p.owner.bossType === 2 && p.stickyTrailTimer >= 12) {
                                stickyCreamPuddles.push({ x: p.x, y: p.y, radius: 36, life: 240 });
                                p.stickyTrailTimer = 0;
                            }
                        }
                        
                        if (p.life <= 0 || p.x < -200 || p.x > canvas.width + 200 || p.y < -200 || p.y > canvas.height + 200) {
                            type.arr.splice(i, 1);
                            continue;
                        }
                        
                        const dx = player.x - p.x;
                        const dy = player.y - p.y;
                        const distSq = dx * dx + dy * dy; // 현재 거리의 제곱
                        const radii = player.radius + p.radius; // 충돌 범위 합
                        if (distSq < radii * radii) {
                        if (player.invincibleTimer > 0) continue;
                            
                            let damage = 0;
                            if (p.isLucaShot) {
                            damage = 38 + Math.floor(score * 0.22);
                            if (!checkShieldBlockStatus('normal', 'blind')) addStatus('blind', 900, 1);
                            showPickupEffect(player.x, player.y, "크헉!", false, true, "sniper-text");
                } else {
                            damage = type.baseDmg + Math.floor(score * 0.17);
                }
                            takeDamage(damage, 'direct', p.accuracy, p);

                            if (type.status === 'evilMind') {
                                 if (addStatus('evilMind', 900, 15)) {
                                     showPickupEffect(player.x, player.y, "정신 오염♥", false, true, "mind-break-text");
                                 }
                             } else if (type.status === 'darkReceiver') {
                                 addStatus('darkReceiver', 900, 10);
                                 showPickupEffect(player.x, player.y, "타락한 사랑♥", false, true, "pink-text");
                            } else if (type.status === 'curse') {
                                 addStatus('curse', 900, 10); // 15초(900프레임) 지속, 최대 10중첩
                                 showPickupEffect(player.x, player.y, "저주..", false, true, "curse-border");
                            } else if (type.status === 'semen') {
                                if (!checkShieldBlockStatus('normal', 'semen')) addStatus('semen', 900, 30);
                                if (!checkShieldBlockStatus('normal', 'fishy')) addStatus('fishy', 900, 50);
                            } else if (type.status === 'darkSemens') {
                                // darkSemens는 상태이상 보호막으로 막히지 않음
                                addStatus('darkReceiver', 900, 20);
                                addStatus('darkSeed', 900, 20);
                                if (!checkShieldBlockStatus('normal', 'fishy')) addStatus('fishy', 900, 50);
                            } else if (type.status === 'darkness') {
                                    addStatus('darkness', 360, 1); // 6초 암흑
                                    showPickupEffect(player.x, player.y, "앞이 안보여!", false, true, "darkness-border");
                            } else if (p.isLucaShot) {
                                // [수정] 보호막 체크 제거 (루카의 실명 탄환은 막을 수 없음)
                                addStatus('blind', 900, 10);
                            }
                            
                            type.arr.splice(i, 1);
                        }
                    }
                });
            }
            
            updateDragShots();
            updateEvilArrows();
            updatePoisonousShots();
            updateFartSmogs(); // [신규] 오즈마: 방구 스모그
            updateExcaliburSlashes();
            updateSlashTrails();
            updateJammingWaves();
            updateNeuroNeedles();
            updateAntiPassingTentacles();
            updateChaosOrbs();
            updateGhosts();
            updateItems();
            updateEnemies();
            updateMovingGases();
            updateStickyCreamPuddles();
            updateExplosions();
            updateShiningInfernoEffects();
            updateHolyCrossEffects();

            // [최적화] 판데모니움 업데이트 (유도 및 단발성 피해)
    for (let i = pandemoniums.length - 1; i >= 0; i--) {
        const p = pandemoniums[i];
        const angle = Math.atan2(player.y - p.y, player.x - p.x);
        p.vx = Math.cos(angle) * p.speed;
        p.vy = Math.sin(angle) * p.speed;
        p.x += p.vx;
        p.y += p.vy;
        p.life--;

        // [추가] 판데모니움 궤적에 진한 검녹색 가스 생성
        p.trailTimer = (p.trailTimer || 0) + 1;
        if (p.trailTimer % 18 === 0) {
            if (darkGreenGases.length < 420) {
                spawnDarkGreenGas(p.x, p.y, 0.55, p.owner || p, 1.0, p.accuracy || 0);
            }
        }

        if (p.life <= 0) {
            pandemoniums.splice(i, 1);
            continue;
        }

        // ★ [최적화] 제곱 거리 계산
        const dx = player.x - p.x;
        const dy = player.y - p.y;
        const distSq = dx * dx + dy * dy;
        const radii = player.radius + p.radius;

        if (distSq < radii * radii) {
            if (player.invincibleTimer <= 0) {
                let dmg = 26 + Math.floor(score * 0.21);
                takeDamage(dmg, 'direct', p.accuracy, p);
                for(let k=0; k<3; k++) {
                    addStatus('gnawingLife', 1800, 15);
                }
                showPickupEffect(player.x, player.y, "생명이 좀먹힌다..", false, true, "poop-text");
                pandemoniums.splice(i, 1);
            }
        }
    }

            draw();
            updateAndDrawBlinkMines();
            updateAndDrawBlackHolyBloods();
            updateAndDrawCursedCatastrophes();
            updateAndDrawSoulHarvestSlashes();
            updateAndDrawPhantomSwords();
            if (doParticles) {
                handlePhantomGasParticles();
                handlePhantomSparkParticles();
                handleCruelChargeAuras();
                handleJusticeChargeAuras();
            }
            updateAndDrawDarkMatters();
            updateAndDrawConfessionalTotems();
            updateAndDrawShadowGrips();
            if (doEffects) {
                drawBlackMoons();
                drawMovingGases();
                drawStickyCreamPuddles();
                drawExplosions();
                drawShiningInfernoEffects();
                drawHolyCrossEffects();
                drawMaliceBallistics();
                drawTetoraEffects();
            }
            if (doParticles) {
                handleMaliceGasParticles();
            }
            if (tetoraRequiemActive) {
            // 새빨간 오버레이 (bloodOverlay 재활용 또는 tint)
            // 여기서는 bloodOverlay를 약하게 적용
            if (bloodOverlay.style.opacity < 0.7) bloodOverlay.style.opacity = 0.7;
        } else {
             // 다른 효과가 없을 때만 0으로 (기존 로직과 충돌 주의)
             // 군주의 위엄(majesty), 더럽혀진 피(corruptedBlood), 페로몬 오버로드(pheromone)가 없을 때만 끄기
             if (!player.majestyActive && player.corruptedBloodTimers.length === 0 && player.pheromoneOverloadTimer <= 0) {
                 bloodOverlay.style.opacity = 0;
             }
        }
        
        // [최적화] 데미지 오버레이 감쇠(히트당 setTimeout 제거)
        if (damageFlashOpacity > 0.001) {
            if (damageFlashDirty) {
                damageOverlay.style.background = `radial-gradient(circle, transparent 50%, rgba(${damageFlashColor}, ${damageFlashAlpha}) 100%)`;
                damageFlashDirty = false;
            }
            damageOverlay.style.opacity = damageFlashOpacity;
            damageFlashOpacity *= DAMAGE_FLASH_DECAY;
        } else {
            if (damageOverlay.style.opacity !== '0') damageOverlay.style.opacity = 0;
            damageFlashOpacity = 0;
        }

        // 광시곡 오버레이 (mindOverlay 재활용 - 보라색)
        if (tetoraRhapsodyActive) {
             mindOverlay.style.opacity = 0.7;
        } else {
             mindOverlay.style.opacity = 0;
        }
        // 매 프레임 초기화 (테토라가 없으면 꺼지도록)
        tetoraRequiemActive = false;
        tetoraRhapsodyActive = false;
            animationId = requestAnimationFrame(animate);
        }
        // [신규] 악의의 탄도 생성 함수
    function spawnMaliceBallistic(x, y, angle, accuracy, owner = null) {
        // 팬(부채꼴) 발사 후 유도 구간에서 "불규칙한" 탄도를 만들기 위해
        // 투사체마다 다른 웨이브(부드러운 요동) 파라미터를 부여
        const seed = Math.random() * 1000;
        maliceBallistics.push({
            x: x, y: y,
            vx: Math.cos(angle) * 5,
            vy: Math.sin(angle) * 5,
            angle: angle,
            life: 360, // 6초 지속
            accuracy: accuracy,
            owner: owner,

            // 불규칙 탄도 파라미터(부드러운 요동 + 느린 랜덤 드리프트)
            wobbleSeed: seed,
            wobblePhase: Math.random() * Math.PI * 2,
            wobbleDrift: 0, // 프레임마다 천천히 변하는 랜덤값(필터링)
            wobbleFreq1: 0.12 + Math.random() * 0.10,
            wobbleFreq2: 0.04 + Math.random() * 0.06,
            wobbleAmpFar: 0.52 + Math.random() * 0.06, // 멀 때(라디안)
            wobbleAmpNear: 0.36 + Math.random() * 0.04, // 가까울 때(라디안)

            // 속도 변동
            speedBase: 5.0 + Math.random() * 1.2,
            speedAmp:  2.0 + Math.random() * 1.8,

            trailInterval: 0
        });
    }

   function updateMaliceBallistics() {
        for (let i = maliceBallistics.length - 1; i >= 0; i--) {
            const b = maliceBallistics[i];
            b.life--;

            // 1. 방구 가스 생성 (3프레임마다 하나씩 흔적을 남김)
            if (frameCount % 3 === 0) {
                maliceGasParticles.push({
                    x: b.x + (Math.random() - 0.5) * 20,
                    y: b.y + (Math.random() - 0.5) * 20,
                    life: 50 + Math.random() * 20,
                    size: 10 + Math.random() * 10,
                    angle: Math.random() * Math.PI * 2
                });
            }

            // 2. 이동 로직 (유도 + 불규칙 탄도)
            const targetAngle = Math.atan2(player.y - b.y, player.x - b.x);
            const distToPlayer = Math.hypot(player.x - b.x, player.y - b.y);

            // 주사율/프레임 영향 완화용(60fps 기준 스케일)
            const dtScale = (typeof frameDtScale === 'number' ? frameDtScale : 1);
            const t60 = frameCount * dtScale; // 60fps 기준 시간축

            // --- (A) 불규칙 탄도: "부드러운" 요동 + 느린 랜덤 드리프트 ---
            // 랜덤 드리프트는 저역통과 필터로 부드럽게(불규칙하지만 지터는 최소)
            b.wobbleDrift = (b.wobbleDrift ?? 0) * 0.98 + (Math.random() - 0.5) * 0.02;
            b.wobblePhase += b.wobbleDrift * dtScale;

            // 거리 기반 요동 강도(가까울수록 조금 줄이되 0으로 만들지 않음)
            const near = 140;
            const far  = 420;
            const k = Math.max(0, Math.min(1, (distToPlayer - near) / (far - near))); // 0(근접)~1(원거리)
            const wobbleAmp = (b.wobbleAmpNear ?? 0.10) + ((b.wobbleAmpFar ?? 0.20) - (b.wobbleAmpNear ?? 0.10)) * k;

            const f1 = (b.wobbleFreq1 ?? 0.16);
            const f2 = (b.wobbleFreq2 ?? 0.06);
            const wobble =
                Math.sin(t60 * f1 + (b.wobblePhase ?? 0)) +
                0.6 * Math.sin(t60 * f2 + (b.wobbleSeed ?? 0));

            // 목표각에 요동을 섞어서 "유도는 되지만 곧장 직진하지 않게"
            const wobbleNearStart = 180; // 이 거리부터 감쇠 시작
            const wobbleMinMul = 0.70;   // 근접 최소 배율(= 30% 감소)
            const wobbleMul = (distToPlayer < wobbleNearStart)
            ? (wobbleMinMul + (1 - wobbleMinMul) * (distToPlayer / wobbleNearStart))
            : 1;  
            const desiredAngle = targetAngle + wobble * wobbleAmp * 0.5 * wobbleMul;
            // --- (B) 유도: 프레임당 최대 회전량으로 clamp (근접 급유도 방지) ---
            let maxTurn = 0.05;   // 60fps 기준
            if (distToPlayer < 220) {
                maxTurn = 0.035;   // 근접에서는 더 완만하게(하지만 요동은 유지)
            }

            let angleDiff = desiredAngle - b.angle;
            while (angleDiff <= -Math.PI) angleDiff += Math.PI * 2;
            while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;

            const turnStep = Math.max(-maxTurn * dtScale, Math.min(maxTurn * dtScale, angleDiff));
            b.angle += turnStep;

            // --- (C) 속도 변동(기존의 '카오스' 느낌 유지) ---
            const speedBase = (b.speedBase ?? 7);
            const speedAmp  = (b.speedAmp ?? 3);
            const speedVariation = speedBase + Math.sin(t60 * 0.22 + (b.wobbleSeed ?? 0)) * speedAmp;

            b.vx = Math.cos(b.angle) * speedVariation;
            b.vy = Math.sin(b.angle) * speedVariation;

            b.x += b.vx;
            b.y += b.vy;

            // 3. 화면 밖 제거
            if (b.life <= 0 || b.x < -100 || b.x > canvas.width + 100 || b.y < -100 || b.y > canvas.height + 100) {
                maliceBallistics.splice(i, 1);
                continue;
            }

            // 4. 충돌 처리
            const dx = player.x - b.x;
            const dy = player.y - b.y;
            const distSq = dx * dx + dy * dy;

            if (distSq < (player.radius + 25) ** 2) {
                if (player.invincibleTimer <= 0) {
                    let dmg = 11 + Math.floor(score * 0.12);
                    takeDamage(dmg, 'direct', b.accuracy, b);
                    // [변경] 피격 디버프: 저주 / 좀먹는 생명 중 1개 랜덤
                    const _maliceDebuff = (Math.random() < 0.5) ? 'curse' : 'gnawingLife';
                    if (_maliceDebuff === 'curse') {
                        addStatus('curse', 900, 10); // 15초, 최대 10중첩 (원하는 값으로 조정 가능)
                        showPickupEffect(player.x, player.y, "저주..", false, true, "curse-border");
                    } else {
                        addStatus('gnawingLife', 1800, 10); // 30초, 최대 10중첩 (원하는 값으로 조정 가능)
                        showPickupEffect(player.x, player.y, "좀먹힌다..", false, true, "gnawing-life-border");
                    }
                    maliceBallistics.splice(i, 1);
                    continue;
                }
            }
        }
    }


        // [신규] 악의의 탄도 그리기 전용 함수
       function drawMaliceBallistics() {
        maliceBallistics.forEach(b => {
        ctx.save();
        ctx.translate(b.x, b.y);
        ctx.rotate(Math.atan2(b.vy, b.vx) + Math.PI / 2);

        // 1. 검보라색 전류 효과 (지지직거림)
        ctx.strokeStyle = "#8A2BE2"; // 보라색 전류
        ctx.lineWidth = 2;
        ctx.lineJoin = "round";
        ctx.beginPath();
        for(let k=0; k<3; k++) { // 전류 줄기 3개
            let startX = (Math.random() - 0.5) * 10;
            let startY = (Math.random() - 0.5) * 10;
            ctx.moveTo(startX, startY);
            ctx.lineTo(startX + (Math.random()-0.5)*50, startY + (Math.random()-0.5)*50);
        }
        ctx.stroke();

        // 2. 검보라색 악마 본체
        // 몸통 (어두운 보라색)
        ctx.fillStyle = "#240046"; 
        ctx.beginPath();
        ctx.arc(0, 0, 22, 0, Math.PI * 2);
        ctx.fill();
        
        // 테두리 (밝은 보라색)
        ctx.strokeStyle = "#4B0082";
        ctx.lineWidth = 3;
        ctx.stroke();

        // 뿔 (검정)
        ctx.fillStyle = "black";
        ctx.beginPath();
        ctx.moveTo(-15, -10); ctx.lineTo(-25, -25); ctx.lineTo(-5, -18);
        ctx.moveTo(15, -10); ctx.lineTo(25, -25); ctx.lineTo(5, -18);
        ctx.fill();

        // 눈 (형광 보라/빨강 - 사악함 강조)
        ctx.fillStyle = "#FF0055";
        ctx.beginPath();
        // 왼쪽 눈 (화난 눈매)
        ctx.moveTo(-15, -5); ctx.lineTo(-5, 2); ctx.lineTo(-15, 5);
        // 오른쪽 눈
        ctx.moveTo(15, -5); ctx.lineTo(5, 2); ctx.lineTo(15, 5);
        ctx.fill();

        // 입 (찢어진 웃음)
        ctx.strokeStyle = "black";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(0, 8, 10, 0, Math.PI, false);
        ctx.stroke();
        
        // 이빨
        ctx.fillStyle = "#E0E0E0";
        ctx.beginPath();
        ctx.moveTo(-8, 8); ctx.lineTo(-5, 13); ctx.lineTo(-2, 8);
        ctx.moveTo(2, 8); ctx.lineTo(5, 13); ctx.lineTo(8, 8);
        ctx.fill();

        ctx.restore();
    });
}

        function spawnBlinkMines(startX, startY, count, owner = null, accuracy = 0) {
    for(let i=0; i<count; i++) {
        // 맵 랜덤 위치 (화면 안쪽 50px 여유)
        const mx = 50 + Math.random() * (canvas.width - 100);
        const my = 50 + Math.random() * (canvas.height - 100);
        
        blinkMines.push({
            x: mx, 
            y: my,
            radius: 50,
            life: 600,  // 10초 (60fps 기준)
            maxLife: 480,
            accuracy: accuracy,
            owner: owner,
        });
    }
    // 스킬 시전 이펙트
   showPickupEffect(startX, startY - 50, "지뢰조심♥", false, true, "pink-text");
}

      function updateAndDrawBlackHolyBloods() {
    for (let i = blackHolyBloods.length - 1; i >= 0; i--) {
        const b = blackHolyBloods[i];
        b.life--;

        // 1. 유도 로직 (각도 계산은 필수이므로 유지)
        const targetAngle = Math.atan2(player.y - b.y, player.x - b.x);
        let angleDiff = targetAngle - b.angle;
        while (angleDiff <= -Math.PI) angleDiff += Math.PI * 2;
        while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
        b.angle += angleDiff * b.homingPower;

        b.x += Math.cos(b.angle) * b.speed;
        b.y += Math.sin(b.angle) * b.speed;

        if (b.life <= 0) {
            blackHolyBloods.splice(i, 1);
            continue;
        }

        // ★ [최적화] 제곱 거리 계산
        const dx = player.x - b.x;
        const dy = player.y - b.y;
        const distSq = dx * dx + dy * dy;
        const radii = player.radius + b.radius;

        if (distSq < radii * radii) {
            if (player.invincibleTimer <= 0) {
                let dmg = 12 + Math.floor(score * 0.13);
                player.serumContaminationTimers.push(480); // 8초
                // [PATCH] 히로 '검은 성혈' 피격 시 악의의 바이러스(말리스) 3중첩
                for (let k = 0; k < 3; k++) { if (!checkShieldBlockStatus('normal', 'malice')) addStatus('malice', 900, 20); }

                updateStatusUI();
                showPickupEffect(player.x, player.y, "혈청 오염!", false, true, "corrupted-text");
                takeDamage(dmg, 'direct', b.accuracy, b);
                blackHolyBloods.splice(i, 1);
                continue;
            }
        }

        // 3. 그리기 로직 (기존 유지)
        ctx.save();
        ctx.translate(b.x, b.y);
        ctx.rotate(b.angle);
        
        const spikes = 10;
        const outerRadius = b.radius;
        const innerRadius = b.radius * 0.75;
        const grd = ctx.createRadialGradient(0, 0, innerRadius * 0.3, 0, 0, outerRadius);
        grd.addColorStop(0, '#8B0000');
        grd.addColorStop(0.6, '#4B0082');
        grd.addColorStop(1, '#000000');

        ctx.beginPath();
        for (let j = 0; j <= spikes * 2; j++) {
            const r = (j % 2 === 0) ? outerRadius : innerRadius;
            const wobble = Math.sin(frameCount * 0.2 + b.wobbleOffset + j) * 2;
            const currAngle = (Math.PI * j / spikes);
            const px = Math.cos(currAngle) * (r + wobble);
            const py = Math.sin(currAngle) * (r + wobble);
            if (j === 0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
        }
        ctx.closePath();
        ctx.fillStyle = grd;
        ctx.fill();
        ctx.strokeStyle = '#8A2BE2';
        ctx.lineWidth = 1.5;
        ctx.stroke();

        ctx.fillStyle = '#9400D3';
        for (let j = 0; j < spikes; j++) {
            const currAngle = (Math.PI * j * 2 / spikes) + (frameCount * 0.05);
            const knobDist = outerRadius * 0.9;
            const kx = Math.cos(currAngle) * knobDist;
            const ky = Math.sin(currAngle) * knobDist;
            ctx.beginPath();
            ctx.arc(kx, ky, 3.5, 0, Math.PI * 2);
            ctx.fill();
        }
        ctx.restore();
    }
}

function updateAndDrawBlinkMines() {
    for (let i = blinkMines.length - 1; i >= 0; i--) {
        const m = blinkMines[i];
        m.life--;

        if (m.life <= 0) {
            blinkMines.splice(i, 1);
            continue;
        }

        // ★ [최적화] 제곱 거리 비교
        const dx = player.x - m.x;
        const dy = player.y - m.y;
        const distSq = dx * dx + dy * dy;
        const hitRadius = m.radius + player.radius; // 지뢰 범위 + 플레이어

        // 밟았을 때
        if (distSq < hitRadius * hitRadius) {
            explosions.push({
                x: m.x, y: m.y,
                radius: 100, // 폭발 범위
                life: 30,
                damage: 20 + Math.floor(score * 0.19),
                accuracy: m.accuracy,
                owner: m.owner,
                hasHit: false
            });
            blinkMines.splice(i, 1);
            continue;
        }

        // [수정됨] 그리기 로직: 볼륨감 있는 검정 올챙이 + 끈적한 검정 연유
        ctx.save();
        ctx.translate(m.x, m.y);

        const time = Date.now() / 150; // 애니메이션 속도
        
        // ★ [신규] 깜빡임 효과 (투명도 0.5 ~ 1.0 반복)
        // Math.sin을 사용하여 시간에 따라 투명도가 변하게 함
        const blinkAlpha = 0.75 + 0.25 * Math.sin(Date.now() / 100); 
        ctx.globalAlpha = blinkAlpha;

        // 1. 끈적한 검정 연유 (바닥에 뿌려짐)
        // ★ [신규] 지뢰의 좌표(x, y)를 시드로 사용하여 매번 다른 불규칙한 모양 생성
        // 좌표가 고정되어 있으므로 모양이 계속 변하지 않고(떨리지 않고) 고유한 형태를 유지함
        const seed = m.x * 0.13 + m.y * 0.27; 
        
        const puddles = [
            { ang: 0 + (seed % 1.5), dist: 25, r: 20 },
            { ang: 2.1 + (seed % 2.5), dist: 30, r: 16 },
            { ang: 4.2 + (seed % 3.5), dist: 22, r: 24 }
        ];

        puddles.forEach((p, idx) => {
            const px = Math.cos(p.ang) * p.dist;
            const py = Math.sin(p.ang) * p.dist;
            
            ctx.beginPath();
            
            // ★ 원형 대신 불규칙한 다각형(Blob)으로 액체 표현
            const vertexCount = 10; // 꼭지점 개수
            for (let k = 0; k <= vertexCount; k++) {
                const a = (k / vertexCount) * Math.PI * 2;
                // 각도와 시드값을 조합하여 반지름을 불규칙하게 변형
                // idx를 더해 웅덩이마다 다른 모양이 나오게 함
                const noise = Math.sin(a * 3 + seed + idx) * 5 + Math.cos(a * 2 + idx) * 3;
                
                // 액체가 살아있는 것처럼 아주 살짝 꿈틀거리게 (time 요소 추가)
                const breathing = Math.sin(time + idx) * 2;
                
                const r = p.r + noise + breathing;
                
                const vx = px + Math.cos(a) * r;
                const vy = py + Math.sin(a) * r;
                
                if (k === 0) ctx.moveTo(vx, vy);
                else ctx.lineTo(vx, vy);
            }
            
            ctx.closePath();
            // 색상: 반투명한 검정 (검정 연유)
            ctx.fillStyle = "rgba(10, 10, 10, 0.85)"; 
            ctx.fill();

            // 연유 광택 (하이라이트) - 젖은 질감 표현
            // 하이라이트 위치도 시드값에 따라 약간 이동
            ctx.fillStyle = "rgba(255, 255, 255, 0.15)";
            ctx.beginPath();
            const hx = px - 4 + Math.cos(seed * 2) * 3;
            const hy = py - 4 + Math.sin(seed * 2) * 3;
            ctx.ellipse(hx, hy, 6, 3, 0.5, 0, Math.PI * 2);
            ctx.fill();
        });

        // 2. 검정 올챙이 본체 (중앙)
        // 전체적으로 살짝 회전하며 꿈틀거리는 느낌
        ctx.rotate(Math.sin(time * 0.5) * 0.1); 

        // 머리 (Head) - 볼륨감 있는 그라데이션
        const headR = 22;
        // 빛이 왼쪽 상단에서 오는 듯한 방사형 그라데이션
        const grad = ctx.createRadialGradient(-6, -6, 4, 0, 0, headR);
        grad.addColorStop(0, "#444");   // 하이라이트 (진회색)
        grad.addColorStop(0.4, "#111"); // 본체 (거의 검정)
        grad.addColorStop(1, "#000");   // 그림자 (완전 검정)

        ctx.fillStyle = grad;
        ctx.beginPath();
        // 머리 모양 (약간 납작한 타원)
        ctx.ellipse(0, 0, headR, headR * 0.85, 0, 0, Math.PI * 2);
        ctx.fill();

        // 꼬리 (Tail) - 베지에 곡선으로 꾸물거림 표현
        const tailWiggle = Math.sin(time * 2) * 15; // 꼬리 흔들림 폭
        
        ctx.beginPath();
        ctx.moveTo(headR * 0.6, 0); // 머리 뒤쪽에서 시작
        // 제어점을 흔들어서 S자 곡선 애니메이션 생성
        ctx.quadraticCurveTo(headR + 10, tailWiggle, headR + 35, tailWiggle * 0.5);
        
        // 꼬리 스타일 (검정색)
        ctx.strokeStyle = "#000";
        ctx.lineWidth = 9;
        ctx.lineCap = "round";
        ctx.stroke();

        // 꼬리 윗부분 하이라이트 (입체감 추가)
        ctx.strokeStyle = "#333";
        ctx.lineWidth = 2;
        ctx.stroke();

        // 눈 (작고 빨간 눈으로 위협적인 느낌)
        ctx.fillStyle = "#FF0000";
        ctx.shadowColor = "#FF0000";
        ctx.shadowBlur = 6; // 붉은 안광
        ctx.beginPath();
        ctx.arc(8, -8, 3, 0, Math.PI*2); // 오른쪽 눈
        ctx.arc(8, 8, 3, 0, Math.PI*2);  // 왼쪽 눈 (회전했으므로 좌표 조정)
        ctx.fill();
        ctx.shadowBlur = 0; // 그림자 효과 초기화

        ctx.restore();
    }
}
   function drawTetoraEffects() {
            // 스포트라이트 그리기
            darknessSpotlights.forEach(spot => {
                ctx.save();
                ctx.translate(spot.x, spot.y);
                ctx.setLineDash([]);
                ctx.lineDashOffset = 0;

                const time = Date.now() / 300; // 애니메이션 시간

                // 1. [볼륨감] 반구형 돔 그라데이션 (가웨인 성역 스타일)
                // 사악한 검보라색 테마
                const domeGrad = ctx.createRadialGradient(0, 0, spot.radius * 0.2, 0, 0, spot.radius);
                domeGrad.addColorStop(0, 'rgba(10, 0, 10, 0.1)');      // 중심부 투명
                domeGrad.addColorStop(0.6, 'rgba(40, 0, 60, 0.3)');    // 중간: 어두운 보라
                domeGrad.addColorStop(0.9, 'rgba(20, 0, 40, 0.7)');    // 외곽: 짙은 남보라
                domeGrad.addColorStop(1, 'rgba(75, 0, 130, 0.5)');     // 테두리: 인디고

                ctx.fillStyle = domeGrad;
                ctx.beginPath();
                ctx.arc(0, 0, spot.radius, 0, Math.PI * 2);
                ctx.fill();

                // 2. [사악한 전류] 볼륨감 있는 검보라색 전류
                // 선 사이사이에 배치하기 위해 여러 겹으로 그림
                const electricityLayers = 5;
                
                ctx.shadowBlur = 15;
                ctx.shadowColor = "#800080"; // Purple Glow
                ctx.lineCap = 'round';

                for(let i=0; i<electricityLayers; i++) {
                    ctx.beginPath();
                    // 레이어마다 색상 농도 조절
                    if(i % 2 === 0) ctx.strokeStyle = "rgba(48, 0, 48, 0.8)"; // 아주 어두운 보라
                    else ctx.strokeStyle = "rgba(75, 0, 130, 0.6)"; // 인디고

                    ctx.lineWidth = 3 + Math.random() * 2; // 두께 불규칙

                    // 스포트라이트 내부를 가로지르는 지그재그 선
                    const startAngle = (Math.PI * 2 * i / electricityLayers) + time;
                    let lx = Math.cos(startAngle) * (spot.radius * 0.2);
                    let ly = Math.sin(startAngle) * (spot.radius * 0.2);
                    ctx.moveTo(lx, ly);

                    // 바깥쪽으로 뻗어나가는 전류
                    for(let j=0; j<6; j++) {
                        const dist = (spot.radius / 6) * j;
                        const angleNoise = (Math.random() - 0.5) * 1.5; // 각도 흔들림
                        
                        lx += Math.cos(startAngle + angleNoise) * 20;
                        ly += Math.sin(startAngle + angleNoise) * 20;
                        
                        ctx.lineTo(lx, ly);
                    }
                    ctx.stroke();
                }
                ctx.shadowBlur = 0; // 초기화

                // 3. [음표] 선 사이사이에 떠다니는 밝은 보라색 음표들
                ctx.fillStyle = "#E0B0FF"; // Mauve (밝은 보라)
                ctx.font = "bold 24px Arial";
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.shadowColor = "#FFFFFF"; // 흰색 글로우로 밝게 표현
                ctx.shadowBlur = 5;

                const noteCount = 12;
                const noteSymbols = ["♪", "♫", "♬", "♩"];

                for(let k=0; k<noteCount; k++) {
                    // 궤도 회전 애니메이션
                    const noteAngle = (k / noteCount * Math.PI * 2) - time * 0.5;
                    // 안팎으로 부유하는 움직임
                    const floatDist = (spot.radius * 0.4) + Math.sin(time * 2 + k) * (spot.radius * 0.3);
                    
                    const nx = Math.cos(noteAngle) * floatDist;
                    const ny = Math.sin(noteAngle) * floatDist;

                    // 흔들림 추가
                    const wobbleX = Math.cos(time * 3 + k) * 5;
                    const wobbleY = Math.sin(time * 3 + k) * 5;

                    const symbol = noteSymbols[k % noteSymbols.length];
                    
                    ctx.fillText(symbol, nx + wobbleX, ny + wobbleY);
                }
                ctx.shadowBlur = 0;

                // 4. [테두리] 회전하는 마법진 링
                ctx.save();
                ctx.rotate(time * 0.2);
                ctx.strokeStyle = "#9370DB"; // MediumPurple
                ctx.lineWidth = 3;
                ctx.setLineDash([20, 15, 5, 15]); // 룬 문자 느낌의 점선
                ctx.beginPath();
                ctx.arc(0, 0, spot.radius, 0, Math.PI*2);
                ctx.stroke();
                ctx.restore();
                
                ctx.restore();
            });

            // 데스메탈 음표 그리기
            deathMetalNotes.forEach(note => {
                ctx.save();
                ctx.translate(note.x, note.y);


                // [수정] note.radius(=히트박스 반경)에 비례해서 화면에서도 같이 커지도록 스케일 적용
                // 기존 데스메탈 음표 도형은 픽셀 단위로 하드코딩되어 있어 radius를 바꿔도 화면 크기는 안 변했음
                const dmBaseVisualR = 25; // [수정] 실제 도형 좌표계 기준 '시각적 반경'(≈25). radius와 시각/피격을 1:1로 맞춤
                const dmR = (note.radius || dmBaseVisualR);
                const dmScale = dmR / dmBaseVisualR;
                ctx.scale(dmScale, dmScale);

                // 1. [전류 이펙트] 사악한 검보라색 지지직 거리는 효과
                // 음표 주변으로 불규칙하게 뻗어나가는 전기
                ctx.shadowBlur = 15 * dmScale;
                ctx.shadowColor = "#9400D3"; // DarkViolet Glow (네온 광채)
                ctx.strokeStyle = "#6A00FF"; // Deep Purple (전류 색상)
                ctx.lineWidth = 2;
                ctx.lineCap = 'round';
                
                // 랜덤한 번개 줄기 3개 생성
                for (let k = 0; k < 3; k++) {
                    ctx.beginPath();
                    // 음표 중심에서 약간 떨어진 곳에서 시작
                    let lx = (Math.random() - 0.5) * 10;
                    let ly = (Math.random() - 0.5) * 10;
                    ctx.moveTo(lx, ly);
                    
                    // 지그재그 선 그리기 (3단계)
                    for (let j = 0; j < 3; j++) {
                        lx += (Math.random() - 0.5) * 25; // X축으로 불규칙하게 튐
                        ly += (Math.random() - 0.5) * 25; // Y축으로 불규칙하게 튐
                        ctx.lineTo(lx, ly);
                    }
                    ctx.stroke();
                }

                // 2. [음표 머리] 볼륨감 있는 구체 (Radial Gradient)
                ctx.shadowBlur = 0; // 본체는 선명하게
                
                // 빛이 왼쪽 상단에서 오는 듯한 입체감
                const headGrad = ctx.createRadialGradient(-3, 7, 2, 0, 10, 12);
                headGrad.addColorStop(0, "#D8BFD8");   // 하이라이트 (Thistle - 밝은 보라)
                headGrad.addColorStop(0.3, "#9370DB"); // 중간톤 (MediumPurple)
                headGrad.addColorStop(1, "#190033");   // 그림자 (아주 어두운 보라/검정)
                
                ctx.fillStyle = headGrad;
                ctx.beginPath();
                ctx.arc(0, 10, 11, 0, Math.PI*2); // 머리
                ctx.fill();

                // 3. [음표 기둥 & 꼬리] 입체감 있는 기둥 (Linear Gradient)
                const stemGrad = ctx.createLinearGradient(6, 0, 14, 0);
                stemGrad.addColorStop(0, "#AB82FF");   // 밝은 면
                stemGrad.addColorStop(0.5, "#4B0082"); // 중간 면
                stemGrad.addColorStop(1, "#000000");   // 어두운 면

                ctx.fillStyle = stemGrad;
                
                // 기둥 (Stem)
                ctx.beginPath();
                ctx.moveTo(8, -15);
                ctx.lineTo(12, -15);
                ctx.lineTo(12, 10);
                ctx.lineTo(8, 10);
                ctx.fill();

                // 꼬리 (Flag) - 곡선으로 부드럽게 표현
                ctx.beginPath();
                ctx.moveTo(12, -15);
                ctx.quadraticCurveTo(24, -5, 24, 5); // 둥근 꼬리
                ctx.lineTo(12, -5); // 안쪽 라인
                ctx.fill();

                ctx.restore();
            });
        }
   
function updateAndDrawCursedCatastrophes() {
    const stride = (performanceState && performanceState.particleStride) ? performanceState.particleStride : 1;
    const timeKey = Math.floor(Date.now() / (83 * stride)); // 12fps 캐시 버킷(성능에 따라 더 느리게)

    for (let i = cursedCatastrophes.length - 1; i >= 0; i--) {
        let p = cursedCatastrophes[i];

        const dtScale = (typeof frameDtScale === 'number' ? frameDtScale : 1);
        const outerR = Math.max(15, (p.radius ?? 30));
        const coreR  = outerR * 0.5;

        p.life--;
        if (p.life <= 0) {
            cursedCatastrophes.splice(i, 1);
            continue;
        }

        // 1. 유도 로직 (플레이어 쪽으로 방향 전환)
        let angleToPlayer = Math.atan2(player.y - p.y, player.x - p.x);

        // 현재 이동 각도
        let currentAngle = Math.atan2(p.vy, p.vx);

        // 각도 차이 계산 (최단 경로)
        let angleDiff = angleToPlayer - currentAngle;
        while (angleDiff <= -Math.PI) angleDiff += Math.PI * 2;
        while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;

        // 유도 성능만큼 회전
        let turnRate = 0.04 * dtScale; // 유도 성능 (dt 보정)
        if (Math.abs(angleDiff) < turnRate) {
            currentAngle = angleToPlayer;
        } else {
            currentAngle += (angleDiff > 0) ? turnRate : -turnRate;
        }

        // 속도 갱신
        let speed = Math.sqrt(p.vx * p.vx + p.vy * p.vy);
        p.vx = Math.cos(currentAngle) * speed;
        p.vy = Math.sin(currentAngle) * speed;

        // 위치 이동
        p.x += p.vx;
        p.y += p.vy;

        // 화면 밖으로 너무 멀어지면 제거 (메모리 관리)
        if (p.x < -200 || p.x > canvas.width + 200 || p.y < -200 || p.y > canvas.height + 200) {
            cursedCatastrophes.splice(i, 1);
            continue;
        }

        // 2. 충돌 판정
        let dist = Math.hypot(p.x - player.x, p.y - player.y);
        const hitR = Math.max(25, coreR * 0.9);
        if (dist < hitR) {
            let damage = 22 + Math.floor(score * 0.17);
            takeDamage(damage, "cursed_catastrophe");

            // 디버프 '죽음의 낙인' 부여 (10초)
            addStatus('deathBrand', 600, 1);

            showPickupEffect(p.x, p.y, "☠️", false, true, "evil-text");
            cursedCatastrophes.splice(i, 1);
            continue;
        }

        // 3. 그리기 - [OPT] 스프라이트 캐시 사용(색감 유지 + 연산 감소)
        const spr = getCursedCatastropheSprite(outerR, timeKey, stride);
        ctx.drawImage(spr.canvas, p.x - spr.w / 2, p.y - spr.h / 2);
    }
}



function updateStickyCreamPuddles() {
    player.slowedByStickyCream = false;
    for (let i = stickyCreamPuddles.length - 1; i >= 0; i--) {
        const p = stickyCreamPuddles[i];
        p.life--;
        if (p.life <= 0) {
            stickyCreamPuddles.splice(i, 1);
            continue;
        }
        const dx = player.x - p.x;
        const dy = player.y - p.y;
        const rr = player.radius + p.radius;
        if (dx * dx + dy * dy < rr * rr) {
            player.slowedByStickyCream = true;
        }
    }
}

function drawStickyCreamPuddles() {
    stickyCreamPuddles.forEach(p => {
        const grad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.radius);
        grad.addColorStop(0, 'rgba(20,20,20,0.8)');
        grad.addColorStop(0.7, 'rgba(40,25,25,0.55)');
        grad.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
        ctx.fill();
    });
}

function updateMovingGases() {
    for (let i = movingGases.length - 1; i >= 0; i--) {
        const g = movingGases[i];
        g.x += g.vx;
        g.y += g.vy;
        g.life--;

        // [최적화] 플레이어 충돌 체크 (제곱 거리 사용)
        const dx = player.x - g.x;
        const dy = player.y - g.y;
        const distSq = dx * dx + dy * dy;
        const hitRadius = player.radius + g.radius;

        if (distSq < hitRadius * hitRadius) {
            player.slowedByCloud = true;
            // 가스 데미지
            takeDamage(0.0004, 'hazardDot', 0);
            
            // 60프레임마다 카인의 향기 디버프 1중첩
            if (frameCount % 60 === 0 && player.invincibleTimer <= 0) {
                addStatus('darkScent', 900, 30);
            }
        }

        // 중앙 도달 체크 (거리가 10 이하이면 폭발) -> 제곱 거리 100 이하
        const cdx = g.centerX - g.x;
        const cdy = g.centerY - g.y;
        const centerDistSq = cdx * cdx + cdy * cdy;

        if (centerDistSq < 100 || g.life <= 0) { // 10 * 10 = 100
            // 폭발 발생!
            spawnExplosion(g.centerX, g.centerY, (g.accuracy || 0), (g.owner || null));
            movingGases.splice(i, 1);
        }
    }
}

// [수정] 이동하는 가스 그리기 (기존 DarkGas와 동일한 비주얼)
function drawMovingGases() {
    movingGases.forEach(g => {
        ctx.save();
        ctx.translate(g.x, g.y);
        
        // DarkGas 고유의 검정+진보라 그라데이션 적용
        const alpha = 0.8; // 기본 투명도
        const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, g.radius);
        
        // 중심부: 검정
        gradient.addColorStop(0, `rgba(0, 0, 0, ${alpha})`);          
        // 중간: 진한 보라색 (DarkGas 컬러)
        gradient.addColorStop(0.5, `rgba(60, 0, 60, ${alpha * 0.9})`); 
        // 외곽: 투명
        gradient.addColorStop(1, `rgba(0, 0, 0, 0)`); 

        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(0, 0, g.radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
    });
}

function spawnExplosion(x, y, accuracy = 0, owner = null) {
    // 폭발 데미지 미리 계산
    let explosionDamage = 16 + Math.floor(score * 0.17);

    // [수정] spawnDarkGas 호출 시, 마지막 인자로 explosionDamage를 전달합니다.
    // (기존: spawnDarkGas(x, y, 3.0, 1.5, 0); )
    spawnDarkGas(x, y, 3.0, 1.5, accuracy, explosionDamage, owner);

    // [삭제] 여기서 explosions.push({...}) 하는 코드는 모두 지웁니다.
    // 이제 데미지는 다크 가스가 다 커졌을 때 발생합니다.

    showPickupEffect(x, y - 50, "뿌우욱♥", false, true, "wicked-large-text");
}

function updateExplosions() {
    for (let i = explosions.length - 1; i >= 0; i--) {
        const e = explosions[i];
        e.life--;
        if (e.life <= 0) {
            explosions.splice(i, 1);
            continue;
        }

        // 플레이어 피격 체크 (이미 맞지 않았고, 무적 아닐 때)
        if (!e.hasHit) {
            // [최적화] 제곱 거리 판정
            const dx = player.x - e.x;
            const dy = player.y - e.y;
            const distSq = dx * dx + dy * dy;
            const hitRadius = e.radius + player.radius;

            if (distSq < hitRadius * hitRadius) {
                if (player.invincibleTimer <= 0) {
                    // 데미지 적용
                    takeDamage(e.damage, 'direct', (e.accuracy || 0), (e.owner || null));
                    // [요청사항] 실명 1중첩 부여
                    addStatus('blind', 900, 1);
                    showPickupEffect(player.x, player.y, "눈이 멀었다..", false, true, "darkness-border");
                    e.hasHit = true; // 피격 처리 완료
                }
            }
        }
    }
}
function drawBlackMoons() {
    blackMoons.forEach(moon => {
        ctx.save();
        ctx.translate(moon.x, moon.y);
        ctx.rotate(moon.angle);

        // 1. 흑월 본체 (입체감 있는 어두운 구체)
        // 빛이 왼쪽 위에서 오는 듯한 그라데이션
        const grad = ctx.createRadialGradient(-15, -15, 10, 0, 0, moon.radius);
        grad.addColorStop(0, '#555555');   // 하이라이트 (어두운 회색)
        grad.addColorStop(0.3, '#222222'); // 중간톤
        grad.addColorStop(1, '#000000');   // 외곽 (완전 검정)
        
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(0, 0, moon.radius, 0, Math.PI * 2);
        ctx.fill();

        // 2. 크레이터 (달 무늬) 그리기
        ctx.fillStyle = 'rgba(0, 0, 0, 0.6)'; // 본체보다 더 어두운 색으로 움푹 패인 느낌
        if (moon.craters) {
            moon.craters.forEach(c => {
                ctx.beginPath();
                ctx.arc(c.dx, c.dy, c.r, 0, Math.PI * 2);
                ctx.fill();
                
                // 크레이터 가장자리 살짝 밝게 (입체감)
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
                ctx.lineWidth = 1;
                ctx.stroke();
            });
        }

        // 3. 사악한 전류 이펙트 (지지직)
        // 보라색/검붉은색 전류가 달 표면에서 불규칙하게 튐
        ctx.shadowBlur = 15;
        ctx.shadowColor = '#9400D3'; // 보라색 광채 (Neon Purple)
        ctx.strokeStyle = '#E0B0FF'; // 연한 보라 (전류 심지)
        ctx.lineWidth = 2;
        ctx.lineJoin = 'round';
        ctx.lineCap = 'round';

        // 프레임마다 랜덤하게 번개 생성 (지지직거리는 느낌)
        const lightningCount = 4 + Math.floor(Math.random() * 3); 
        
        for(let i=0; i<lightningCount; i++) {
            if(Math.random() < 0.2) continue; // 가끔 깜빡임

            ctx.beginPath();
            const angle = Math.random() * Math.PI * 2;
            
            // 달 표면 근처에서 시작
            let startR = moon.radius * 0.9;
            let currX = Math.cos(angle) * startR;
            let currY = Math.sin(angle) * startR;
            ctx.moveTo(currX, currY);

            // 바깥으로 뻗어나가는 지그재그 선
            for(let j=0; j<5; j++) {
                // 진행 방향 + 랜덤 지터
                currX += (Math.cos(angle) * 12) + (Math.random()-0.5) * 20;
                currY += (Math.sin(angle) * 12) + (Math.random()-0.5) * 20;
                ctx.lineTo(currX, currY);
            }
            ctx.stroke();
        }
        
        // 4. 외곽 글로우 (사악한 기운 펄스)
        const pulse = 1 + Math.sin(Date.now() / 100) * 0.05;
        ctx.shadowColor = '#4B0082'; // Indigo
        ctx.shadowBlur = 20;
        ctx.strokeStyle = `rgba(75, 0, 130, ${0.4 + Math.random()*0.2})`;
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(0, 0, moon.radius * pulse, 0, Math.PI * 2);
        ctx.stroke();

        ctx.restore();
    });
}

function updateShiningInfernoEffects() {
    for (let i = shiningInfernoEffects.length - 1; i >= 0; i--) {
        const fx = shiningInfernoEffects[i];
        fx.life--;
        fx.t += 1;
        if (fx.life <= 0) {
            shiningInfernoEffects.splice(i, 1);
            continue;
        }
    }
}

function drawShiningInfernoEffects() {
    for (const fx of shiningInfernoEffects) {
        const p = 1 - (fx.life / fx.maxLife);
        const rise = p * 54;
        const flameCount = 7;
        for (let k = 0; k < flameCount; k++) {
            const a = (Math.PI * 2 / flameCount) * k + (fx.t * 0.08);
            const r = 6 + Math.sin(fx.t * 0.18 + k) * 3;
            const x = fx.x + Math.cos(a) * r;
            const y = fx.y - rise + Math.sin(fx.t * 0.11 + k) * 2;
            const size = 8 + Math.sin(fx.t * 0.15 + k) * 2;
            ctx.save();
            ctx.globalAlpha = Math.max(0, 0.75 - p * 0.45);
            const grad = ctx.createRadialGradient(x, y, 1, x, y, size);
            grad.addColorStop(0, 'rgba(255,255,180,0.95)');
            grad.addColorStop(0.45, 'rgba(255,170,40,0.92)');
            grad.addColorStop(1, 'rgba(255,40,0,0.00)');
            ctx.fillStyle = grad;
            ctx.beginPath();
            ctx.arc(x, y, size, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        }
    }
}

function updateHolyCrossEffects() {
    for (let i = holyCrossEffects.length - 1; i >= 0; i--) {
        const fx = holyCrossEffects[i];
        fx.life--;
        fx.t += 1;
        if (fx.life <= 0) {
            holyCrossEffects.splice(i, 1);
            continue;
        }
    }
}

function drawHolyCrossEffects() {
    for (const fx of holyCrossEffects) {
        const p = 1 - (fx.life / fx.maxLife);
        const boom = Math.max(0, (p - 0.55) / 0.45);
        const alpha = 0.85 - p * 0.5;
        ctx.save();
        ctx.translate(fx.x, fx.y - 24);

        const crossH = 46 + Math.sin(fx.t * 0.2) * 2;
        const crossW = 14 + Math.sin(fx.t * 0.16) * 1.5;

        ctx.globalAlpha = Math.max(0, alpha);
        ctx.shadowColor = 'rgba(80,180,255,0.95)';
        ctx.shadowBlur = 18;
        ctx.fillStyle = 'rgba(140,220,255,0.88)';
        ctx.fillRect(-crossW * 0.28, -crossH * 0.5, crossW * 0.56, crossH);
        ctx.fillRect(-crossW * 0.9, -crossH * 0.1, crossW * 1.8, crossW * 0.52);

        if (boom > 0) {
            const ringR = 14 + boom * 56;
            ctx.globalAlpha = 0.65 * (1 - boom);
            ctx.strokeStyle = 'rgba(120,210,255,0.95)';
            ctx.lineWidth = 3 + (1 - boom) * 2;
            ctx.beginPath();
            ctx.arc(0, 0, ringR, 0, Math.PI * 2);
            ctx.stroke();
        }

        ctx.restore();
    }
}

function drawExplosions() {
    explosions.forEach(e => {
        ctx.save();
        ctx.translate(e.x, e.y);
        ctx.globalAlpha = e.life / 20; // 서서히 사라짐
        
        ctx.beginPath();
        ctx.arc(0, 0, e.radius, 0, Math.PI * 2);
        ctx.fillStyle = "rgba(138, 43, 226, 0.5)"; // 보라색 폭발
        ctx.fill();
        
        ctx.strokeStyle = "white";
        ctx.lineWidth = 3;
        ctx.stroke();
        ctx.restore();
    });
}

    function updateAndDrawSoulHarvestSlashes() {
        for (let i = soulHarvestSlashes.length - 1; i >= 0; i--) {
            let s = soulHarvestSlashes[i];
            s.life--;
            if (s.life <= 0) {
                soulHarvestSlashes.splice(i, 1);
                continue;
            }

            ctx.save();
            ctx.translate(s.x, s.y);
            // 낫이 베는 애니메이션
            let progress = 1 - (s.life / 45);
            ctx.rotate(s.angle + (progress * Math.PI)); 
            ctx.scale(5, 5); // 크기 키움

            // 낫 날 (은색 + 보라빛 오라)
            ctx.shadowColor = "#8A2BE2"; // 보라색 오라
            ctx.shadowBlur = 20;
            
            let grad = ctx.createLinearGradient(0, -40, 0, 40);
            grad.addColorStop(0, "#C0C0C0"); // 은색
            grad.addColorStop(0.5, "#FFFFFF");
            grad.addColorStop(1, "#808080");

            ctx.beginPath();
            ctx.arc(0, 0, 40, Math.PI * 1.2, Math.PI * 1.8); // 초승달 모양
            ctx.strokeStyle = grad;
            ctx.lineWidth = 4;
            ctx.lineCap = "round";
            ctx.stroke();

            // 해골 장식 (검보라색)
            ctx.shadowBlur = 0;
            ctx.fillStyle = "#2e003e";
            ctx.beginPath();
            ctx.arc(0, -35, 8, 0, Math.PI*2); // 해골 머리
            ctx.fill();
            ctx.fillStyle = "red"; // 눈
            ctx.beginPath();
            ctx.arc(-2, -35, 1, 0, Math.PI*2);
            ctx.arc(2, -35, 1, 0, Math.PI*2);
            ctx.fill();

            ctx.restore();
        }
    }

     function gainXp(amount) {
            if (level >= MAX_LEVEL) return; // 만렙 제한
            amount = amount * (1 + player.bonusXpGain);
            xp += amount;
            // XP바 UI 갱신
            const percent = Math.min(100, (xp / maxXp) * 100);
            document.getElementById('xp-bar').style.width = percent + '%';

            if (xp >= maxXp) {
                levelUp();
            }
        }

        function levelUp() {
            xp -= maxXp;
            level++;

            // [NEW] 유물 특수 효과: 호출부호 수신기 (장착 시)
            if (typeof isRelicEquipped === 'function' && isRelicEquipped('stellar_compass')) {
                if (Math.random() < 0.15) {
                    rerollCount += 1;
                    showPickupEffect(player.x, player.y - 60, '호출부호 수신기: 리로드 +1', false, true, 'heal-text');
                }
            }
             // [밸런스] 레벨업 필요 XP: 구간별 증가 배율
let xpMult = XP_GROWTH_SEG4_MULT; // 기본(후반)
if (level <= XP_GROWTH_SEG1_END_LV) xpMult = XP_GROWTH_SEG1_MULT;
else if (level <= XP_GROWTH_SEG2_END_LV) xpMult = XP_GROWTH_SEG2_MULT;
else if (level <= XP_GROWTH_SEG3_END_LV) xpMult = XP_GROWTH_SEG3_MULT;
// else: seg4 (Lv 301~)
maxXp = Math.ceil(maxXp * xpMult); 
            
            document.getElementById('level-text').innerText = 'Lv.' + level;
            document.getElementById('xp-bar').style.width = '0%';

            if (level % 10 === 0) {
               rerollCount++;
               showPickupEffect(player.x, player.y - 80, "리로드 기회 획득!", false, true, "justice-border");
            }
            
            // 게임 일시정지 및 UI 호출
            isLevelUpPaused = true;
            showLevelUpUI();
            
            // 레벨업 효과음 (기존 사운드 재활용 또는 추가)
            showPickupEffect(player.x, player.y - 50, "Level Up!", false, true, "goddess-text");
        }

       function showLevelUpUI() {
       uiLayer.style.zIndex = UI_LAYER_LEVELUP_Z;
    const modal = document.getElementById('levelUpModal');
    const container = document.getElementById('cardContainer');
    container.innerHTML = '';
    
    // 기존 카드 초기화 
    const selectedCards = [];
    let attempts = 0;
    
    // 무한 루프 방지용 안전장치 
    while(selectedCards.length < 3 && attempts < 100) {
        attempts++;
        const newCard = generateRandomCard();
        // 이미 뽑은 카드 중에 타입과 수치가 같은 것이 있는지 확인 
        const isDuplicate = selectedCards.some(card => card.type === newCard.type && card.value === newCard.value);
        if (!isDuplicate) {
            selectedCards.push(newCard);
        }
    }
    
    // 수집된 카드 렌더링 
    selectedCards.forEach(cardData => {
        const card = document.createElement('div');
        card.className = `upgrade-card rarity-${cardData.rarity}`;
        let rarityText = cardData.rarity.toUpperCase();
        card.innerHTML = ` <div class="card-rarity rarity-text-${cardData.rarity}">${rarityText}</div> <div class="card-name">${cardData.name}</div> <div class="card-desc">${cardData.desc}</div> <div class="card-stat rarity-text-${cardData.rarity}">${cardData.statDisplay}</div> `;
        card.onclick = () => {
            selectUpgrade(cardData);
        };
        container.appendChild(card);
    });

    // ============================================================
    // [신규] 리로드 버튼 로직
    // ============================================================
    let rerollBtn = document.getElementById('rerollCardBtn');
    
    // 버튼이 없으면 새로 생성 (showStatsBtn 옆이나 모달 하단에 추가)
    if (!rerollBtn) {
        rerollBtn = document.createElement('button');
        rerollBtn.id = 'rerollCardBtn';
        rerollBtn.style.marginTop = '20px';
        rerollBtn.style.marginLeft = '10px';
        rerollBtn.style.padding = '10px 20px';
        rerollBtn.style.fontSize = '20px';
        rerollBtn.style.background = '#4B0082'; // 보라색 계열
        rerollBtn.style.color = '#fff';
        rerollBtn.style.border = '2px solid #fff';
        rerollBtn.style.borderRadius = '10px';
        rerollBtn.style.cursor = 'pointer';
        rerollBtn.style.fontFamily = "'Black Han Sans', sans-serif";
        rerollBtn.style.transition = '0.2s';
        
        rerollBtn.onmouseover = () => { rerollBtn.style.background = '#6A0DAD'; };
        rerollBtn.onmouseout = () => { rerollBtn.style.background = '#4B0082'; };

        // 버튼 위치 잡기 (스탯 확인 버튼 뒤에 붙이기)
        const statsBtn = document.getElementById('showStatsBtn');
        if(statsBtn && statsBtn.parentNode === modal) {
            modal.insertBefore(rerollBtn, statsBtn.nextSibling);
        } else {
            modal.appendChild(rerollBtn);
        }

        // 클릭 이벤트
        rerollBtn.onclick = () => {
            if (rerollCount > 0) {
                rerollCount--;

                // [NEW] 유물 특수 효과: 탐욕의 잉크 인장 (장착 시) - 리로드 환급
                if (typeof isRelicEquipped === 'function' && isRelicEquipped('chaos_ink')) {
                    if (Math.random() < 0.15) {
                        rerollCount += 1;
                        showPickupEffect(player.x, player.y - 60, '탐욕의 잉크 인장: 리로드 환급!', false, true, 'heal-text');
                    }
                }

                // 효과음이나 이펙트를 넣고 싶다면 여기에 추가
                showLevelUpUI(); // UI 재호출로 카드 갱신
            }
        };
    }

    // 리로드 횟수가 있을 때만 버튼 표시
    if (rerollCount > 0) {
        rerollBtn.style.display = 'inline-block';
        rerollBtn.innerText = `카드 리로드 (${rerollCount})`;
    } else {
        rerollBtn.style.display = 'none';
    }
    // ============================================================

    modal.style.display = 'flex';
}


// [UI] 카드 수치 표기: 표시만 정수(반올림) + 부동소수점 꼬리 제거
function fmtCardNumber(n, digits = 0) {
    if (!Number.isFinite(n)) return String(n);
    const fixed = Number(n.toFixed(digits));
    // 정수에 매우 가까우면 정수로 표기
    if (Math.abs(fixed - Math.round(fixed)) < 1e-9) return String(Math.round(fixed));
    return String(fixed);
}


        function generateRandomCard() {
            // 1. 등급 결정 로직 (수정됨)
            // 행운 1당 노멀 확률 1% 감소, 나머지 3개 등급에 1/3%씩 분배
            const rand = Math.random(); // 행운을 더하지 않은 순수 0~1 랜덤값 사용
            
            // 감소시킬 노멀 확률 계산 (최대 60%까지만 감소)
            const reduceCommon = Math.min(0.60, luck * 0.01);
            
            // 다른 등급들이 나눠 가질 추가 확률 (N분의 1)
            const bonusPerTier = reduceCommon / 3;

            // 확률 경계값 재계산
            // [기본] 노멀(~60%) / 레어(~85%) / 유니크(~98%) / 레전더리(나머지)
            // [변경] 경계값이 낮아져서 상위 등급의 구간이 넓어짐
            const cutRare = 0.60 - reduceCommon;                     // 노멀 끝, 레어 시작 지점
            const cutUnique = 0.85 - (reduceCommon - bonusPerTier);  // 레어 끝, 유니크 시작 지점 (0.85 - 2*bonus)
            const cutLegendary = 0.98 - bonusPerTier;                // 유니크 끝, 레전더리 시작 지점

            let rarity = 'common';

            // 레벨이 10의 배수(10, 20, 30...)일 경우 무조건 레전더리 등급 고정
            if (level % 10 === 0) {
                rarity = 'legendary';
            } else {
                // 새로운 확률 구간 적용
                if (rand > cutLegendary) rarity = 'legendary';
                else if (rand > cutUnique) rarity = 'unique';
                else if (rand > cutRare) rarity = 'rare';
                else rarity = 'common';
            }

            // 2. 능력치 종류 결정 (기존 동일)
            const types = ['atk', 'atkSpeed', 'range', 'hp', 'defense', 'moveSpeed', 'luck', 'accuracy', 'evasion', 'stunChance', 'critChance', 'critDamage', 'critResist', 'xpGain', 'regen', 'skillCooldownReduction'];
            const type = types[Math.floor(Math.random() * types.length)];

            let name = "";
            let desc = "";
            let statDisplay = "";
            let value = 0;

            // 등급별 배율 (기존 동일)
            let multiplier = 1;
            if (rarity === 'rare') multiplier = 2;
            if (rarity === 'unique') multiplier = 3;
            if (rarity === 'legendary') multiplier = 4;

            switch(type) {
                case 'atk':
                    name = "근력 강화";
                    desc = "공격력이 증가합니다.";
                    value = 1 * multiplier;
                    statDisplay = `+${fmtCardNumber(value, 0)}`;
                    break;
                case 'atkSpeed':
                    name = "광속 공격";
                    desc = "공격 속도가 증가합니다.";
                    value = 0.03 * multiplier; 
                    statDisplay = `+${(value * 100).toFixed(0)}%`;
                    break;
                case 'range':
                    name = "용이한 무기";
                    desc = "공격 범위가 증가합니다.";
                    value = 1.2 * multiplier;
                    statDisplay = `+${fmtCardNumber(value, 0)}`;
                    break;
                case 'hp':
                    name = "건강한 신체";
                    desc = "최대 체력이 증가합니다.";
                    value = 12 * multiplier;
                    statDisplay = `+${fmtCardNumber(value, 0)}`;
                    break;
                case 'defense':
                    name = "단단한 피부";
                    desc = "방어력이 증가합니다.";
                    value = 1.2 * multiplier;
                    statDisplay = `+${fmtCardNumber(value, 0)}`;
                    break;
                case 'moveSpeed':
                    name = "가벼운 발걸음";
                    desc = "이동 속도가 증가합니다.";
                    value = 0.1 * multiplier;
                    statDisplay = `+${value.toFixed(1)}`;
                    break;
                case 'luck':
                    name = "행운";
                    desc = "더 좋은 선택지가 나올 확률이 증가합니다.";
                    value = 1 * multiplier;
                    statDisplay = `+${fmtCardNumber(value, 0)}`;
                    break;
                case 'accuracy':
                    name = "정밀 타격";
                    desc = "명중률이 증가합니다.";
                    value = 0.02 * multiplier; 
                    statDisplay = `+${(value * 100).toFixed(1)}%`;
                    break;
                case 'evasion':
                    name = "민첩한 몸놀림";
                    desc = "회피율이 증가합니다.";
                    value = 0.03 * multiplier; 
                    statDisplay = `+${(value * 100).toFixed(1)}%`;
                    break;
                case 'stunChance':
                    name = "급소 일격";
                    desc = "공격 시 적을 기절시킬 확률이 증가합니다.";
                    value = 0.01 * multiplier;
                    statDisplay = `+${(value * 100).toFixed(0)}%`;
                    break;
                case 'critChance':
                    name = "예리한 일격";
                    desc = "치명타 확률이 증가합니다.";
                    value = 1 * multiplier;
                    statDisplay = `+${value.toFixed(1)}%`;
                    break;
                case 'critDamage':
                    name = "집중 공격";
                    desc = "치명타 피해 배율이 증가합니다.";
                    value = 0.025 * multiplier;
                    statDisplay = `+${(value * 100).toFixed(0)}%`;
                    break;
                case 'critResist':
                    name = "굳건한 의지";
                    desc = "치명타 저항률이 증가합니다.";
                    value = 3 * multiplier;
                    statDisplay = `+${value.toFixed(1)}%`;
                    break;
                case 'xpGain':
                    name = "학습 능력";
                    desc = "경험치 획득량이 증가합니다.";
                    value = 0.03 * multiplier; 
                    statDisplay = `+${(value * 100).toFixed(1)}%`;
                    break;
                 case 'regen':
                    name = "자연 치유";
                    desc = "초당 체력 회복량이 증가합니다.";
                    value = 3 * multiplier;
                    statDisplay = `+${fmtCardNumber(value, 0)}`;
                    break;
                case 'skillCooldownReduction':
                    name = "스킬 순환";
                    desc = "스킬 쿨타임 회복 속도가 증가합니다.";
                    value = 0.005 * multiplier;
                    statDisplay = `+${(value * 100).toFixed(1)}%`;
                    break;
            }

            return { type, name, desc, value, rarity, statDisplay };
        }

        function selectUpgrade(data) {
            switch(data.type) {
                case 'atk':
                    player.weapon.baseDamage += data.value;
                    player.weapon.damage = player.weapon.baseDamage;
                    break;
                case 'atkSpeed':
                    player.bonusAttackSpeed += data.value;
                    player.weapon.baseAutoAttackInterval = player.weapon.originalAutoAttackInterval / (1 + player.bonusAttackSpeed);
                    player.weapon.baseAutoAttackInterval = Math.max(5, player.weapon.baseAutoAttackInterval);
                    if(player.weapon.autoAttackInterval > player.weapon.baseAutoAttackInterval) {
                        player.weapon.autoAttackInterval = player.weapon.baseAutoAttackInterval;
                    }
                    break;
                case 'range':
                    player.weapon.baseLength += data.value;
                    player.weapon.length = player.weapon.baseLength;
                    break;
                case 'hp':
                    player.baseMaxHealth += data.value;
                    updateMaxHealth();
                    player.health += data.value; // 체력 회복도 같이
                    updateHealthUI();
                    break;
                case 'defense':
                    player.defense += data.value;
                    break;
                case 'moveSpeed':
                    player.baseSpeed += data.value;
                    player.speed = player.baseSpeed;
                    break;
                case 'luck':
                    luck += data.value;
                    break;

                // [신규] 명중, 회피, 치명타 저항 확률 적용 로직
                case 'accuracy':
                    player.bonusAccuracy += data.value;
                    break;
                case 'evasion':
                    player.bonusEvasion += data.value;
                    break;
                case 'stunChance':
                    player.bonusStunChance += data.value;
                    break;
                case 'critChance':
                    player.baseCritChance += data.value;
                    player.critChance = player.baseCritChance;
                    break;
                case 'critDamage':
                    player.baseCritDamageMultiplier += data.value;
                    player.critDamageMultiplier = player.baseCritDamageMultiplier;
                    break;
                case 'critResist':
                    player.baseCritResist += data.value;
                    player.critResist = player.baseCritResist;
                    break;
                case 'xpGain':
                    player.bonusXpGain += data.value;
                    break;
                case 'regen':
                    player.baseRegen += data.value;
                    player.regen = player.baseRegen;
                    break;
                case 'skillCooldownReduction':
                    // [스킬 순환] 감소(감쇠) 없이 영구 누적 (런 동안 지속)
                    player.permanentSkillCooldownReduction = Math.min(0.75, (player.permanentSkillCooldownReduction || 0) + data.value);
                    player.bonusSkillCooldownReduction = player.permanentSkillCooldownReduction; // (호환용)
                    break;
            }

            // 모달 닫기 및 게임 재개
            document.getElementById('levelUpModal').style.display = 'none';
            uiLayer.style.zIndex = UI_LAYER_DEFAULT_Z;
            isLevelUpPaused = false;
            
            // 멈춰있던 루프 재가동
            requestAnimationFrame(animate);
        }
            // =========================================================
        // [신규] 스탯 확인 기능 스크립트
        // =========================================================
        const showStatsBtn = document.getElementById('showStatsBtn');
        const statsInfoBox = document.getElementById('statsInfoBox');
        const closeStatsBtn = document.getElementById('closeStatsBtn');
        const statsContent = document.getElementById('statsContent');

        showStatsBtn.addEventListener('click', () => {
            updateStatsContent();
            statsInfoBox.style.display = 'block';
        });

        closeStatsBtn.addEventListener('click', () => {
            statsInfoBox.style.display = 'none';
        });

function updateStatsContent() {
    // 1. 체력 & 최대 체력 감소 정보
    let maxHpInfo = "";
    if (player.evilLightTimers.length > 0) maxHpInfo += " (빛 -15%)";
    if (player.evilMindTimers.length > 0) {
        const mindReduc = (player.evilMindTimers.length * 2).toFixed(1);
        maxHpInfo += ` (마음 -${mindReduc}%)`;
    }
    const hpStr = Math.floor(player.health) + " / " + Math.floor(player.maxHealth) + 
                  (maxHpInfo ? `<span style="color:#ff4444; font-size:0.8em;">${maxHpInfo}</span>` : "");
    
    // 2. 공격력
    let displayDamage = player.weapon.damage;
    if (player.limitFocusSkill.activeTimer > 0) displayDamage *= (1.25 + (level * 0.00025));
    let dmgExtraInfo = "";
    
    // [감소] 카인의 씨앗
    if (player.darkSeedTimers.length > 0) {
        const seedReduction = player.weapon.damage * (player.darkSeedTimers.length * 0.02);
        displayDamage -= seedReduction; 
        if (displayDamage < 0.1) displayDamage = 0.1; 
        dmgExtraInfo += ` <span style="color:#ff4444;">(-${seedReduction.toFixed(1)})</span>`;
    }
    // [패널티] 어둠의 수신자 (적 방어력 증가)
    if (player.darkReceiverTimers.length > 0) {
        const receiverPenalty = (player.darkReceiverTimers.length * 2).toFixed(1);
        dmgExtraInfo += ` <span style="color:#ff4444;">(적 방어 +${receiverPenalty}%)</span>`;
    }
    const atkStr = displayDamage.toFixed(1) + dmgExtraInfo;
    
    // 3. 방어력 & 받는 피해
    let displayDefense = player.defense;
    if (player.sacredFaithSkill.activeTimer > 0) displayDefense *= (1.25 + (level * 0.0005));
    if (player.defenseBroken) displayDefense = 0;
    if (player.stunTimer > 0) displayDefense *= 0.5; // [신규] 기절 중 방어 50% 감소(표시)
    
    let defStr = displayDefense.toFixed(1);
    if (player.defenseBroken) defStr += " <span style='color:#ff0000;'>(파괴됨!)</span>";

    let takenInfo = "";
    if (player.corruptedBloodTimers.length > 0) {
        const bloodAmp = (player.corruptedBloodTimers.length * 2.5).toFixed(1);
        takenInfo += `<div>피해 +${bloodAmp}% (피)</div>`;
    }
    if (player.maliceTimers.length > 0) {
        const maliceAmp = (player.maliceTimers.length * 10).toFixed(0);
        takenInfo += `<div>독/함정 피해 +${maliceAmp}% (악의)</div>`;
    }
    if (takenInfo) defStr += ` <span style="color:#ff4444; font-size:0.8em;">${takenInfo}</span>`;

    // 4. 명중률 (플레이어 감소 + 적 회피 증가 통합)
    let currentAccuracy = player.bonusAccuracy;
    if (player.limitFocusSkill.activeTimer > 0) currentAccuracy += (0.10 + (level * 0.001));
    if (player.deepDarknessStacks > 0) currentAccuracy -= (player.deepDarknessStacks * 0.1);
    if (player.blindTimers.length > 0) currentAccuracy -= (player.blindTimers.length * 0.05);
    
    let enemyEvasionBonus = 0;
    if (player.semenTimers.length > 0) enemyEvasionBonus += (player.semenTimers.length * 0.005);
    if (typeof activeAkiCount !== 'undefined' && activeAkiCount > 0) enemyEvasionBonus += (activeAkiCount * 0.02);

    let accStr = (currentAccuracy > 0 ? "+" : "") + (currentAccuracy * 100).toFixed(1) + "%";
    if (enemyEvasionBonus > 0) {
        accStr += ` <span style="color:#ff4444;">(적 회피 +${(enemyEvasionBonus * 100).toFixed(1)}%)</span>`;
    }

    // 5. 회피율 (총 회피 = 기본 2% + 보너스)
    let displayEvasionTotal = 0.02 + (player.bonusEvasion || 0);
    if (player.stunTimer > 0) displayEvasionTotal *= 0.5; // [신규] 기절 중 총 회피 50% 감소(표시)
    if (player.deathBrandTimers.length > 0) displayEvasionTotal *= 0.5;
    const evaStr = (displayEvasionTotal * 100).toFixed(0) + "%" + (player.deathBrandTimers.length > 0 ? " (▼)" : "") + (player.stunTimer > 0 ? " (기절▼)" : "");

    // 5-1. 기절 확률
    const stunStr = "+" + (((player.bonusStunChance || 0) * 100).toFixed(0)) + "%";


    // 6. 치명타 확률 & 치명타 저항 확률
    let displayCritResist = player.critResist;
    let displayCritChance = player.critChance;


    let displayCritDamageMultiplier = (player.critDamageMultiplier || 1.5);
    if (player.sacredFaithSkill.activeTimer > 0) {
        displayCritResist += (15 + (level * 0.25));
    }
    if (player.limitFocusSkill.activeTimer > 0) displayCritChance += (10 + (level * 0.1));
    if (player.corruptedOathStacks > 0) displayCritChance += (player.corruptedOathStacks * 10);
    if (player.trueAncestorKissTimers.length > 0) displayCritChance += (player.trueAncestorKissTimers.length * 3);
    if (player.shadingTimers.length > 0) displayCritChance += 15;
    
    if (player.dangerousJudgmentStacks > 0) displayCritResist -= (player.dangerousJudgmentStacks * 10);
    if (player.fatalScarTimers.length > 0) displayCritResist -= (player.fatalScarTimers.length * 3);
    if (player.inPinkGas) displayCritResist *= 0.5;
    if (player.deathBrandTimers.length > 0) displayCritResist *= 0.5;
    if (player.fractureTimers.length > 0) displayCritResist -= (player.fractureTimers.length * 5);

    // 7. 공격 속도
    let attackInterval = player.weapon.autoAttackInterval;
    let atkSpeedReduction = 0;
    if (player.darkKissTimers.length > 0) atkSpeedReduction += (player.darkKissTimers.length * 0.011);
    if (player.darknessOverwhelmActive) atkSpeedReduction += 0.05;
    
    if (atkSpeedReduction > 0) {
        let speedFactor = 1 - atkSpeedReduction;
        if (speedFactor > 0.1) attackInterval = attackInterval / speedFactor;
    }

    // [수정] 퍼센트 표기 추가
    let bonusStr = (player.bonusAttackSpeed * 100).toFixed(0);
    const aspdStr = `${bonusStr}% 증가 ` + 
                    (atkSpeedReduction > 0 ? " <span style='color:#ff4444;'>(느려짐)</span>" : "");

    // 8. 공격 범위
    let rangeStr = player.weapon.length.toFixed(0);
    let rangeReduced = false;
    if (player.oralTimers.length > 0) rangeReduced = true;
    if (player.evilLightTimers.length > 0) rangeReduced = true;
    if (rangeReduced) rangeStr += " <span style='color:#ff4444;'>(단축됨)</span>";

    // 9. HP 회복
    let displayRegen = player.regen;
    if (player.gnawingLifeTimers.length > 0) displayRegen *= (1 - player.gnawingLifeTimers.length * 0.02);
    if (player.majestyActive) displayRegen *= 0.9;
    if (player.bleedingTimers.length > 0) displayRegen *= (1 - player.bleedingTimers.length * 0.02);

    let regenStr = (displayRegen / 2).toFixed(1);
    let regenInfo = "";

    if ((player.serumContaminationTimers && player.serumContaminationTimers.length > 0) || 
        (player.blasphemyTimers && player.blasphemyTimers.length > 0)) {
        regenStr = "0.0";
        regenInfo += " (회복 불가!)";
    } else if (player.bleedingTimers.length > 0) {
        regenInfo += ` (출혈:효율-${(player.bleedingTimers.length * 2).toFixed(0)}%)`;
    }

    if (player.poisonTimers.length > 0 || player.darkScentTimers.length > 0 || player.darkSmellTimers.length > 0 || player.poopPoisonTimers.length > 0) {
        regenInfo += " <span style='color:#ff4444;'>(독/지속피해 중!)</span>";
    }
    if (player.curseTimers.length > 0) {
        regenInfo += " <span style='color:#800080;'>(저주:종료시 피해)</span>";
    }
    if (regenInfo) regenStr += `<span style="font-size:0.8em; color:#ff4444;">${regenInfo}</span>`;

    // 10. 이동 속도
    let totalSlowFactor = 0;
    if (player.slowedByCloud) totalSlowFactor += 0.5;
                if (player.slowedByStickyCream) totalSlowFactor += 0.25;
    if (player.darknessOverwhelmActive) totalSlowFactor += 0.05;
    if (player.paralysisTimers.length > 0) totalSlowFactor += (player.paralysisTimers.length * 0.025);
    totalSlowFactor = Math.min(0.9, totalSlowFactor);
    
    let displaySpeed = player.baseSpeed * (1 - totalSlowFactor);
    let speedExtraInfo = "";
    if (player.stunTimer > 0) { displaySpeed = 0; speedExtraInfo = " (기절)"; } 
    else if (player.rootTimer > 0) { displaySpeed = 0; speedExtraInfo = " (속박)"; }
    else if (player.kissTimers.length > 0) { speedExtraInfo = " (키스중)"; }
    else if (player.confusionTimers.length > 0) { speedExtraInfo = " (혼란)"; }

    const speedStr = displaySpeed.toFixed(1) + speedExtraInfo;

    // 11. 쿨타임 회복
    let cdRecovery = 1.0;
    if (player.majestyActive) cdRecovery *= 0.75; 
    if (player.corruptedJusticeStacks > 0) cdRecovery -= (player.corruptedJusticeStacks * 0.25);
    cdRecovery *= (1 + Math.min(0.75, player.permanentSkillCooldownReduction || 0));
    if (cdRecovery < 0.1) cdRecovery = 0.1;

    let cooldownStr = (cdRecovery * 100).toFixed(0) + "%";
    if (cdRecovery < 1.0) cooldownStr += " <span style='color:#ff4444;'>(저하됨)</span>";

    // UI 업데이트
    statsContent.innerHTML = `
        <div class="stat-row"><span class="stat-label">체력</span> <span class="stat-value">${hpStr}</span></div>
        <div class="stat-row"><span class="stat-label">공격력</span> <span class="stat-value">${atkStr}</span></div>
        <div class="stat-row"><span class="stat-label">방어력</span> <span class="stat-value">${defStr}</span></div>
        <div class="stat-row"><span class="stat-label">명중률</span> <span class="stat-value">${accStr}</span></div>
        <div class="stat-row"><span class="stat-label">회피율</span> <span class="stat-value">${evaStr}</span></div>
        <div class="stat-row"><span class="stat-label">기절 확률</span> <span class="stat-value">${stunStr}</span></div>
        <div class="stat-row"><span class="stat-label">치명타 확률</span> <span class="stat-value">${displayCritChance.toFixed(1)}</span></div>
        <div class="stat-row"><span class="stat-label">치명타 데미지</span> <span class="stat-value">x${displayCritDamageMultiplier.toFixed(2)}</span></div>
        <div class="stat-row"><span class="stat-label">치명타 저항 확률</span> <span class="stat-value">${displayCritResist.toFixed(1)}</span></div>
        <div class="stat-row"><span class="stat-label">공격속도</span> <span class="stat-value">${aspdStr}</span></div>
        <div class="stat-row"><span class="stat-label">공격범위</span> <span class="stat-value">${rangeStr}</span></div>
        <div class="stat-row"><span class="stat-label">쿨타임 회복</span> <span class="stat-value">${cooldownStr}</span></div>
        <div class="stat-row"><span class="stat-label">경험치 증가</span> <span class="stat-value">+${(player.bonusXpGain*100).toFixed(0)}%</span></div>
        <div class="stat-row"><span class="stat-label">초당 HP회복</span> <span class="stat-value">${regenStr}</span></div>
        <div class="stat-row"><span class="stat-label">이동속도</span> <span class="stat-value">${speedStr}</span></div>
    `;
}
    </script>
</div></body>
</html>
